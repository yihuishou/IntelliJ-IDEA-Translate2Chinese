action.DlvDebugger.ViewAsGroup.text=作为...查看
action.DlvRewindAction.description=向后执行程序，直到上一个断点
action.DlvRewindAction.text=后退
action.DlvToggleThreadsAction.description=显示线程
action.DlvToggleThreadsAction.text=显示线程
action.Go.NewGoFile.description=创建新 Go 文件
action.Go.NewGoFile.text=Go 文件
action.GoAddContentRootFromGopath.description=将选定目录添加到当前项目中
action.GoAddContentRootFromGopath.text=将目录添加到当前项目中
action.GoCallHierarchyPopupMenu.BaseOnThisDeclaration.text=基于此声明
action.GoCoreDumpAction.text=打开核心转储…
action.GoFmtFileAction.description=使用 go fmt util 格式化选定文件
action.GoFmtFileAction.text=Go Fmt 文件
action.GoFmtProjectAction.description=使用 go fmt util 格式化项目
action.GoFmtProjectAction.text=Go Fmt 项目
action.GoGenerateConstructorAction.description=为结构生成构造函数
action.GoGenerateConstructorAction.text=构造函数
action.GoGenerateFileAction.description=在选定文件上运行 go generate
action.GoGenerateFileAction.text=Go Generate 文件
action.GoGenerateGetterAction.description=为字段生成 getter 方法
action.GoGenerateGetterAction.text=Getter
action.GoGenerateGetterSetterAction.description=为字段生成 getter 和 setter 方法
action.GoGenerateGetterSetterAction.text=Getter 和 Setter
action.GoGenerateSetterAction.description=为字段生成 setter 方法
action.GoGenerateSetterAction.text=Setter
action.GoIdeNewProjectAction.text=项目...
action.GoImportsFileAction.description=使用 goimports util 优化选定文件的导入
action.GoImportsFileAction.text=Goimports 文件
action.GoOpenProjectFromGopath.description=作为项目打开选定目录
action.GoOpenProjectFromGopath.text=作为项目打开目录
action.GoRemoveContentRootAction.description=从当前项目中移除选定内容根
action.GoRemoveContentRootAction.text=分离目录…
action.GoReplayTraceAction.text=调试保存的跟踪…
action.GoVetFileAction.description=使用 go vet 工具 Lint 选定文件或目录
action.GoVetFileAction.text=Go Vet 文件
action.Vgo.NewVgoFile.description=创建新的 Go 模块文件
action.Vgo.NewVgoFile.text=Go 模块文件
action.SaveAs.text=另存为...
action.WelcomeScreen.CreateDirectoryProject.text=新建项目...
action.WelcomeScreen.OpenDirectoryProject.text=打开项目...
action.com.goide.vgo.actions.VgoSyncAction.description=同步 go 模块
action.com.goide.vgo.actions.VgoSyncAction.text=同步 Go 模块
action.com.goide.vgo.actions.VgoTidyAction.description=在模块中运行 `go mod tidy`
action.com.goide.vgo.actions.VgoTidyAction.text=Go Mod Tidy
action.go.fill.paragraph=填充段落
action.GoShareInPlaygroundAction.text=在 Playground 中共享
action.GoShareInPlaygroundAction.description=在 Go Playground 中共享当前文件
action.GoShareInPlaygroundAction.error=无法在 Playground 中共享文件\: {0}
action.GoShareInPlaygroundAction.empty.id=Playground 返回空的 id
empty.text.go.to.type=转到类型
empty.text.switch.view.or.keymap=切换视图或键盘映射
go.app.engine.choose.file.action.text=选择文件…
go.app.engine.not.gae.sdk.validation.message=选定 SDK 与 App Engine 不相似<br>您可以在 <a href\="https\://cloud.google.com/appengine/downloads">https\://cloud.google.com/appengine/downloads</a> 找到 App Engine SDK
go.app.engine.run.confinguration.not.gae.sdk.validation.message=<code>{0}</code> 模块的 Go SDK 非 AppEngine 式
go.app.engine.run.configuraiton.sdk.is.not.set.validation.message=没有为模块 <code>{0}</code> 指定 Go SDK
go.app.engine.run.configuraiton.is.deprecated.validation.message=Go 1.11 及更高版本不建议使用 Go App Engine 运行配置。<br/>请改用 Go Build 运行配置。
go.app.engine.run.configuration.admin.port.label=管理端口(&D)\:
go.app.engine.run.configuration.name=Go App Engine
go.app.engine.run.configuration.description=Go app engine web 服务器运行程序
go.app.engine.run.configuration.config.files.label=配置文件(&C)\:
go.app.engine.run.configuration.host.label=主机(&H)\:
go.app.engine.run.configuration.server.port.label=端口(&P)\:
go.app.engine.run.configuration.invalid.port.validation.message=无效端口
go.app.engine.run.configuration.invalid.admin.port.validation.message=无效管理端口
go.app.engine.wizard.description=创建 Go App Engine 项目以开发使用 Google App Engine 的 Go 应用程序。<br/>新模块包括 Go 中的默认配置设置和基本处理程序。
go.app.engine.wizard.name=App Engine
go.modules.wizard.description=创建 Go 模块项目，以开发使用 Go 模块进行依赖项管理的 Go 应用程序和库。
go.wizard.description=创建 Go 项目以开发应用程序或库。<br/>此选项将创建一个空的 Go 项目。
go.background.task.running.title=运行中...
go.background.task.compiling.title=编译...
go.cgo.file.type.description=Cgo 文件
go.checkin.factory.fmt.commit.anyway.question=仍要提交吗?
go.checkin.factory.fmt.failed.message=GoFmt 在某些文件上返回了非零代码。
go.checkin.factory.fmt.not.started.message=无法运行 go fmt。{0}
go.colors.and.fonts.bad.character=错误字符
go.colors.and.fonts.braces.and.operators.braces=大括号
go.colors.and.fonts.braces.and.operators.brackets=方括号
go.colors.and.fonts.braces.and.operators.colon=冒号
go.colors.and.fonts.braces.and.operators.comma=逗号
go.colors.and.fonts.braces.and.operators.dot=点
go.colors.and.fonts.braces.and.operators.operator=运算符
go.colors.and.fonts.braces.and.operators.parentheses=括号
go.colors.and.fonts.braces.and.operators.semicolon=分号
go.colors.and.fonts.braces.and.operators=大括号和运算符
go.colors.and.fonts.comments.block.comment=块注释
go.colors.and.fonts.comments.comment.keyword=注释关键字
go.colors.and.fonts.comments.comment.reference=注释引用
go.colors.and.fonts.comments.line.comment=行注释
go.colors.and.fonts.comments=注释
go.colors.and.fonts.declarations.constants.builtin.constant=内置常量
go.colors.and.fonts.declarations.constants.local.constant=局部常量
go.colors.and.fonts.declarations.constants.package.exported.constant=打包导出的常量
go.colors.and.fonts.declarations.constants.package.local.constant=打包局部常量
go.colors.and.fonts.declarations.constants=常量
go.colors.and.fonts.declarations.function.parameter=函数参数
go.colors.and.fonts.declarations.functions.builtin.function=内置函数
go.colors.and.fonts.declarations.functions.exported.function=导出的函数
go.colors.and.fonts.declarations.functions.package.local.function=打包本地函数
go.colors.and.fonts.declarations.functions=函数
go.colors.and.fonts.declarations.label=标签
go.colors.and.fonts.declarations.method.receiver=方法接收器
go.colors.and.fonts.declarations.package=包
go.colors.and.fonts.declarations.types.package.exported.interface=打包导出的接口
go.colors.and.fonts.declarations.types.package.exported.struct=打包导出的结构
go.colors.and.fonts.declarations.types.package.local.interface=打包本地接口
go.colors.and.fonts.declarations.types.package.local.struct=打包本地结构
go.colors.and.fonts.declarations.types.type.specification=类型规范
go.colors.and.fonts.declarations.types=类型
go.colors.and.fonts.declarations.variables.builtin.variable=内置变量
go.colors.and.fonts.declarations.variables.local.variable=局部变量
go.colors.and.fonts.declarations.variables.package.exported.variable=打包导出的变量
go.colors.and.fonts.declarations.variables.package.local.variable=打包局部变量
go.colors.and.fonts.declarations.variables.reassignment.in.short.variable.declaration=短变量声明中的重新赋值
go.colors.and.fonts.declarations.variables.scope.declared.variable=范围声明变量
go.colors.and.fonts.declarations.variables.shadowing.variable=阴影变量
go.colors.and.fonts.declarations.variables.struct.exported.member=结构导出的成员
go.colors.and.fonts.declarations.variables.struct.local.member=结构本地成员
go.colors.and.fonts.declarations.variables=变量
go.colors.and.fonts.declarations=声明
go.colors.and.fonts.identifier=标识符
go.colors.and.fonts.keyword=关键字
go.colors.and.fonts.number=数字
go.colors.and.fonts.references.function.calls.builtin.function.call=内置函数调用
go.colors.and.fonts.references.function.calls.exported.function.call=导出的函数调用
go.colors.and.fonts.references.function.calls.local.function.call=局部函数调用
go.colors.and.fonts.references.function.calls=函数调用
go.colors.and.fonts.references.type.references.builtin.type.reference=内置类型引用
go.colors.and.fonts.references.type.references.package.exported.interface=打包导出的接口
go.colors.and.fonts.references.type.references.package.exported.struct=打包导出的结构
go.colors.and.fonts.references.type.references.package.local.interface=打包本地接口
go.colors.and.fonts.references.type.references.package.local.struct=打包本地结构
go.colors.and.fonts.references.type.references.type.specification=类型规范
go.colors.and.fonts.references.type.references=类型引用
go.colors.and.fonts.references.variable.calls.exported.variable.call=导出的变量调用
go.colors.and.fonts.references.variable.calls.local.variable.call=局部变量调用
go.colors.and.fonts.references.variable.calls.package.local.variable.call=打包局部变量调用
go.colors.and.fonts.references.variable.calls.struct.exported.member.call=结构导出的成员调用
go.colors.and.fonts.references.variable.calls.struct.local.member.call=结构本地成员调用
go.colors.and.fonts.references.variable.calls=变量调用
go.colors.and.fonts.references=引用
go.colors.and.fonts.string.invalid.escape=无效的转义
go.colors.and.fonts.string.text=文本文件
go.colors.and.fonts.string.valid.escape=有效的转义
go.colors.and.fonts.string=字符串
go.completion.insert.if.not.nil.statement.command.name=插入 ''if value \!\= nil {...}'' 语句
go.completion.insert.literal.command.name=插入 Go 文字
go.completion.insert.type.name.command.name=插入类型名称
go.completion.insert.return.statement.command.name=插入返回语句
go.completion.method.like.completion.advertisement=按 {0} 查看将表达式作为第一个参数的函数
go.completion.method.like.completion.command.name=函数的方法式补全
go.core.dump.dialog.dump.path.label=核心转储(&C)\:
go.core.dump.dialog.executable.label=可执行文件(&E)\:
go.core.dump.dialog.invalid.core.dump.validation.message=该文件不是有效的核心转储
go.core.dump.dialog.invalid.executable.validation.message=该文件不是可执行文件
go.core.dump.dialog.specify.core.dump.validation.message=指定核心转储
go.core.dump.dialog.specify.executable.validation.message=指定可执行文件
go.core.dump.failed.to.start.error.message=无法为核心转储 {0} 启动调试器\: {1}
go.core.dump.session.name=核心转储 {0}
go.create.new.file.action.command.name=创建 Go 文件 {0}
go.create.new.file.action.name=Go 文件
go.create.new.file.dialog.title=新建 Go 文件
go.create.new.file.empty.file.kind.name=空文件
go.create.new.file.simple.application.kind.name=简单的应用程序
go.debug.show.goroutines.action.name=显示 Goroutine
go.debug.show.threads.action.name=显示线程
go.declarations.intentions.category=Go/声明
go.dep.checking.dep.projects.task.name=检查 Dep 项目
go.dep.enable.integration.checkbox=启用 dep 集成
go.edit.auto.import.settings.action.name=编辑自动导入设置
go.auto.import.and.completion.title=自动导入和补全
go.auto.import.and.completion.add.exclude.label=输入要从自动导入和补全中排除的导入路径\:
go.element.is.not.go.expression.error.hint=选择范围不包含 Go 表达式
go.exclude.import.path.dialog.empty.path.validation.message=导入路径不能为空
go.exclude.import.path.dialog.title=排除导入路径
go.exclude.import.path.from.completion.action.name=排除 ''{0}''
go.feature.trainer.specify.sdk.to.continue.learning.title=指定 Go SDK 以继续学习
go.feature.trainer.too.old.go.sdk.notification.title=Go SDK 太旧
go.feature.trainer.too.old.go.sdk.notification.text=<b>{0}</b> 当前设置为项目 SDK。建议使用版本至少为 <b>{1}</ b> 的 Go SDK，以在使用教程时获得最佳体验。
go.file.type.description=Go 文件
go.fix.searching.for.usages.progress.title=搜索用途...
go.fix.change.parameters.parameter={0,choice,0\#参数|1\#参数|2\#参数}
go.fix.add.missing.new.line.name=添加缺少的新行
go.fix.add.comma.name=添加逗号
go.fix.add.whitespace.name=添加空格
go.fix.add.import.for.side.effects.name=副作用导入
go.fix.add.prefix.to.comment.name=向注释中添加 ''{0}'' 前缀
go.fix.add.return.statement.name=添加 return 语句
go.fix.change.import.sorting.settings.name=更改导入排序设置
go.fix.change.result.parameters.result.parameter={0,choice,0\#结果参数|1\#结果参数|2\#结果参数}
go.fix.create.directory.text=在 {1} 处创建目录{0}
go.fix.change.parameters.name=更改参数
go.fix.change.result.parameters.in.assignment.name=更改赋值中的结果参数
go.fix.change.result.parameters.in.call.name=更改调用中的结果参数
go.fix.change.result.parameters.in.return.name=更改返回中的结果参数
go.fix.change.result.parameters.in.variable.specification.name=更改变量规范中的结果参数
go.fix.change.result.parameters.name=更改结果参数
go.fix.change.signature.from.function.type.name=从函数类型更改签名
go.fix.change.signature.from.usage.text=从用法更改签名
go.fix.change.signature.from.function.type.text=将{0} ''{1}'' 的签名更改为 ({2}) ({3})
go.fix.change.signature.from.usage.add=将 ''{0}'' 作为第 {1,number,ordinal} 个{2}添加到{3} ''{4}'' 中
go.fix.change.signature.from.usage.remove=从{2} ''{3}'' 中移除第 {0,number,ordinal} 个{1}
go.fix.change.signature.from.usage.change=将{2} ''{3}'' 的第 {0,number,ordinal} 个{1}从 ''{4}'' 更改为 ''{5}''
go.fix.change.signature.from.usage.mix=将{1} ''{2}'' 的{0}更改为 ({3})
go.fix.convert.to.is.equal.name=转换为 '\=\='
go.fix.delete.name=删除 {0}
go.fix.delete.text=删除{0} ''{1}''
go.fix.delete.range.name=删除元素
go.fix.delete.third.index.name=删除第三索引
go.fix.delete.blank.argument.name="删除空白参数"
go.fix.export.name=导出
go.fix.export.field.name=导出字段
go.fix.replace.tilda.with.hat.name=将 '~' 替换为 '^'
go.fix.replace.assign.with.equals.name=将 '\:\=' 替换为 '\='
go.fix.replace.equals.with.assign.name=替换为 '\:\='
go.fix.replace.with.nil.with.side.effects.name=替换为 nil (更改语义)
go.fix.replace.with.correct.defer.name=替换为正确的 defer 结构
go.fix.add.function.call.name=添加函数调用
go.fix.delete.redundant.index.name=删除冗余索引
go.fix.delete.conversion.name=删除转换
go.fix.delete.conversion.with.side.effects.name=删除转换 (更改语义)
go.fix.disable.vendoring.in.module.text=在模块 ''{0}'' 中禁用 vendoring 试验支持
go.fix.disable.vendoring.in.module.name=在模块中禁用 vendoring 试验支持
go.fix.drop.suffix.text=删除特定于单元的后缀 ''{0}''
go.fix.drop.suffix.name=删除特定于单元的后缀
go.fix.multiple.packages.name=移除包
go.fix.multiple.packages.text=将包重命名为 {0}
go.fix.choose.package.name=选择包名称
go.fix.simplify.bool.expr.name=简化表达式
go.fix.failed.to.simplify.if.statement=无法简化 'if' 语句
go.fix.view.all.duplicates.name=查看重复的名称
go.fix.view.all.duplicates.text=查看 ''{0}'' 的重复名称
go.fix.view.all.duplicates.targets.tab.text=''{0}'' 的重复项
go.fix.view.all.duplicates.targets.tool.window.title={1} 中的 {0}
go.fix.view.all.duplicates.targets.usages.word=副本
go.fix.view.all.duplicates.targets.code.usages.string=已找到重复项
go.fix.add.function.block.name=添加正文
go.fix.add.keys.to.struct.literal.value.name=添加键并删除零值
go.fix.add.local.var.for.expression.name=引入局部变量
go.fix.add.missing.return.value.name=添加缺少的返回值
go.fix.add.pointer.name=添加指针
go.fix.add.explicit.dereference.name=添加显式取消引用
go.fix.always.false.if.name=移除 'if' 分支
go.fix.always.true.if.name=移除剩余分支并简化当前的 'if'
go.fix.convert.int.to.string.using.conversion.call=使用 {0} 调用将整数转换为字符串
go.fix.convert.string.to.byte.name=将字符串转换为字节
go.fix.convert.to.expected.type.name=转换为
go.fix.convert.to.expected.type.text=转换为 ''{0}''
go.fix.create.wrapper.type.name=创建类型
go.fix.delete.all.unused.parameters.name=删除所有未使用的参数
go.fix.delete.ampersand.and.type.in.composite.lit.name=删除冗余类型
go.fix.delete.extra.expressions.name=删除多余的表达式
go.fix.delete.import.name=删除导入
go.fix.delete.impossible.asserted.type=删除不可能的断言类型
go.fix.delete.parameter.names.name=删除参数名称
go.fix.delete.unused.parameter.name=删除未使用的参数
go.fix.empty.signature.name=修复签名
go.fix.exclude.from.unhandled.inspection.name=不再报告此方法/函数
go.fix.extract.empty.slice.to.var.declaration.name=替换为零切片声明 (更改语义)
go.fix.extract.to.own.declaration.name=提取到自己的声明
go.fix.finish.call.name=完成调用表达式
go.fix.ignore.explicitly.name=显式忽略
go.fix.ignore.unused.call.result.name=忽略未使用的调用结果
go.fix.implement.missing.methods.name=实现缺少的方法
go.fix.insert.blank.identifiers.name=将空白标识符插入赋值语句的左侧
go.fix.navigate.to.name=导航到
go.fix.navigate.to.text=导航到 {0}
go.fix.optimize.imports.name=优化导入
go.fix.place.build.tag.before.package.name=在包前面放置构建标签
go.fix.remove.redundant.bool.literal.name=简化为
go.fix.replace.with.name=替换为
go.fix.replace.with.text=替换为 ''{0}''
go.fix.rename.to.name=重命名为
go.fix.rename.to.text=重命名为 ''{0}''
go.fix.rename.all.receivers.name=重命名所有接收器
go.fix.rename.all.receivers.text=重命名所有接收器为 ''{0}'' 
go.fix.replace.expression.name=在前面追加 '\\&'
go.fix.signature.name=修复签名
go.fix.sort.imports=import 排序
go.fix.simplify.expression.to.boolean.literal.name=简化条件
go.fix.simplify.to.text=简化为 ''{0}''
go.fix.simplify.something.to.text=将 ''{0}'' 简化为 ''{1}''
go.fix.suppress.inspection.for.text=对{0}禁止
go.fix.suppress.all.inspections.for.text=禁止{0}的所有检查
go.fix.unwrap.parens.name=取消换行括号
go.fix.convert.to.format.function.name=更改为格式设置函数
go.fix.convert.to.format.function.text=更改 ''{0}'' 为格式设置函数
go.fix.introduce.local.variable.for.expression=引入 ''{0}'' 的局部变量
go.fix.introduce.method.name=创建方法
go.fix.introduce.method.text=创建方法 ''{0}''
go.fix.introduce.function.name=创建函数
go.fix.introduce.function.text=创建函数 ''{0}''
go.fix.field.with.the.same.tag=包含相同 ''{1}'' 标签的字段 ''{0}''
go.fix.field.repeats.tag.with.value=字段 ''{0}'' 重复 ''{3}'' 字段中值为 ''{2}'' 的 ''{1}'' 标签
go.fix.export.field=导出字段
go.fix.convert.int.to.rune=将整数转换为 rune
go.fix.unpack.slice.name=解压缩切片
go.fix.enable.gopath.indexing.name=启用 GOPATH 索引
go.fix.rename.file.to.go2.name=将文件重命名为 .go2
go.fix.rename.file.to.go2.text=将文件重命名为 ''{0}''
go.get.package.fix.family.name=运行 'go get'
go.use.gopath.from.system.environment.checkbox=使用系统环境中定义的 GOPATH
go.index.entire.gopath.checkbox=为整个 GOPATH 编制索引
go.index.entire.gopath.tooltip=禁用时，将仅对项目和 vendor 包编制索引。<br/>这样可以提升整体性能，但无法使用 GOPATH 中的包。
go.inspection.assignment.nil.without.explicit.type.display.name=赋值零无显式类型
go.inspection.assignment.nil.without.explicit.type.message=没有显式类型就无法分配 nil
go.inspection.assignment.to.receiver.display.name=分配给接收器
go.inspection.binary.expressions.types.check.display.name=二进制表达式类型检查
go.inspection.bool.condition.display.name=布尔型条件
go.inspection.comment.has.no.leading.space.display.name=注释没有前导空格
go.inspection.comment.of.exported.element.starts.with.incorrect.name.display.name=导出元素的注释以不正确的名称开头
go.inspection.comment.should.have.package.prefix.message=包注释应采用 ''Package {0} ...'' 的形式
go.inspection.comment.should.be.without.article.message=注释格式必须为 ''{0} ...'' (有可选的前导条目)
go.inspection.comment.should.be.meaningful.message=注释应有意义，否则应当移除
go.inspection.defer.go.statement.calls.recover.or.panic.directly.display.name=Defer/go 语句调用直接恢复或 panic
go.inspection.defer.or.go.should.not.call.function.message={0} 不应直接调用 {1}
go.inspection.defer.in.loop.display.name=循环中存在 defer
go.inspection.deprecated.element.display.name=弃用的元素
go.inspection.division.by.zero.display.name=除以零
go.inspection.duplicate.case.display.name=重复的 case
go.inspection.duplicate.names.display.name=重复的名称
go.inspection.empty.declaration.display.name=空声明
go.inspection.empty.declaration.message=声明 {0} 为空
go.inspection.empty.slice.declared.via.literal.display.name=通过文字声明的空切片
go.inspection.error.string.should.not.be.capitalized.or.end.with.punctuation.display.name=错误字符串不应大写或以标点结尾
go.inspection.exceeded.shift.expression.display.name=已超出 shift 表达式
go.inspection.expected.equals.got.assign.display.name=预期 '\='，得到 '\:\='
go.inspection.explicit.dereference.required.display.name=需要显式取消引用
go.inspection.explicit.dereference.calling.method.with.receiver.message=包含接收器 {1}(类型为 {2})的调用方法 {0} 需要显式取消引用
go.inspection.explicit.dereference.accessing.field.message=访问 {1}(类型为 {2})的字段 {0} 需要显式取消引用
go.inspection.exported.element.should.have.comment.display.name=导出的元素应具有注释
go.inspection.exported.element.should.have.its.own.declaration.display.name=导出的元素应有自己的声明
go.inspection.extended.method.expression.syntax.before.go.1.10.display.name=在 Go 1.10 前扩展了方法表达式语法
go.inspection.extended.method.expression.syntax.before.go.1.10.message=接收器类型异常，自 Go 1.10 起可以使用扩展的方法表达式语法
go.inspection.function.call.display.name=函数调用
go.inspection.imported.package.name.as.name.identifier.display.name=作为名称标识符导入了包名称
go.inspection.impossible.type.assertion.display.name=无法实现的类型断言
go.inspection.impossible.interface.type.assertion=不可能的接口类型断言
go.inspection.incorrect.strings.replace.count.argument.display.name=字符串不正确。替换计数参数
go.inspection.incorrect.usage.of.println.display.name=Println/Printf 类函数的使用不正确
go.inspection.incorrect.usage.of.the.errors.as.function.display.name=errors.As 函数的使用不正确
go.inspection.incorrect.usage.of.the.sync.display.name=sync/atomic 包的使用不正确
go.inspection.locks.mistakenly.passed.by.value=锁通过值错误传递
go.inspection.possible.misuse.of.unsafe.pointer=可能滥用 {0}
go.inspection.invalid.conversions.of.uintptr.to.unsafe.Pointer=uintptr 到 unsafe.Pointer 的转换无效
go.inspection.infinite.for.loop.display.name=无限的 for 循环
go.inspection.invalid.composite.literals.display.name=无效的复合文字
go.inspection.invalid.expression.conversion.display.name=无效的表达式转换
go.inspection.invalid.index.or.slice.expression.display.name=无效的索引或切片表达式
go.inspection.problem.cannot.take.address=无法提取 {0} 的地址
go.inspection.problem.invalid.indirect={0} (类型 {1})的间接引用无效
go.inspection.invalid.package.import.display.name=无效的包导入
go.inspection.invalid.receiver.type.display.name=无效的接收器类型
go.inspection.invalid.recursive.type.display.name=无效的递归类型
go.inspection.int.to.string.conversion=整数转换为字符串类型
go.inspection.jump.over.declaration.display.name=跳过声明
go.inspection.loop.closure.display.name=函数文字捕获的循环变量
go.inspection.loop.closure.message=函数文字 {1} 捕获的循环变量 {0}
go.inspection.malformed.build.tag.display.name=构建标记的格式错误
go.inspection.malformed.struct.tag.display.name=结构标记的格式错误
go.inspection.mismatched.byte.and.string.display.name=不匹配的类型\: 字节和字符串
go.inspection.missing.trailing.comma.before.newline.in.composite.literal.display.name=复合文字中换行前缺少尾随逗号
go.inspection.multiple.packages.in.directory.declaration.display.name=目录声明中存在多个包
go.inspection.name.starts.with.package.name.display.name=名称以包名称开头
go.inspection.nilness.analyzer.display.name=为零性分析器
go.inspection.non-function.call.display.name=非函数调用
go.inspection.non-standard.signature.for.well.known.function.names.display.name=已知函数名称采用非标准签名
go.inspection.receiver.has.generic.name.display.name=接收器具有通用名称
go.inspection.redundant.blank.argument.in.range.display.name=范围中存在冗余空白参数
go.inspection.redundant.comma.display.name=冗余逗号
go.inspection.redundant.import.alias.display.name=冗余导入别名
go.inspection.redundant.parentheses.display.name=冗余括号
go.inspection.redundant.second.index.in.slices.display.name=切片中存在冗余的第二个索引
go.inspection.redundant.semicolon.display.name=冗余分号
go.inspection.redundant.type.conversion.display.name=冗余类型转换
go.inspection.redundant.types.in.composite.literals.display.name=复合文字中存在冗余类型
go.inspection.reserved.word.used.as.name.display.name=保留词用作名称
go.inspection.self.assignment.display.name=自赋值
go.inspection.self.import.display.name=自导入
go.inspection.shadowing.variable.display.name=阴影变量
go.inspection.struct.initialization.without.field.names.display.name=结构初始化没有字段名称
go.inspection.struct.initialization.settings.report.for.local.type.checkbox=还报告本地类型定义
go.inspection.struct.initialization.settings.report.for.literals.without.type.checkbox=报告无类型的结构文字
go.inspection.struct.field.has.tag.but.is.not.exported=结构字段 ''{0}'' 具有 ''{1}'' 标签，但未导入
go.inspection.type.can.be.omitted.display.name=类型可以省略
go.inspection.type.can.be.omitted.message=类型可以省略
go.inspection.types.compatibility.check.display.name=类型兼容性检查
go.inspection.underscore.used.as.value.display.name=下划线用作值
go.inspection.unexpected.tilda.display.name=未预料到的 '~'
go.inspection.unexported.return.type.of.exported.function.display.name=未导出返回类型的导出函数
go.inspection.unhandled.error.display.name=未处理错误
go.inspection.unit.specific.suffix.for.time.duration.display.name=为 time.Duration 使用单位特定的后缀
go.inspection.unnecessarily.exported.identifier.display.name=不必要地导出了标识符
go.inspection.unreachable.code.display.name=不可到达的代码
go.inspection.unknown.field.message=结构文字中的字段 {0} 未知
go.inspection.ambiguous.reference.message=不明确的引用 {0}
go.inspection.unresolved.reference.message=未解析的引用 {0}
go.inspection.unresolved.type.message=未解析的类型 {0}
go.inspection.unresolved.label.message=未解析的标签 {0}
go.inspection.unresolved.reference.display.name=未解析的引用
go.inspection.unresolved.disabled.gopath.indexing.display.name=已禁用 GOPATH 索引
go.inspection.unresolved.disabled.gopath.indexing.message=禁用 GOPATH 索引可能会阻止正确进行引用解析
go.inspection.unsorted.imports.display.name=未排序的导入
go.inspection.unused.constant.display.name=未使用的常量
go.inspection.unused.constant.message=未使用的常量 {0}
go.inspection.unused.exported.function.display.name=未使用的导出函数
go.inspection.unused.function.message=未使用的函数 {0}
go.inspection.unused.label.message=未使用的标签 {0}
go.inspection.unused.exported.type.display.name=未使用的导出类型
go.inspection.unused.function.display.name=未使用的函数
go.inspection.unused.function.or.method.call.result.display.name=未使用的函数或方法调用结果
go.inspection.unused.global.variable.display.name=未使用的全局变量
go.inspection.unused.import.display.name=未使用的导入
go.inspection.unused.parameter.display.name=未使用的参数
go.inspection.unused.parameter.message=未使用的参数 {0}
go.inspection.unused.type.display.name=未使用的类型
go.inspection.unused.type.message=未使用的类型 {0}
go.inspection.unused.variable.display.name=未使用的变量
go.inspection.unused.variable.message=未使用的变量 {0}
go.inspection.usage.of.cgo.in.tests.is.not.supported.display.name=不支持在测试中使用 cgo
go.inspection.usage.of.snake.case.display.name=使用了 Snake_Case
go.inspection.used.as.value.in.condition.display.name=在条件中用作值
go.inspection.wrong.test.declaration.display.name=错误的测试声明
go.inspection.incorrect.call.to.unmarshal.display.name=使用错误的参数调用 Unmarshal
go.inspection.struct.tag.value.consists.only.of.spaces=结构标签值仅包含空格
go.inspection.suspicious.space.in.the.beginning.of.the.struct.tag.value=结构标签值开头有可疑的空格
go.inspection.suspicious.space.in.the.end.of.the.struct.tag.value=结构标签值末尾有可疑的空格
go.inspection.suspicious.extra.space.in.struct.tag.value=结构标签值中有可疑的额外空格
go.inspection.suspicious.space.in.struct.tag.value=结构标签值中有可疑的空格
go.inspection.missing.closing.double.quote.character.in.value=值中缺少右双引号字符
go.inspection.expected.opening.double.quote.character.after.colon=\ '\:' 后面应为左双引号字符
go.inspection.expected.colon.after.key=键后面应为 '\:' 
go.inspection.key.is.empty.or.starts.from.incorrect.symbol=键为空或从不正确的符号开始
go.inspection.key.is.not.separated.by.space.from.previous.pair=键与上一对没有用空格隔开
go.inspection.test.name.display.name=测试函数名称格式错误
go.inspection.problem.malformed.test.name=测试名称格式错误\: 'Test' 后面的首字母不能小写
go.inspection.problem.malformed.benchmark.name=基准名称格式错误\: 'Benchmark' 后面的首字母不能小写
go.inspection.problem.malformed.example.suffix=示例名称格式错误\: 后缀 {0} 必须以小写字母开头
go.inspection.problem.example.for.unknown.identifier=示例引用了未知标识符\: {0}
go.inspection.problem.example.for.unknown.field.or.method=示例涉及未知的字段或方法\:{0}。{1}
go.intention.add.comment.name=添加注释
go.intention.add.declaration.parens.name=向声明添加圆括号
go.intention.add.dot.import.alias.name=添加点导入别名
go.intention.add.fmt.string.argument.name=Add format string argument
go.intention.add.import.alias.name=添加导入别名
go.intention.convert.to.short.var.declaration.name=转换为短变量声明
go.intention.convert.to.var.declaration.name=转换为变量声明
go.intention.create.field.getter.and.setter.name=生成 getter 和 setter
go.intention.create.field.getter.and.setter.command.name=创建字段访问器
go.intention.create.field.getter.and.setter.already.exists.error.hint=已存在
go.intention.create.field.getter.name=创建 Getter
go.intention.create.field.setter.name=创建 Setter
go.intention.expand.signature.types.name=展开签名类型
go.intention.export.name=导出
go.intention.fill.all.fields.name=填充所有字段
go.intention.fill.all.fields.recursively.checkbox=递归
go.intention.fill.all.fields.enforce.multiline.checkbox=执行多行
go.intention.fill.all.fields.command.name=填充结构
go.intention.fill.all.fields.recursively.name=递归填充所有字段
go.intention.fill.fields.name=填充字段…
go.intention.flip.binary.operator.changes.operator.text=将 ''{0}'' 翻转为 ''{1}''
go.intention.flip.binary.operator.changes.semantics.text=翻转 ''{0}'' (更改语义)
go.intention.flip.binary.operator.name=翻转二进制运算符
go.intention.flip.binary.operator.text=翻转 ''{0}''
go.intention.fmt.string.argument.bad.position.error.message=位置错误
go.intention.fmt.string.argument.explicit.indices.error.message=字符串具有显式索引
go.intention.fmt.string.argument.percent.with.args.error.message=字符串具有带参数的 %%
go.intention.fmt.string.argument.syntax.error.message=字符串有语法错误
go.intention.fmt.string.argument.too.few.arguments.error.message=字符串的参数太少
go.intention.fmt.string.argument.variadic.arg.error.message=字符串具有 ... 参数
go.intention.fmt.string.title.error.message=无法添加 Fmt 字符串参数
go.intention.generate.constructor.name=创建构造函数
go.intention.getter.already.exists.error.message=Getter 已存在 (未创建)
go.intention.getter.and.setter.already.exist.error.message=getter 和 setter 都已存在
go.intention.go.to.implementation.name=转到实现
go.intention.go.to.implementation.text=转到实现…
go.intention.go.to.super.name=转到接口
go.intention.go.to.super.text=转到接口…
go.intention.implement.interface.name=实现接口
go.intention.implement.interface.text=实现接口...
go.intention.invert.if.name=反转 if
go.intention.merge.all.declarations.name=合并所有声明
go.intention.merge.declaration.up.name=向上合并声明
go.intention.merge.declarations.by.comma.name=通过逗号向上合并声明
go.intention.move.to.struct.initialization.name=将字段赋值移动到结构初始化
go.intention.negate.boolean.expression.name.recursively.suffix=递归
go.intention.negate.boolean.expression.name=求反表达式
go.intention.negate.boolean.expression.text=将 ''{0}'' 求反为 ''{1}''
go.intention.negate.boolean.topmost.expression.name=求反最顶端的表达式
go.intention.negate.boolean.topmost.expression.text=将最顶端的 ''{0}'' 求反为 ''{1}''
go.intention.remove.declaration.parens.name=从声明中移除圆括号
go.intention.remove.dot.import.alias.name=移除点导入别名
go.intention.remove.keys.from.struct.literal.value.name=从结构文本中移除键
go.intention.reuse.signature.types.name=重用签名类型
go.intention.run.go.generate.name=在注释上运行 go generate
go.intention.run.go.generate.on.file.name=在文件上运行 go generate
go.intention.run.go.generate.on.package.name=在包上运行 go generate
go.intention.run.go.generate.text=Go generate ''{0}''
go.intention.select.fields.dialog.title=选择字段
go.intention.setter.already.exists.error.message=Setter 已存在 (未创建)
go.intention.specify.type.name=明确地指定类型
go.intention.split.all.declarations.name=拆分所有声明
go.intention.split.declarations.by.comma.name=通过逗号拆分声明
go.intention.split.declarations.name=将声明拆分为两个组
go.intention.chop.arguments=将参数放在单独的行上
go.intention.chop.parameters=将参数放在单独的行上
go.intention.chop.composite.literal.elements=将元素放在单独的行中
go.intention.join.arguments=将参数放在同一行上
go.intention.join.parameters=将参数放在同一行上
go.intention.join.composite.literal.elements=将元素放在同一行中
go.intention.experimental.support.for.type.parameters.family.name=泛型(实验性支持类型参数)
go.intention.experimental.support.for.type.parameters.enable.name=启用泛型(实验性支持类型参数)
go.intention.experimental.support.for.type.parameters.disable.name=禁用泛型(实验性支持类型参数)
go.intentions.category=Go
go.macro.bin.dirs.description=包含 Go 工具的 bin 目录路径
go.macro.executable.path.description=Go 可执行文件路径
go.macro.file.import.path.description=导入当前文件的路径
go.macro.file.go.path.description=GOPATH 值
go.macro.file.go.root.description=项目 SDK 路径
go.mozilla.rr.dialog.specify.trace.directory.validation.message=指定跟踪目录
go.mozilla.rr.dialog.trace.directory.label=跟踪目录(&T)\:
go.mozilla.rr.failed.to.start.error.message=无法为 rr 跟踪 {0} 启动调试器\: {1}
go.mozilla.rr.session.name=跟踪 {0}
go.navigation.progress.title=正在搜索 {0}...
go.navigation.shadowed.method.usages.title={0} 的隐藏方法
go.navigation.go.to.shadowed.method.popup.title=方法 {0} 隐藏 {1} {1, choice, 0\#类型|1\#类型|2\#类型}的方法
go.navigation.go.to.shadowed.method=转到阴影方法
go.navigation.go.to.super.method.popup.title=方法 {0} 实现 {1} {1, choice, 0\#接口|1\#接口|2\#接口} 中的方法
go.navigation.go.to.super.method.find.usages.title.kind={0} 已实现的方法规范
go.navigation.go.to.super.method=转到方法规范
go.navigation.go.to.super.popup.title=类型 {0} 实现 {1} {1, choice, 0\#接口|1\#接口|2\#接口}
go.navigation.go.to.super.find.usages.title={0} 已实现的接口
go.navigation.go.to.super=转到接口
go.navigation.go.to.type.implementation.popup.title={1} {1, choice, 0\#类型|1\#类型|2\#类型}中实现的类型 {0}
go.navigation.go.to.method.implementation.popup.title={1} {1, choice, 0\#类型|1\#类型|2\#类型}中实现的方法 {0}
go.navigation.go.to.implementation.find.usages.title={0} 的实现
go.navigation.go.to.implementation=转到实现
go.navigation.go.to.shadowing.method.popup.title={1} {1, choice, 0\#类型|1\#类型|2\#类型}中隐藏的方法 {0}
go.navigation.go.to.shadowing.method.find.usages.title={0} 的隐藏方法
go.navigation.go.to.shadowing.method=转到隐藏方法
go.navigation.recursive.call=递归调用
go.notification.dep.project.out.of.sync.text=Dep 项目 {0} 不同步。
go.notification.gokpg.toml.modified.text=修改了 {0} 的 Gopkg.toml。
go.notification.go.edit.project.settings.action.text=编辑 Go 项目设置
go.notification.go.support.is.disabled.in.module.text=''{0}'' 中禁用 Go 支持
go.notification.go.support.enable.action.text=启用 Go 支持
go.notification.go.setup.action.text=设置 GOROOT
go.notification.gopath.is.empty.text=GOPATH 为空
go.notification.gopath.configure.action.text=配置 GOPATH
go.notification.gopath.detected.title=检测到 GOPATH
go.notification.gopath.detected.text=我们从您的 GOPATH 中检测到一些库。您可能想在 GOPATH 配置中添加额外的库。
go.notification.gopath.detected.configure.gopath.action.text=配置 GOPATH
go.notification.vendoring.detected.title=检测到 Vendoring 用法
go.notification.vendoring.detected.text=<strong>供应商</strong>目录通常意味着项目使用 Go Vendor Experiment。选定的 Go SDK 版本支持供应商，但默认情况下处于禁用状态。您可能需要在项目设置中显式启用 Go Vendor Experiment。
go.notification.vendoring.detected.configure.go.vendor.experiment.action.text=配置 Go Vendor Experiment
go.notification.go.tool.is.missing.text=GOPATH 中缺少可执行文件 ''{0}''。您要安装吗?
go.notification.go.tool.is.missing.run.go.get.text=在 GOPATH 中找不到 ''{0}''。
go.notification.go.tool.is.missing.run.go.get.invoke.go.get.action.text=调用 ''go get {0}''
go.notification.install.go.tool.action.text=安装 Go 工具
go.notification.enable.gopath.indexing.action.text=启用 GOPATH 索引
go.notification.gopath.indexing.disabled.text=已禁用 GOPATH 索引
go.notification.gopath.indexing.disabled.content=因为项目使用 {0}，所以它冗余。\n您仍可以启用它。
go.notification.no.dependency.manager.configured.text=没有为此项目配置任何依赖项管理器。
go.notification.dependency.manager.integration.enabled.text=Integration is enabled.
go.notification.dependency.manager.enable.integration.action.text=启用集成
go.notification.dependency.manager.open.settings.action.text=打开设置
go.notification.add.to.gopath.action.text=添加到 GOPATH
go.notification.add.to.module.action.text=添加到模块
go.notification.create.go.mod.file.action.text=创建 go.mod 文件
go.notification.customize.ide.with.status.bar.widget.title=使用状态栏中的扳手图标编辑项目和应用程序 {0}
go.notification.dep.integration.title=Dep 集成
go.notification.dep.init.failed.title=Dep Init 失败
go.notification.dep.init.failed.configure.dep.action.text=配置 Dep
go.notification.go.modules.detected.text=Go module is detected
go.notification.go.modules.detected.module.path=Module path is ''{0}''.
go.notification.disable.go.modules.integration.action.text=Disable Go modules integration
go.notification.do.not.show.action.text=不要再显示
go.notification.cgo.optimizations.are.not.disabled=CGO_CFLAGS 未设置为 '-O0 -g'，无法优化 Cgo 代码。
go.notification.install.package.action.text=安装 {0}
go.notification.modules.file.is.absent.title=go.mod 文件不存在
go.notification.obsolete.imports.code.style.detected.title=检测到过时的导入代码样式设置
go.notification.review.code.style.settings.action.text=查看代码样式设置
go.notification.run.dep.ensure.action.text=运行 dep 确保
go.notification.file.starts.with.underscore.text=''{0}'' 将被构建工具忽略，因为其名称以 ''{1}'' 开头
go.notification.file.does.not.match.target.system.text=''{0}'' 与目标系统不匹配。文件将被构建工具忽略
go.notification.inspections.are.disabled.text=已禁用对此文件进行检查。
go.notification.inspections.are.disabled.enabled.action.text=启用检查
go.notification.code.insight.features.are.disabled.text=代码洞察功能不可用。
go.notification.file.exceeds.size.limit.text="文件大小 ({0}) 超出了所配置的限制 ({1}) 。{2}
go.notification.code.insight.disabled.for.vendored.files.text=库中供应文件的编辑代码洞察功能已禁用
go.notification.add.vendored.package.to.project.action.text=向项目中添加 ''{0}''；
go.profiler.profile.fraction.comment.text=控制配置文件中报告的互斥争用事件的分数。平均而言，报告 1/分数个事件。留空将使用默认分数 1。
go.profiler.profile.fraction.label.text=配置文件分数\:
go.profiler.profile.rate.cpu.comment.text=控制配置文件中报告的 goroutine 阻塞事件的分数。平均而言，分析器对程序每被阻塞速率纳秒采样一个阻塞事件。要将每个阻塞事件都包括在配置文件中，请将速率设置为 1。留空将使用默认速率 1。
go.profiler.profile.rate.label.text=配置文件速率\:
go.profiler.profile.illegal.rate.validation.message=非法分析速率\: {0}
go.profiler.profile.illegal.profile.fraction.validation.message=非法分析分数\: {0}
go.profiler.profile.rate.memory.comment.text=控制配置文件中记录和报告的内存分配的分数。平均而言，分析器对分配的每速率字节采样一次分配。要将每个分配的块都包括在配置文件中，请将速率设置为 1。留空将使用默认速率 512Kb。
go.profiler.blocking.profiler.name=阻止分析器
go.profiler.blocking.profile.prefix=阻止分析
go.profiler.cpu.profiler.name=CPU 分析器
go.profiler.cpu.profile.prefix=CPU 分析
go.profiler.memory.profiler.name=内存分析器
go.profiler.memory.profile.prefix=内存分析
go.profiler.mutex.profiler.name=Mutex 分析器
go.profiler.mutex.profile.prefix=Mutex 分析
go.project.sdk.label=项目 SDK\:
go.run.configuration.environment.label=环境(&V)\:
go.run.configuration.go.tool.arguments.label=Go 工具参数(&G)\:
go.run.configuration.module.label=模块(&M)\:
go.run.configuration.output.directory.label=输出目录(&O)\:
go.run.configuration.program.arguments.label=程序参数(&P)\:
go.run.configuration.run.after.build.checkbox=构建后运行(&R)
go.run.configuration.build.on.remote.target.checkbox=在远程目标上构建(&B)
go.run.configuration.run.kind.label=运行种类(&K)\:
go.run.configuration.run.with.sudo.label=通过 sudo 运行(&I)
go.run.configuration.run.with.sudo.tooltip=使用超级用户权限运行配置
go.run.configuration.run.with.sudo.mnemonic=使用提升的权限运行(&I)
go.run.configuration.add.go.tool.argument.label=添加
go.run.configuration.target.directory.label=目录(&D)
go.run.configuration.target.files.label=文件(&F)\:
go.run.configuration.target.package.label=包路径(&E)\:
go.run.configuration.test.framework=测试框架(&R)\:
go.run.configuration.test.kind.label=测试种类(&K)\:
go.run.configuration.test.kind.directory=目录
go.run.configuration.test.kind.package=包
go.run.configuration.test.kind.file=文件
go.run.configuration.application.kind.directory=目录
go.run.configuration.application.kind.package=包
go.run.configuration.application.kind.file=文件
go.run.configuration.test.pattern.label=模式(&T)\:
go.run.configuration.use.all.custom.build.tags.label=使用所有自定义构建标记(&L)
go.run.configuration.use.all.custom.build.tags.tooltip=构建时，将添加“设置”中的所有自定义构建标记
go.settings.build.tags.arch.label=弯弧
go.settings.build.tags.cgo.support.label=CGO 支持
go.settings.build.tags.compiler.label=编译器
go.settings.build.tags.custom.tags.hint=使用空格分隔标记
go.settings.build.tags.custom.tags.label=自定义标记
go.settings.build.tags.description=<html>\n  <head>\n    \n  </head>\n  <body>\n    <p>\n      以下选项描述了项目的目标系统。IDE 将使用这些值确定在验证期间应忽略哪些文件，解析并建议符号。有关详细信息，请参阅 <a href\="https\://golang.org/pkg/go/build/\#hdr-Build_Constraints">Go 约束文档</a>。\n    </p>\n  </body>\n</html>
go.settings.build.tags.display.name=构建标记 \\& Vendoring
go.settings.build.tags.group.name=构建标记
go.settings.build.tags.os.label=OS
go.settings.build.tags.version.label=Go 版本
go.settings.build.tags.any.sdk.value=任意
go.settings.default.value=默认 ({0})
go.settings.project.sdk.value=项目 SDK ({0})
go.settings.default.for.project.sdk.value=SDK ({0}) 的默认值
go.settings.enabled=启用
go.settings.disabled=禁用
go.settings.common.suggest.parameter.names.checkbox=在补全时建议参数名称
go.settings.common.show.auto.import.in.completion.popup.checkbox=在键入时建议需要另外导入的变体
go.settings.common.indent.on.enter.in.raw.strings.checkbox=在输入原始字符串时缩进
go.settings.common.show.documentation.in.parameter.info.checkbox=在参数信息中显示文档
go.settings.common.detect.go.packages.from.clipboard.checkbox=从剪贴板检测 go 包
go.settings.common.enable.experimental.support.for.type.parameters=启用泛型(实验性支持类型参数)
go.settings.common.enable.experimental.support.for.type.parameters.tooltip=当前实现基于类型参数 - Ian Lance Taylor 和 Robert Griesemer 的草稿设计已于 2020 年 6 月 16 日发布。
go.settings.common.enable.experimental.support.for.type.parameters.link.title=阅读详细信息。
go.settings.common.confirmation.show.options.option=显示选项
go.settings.common.package.rename.rename.directory.option=重命名目录
go.settings.common.package.rename.do.not.rename.directory.option=不重命名目录
go.settings.common.directory.rename.rename.package.option=重命名包
go.settings.common.directory.rename.do.not.rename.package.option=不重命名包
go.settings.common.test.rename.corresponding.file.option=重命名相应的测试或生产文件
go.settings.common.test.do.not.rename.corresponding.file.option=不重命名相应的测试或生产文件
go.settings.common.directory.rename.option=重命名目录时
go.settings.common.package.rename.option=重命名包时
go.settings.common.test.rename.option=重命名文件时
go.settings.debugger.stack.depth.name=堆栈深度
go.settings.debugger.goroutines.limit.name=Goroutines 限制
go.settings.debugger.rebuild.transitive.packages.checkbox=重新构建过渡包(&R)
go.settings.debugger.rebuild.transitive.packages.description=为了获得更好的调试体验，Delve 需要在 $GOROOT/pkg 中重新编译优化的模块。
go.settings.imports.display.name=导入
go.settings.modules.display.title=Go 模块
go.settings.modules.display.name=Go modules
go.settings.sdk.unknown.version.at.path=''{0}'' 中的 Go 版本未知
go.settings.sdk.detected.notification.title=检测到 GOROOT
go.settings.sdk.detected.notification.text=<b>{0}</b> 被自动设置为项目 SDK。您可以在 GOROOT 配置中进行更改。
go.settings.sdk.detected.notification.configure.go.sdk.action.text=配置 Go SDK
go.settings.sdk.enable.integration.label=在模块中启用 Go 支持\: 
go.settings.sdk.combo.tooltip=添加 SDK...
go.settings.sdk.add.button=添加 SDK...
go.settings.sdk.add.action.name=本地...
go.settings.sdk.add.local.title=为 Go SDK 选择主目录
go.settings.sdk.add.button.tooltip=添加 SDK ({0})
go.settings.sdk.download.action.name=下载...
go.settings.sdk.download.dialog.title=下载 Go SDK
go.settings.sdk.download.dialog.version.label=版本：
go.settings.sdk.download.dialog.location.label=位置\:
go.settings.sdk.download.dialog.reload.versions.action.name=重启
go.settings.sdk.download.dialog.cannot.load.go.versions.validation.message=无法下载 Go 版本。{0}
go.settings.sdk.download.dialog.version.is.not.specified.validation.message=指定版本。
go.settings.sdk.download.dialog.location.is.not.specified.validation.message=指定目标目录。
go.settings.sdk.download.dialog.cannot.create.directory.validation.message=无法在给定路径中创建目录。
go.settings.sdk.download.progress.downloading.status=下载 Go {0}
go.settings.sdk.download.progress.verifying.status=正在验证下载的档案...
go.settings.sdk.download.progress.unpacking.status=正在解压缩 SDK...
go.settings.sdk.download.unpacked.sdk.is.corrupted.error=解压缩的 SDK 损坏
go.settings.sdk.download.checksum.of.downloaded.file.mismatched.error=下载的文件的校验和不匹配
go.settings.sdk.download.could.not.get.checksum.error=无法获取校验和\: {0}
go.settings.sdk.download.could.not.find.go.directory.in.downloaded.file.error=在下载的文件中找不到 go 目录
go.settings.sdk.download.could.not.unpack.downloaded.file.error=无法解压缩下载的文件
go.settings.sdk.download.could.not.copy.unpacked.sdk.error=无法复制解压缩的 SDK
go.settings.sdk.download.could.not.create.target.directory.error=无法创建目标目录
go.settings.sdk.download.installed.notification.title=已安装 Go {0}
go.settings.sdk.download.failed.to.download.notification.title=下载 SDK 失败
go.settings.modules.enable.integration.checkbox=Enable Go modules integration
go.settings.modules.choose.module.dialog.title=选择 Go 模块
go.settings.modules.choose.module.validation.message=应至少选择一个模块
go.settings.modules.dependency.file.type.description=Go modules dependency file
go.settings.modules.goproxy.documentation.link.title=模块下载和验证
go.settings.modules.goproxy.tooltip=GOPROXY 指示 go 命令在下载依赖项时使用特定的代理服务器。
go.settings.modules.environment.label=环境：
go.settings.modules.environment.context.help=GOPROXY、GOPRIVATE 等
go.settings.modules.sync.dependencies.fix.family.name=同步依赖关系
go.settings.modules.sync.dependencies.fix.text=同步 {0} 的依赖关系
go.settings.modules.vendoring.checkbox=自动启用供应支持
go.settings.modules.vendoring.checkbox.tooltip=自 Go 1.14 以来已忽略。<br>在 Go 1.14 之前，每当模块包含 vendor 目录时，都会启用 vendoring 支持。特别是，IDE 使用 -mod\=vendor 标志运行 go 工具。
go.settings.modules.vendoring.documentation.link.title=如何为模块使用 vendoring
go.settings.run.configuration.invalid.env.name=非法的环境变量名称\: ''{0}''
go.settings.run.configuration.invalid.env.value=环境变量 ''{0}'' 的值非法\: ''{1}''
go.settings.modules.explain.environment.variable=解释变量
go.settings.modules.add.other.environment.variable=其它
go.settings.modules.gosumdb.description=GOSUMDB 识别校验和数据库的名称。go 命令使用它来确保下载的依赖项的校验和没有更改。
go.settings.modules.gosumdb.documentation.link.title=模块身份验证失败
go.settings.modules.goprivate.description=GOPRIVATE 列出了被视为 private 的包。在下载和验证这些包时，go 命令不会使用代理或校验和数据库。
go.settings.modules.goprivate.documentation.link.title=非 public 模块的模块配置
go.settings.modules.gonoproxy.description=GONOPROXY 列出了被视为 private 的包。下载这些包时，go 命令不会使用代理。覆盖 GOPRIVATE。
go.settings.modules.gonosumdb.description=GONOSUMDB 列出了被视为 private 的包。验证这些包时，go 命令不会使用校验和数据库。覆盖 GOPRIVATE。
go.settings.modules.gomodcache.description=GOMODCACHE 设置模块缓存位置。
go.settings.modules.gomodcache.documentation.link.title=Go 1.15 发行说明
go.settings.postfix.enter.type.import.path.label=导入路径(&I)\:
go.settings.postfix.enter.type.name.label=类型名称(&T)\:
go.settings.postfix.enter.type.empty.type.validation.message=指定类型名称
go.settings.postfix.enter.type.action.name=输入类型名称...
go.settings.postfix.choose.type.action.name=选择类型...
go.settings.postfix.choose.type.prompt.text=选择类型
go.settings.vendoring.cannot.be.disabled.error.message=Go {0} 不支持禁用 vendor 试验
go.settings.vendoring.description=<html>\n  <head>\n    \n  </head>\n  <body>\n    <p>\n      启用此选项时，IDE 将按照 <a href\="https\://golang.org/s/go15vendor">Go Vendoring 试验方案</a>解析并补全符号。\n    </p>\n    <p>\n      也会在 IDE 中为所有 go 执行设置 <strong>GO15VENDOREXPERIMENT</strong> 环境变量的对应值。\n    </p>\n  </body>\n</html>
go.settings.vendoring.enable.vendoring.checkbox=启用 vendoring
go.settings.vendoring.group.name=供应商实验
go.settings.vendoring.is.not.supported.error.message=Go {0} 不支持 vendor 试验
go.template.intention.add.type.hint.name=指定点类型
go.unknown.type.information.hint=<未知>
group.GoTools.description=Go 外部工具
group.GoTools.text=Go 工具
go.call.hierarchy.respect.interface.calls.action.name=遵循接口调用
go.call.hierarchy.respect.interface.calls.description=遵循接口调用
go.settings.formatter.no.exceptions.empty.text=无异常
go.settings.formatter.comment.prefix.dialog.title=注释前缀
go.settings.formatter.wrap.call.arguments=函数调用参数
go.settings.formatter.wrap.comp.lit=复合文字
go.settings.formatter.wrap.func.params=函数参数
go.settings.formatter.wrap.func.result=函数结果参数
go.settings.diff.ignore.imports.and.formatting.description=忽略导入和格式化
go.settings.debugger.default.integer.format.label=默认整数格式\:
go.status.bar.configure.project.widget=IDE 和项目 {0}
go.executable.file.chooser.title=选择 {0}
go.executable.file.process.icon.tooltip=正在发现 {0}
go.executable.file.invalid.path.text=无效路径
go.executable.file.cannot.retrieve.version=无法检索版本
go.executable.file.empty.value=<Empty>
go.fmt.add.leading.space.to.comments=向注释添加前导空格
go.fmt.add.parentheses.for.single.import=为单个导入添加括号
go.fmt.group.current.project.imports=组合当前项目导入
go.fmt.group.stdlib.imports=组合 stdlib 导入
go.fmt.imports.tab.title=导入
go.fmt.move.all.imports.in.single.declaration=将所有导入移动到一个声明中
go.fmt.move.all.stdlib.imports.in.single.group=将所有 stdlib 导入移动到一个组中
go.fmt.other.tab.title=Java EE
go.fmt.remove.redundant.import.aliases=移除冗余导入别名
go.fmt.import.sorting.type=排序类型
go.fmt.use.back.quotes.for.imports=为导入使用左引号
go.fmt.fill.paragraph.width.label=填充段落宽度\: 
go.debugger.disconnected.unexpectedly=调试器意外断开连接
go.debugger.failed.to.compute.node.presentation=无法计算节点表示
go.debugger.connection.failed.generic.message=连接到 {0} 失败
go.debugger.connecting.to.address.message=连接到{0}...
go.debugger.connecting.to.unknown.address.message=正在连接到远程地址...
go.debugger.cannot.retrieve.go.processes=无法检索 Go 进程
go.debugger.install.gops.to.attach.to.go.processes=安装 {0} 以附加到 Go 进程
go.debugger.local.attach.group.name=Go
go.debugger.breakpoint.title=Go 断点
go.debugger.error.breakpoint.title=Go 错误断点
go.debugger.error.breakpoint.display.text=致命错误
go.debugger.missing.function.name=<缺少>
go.debugger.record.and.debug.action.name=录制并调试
go.debugger.record.and.debug.description=录制并调试
go.debugger.record.and.debug.start.action.text=录制并调试
go.debugger.record.and.debug.cannot.find.rr.message=<html>无法找到 <a href\="https\://rr-project.org">mozilla rr</a> 可执行文件。安装该文件并将其添加到 PATH 中。</html>
go.debugger.internal.messaging.error=内部消息传递错误
go.debugger.cannot.connect.twice=Delve 进程不能连接两次
go.debugger.cannot.connect.non.remote=Delve 进程无法连接，因为它不使用远程连接
go.debugger.cannot.evaluate.expression=无法评估表达式 ''{0}''\: {1}
go.debugger.cannot.get.current.goroutine=无法获取当前 goroutine
go.debugger.go.version.is.not.officially.supported=Go {0} 未受到该调试器的官方支持，某些功能可能无法正常运行。请升级到 go {1} 或更高版本。
go.debugger.go.version.is.not.supported=Go {0} 未受到该调试器的支持。请升级到 go {1} 或更高版本。
go.debugger.no.debug.information.for.file=可执行文件不包含 {0} 的调试信息
go.debugger.cannot.pause=无法暂停
go.debugger.recording.in.progress=正在录制程序执行。要调试录制，请等待程序终止或<a href\=''{0}''>停止录制</a>。
go.debugger.failed.to.stop.mozilla.rr.recording=无法停止 Mozilla rr 记录
go.debugger.failed.to.stop.mozilla.rr.recording.details=无法停止 Mozilla rr 记录\: {0}
go.debugger.cannot.evaluate.call=无法评估调用\: {0}
go.debugger.non.top.frame.selected=已选择非顶部框架
go.debugger.missing.current.function=缺少当前函数
go.debugger.unused.functions.are.not.included.message=" (未使用的函数未包含在可执行文件中)"
go.debugger.unused.methods.are.not.included.message=" (未使用的方法未包含在可执行文件中)"
go.debugger.smart.step.into.failed=智能单步进入失败\: {0}
go.debugger.expression.is.not.a.function=''{0}'' 不是函数
go.debugger.expression.is.nil=''{0}'' 为零
go.debugger.cannot.retrieve.interface.value.type=无法检索接口值的类型
go.debugger.cannot.get.current.stack=无法获取当前堆栈
go.debugger.smart.step.into.popup.title=单步进入函数
go.debugger.renderers.binary.name=二进制
go.debugger.renderers.decimal.name=十进制
go.debugger.renderers.hex.name=十六进制
go.debugger.renderers.default.renderer.name=默认渲染器
go.debugger.computing.full.value.of.call.results.is.not.supported=不支持计算调用结果的完整值
go.debugger.cannot.calculate.value=无法计算值
go.debugger.obsolete.value=<过时>
go.debugger.cannot.calculate.string.presentation=无法计算字符串表示\: {0}
go.debugger.unsupported.type=<不支持的类型\: {0}>
go.debugger.cannot.load.remaining.call.result.children=无法加载剩余的调用结果子级
go.debugger.unreadable.error=\ 不可读\: {0}
go.debugger.fmt.sprintf.unsupported.format=(不支持的格式)
go.debugger.fmt.sprintf.unsupported.verb=(不支持的动词)
go.debugger.fmt.sprintf.cannot.format.value=(无法格式化值)
go.debugger.async.stacktrace.caption=异步堆栈跟踪
go.debugger.thread=线程
go.debugger.goroutine=Goroutine
go.debugger.unsupported.architecture.error=仅 64 位系统和 32位 linux 中支持调试
go.debugger.only.first.goroutines.are.shown=仅显示第一个 {0} goroutines
go.settings.debugger.general.section.name=Go
go.settings.debugger.dataViews.section.name=Go
go.execution.package.is.not.specified.error=未指定包
go.execution.cannot.find.package.error=无法找到包 <code>{0}</code>
go.execution.package.contains.several.mains.error=包 <code>{0}</code> 包含多个 <code>main</code> 函数<br>请考虑改用文件种类
go.execution.cannot.find.directory.error=无法找到目录 <code>{0}</code>
go.execution.run.after.build.is.not.possible.incompatible.os.error=无法在构建后运行<br>结果二进制文件将与操作系统不兼容
go.execution.run.after.build.is.not.possible.main.not.found.single.file.error=无法在构建后运行<br>主文件具有非主包或不包含主函数
go.execution.run.after.build.is.not.possible.main.not.found.many.files.error=无法在构建后运行<br>选定的文件都没有主包或主函数
go.execution.file.not.found.error=未找到文件\: <code>{0}</code>
go.execution.files.must.be.in.one.directory.error=命名文件必须全部位于一个目录中
go.execution.not.go.file.error=文件不是 Go 文件\: {0}
go.execution.application.run.configuration.display.name=Go 构建
go.execution.application.run.configuration.description=Go 构建运行配置
go.execution.before.run.task.name=Run Go command
go.execution.before.run.task.description=运行 `{0}`
go.execution.before.run.task.supports.only.go.run.configurations.error=Go command task supports only Go run configurations
go.execution.before.run.task.supports.only.go.modules.error=Go command task supports only modules with enabled Go integration
go.execution.before.run.task.executing.presentable.name=正在执行 `{0}`
go.execution.before.run.task.error.dialog.title=Go 命令任务
go.execution.before.run.task.edit.go.command.dialog.title=编辑 Go 命令任务
go.execution.before.run.task.empty.command.error=不允许空 Go 命令
go.execution.before.run.task.command.should.not.start.with.go.error=Go 命令不应以 `go` 开始
go.execution.extension.failed.to.patch.command.line.error=无法修补命令行
go.execution.coverage.percent.statements=语句百分比
go.execution.coverage.percent.files=% 文件
go.execution.coverage.covered=已覆盖
go.execution.coverage.engine.name=Go 覆盖率
go.execution.coverage.cannot.run.coverage.on.directory.kind.run.configurations.error=无法在目录种类运行配置上运行覆盖率分析
go.execution.coverage.loading.coverage.data=正在加载覆盖率数据...
go.execution.coverage.runner.name=Go
go.test.creator.empty.test.file.name=空测试文件
go.test.creator.test.for.function.name=函数测试
go.test.creator.test.for.file.name=文件测试
go.test.creator.test.for.package.name=包测试
go.test.creator.test.for.selection.name=选择范围测试
go.test.creator.gotests.download.gotests.dialog.title=gotest
go.test.creator.gotests.generation.name=测试生成
go.test.creator.gotests.no.tests.generated=未生成测试
go.test.creator.gotests.failed.to.create.test.file=无法创建测试文件 {0}
go.test.creator.gotests.generation.failed.notification.title=测试生成失败
go.test.creator.cannot.find.test.package.name=无法找到测试包名称
go.test.creator.cannot.find.test.import.path=无法找到测试导入路径
go.test.creator.cannot.find.function.signature=无法找到函数签名
go.test.creator.cannot.find.method.receiver=无法找到 {0} 的方法接收器
go.test.creator.cannot.find.method.receiver.type=无法找到 {0} 的方法接收器类型
go.test.creator.cannot.find.field.type=无法找到 {0} 的字段类型
go.test.generate.table.benchmark.text=表基准
go.test.generate.table.benchmark.description=生成表基准函数
go.test.generate.table.test.text=表测试
go.test.generate.table.test.description=生成表测试函数
go.test.generate.function.description=生成 {0} 函数
go.test.generate.test.text=测试
go.test.generate.test.main.text=Test_main
go.test.generate.benchmark.text=基准
go.test.generate.example.text=Example
go.test.testify.run.configuration.name={1} 中的 {0}
go.test.testify.unknown.target.name=未知
go.test.framework.not.available.in.module.error=框架 <code>{0}</code> 在选定模块中不可用
go.test.working.directory.should.be.ancestor.of.testing.directory.error=工作目录应该是测试目录的祖先
go.test.testing.directory.does.not.exist.error=测试目录不存在
go.test.non.a.package.error=<code>{0}</code> 不是包。<br>使用目录种类运行配置在目录上递归运行测试
go.test.cannot.find.files.compatible.with.framework.error=无法在与 <code>{1}</code> 框架兼容的 <code>{0}</code> 中找到 Go 测试文件
go.test.file.does.not.exist.error=文件不存在\: {0}
go.test.not.go.file.error=文件 ''{0}'' 不是 Go 文件
go.test.framework.is.not.available.on.files.error=框架 <code>{0}</code> 在任何文件 <code>{1}</code> 上都不可用
go.test.suggested.run.configuration.name={1} 中的 {0}
go.test.run.configuration.name=Go 测试
go.test.run.configuration.description=Go 测试运行配置
go.test.template.run.configuration.name=Go 测试
go.test.run.test.tooltip=运行测试
go.test.no.tests.were.run=未运行任何测试
go.test.cannot.run.compiling.on.directory.kind.run.configurations.error=无法在目录种类运行配置上运行编译
go.execution.cannot.find.target.to.compile.error=无法找到要编译的目标
go.execution.cannot.create.temp.output.file.error=无法创建临时输出文件
go.execution.cannot.create.output.file.error=无法创建输出文件 {0}
go.execution.cannot.create.output.file.in.error=无法在 {0} 中创建输出文件
go.execution.cannot.make.temporary.file.executable.error=无法使临时文件成为可执行文件 {0}
go.execution.outdated.go.notification.title=Your version of Go is outdated
go.execution.outdated.go.notification.text=要完全支持所有调试功能，请更新 Go 版本。
go.execution.change.goroot.action.name=更改 GOROOT
go.execution.compilation.finished.with.exit.code=编译完成，并显示退出代码 $EXIT_CODE$
go.execution.compiled.binary.cannot.be.executed=无法执行已编译的二进制文件
go.execution.compilation.failed.notification.title=编译失败
go.execution.install.lldb.notification.text=使用 xcode-select --install 安装 lldb
go.execution.go.setup.folding.placeholder=<{0} go 设置{0,choice,1\#调用|2\#调用}>
go.execution.remote.run.configuration.display.name=Go Remote
go.execution.remote.run.configuration.description=Go Remote
go.execution.remote.run.configuration.start.delve.text=在运行此配置之前，请按以下说明启动应用程序和 Delve。<br><br>允许 Delve 编译应用程序\:<br><pre>dlv debug --headless --listen\=\:{0} --api-version\=2 --accept-multiclient</pre><br>或使用 Go {3} 或更高版本编译应用程序\:<br><pre>go build -gcflags \"all\=-N -l\" github.com/app/demo</pre><br>，然后使用以下命令通过 Delve 运行\:<br><pre>dlv --listen\=\:{1} --headless\=true --api-version\=2 --accept-multiclient exec ./{2}</pre>
go.execution.remote.run.configuration.host.label=主机(&H)\:
go.execution.remote.run.configuration.port.label=端口(&P)\:
go.execution.sdk.is.not.specified.error=没有为模块 <code>{0}</code> 指定 Go SDK
go.execution.module.does.not.exist.error=模块 <code>{0}</code> 在项目中不存在
go.execution.working.directory.is.not.specified.error=未指定工作目录
go.execution.cannot.find.working.directory.error=无法找到工作目录 <code>{0}</code>
go.execution.go.is.not.configured.error=没有为运行配置配置 Go\: {0}
go.execution.run.application.tooltip=运行应用程序
go.execution.process.finished.with.exit.code={0}完成，并显示退出代码 {1}
go.execution.application.process.name=进程
go.execution.debugger.process.name=调试器
go.execution.unknown.target.delve.socket.error=无法运行 Delve。目标套接字未知。运行状态\: {0}
go.execution.process.interrupted=已中断
go.execution.process.cancelled=已取消
go.execution.go.sdk.is.not.downloaded.yet=Go SDK 尚未下载
go.execution.process.finished.successfully=成功完成
go.execution.process.failed.to.run=运行失败
go.execution.unknown.error=未知错误，详情参见日志
go.execution.sdk.is.not.set=未设置 SDK 或模块的 SDK 主路径为空
go.execution.enter.sudo=请输入您的 sudo 密码\:
go.import.optimizer.removed.imports=移除的 {0} 个{0,choice,1\#导入|2\#导入}
go.import.optimizer.removed.aliases=移除的 {0} 个{0,choice,1\#别名|2\#别名}
go.import.optimizer.removed.imports.and.aliases=移除的 {0} 个{0,choice,1\#导入|2\#导入}和 {1} 个{0,choice,1\#别名|2\#别名}
go.import.package.fix.family.name=导入包
go.import.package.fix.text=导入包
go.import.package.fix.text.no.variants=导入包?
go.import.package.fix.text.single.variant=导入 {0}?
go.import.package.fix.text.many.variants=导入{0}? (多个选择…)
go.import.package.popup.title=要导入的包
go.import.package.cannot.invoke.fix.with.ambiguous.imports.error=无法在编辑器 {0} 上对不明确的导入调用修复。包\: {1}
go.create.intermediate.variable.declaration.fix.name=创建中间变量
go.add.import.command.name=添加导入
go.add.import.with.alias.presentation={0} 作为 {1}
go.error.parser.expected=应为 ''{0}''
go.error.parser.expected.got=应为 ''{0}''，但得到的是 ''{1}''
go.error.parser.unexpected=意外的''{0}''
go.error.annotator.invalid.package.name=无效的包名称
go.error.annotator.continue.statement.not.inside.a.for.loop=Continue 语句不在 for 循环内
go.error.annotator.break.statement.not.inside.a.for.loop.select.or.switch=Break 语句不在 for 循环内，请选择或切换
go.error.annotator.unexported.field.usage.in.struct.literal=在结构文字中使用了未导出的字段 ''{0}''
go.error.annotator.unexported.reference.usage=使用了未导出的{0} ''{1}'' 
go.error.annotator.type.is.not.an.expression=类型 {0} 不是表达式
go.error.annotator.unexported.type.usage=使用了未导出的类型 {0}''
go.error.annotator.reference.is.not.a.type={0} 不是类型
go.error.annotator.missing.key.in.map.literal=映射文字中缺少键
go.error.annotator.use.of.type.outside.type.switch=在类型 switch 外部使用 .(类型)
go.error.annotator.invalid.type.assertion=无效的类型断言\: {0} (左侧为非接口类型 {1})
go.error.annotator.invalid.type.switch.guard=无效的类型 switch 临界\: {0} (左侧为非接口类型 {1})
go.error.annotator.map.key.type.is.not.comparable=无效的映射键类型\: 必须为键类型完全定义比较运算符 \=\= 和 \!\=
go.error.annotator.call.used.as.value.but.it.returns.nothing={0} 用作值，但它不返回任何内容
go.error.annotator.multiple.value.in.single.value.context=单值上下文中存在多值 {0}
go.error.annotator.type.aliases.are.available.since.go.1.9=类型声明中存在意外的 \=; 类型别名自 Go 1.9 以后可用
go.error.annotator.missing.function.body=缺少{0}正文
go.error.annotator.main.or.init.has.invalid.signature={0} 函数必须没有参数和返回值
go.error.annotator.invalid.index.or.slice.operation=无效的操作 {0} (字符串的 3 索引切片)
go.error.annotator.unexpected.end.of.statement=语法错误\: 语句意外结束，预期 \:\= 或 \= 或逗号
go.error.annotator.unexpected.newline.after.if=意外的新行，在 if 子句之后预期 '{'
go.error.annotator.missing.condition.in.if.statement=if 语句中缺少条件
go.error.annotator.semicolon.is.missing=缺少 ;
go.error.annotator.fallthrough.statement.out.of.place=Fallthrough 语句不在合适的位置
go.error.annotator.cannot.fallthrough.final.case.in.switch=无法在 switch 中直落最终 case
go.error.annotator.cannot.fallthrough.in.type.switch=无法在类型 switch 中直落
go.error.annotator.end.of.file.in.comment=文件结尾位于注释中
go.error.annotator.array.bound.must.be.a.constant.expression=无效的数组绑定 ''{0}''，必须是一个常量表达式
go.error.annotator.array.bound.must.be.non.negative=无效的数组绑定 ''{0}''，必须为非负
go.error.annotator.array.bound.must.be.representable.by.int.type=无效的数组绑定 ''{0}''，该值必须可以通过 ''int'' 类型表示
go.error.annotator.invalid.argument.for.len=参数的 len 无效
go.error.annotator.invalid.argument.for.cap=参数的 cap 无效
go.error.annotator.cannot.declare.init.must.be.a.function=无法声明 init，必须为函数
go.error.annotator.too.many.arguments.to.new=参数过多，无法添加新参数
go.error.annotator.cannot.make.type=无法生成 {0}
go.error.annotator.argument.is.not.a.type={0} 不是类型
go.error.annotator.missing.argument.to.make=缺少要生成的参数
go.error.annotator.non.integer.size.argument.to.make=要生成非整数大小参数
go.error.annotator.non.integer.capacity.argument.to.make=要生成非整数容量参数
go.error.annotator.missing.len.argument.to.make=缺少要生成的 len 参数
go.error.annotator.too.many.arguments.to.make=要生成的参数过多
go.error.annotator.cyclic.definition.detected=检测到循环定义
go.error.annotator.use.of.package.without.selector=使用无选择器的包 {0}
go.error.annotator.unexpected.assign.operator=意外{0}，预期 \:\= 或 \= 或逗号
go.error.annotator.invalid.constant.type=无效的常量类型
go.error.annotator.const.initializer.is.not.a.constant=常量初始值设定项 ''{0}'' 不是常量
go.error.annotator.missing.value.in.const.declaration=常量声明中缺少值
go.error.annotator.extra.expression.in.const.declaration=常量声明中有额外的表达式
go.error.annotator.conversion.in.defer.or.go={0} 需要函数调用，而不是转换
go.error.annotator.function.not.permitted.in.defer.or.go=无法在 {0} 声明中调用此函数
go.error.annotator.parenthesized.expression.in.defer.or.go={0} 中的表达式不得使用括号
go.error.annotator.defer.or.go.requires.function.call={0} 中的表达式必须为函数调用
go.error.annotator.evaluated.but.not.used={0} 已评估但未使用
go.error.annotator.cannot.declare.in.post.statement.of.for.loop=无法在 for 循环的 post 语句中声明
go.error.annotator.too.many.variables.in.range=范围中的变量过多
go.error.annotator.named.and.unnamed.parameters={0} 同时具有命名参数和未命名参数 ''{1}''
go.error.annotator.named.and.unnamed.return.parameters={0} 同时具有命名和未命名的返回参数 ''{1}''
go.error.annotator.can.only.use.triple.dot.as.final.argument=只能将 '...' 用作列表中的最后一个参数
go.error.annotator.cannot.use.triple.dot.for.output.arguments=不能在输出参数列表中使用 '...'
go.error.annotator.method.name.in.interface.cannot.be.blank=接口中的方法名称不能为空
go.error.annotator.digit.separator.is.not.supported=从 Go {0} 开始支持数字分隔符
go.error.annotator.binary.digits.are.not.supported=从 Go {0} 开始支持二进制字符串
go.error.annotator.octal.prefix.is.not.supported=从 Go {0} 开始支持八进制前缀
go.error.annotator.hex.floats.are.not.supported=从 Go {0} 开始支持十六进制浮点
go.error.annotator.closing.single.quote.expected=预期右 '
go.error.annotator.empty.rune.literal=空卢恩文字
go.error.annotator.too.many.characters.in.rune.literal=卢恩文字中的字符数过多
go.error.annotator.invalid.select.assignment=选定赋值在右侧必须具有 receive
go.error.annotator.invalid.select.case=选定 case 必须为 receive、send 或 assign receive
go.error.annotator.cannot.reassign.a.constant=不能重新分配常量
go.error.annotator.no.new.variables=\:\= 的左侧没有新变量
go.error.annotator.assignment.count.mismatch=赋值计数不匹配\: {0} \= {1}
go.error.annotator.cannot.assign.to.expression=无法分配给 {0}
go.error.annotator.multiple.defaults={0} 中存在多个默认值
go.error.annotator.new.line.in.string=字符串中出现新行
go.error.annotator.bad.octal.escape=八进制转义必须包含三个八进制数字，第一个数字必须小于或等于 3
go.error.annotator.invalid.hex.escape.sequence.syntax=\\x 必须后跟两个十六进制数字
go.error.annotator.invalid.unicode.escape.sequence.syntax=\\u 必须后跟四个十六进制数字
go.error.annotator.invalid.long.unicode.escape.sequence.syntax=\\U 必须后跟八个十六进制数字
go.error.annotator.invalid.escape.sequence=无效的转义序列
go.error.annotator.invalid.unicode.code.point=无效的 Unicode 代码点
go.error.annotator.invalid.embedded.type=无效的类型 {0}\: 必须为 typeName 或 *typeName
go.error.annotator.embedded.type.cannot.be.a.pointer=嵌入类型不能是指针
go.error.annotator.embedded.type.cannot.be.a.pointer.to.interface=嵌入类型不能是指向接口的指针
go.error.annotator.cannot.call.pointer.method=无法在 ''{0}'' 中调用指针方法
go.error.annotator.type.parameters.are.not.supported=泛型(实验性支持类型参数)已禁用
go.error.annotator.type.parameters.are.supported.only.in.go2.files=泛型(实验性支持类型参数)仅适用于 .go2 文件
go.go.mod.error.annotator.no.module.statement=文件中没有模块语句
go.go.mod.error.annotator.multiple.module.statements=文件中存在多个模块语句
go.go.mod.error.annotator.multiple.version.statements=文件中存在多个 go 版本的语句
go.go.mod.error.annotator.missing.dependency=缺少依赖关系
go.go.mod.error.annotator.unresolved.dependency=未解析的依赖项
go.go.mod.error.module.version.expected=应为模块版本
go.terms.duplicate=重复
go.terms.duplicated.case=重复的 case
go.terms.duplicated.default=重复的默认值
go.terms.version.statement=版本语句
go.terms.module.statement=模块语句
go.terms.empty.declaration=空声明
go.terms.shadowed.declaration=隐藏的声明
go.terms.comment=注释
go.terms.variable=变量
go.terms.method=方法
go.terms.closure=结束
go.terms.import=导入
go.terms.parameter=参数
go.terms.receiver=接收器
go.terms.import.alias=导入别名
go.terms.label=标签
go.terms.package=包
go.terms.package.statement=包语句
go.terms.package.capitalized=包
go.terms.map=映射
go.terms.chan=chan
go.terms.string=字符串
go.terms.array=数组
go.terms.declaration=声明
go.terms.statement=声明
go.terms.semicolon=分号
go.terms.comma=逗号
go.terms.go.statement=go 语句
go.terms.case=case
go.terms.slice=切片
go.terms.pointer=指针
go.terms.struct=结构
go.terms.anonymous.field=匿名字段
go.terms.type.alias=类型别名
go.terms.global.variable=全局变量
go.terms.constant=常量
go.terms.global.constant=全局常量
go.terms.field=字段
go.terms.type=类型
go.terms.type.pluralized=类型
go.terms.interface=接口
go.terms.function=函数
go.terms.method.specification=方法规范
go.refactoring.implement.methods.command=实现{0}
go.refactoring.implement.methods.prompt=选择要实现的接口\:
go.refactoring.implement.methods.checkbox=非项目
go.refactoring.implement.methods.dummy.background.updater.task.title=处理中...
go.refactoring.implement.methods.create.type.name=创建类型...
go.refactoring.extract.interface.caret.should.be.inside.type.error.message=脱字符号应定位在要重构的类型内
go.refactoring.unexported.validation.message=未导出的{0}将不再可以从{1}访问
go.refactoring.redeclare.validation.message={0} 将重新声明相同名称的 {1}
go.refactoring.less.than.one.declaration.validation.message=应至少选择一个声明。
go.refactoring.empty.target.directory.path.validation.message=目标目录路径不应为空。
go.refactoring.empty.target.file.name.validation.message=目标文件名不应为空。
go.refactoring.incorrect.file.name.validation.message=目标文件名不正确。
go.refactoring.empty.target.package.validation.message=目标包名称不应为空。
go.refactoring.incorrect.package.name.validation.message=目标包名称不正确。
go.refactoring.non.writable.directory.validation.message=目标目录不可写。
go.refactoring.non.writeable.file.validation.message=目标文件不可写。
go.refactoring.different.package.name.validation.message=现有文件的包名称不应不同。
go.refactoring.non.go.file.validation.message=目标文件应为 Go 文件。
go.refactoring.file.chooser.dialog.title=选择目标目录或文件
go.refactoring.file.label=目标文件\:
go.refactoring.failed.to.create.directory.error.message=无法找到或创建目录 ''{0}''
go.refactoring.failed.to.create.file.for.package.error.message=无法为包 ''{1}'' 找到或创建文件 ''{0}''
go.refactoring.refactor.action=重构
go.refactoring.rename.action=收藏列表的新名称
go.refactoring.inline.defined.in.goroot.error.message=变量 {0} 在 GOROOT 中定义
go.refactoring.inline.no.initializer.error.message={0} {1} 没有初始值设定项
go.refactoring.inline.defined.in.multi.value.context.error.message={0} {1} 在多值上下文中定义
go.refactoring.inline.found.usages.in.goroot.message=已在 GOROOT 中找到 ''{1}'' 的 {0, choice, 1\#1 个用法|2\#{0} 个用法}。
go.refactoring.inline.kept.definition.and.inlined.message=已保留定义{0, choice, 0\#|1\#和项目与 GOPATH 中的 1 个内联用例|2\#和项目与 GOPATH 中的 {0} 个内联用例}。
go.refactoring.change.signature.reuse.types.checkbox=重用类型
go.refactoring.change.signature.result.parameters.tab.title=结果参数
go.refactoring.change.signature.not.legal.identifier.validation.message=''{0}'' 不是合法标识符。
go.refactoring.change.signature.named.and.unnamed.parameters.validation.message=不允许同时存在命名和未命名参数。
go.refactoring.change.signature.parameter.without.type.validation.message=第 {0,number,ordinal} 个参数应具有类型。
go.refactoring.change.signature.used.multiple.times.validation.message=''{0}'' 被多次使用。
go.refactoring.change.signature.variadic.parameter.in.result.validation.message=结果中不允许使用可变参数。
go.refactoring.change.signature.variadic.is.not.last.validation.message=可变参数应始终是最后一个参数。
go.refactoring.change.signature.method.specification.and.implementations.option={0}方法规范和所有实现
go.refactoring.change.signature.current.method.option=仅{0}当前方法
go.refactoring.change.signature.target.not.found.error.message=脱字符号应置于要重构的函数或方法的名称处
go.refactoring.change.signature.function.will.not.start.application.validation.message=函数 {0} 将不再启动应用程序
go.refactoring.change.signature.function.will.not.perform.initialization.validation.message=函数 {0} 将不再执行初始化
go.refactoring.change.signature.renamed.parameter.validation.message.part=重命名的参数
go.refactoring.change.signature.new.parameter.validation.message.part=新参数
go.refactoring.extract.interface.rename.type.and.use.interface.radio.button=重命名原始类型并在可能的情况下使用接口(&E)
go.refactoring.extract.interface.rename.type.spec.label=将类型规范重命名为\:
go.refactoring.extract.interface.unexported.method.specification.validation.message={0} {1} 不会实现未导出的方法规范
go.refactoring.extract.interface.unexported.not.be.accessible.validation.message=未导出的{0}将无法从{1}访问
go.refactoring.extract.interface.empty.type.name.validation.message=类型名称不应为空。
go.refactoring.extract.interface.incorrect.type.name.validation.message=类型名称不正确。
go.refactoring.introduce.extract.title=提取
go.refactoring.introduce.extract.function.title=提取函数
go.refactoring.introduce.extract.function.command=提取函数
go.refactoring.introduce.extract.method.command=提取方法
go.refactoring.introduce.extract.variable.command=提取变量
go.refactoring.introduce.extract.method.or.function.title=提取方法或函数
go.refactoring.introduce.write.command=在提取函数期间写入命令
go.refactoring.introduce.range.contains.defer.message=选定的范围包含 `defer` 语句，该语句可以在提取期间录制
go.refactoring.introduce.receiver.without.name.error.message=接收器应具有名称
go.refactoring.introduce.continue.statement.interrupts.execution.flow.error.message=当 continue 语句中断执行流时，不支持重构
go.refactoring.introduce.label.reference.interrupts.execution.flow.error.message=当标签引用中断执行流时，不支持重构
go.refactoring.introduce.label.definition.selected.with.all.references.error.message=只有选择标签定义及其所有引用时，才支持重构
go.refactoring.introduce.does.not.return.value.error.message=表达 {0} 不返回值。
go.refactoring.introduce.not.constant.value.error.message=表达式 {0} 不是常量值。
go.refactoring.introduce.method.with.receiver.renderer=带 {0} 接收器的方法
go.refactoring.move.affect.initialization.order.validation.message=移动函数 {0} 可能会影响应用程序的初始化顺序
go.refactoring.move.break.initialization.validation.message=移动变量 {0} 可能会中断变量 {1} 的初始化
go.refactoring.move.value.will.change.validation.message=常量 {0} 的值将更改，因为它使用 {1} 声明
go.refactoring.move.function.will.not.start.application.validation.message=包 {1} 外部的函数 {0} 将不再启动应用程序
go.refactoring.move.type.will.not.implement.interface.validation.message=类型 {0} 将不再实现接口 {1}
go.refactoring.move.exported.function.will.not.start.application.validation.message=导出的函数 {0} 将不再启动应用程序
go.refactoring.move.exported.function.will.not.perform.initialization.validation.message=导出的函数 {0} 将不再执行初始化
go.refactoring.move.type.will.become.non.local.for.method.validation.message=类型 {0} 将成为方法 {1} 的非本地类型
go.refactoring.move.required.by.validation.message={0}需要
go.refactoring.move.file.should.differ.validation.message=目标文件应与源文件不同。
go.refactoring.rename.looking.for.anonymous.field.usages.progress.title=正在查找匿名字段的用法
go.refactoring.rename.looking.for.method.usages.progress.title=正在查找方法的用法
go.refactoring.rename.package.title=同时将包 ''{0}'' 重命名为 ''{1}''?
go.refactoring.rename.file.title=同时重命名{0}文件 ''{1}''?
go.refactoring.rename.directory.message=同时重命名包的目录 ''{0}''?
go.refactoring.rename.current.receiver.option=仅重命名当前接收器
go.refactoring.rename.all.receivers.option=重命名所有接收器
go.find.usages.of.interface.methods.dialog.base.methods.checkbox=基本方法(&B)
go.find.usages.of.interface.methods.dialog.title=查找接口方法的用法?
go.find.usages.of.interface.methods.dialog.message=类型 ''{0}'' 实现接口，方法 ''{1}'' 重写方法。要查找接口方法的用法吗?
go.find.usages.of.interface.methods.notification.title=正在查找接口方法的用法
go.find.usages.of.interface.methods.notification.show.options.text=显示选项 {0}
go.code.smells.commit.local.paths=提交本地路径可能无法移植
go.init.with.zero.value=使用零值初始化
go.usage.type.return.type=返回类型
go.usage.type.parameter.declaration=参数声明
go.usage.type.struct.initialization=结构初始化
go.usage.type.import=导入
go.usage.type.variable.declaration=变量声明
go.usage.type.field.declaration=字段声明
go.usage.type.const.declaration=常量声明
go.usage.type.receiver=接收器
go.usage.type.type.assertion=类型断言
go.usage.type.type.alias=类型别名
go.usage.type.type.conversion=类型转换
go.inspection.problem.unmarshal.argument.must.be.a.pointer=此参数必须为指针类型
go.enable.template.plugin.notification.text=启用 Go 模板以增强 html/templates 包中的突出显示、补全和导航功能
go.enable.template.plugin.action.text=启用插件
go.install.template.plugin.notification.text=安装 Go 模板以增强 html/templates 包中的突出显示、补全和导航功能
go.install.template.plugin.action.text=安装插件
go.ignore.template.plugin.action.text=忽略此项目的插件
go.inspection.problem.range.var.copies.lock=范围变量 {0} 复制锁定\: {1}
go.inspection.problem.function.passes.lock.by.value={0} 按值传递锁定\: {1}
go.inspection.problem.return.copies.lock.value=返回副本锁定值\: {0}
go.inspection.problem.call.copies.lock.value=调用 {0} 将复制锁定值\: {1}
go.inspection.problem.literal.copies.lock.value=文字从 {0} 复制锁定值\: {1}
go.inspection.problem.assignment.copies.lock.value=赋值将锁定值复制到 {0}\: {1}
go.inspection.problem.variable.declaration.copies.lock.value=变量声明将锁定值复制到 {0}\: {1}
go.inspection.problem.invalid.second.argument.to.errors.as={0} 的第二个参数必须是指向接口或类型实现错误的指针
go.inspection.problem.expression.is.too.small.for.shift={0} ({1} 位)对于 {2} 的移位太小
go.inspection.problem.method.has.non.standard.signature=方法 {0} 应具有签名 {1}
go.inspection.problem.direct.assignment.to.atomic.value=直接赋值给原子值
go.inspection.problem.cannot.take.address.of.non.addressable.operand=无法获取不可寻址操作数的地址
go.inspection.problem.assignment.to.method.receiver.propagates.only.to.callees=对方法接收者的赋值仅传播到被调用方，不传播到调用方
go.inspection.problem.assignment.to.method.receiver.doesnt.propagate=对方法接收器的赋值不传播到其他调用
go.inspection.problem.expression.can.be.simplified.to.other={0} 可以简化为 {1}
go.inspection.problem.condition.is.always.true.or.false=条件 {0} 始终为 {1}
go.inspection.problem.conversion.from.int.to.string=从 {0} 到 {1} 的转换将整数值解释为代码点
go.inspection.problem.expression.is.always.true.or.false=表达式 {0} 始终为 {1}
go.inspection.problem.expression.can.be.simplified=可以简化表达式
go.inspection.problem.possible.malformed.build.comment=+build 注释可能格式错误
go.inspection.problem.wrong.location.of.build.comment=构建注释必须出现在包子句前面，并在其后添加一个空白的行
go.inspection.problem.invalid.double.negative.in.build.constraint=构建约束中的 double 型负数无效\: {0}  
go.inspection.problem.invalid.non.alphanumeric.build.constraint=非字母数字构建约束无效\: {0}
go.inspection.problem.usage.of.cgo.in.tests=不支持在测试中使用 cgo
go.inspection.problem.comment.should.start.with.whitespace=注释应以空格开头
go.inspection.problem.defer.is.called.in.a.for.loop=可能发生资源泄漏，在 {1} 循环中调用了 {0}
go.inspection.problem.deprecated.is.still.used=被弃用的 {0} 仍在使用
go.inspection.problem.reference.is.deprecated=已弃用 {0}
go.inspection.problem.division.by.zero=除以零
go.inspection.problem.duplicate.case=case {0} 重复
go.inspection.problem.variable.repeated.on.left.side={0} 在 \:\= 的左侧重复
go.inspection.problem.name.redeclared.as.imported.package={0} 被重新声明为导入的包名称
go.inspection.problem.name.collides.with.name.declared.in.this.package={0} 与此包中声明的名称冲突
go.inspection.problem.label.already.defined=已定义标签 {0}
go.inspection.problem.duplicate.argument=参数 {0} 重复
go.inspection.problem.name.redeclared.in.this.function=此函数中重新声明了 {0}
go.inspection.problem.duplicate.field=重复字段 {0} 
go.inspection.problem.type.has.same.named.field.and.method=\n类型 {0} 的字段和方法均命名为 {1}
go.inspection.problem.method.redeclared=方法重新声明 {0}
go.inspection.problem.type.has.both.field.and.method.with.name=\n类型 {0} 的字段和方法均命名为 {1}
go.inspection.problem.duplicate.method=方法 {0} 重复
go.inspection.problem.name.redeclared.in.this.package=此包中重新声明了 {0}
go.inspection.problem.name.redeclared.in.this.block=此块中重新声明了 {0}
go.inspection.problem.bad.error.string=错误字符串不应大写或以标点结尾
go.inspection.problem.exported.element.should.have.comment=导出的 {0} {1} 应有注释，否则就是未导出
go.inspection.problem.exported.function.with.unexported.return.type=导出的 {0} 具有未导出的返回类型
go.inspection.problem.exported.var.should.have.its.own.declaration=导出的变量 {0} 应有自己的声明
go.inspection.problem.exported.const.should.have.its.own.declaration=导出的常量 {0} 应有自己的声明
go.inspection.problem.missing.argument.to.conversion=缺少要转换为 {0} 的参数\: {1}
go.inspection.problem.too.many.arguments.to.conversion=要转换为 {0} 的参数过多\: {1}
go.inspection.problem.too.many.arguments.in.call={0} 调用中的参数过多
go.inspection.problem.not.enough.arguments.in.call={0} 调用中的参数不足
go.inspection.problem.name.collides.with.imported.package={0} {1} 与导入的包名称冲突
go.inspection.problem.impossible.type.assertion=不可能的类型断言\: {0} 未实现 {1}
go.inspection.problem.impossible.interface.assertion=从 {0} 到 {1} 的接口声明无效。模糊\: {2}
go.inspection.problem.impossible.type.switch.case=不可能的类型 swich case\: {0} 未实现 {1}
go.inspection.problem.infinite.for.loop=无限的 {0} 循环
go.inspection.problem.cannot.convert.expression=无法将类型 {0} 的表达式转换为类型 {1}
go.inspection.problem.invalid.conversion=无效转换
go.inspection.problem.cannot.slice=无法切片 {0} (类型 {1})
go.inspection.problem.type.does.not.support.indexing=无效运算\: {0} (类型 {1} 不支持索引)
go.inspection.problem.cannot.use.expression.in.map.index=无法在映射索引中将 {0} (类型 {1})用作类型 {2}
go.inspection.problem.invalid.low.high.indices=无效索引值，必须低值 <\= 高值
go.inspection.problem.invalid.low.high.max.indices=无效索引值，必须为低值 <\= 高值 <\= 最大值
go.inspection.problem.non.integer.slice.index=非整数切片索引 {0}
go.inspection.problem.non.integer.iterable.index=非整数 {0} 索引 {0}
go.inspection.problem.slice.index.must.be.non.negative=切片索引 {0} 无效(索引必须为非负数)
go.inspection.problem.iterable.index.must.be.non.negative={0} 索引 {1} 无效(索引必须为非负数)
go.inspection.problem.slice.index.out.of.bounds.for.string=切片索引 {0} 无效(超出 {1} 字节字符串的界限)
go.inspection.problem.string.index.out.of.bounds.for.string=字符串索引 {0} 无效(超出 {1} 字节字符串的界限)
go.inspection.problem.slice.index.out.of.bounds.for.array=切片索引 {0} 无效(超出 {1} 元素数组的界限)
go.inspection.problem.iterable.index.out.of.bounds.for.array={0}索引{1} 无效(超出 {2} 元素数组的界限)
go.inspection.problem.invalid.receiver.type=无效接收器类型{0} ({1} 为 {2})
go.inspection.problem.invalid.receiver.unnamed.type=未命名类型
go.inspection.problem.invalid.receiver.interface.type=接口类型
go.inspection.problem.invalid.receiver.pointer.type=指针类型
go.inspection.problem.cannot.define.new.methods.on.non.local.type=无法对非本地类型 {0} 定义新方法
go.inspection.problem.use.of.internal.package.is.not.allowed=不允许使用内部包
go.inspection.problem.use.of.vendored.package.is.not.allowed=不允许使用供应商供应的包
go.inspection.problem.must.be.imported.as=必须作为 {0} 导入
go.inspection.problem.at.is.not.allowed.in.import.paths=导入路径中不允许 @
go.inspection.problem.cannot.import.absolute.path=无法导入绝对路径
go.inspection.problem.cannot.import.builtin.package=无法导入 'builtin' 包
go.inspection.problem.non.canonical.import.path=非规范的导入路径\: {0} 应为 {1}
go.inspection.problem.build.constraints.exclude.all.go.files=构建约束排除 {0} 中所有的 Go 文件
go.inspection.problem.path.is.a.program.not.an.importable.package={0} 是程序，不是可导入的包
go.inspection.problem.found.several.packages=在 {1} 中找到多个包 [{0}] 
go.inspection.problem.no.non.test.go.files={0} 中没有非测试 Go 文件
go.inspection.problem.cannot.import=无法导入 {0}
go.inspection.problem.cannot.rename.import.c=无法重命名 import 'C'
go.inspection.problem.path.imports.package.with.invalid.import.comment={0} 个包含无效导入注释的包
go.inspection.problem.path.imports.package.that.expects.canonical.import=应为 import "{1}"，但 {0} 导入了包
go.inspection.problem.cannot.truncate=无法截断\: {0} 为类型 {1}
go.inspection.problem.invalid.composite.literal.type=无效的复合文字类型\: {0}
go.inspection.problem.too.few.values=值太少
go.inspection.problem.too.many.values=值太多
go.inspection.problem.cannot.assign.value.to.blank.field=无法将值赋给空字段
go.inspection.problem.cannot.assign.value.to.unexported.field=无法将值赋给未导出的字段 {0}
go.inspection.problem.missing.type.in.composite.literal=复合文字中缺少类型
go.inspection.problem.mixture.of.field=混合字段\: 值和初始值设定项
go.inspection.problem.invalid.field.name=字段名无效
go.inspection.problem.missing.expression=缺少表达式
go.inspection.problem.missing.key.in.map.literal=映射文字中缺少键
go.inspection.problem.duplicate.key.in.map.literal=映射文字中的键 {0} 重复
go.inspection.problem.cannot.convert.known.value.to.type=无法将 {0} 转换为 {1}
go.inspection.problem.cannot.convert.value.to.type=无法将值转换为 {0}
go.inspection.problem.index.must.be.a.non.negative.integer.constant=索引 {0} 必须是非负整数常量
go.inspection.problem.negative.index=负索引\: {0}
go.inspection.problem.index.out.of.bounds=索引超出界限\: {0}
go.inspection.problem.duplicate.index=重复的索引\: {0}
go.inspection.problem.reference.jumps.over.declaration={0} 跳过 {1} 的声明
go.inspection.problem.missing.return=函数结束处缺少返回
go.inspection.problem.need.trailing.comma.in.composite.literal=在复合文字中的换行符前面需要尾随逗号
go.inspection.problem.need.trailing.comma.in.parameter.list=形参列表中的换行符前需要尾随逗号
go.inspection.problem.need.trailing.comma.in.argument.list=实参列表中的换行符前需要尾随逗号
go.inspection.problem.multiple.packages.in.directory=目录中有多个包\: {0}
go.inspection.problem.name.starts.with.package.name=名称以包名称开头
go.inspection.problem.cannot.call.non.function=无法调用非函数 {0} (类型 {1})
go.inspection.problem.empty.slice.declaration.via.literal=通过文字进行的切片声明为空
go.inspection.problem.function.does.not.take.writer=\n函数不使用 {0}，但第一个参数是 {1}
go.inspection.problem.possible.formatting.directive={0} 中可能的格式指令
go.inspection.problem.last.argument.ends.with.redundant.newline={0} 的最后一个参数以冗余的换行符结尾
go.inspection.problem.return.value.has.a.function.type=返回值 {0} 具有函数类型
go.inspection.problem.argument.is.not.a.function.call=参数 {0} 不是函数调用
go.inspection.problem.argument.causes.recursive.call.to.string.method=参数 {0} 导致对 {1} 方法的递归调用
go.inspection.problem.receiver.has.generic.name=接收器具有通用名称
go.inspection.problem.receiver.names.are.different=接收器名称不同
go.inspection.problem.invalid.recursive.type=无效递归 {0} {1}{2}
go.inspection.problem.redundant.blank.expression=冗余 {0} 表达式
go.inspection.problem.redundant.comma=冗余逗号
go.inspection.problem.possibly.redundant.type.conversion=类型转换可能冗余
go.inspection.problem.redundant.type.conversion=冗余类型转换
go.inspection.problem.redundant.alias=冗余别名
go.inspection.problem.redundant.parentheses=冗余括号
go.inspection.problem.redundant.index=冗余索引 {0}
go.inspection.problem.redundant.semicolon=冗余分号
go.inspection.problem.redundant.type=冗余类型
go.inspection.problem.name.collides.with.builtin={0} {1} 与内置的 {2} 冲突
go.inspection.problem.value.is.assigned.to.itself={0} 的值被赋予本身
go.inspection.problem.self.import.is.not.allowed=不允许自我导入
go.inspection.problem.declaration.shadows.declaration={0} 的声明隐藏声明
go.inspection.problem.declaration.shadows.declaration.at={0} 的声明隐藏 {1} 处的声明
go.inspection.problem.eliminate.snake.case=消除蛇形拼写法
go.inspection.problem.use.camelcase.instead.of.snake.case=使用驼峰拼写法，不使用蛇形拼写法
go.inspection.problem.mismatched.types.byte.and.string=不匹配的类型\: 字节和字符串
go.inspection.problem.bad.count.argument.of.strings.replace={0} 的计数参数不应为 {1}
go.inspection.problem.fields.are.assigned.without.explicit.names=字段分配时没有显式名称
go.inspection.problem.wrong.example.signature=示例签名错误
go.inspection.problem.wrong.test.signature=测试签名错误
go.inspection.problem.cannot.use.underscore.as.value=不能将 {0} 作为值使用
go.inspection.problem.unhandled.error=未处理错误
go.inspection.problem.unit.specific.suffix=特定于单元的后缀 {0}
go.inspection.problem.unnecessarily.exported.element=不必要地导出了 {0} {1}
go.inspection.problem.unreachable.code=不可到达的代码
go.inspection.problem.imports.are.not.sorted=import 未排序
go.inspection.problem.unused.result=未使用的结果\: {0}
go.inspection.problem.unused.import=未使用的导入
go.inspection.problem.assignment.used.as.value={0} 作为值使用
go.inspection.problem.no.placeholders.in.format.string=格式字符串中没有占位符
go.inspection.problem.too.many.arguments.for.format.string=格式字符串的参数过多\: 应为 {0}，实际为 {1}
go.inspection.problem.verb.will.ignore.flag=动词将忽略 {0} 标志 {1}
go.inspection.problem.verb.will.ignore.flags=动词将忽略 {0} 标志 {1}
go.inspection.problem.placeholder.syntax.error=占位符语法错误 {0}
go.inspection.problem.this.verb.can.be.used.only.in.fmt.errorf=此动词只能在 {0} 个调用 {1} 中使用
go.inspection.problem.this.verb.can.be.used.only.once.in.a.format.string=此动词只能在格式字符串 {0} 中使用一次
go.inspection.problem.fmt.parameter.with.non.integer.expression=指定的{0, choice, 0\#宽度|1\#精度|2\#动词}没有整数表达式 {1}{2}
go.inspection.problem.no.argument.for.placeholder.part=没有{0, choice, 0\#宽度|1\#精度|2\#动词}的参数\: 参数索引 \= {1}，参数计数 \= {2}{3}
go.inspection.problem.unknown.verb=未知动词 {0}{1}
go.inspection.problem.return.value.of.placeholder.argument.has.a.function.type=占位符参数的返回值具有函数类型 {0}
go.inspection.problem.placeholder.argument.is.not.a.function.call=占位符参数不是函数调用 {0}
go.inspection.problem.placeholder.argument.has.wrong.type=占位符参数 {0} 有错误的类型 {1} {2}
go.inspection.problem.placeholder.argument.causes.recursive.call.to.string=占位符参数导致对 {0} 方法 {1} 的递归调用
go.inspection.problem.index.zero.is.illegal=索引值 [0] 为非法的 {0}
go.inspection.problem.invalid.use.of.triple.dot=无效使用...，对应参数是非可变参数
go.inspection.problem.too.many.arguments.to.return=要返回的参数太多
go.inspection.problem.not.enough.arguments.to.return=要返回的参数不足
go.inspection.problem.invalid.argument.must.be.complex.type=无效的参数 {0}(类型 {1})\: 必须为复杂类型
go.inspection.problem.expression.with.type={0} (类型 {1})
go.inspection.problem.non.bool.used.as.condition=非 bool {0} 作为条件使用
go.inspection.problem.cannot.range=范围不能超过 {0}
go.inspection.problem.type.or.type={0} 或 {1}
go.inspection.problem.nil.is.not.allowed=不允许 {0}。必须为 {1}
go.inspection.problem.incompatible.types=无法将 {0} 用作类型 {1}
go.inspection.problem.incompatible.types.in.switch=switch {1} 中的 case {0} 无效
go.inspection.problem.incompatible.types.in.switch.on.expression={1} {2} 的 switch 中的 case {0} 无效
go.inspection.problem.mismatched.types=(类型 {0} 和 {1} 不匹配)
go.inspection.problem.incompatible.types.some.methods.are.missing=类型未实现 {0} {1}，因为缺少某些方法\: {2} {3}
go.inspection.problem.incompatible.types.ambiguous.methods=类型未实现 {0}，因为{1} {2} 为不明确的 {3}
go.inspection.problem.incompatible.method.has.pointer.receiver=类型未实现 {0}，因为{1} {2} 方法具有指针接收器 {3}
go.inspection.problem.incompatible.need.method.have.method=类型未实现 {0} {1}需要的方法\: {2}使用的方法\: {3} {4}
go.inspection.problem.incompatible.unexported.method=类型无法实现 {0}，因为类型 {1} 具有未导出的方法，并且是在不同的包 {2} 中定义
go.inspection.problem.invalid.inc.dec.operation=无效运算\: {0}(非数值类型 {1})
go.inspection.problem.cannot.assign.in.multiple.assignment=无法在多个赋值中将 {0} 赋给 {1}
go.inspection.problem.cannot.convert.nil.to.type=无法将 {0} 转换为类型 {1}
go.inspection.problem.invalid.unary.operation=无效运算\: {0}
go.inspection.problem.cannot.convert.constant=无效运算\: {0}(无法将常量 {1} 转换为类型 {2})
go.inspection.problem.operator.not.defined=无效运算\: {0}(在 {2} 中未定义运算符 {1})
go.inspection.problem.receive.from.send.only.type=无效运算\: {0}(从仅发送类型 {1} 接收)
go.inspection.problem.receive.from.non.chan.type=无效运算\: {0}(从非 chan 类型{1} 接收)
go.inspection.problem.send.to.non.chan.type=无效运算\: {0}(发送到非 chan 类型{1})
go.inspection.problem.send.to.receive.only.type=无效运算\: {0}(发送到仅接收类型{1})
go.inspection.problem.invalid.operation.mismatched.types=无效运算\: {0}(类型 {1} 和 {2} 不匹配)
go.inspection.problem.shift.count.must.be.unsigned.integer=无效运算\: {0}(移位计数类型 {1}，必须为无符号整数)
go.inspection.problem.shift.count.must.be.integer=无效运算\: {0}(移位计数类型 {1}，必须为整数)
go.inspection.problem.negative.shift.count=无效运算\: {0}(负移位计数)
go.inspection.problem.receiver.may.be.nil.in.call=接收器 {0} 在调用中可能是 {1}
go.inspection.problem.method.call.may.lead.to.nil.pointer.dereference=方法调用 {0} 可能导致 nil 指针取消引用
go.inspection.problem.function.call.may.lead.to.nil.pointer.dereference=函数调用 {0} 可能导致 nil 指针取消引用
go.inspection.problem.accessing.field.may.lead.to.nil.pointer.dereference=访问字段 {0} 可能导致 nil 指针取消引用
go.inspection.problem.send.may.block.because.of.nil.channel=可能由于 {0} 通道而阻止发送
go.inspection.problem.receive.may.block.because.of.nil.channel=可能由于 {0} 通道而阻止接受
go.inspection.problem.potential.nil.pointer.dereference=可能发生 nil 指针取消引用
go.inspection.problem.assignment.to.entry.may.panic.because.of.nil.map=由于 {0} 映射，赋值条目可能会出现 panic
go.inspection.problem.indexing.may.panic.because.of.nil.slice=由于切片 {0} ，索引可能会出现 panic
go.inspection.problem.nil.loop.is.always.skipped=总是跳过循环，因为 {0} 总是 {1}
go.inspection.problem.corresponding.error.may.be.not.nil={0} 可能有 {1} 或其他异常的值，因为它相应的错误变量可能不是 {2}
go.inspection.problem.condition.is.always.true.or.false.because.of.nil=条件始终为 {0}，因为 {1} 始终是 {2}
go.inspection.problem.condition.is.always.true.or.false.because.of.not.nil=条件始终为 {0}，因为 {1} 始终不是 {2}
go.inspection.problem.unused.dependency=未使用的依赖项
go.inspection.problem.contains=包含
go.inspection.problem.type.which.is.sync.locker=类型 %s，它是 <code>sync.Locker</code>
go.inspection.problem.type.is.sync.locker=类型 %s 为 <code>sync.Locker</code>
go.modules.scratch.file.notification.text=使用模块上下文
go.version.does.not.support.go.modules.validation.message={0} 不支持 Go 模块
go.run.target.executable.path.label=Go 可执行文件\: 
go.run.target.gopath.label=GOPATH\: 
go.run.target.version.label=版本：
go.run.target.configure.label=配置 Go
go.run.target.run.label=运行 Go 应用程序
go.vgo.executable.path.label=Vgo 可执行文件
go.vgo.executable.project.label=项目SDK
go.attach.directory.action.text=附加目录 "{0}"
go.detach.directory.action.text=分离目录 "{0}"
go.remove.else=移除 else
go.unwrap.else=解开 else
go.unwrap.for=解开 for
go.unwrap.argument=解开参数
go.unwrap.if=解开 if
go.settings.global.gopath.group.name=全局 GOPATH
go.settings.project.gopath.group.name=项目 GOPATH
go.settings.module.gopath.group.name=模块 GOPATH
go.notification.dep.projects.are.detected.text=检测到 Dep 项目
go.dep.executable.path.label=Dep 可执行文件
go.quick.doc.package.label=包\:
go.quick.doc.resolved.value.label=已解析的值\: 
go.quick.doc.methods.label=方法\:
go.settings.folding.one.line.return.checkbox=一行返回
go.settings.folding.one.line.panics.checkbox=1 行 panic
go.settings.folding.format.strings.checkbox=格式字符串
go.settings.formatter.add.space.except.for.comments.label=以此开头的注释除外\: 
go.settings.formatter.comment.prefix.cannot.be.empty.validation.message=注释前缀不能为空
go.notification.go.root.is.not.defined.text=未定义 GOROOT
go.notification.go.root.is.incorrect.text=GOROOT 不正确
go.refactoring.split.declarations.action.text=拆分声明
go.refactoring.merge.declarations.action.text=合并声明
go.inlays.show.unnamed.fields.in.structure.values.option=在结构值中显示未命名字段
go.inlays.show.return.parameters.option=显示返回参数
go.quick.settings.file.watchers.text=执行保存操作时...
go.quick.settings.file.watchers.description=编辑 go fmt、goimports 和其他命令行工具
go.file.watcher.go.imports.description=在 Go 文件上运行 `goimports`
go.file.watcher.go.fmt.description=在 Go 文件上运行 `go fmt`
go.file.watcher.golangci.description=在当前 Go 文件目录中运行 `golangci-lint`
go.before.check.in.show.fmt.error.button=详细(&D)...
go.completion.fill.all.fields.lookup.string=填充所有字段...
go.completion.fill.selected.fields.lookup.string=填充选定字段...
go.modules.dependency.diagram=Go modules dependency diagram
go.converter.build.run.configuration.description=`Go Build` 运行配置已更改。需要转换现有配置。
go.converter.single.file.run.configuration.description=Go `Run single file` 运行配置已移除。需要转换现有配置。
go.converter.build.tags.description=Go 项目设置存储机制已更改，因此需要更新项目及其模块。
go.converter.sdk.description=Go 项目模型已更改，因此需要更新项目及其模块
go.converter.project.model.description=Go 项目模型已更改，因此需要更新项目及其模块
go.inspection.options.panel.import.path=导入路径
go.inspection.options.panel.function.name=函数名称
go.inspection.options.panel.string.methods=字符串方法
go.inspection.options.panel.reported.functions=报告的函数/方法\: 
go.inspection.options.panel.receiver=接收器
go.inspection.options.panel.method.name=方法名称
go.inspection.options.panel.exclude=排除\:
go.structure.view.show.package.structure.action.text=显示包结构
go.structure.view.private.members.filter.text=显示 private 成员
go.structure.view.exportability.sorter.text=按导出性排序
go.structure.view.method.location=在 {0} 中
go.sum.generated.sources.filter.notification.text=不应编辑该文件，因为该文件仅供 Go 工具使用。变更可能会导致构建进程中断。
go.modules.background.task.updating.dependencies.title=Updating Go modules dependencies
go.modules.background.task.updating.dependencies.text=Executing ''go list'' on {0} ''go.mod'' files...
go.modules.unknown.dependencies.notification.text=完整的模块依赖关系集合未知，某些特定于 Go 模块的功能可能不可用。
go.modules.unknown.dependencies.notification.tooltip=可能是由网络连接问题或显式 GOPROXY\=off 导致。
go.modules.unknown.dependencies.notification.retry=重新运行 ''{0}''
go.modules.tree.structure.replaced=(replaced)
go.modules.tree.structure.original.version=Original version\: {0}
go.modules.tree.structure.replacement=Replacement\: {0}