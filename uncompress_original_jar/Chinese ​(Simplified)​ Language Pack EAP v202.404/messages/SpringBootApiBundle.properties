spring.boot.name=Spring Boot

spring.boot.application.endpoints.application.is.starting=''{0}'' 正在启动
spring.boot.application.endpoints.updated.at=更新于 {0}
spring.boot.application.endpoints.error.caused.by=原因是\: {0}\: {1}
spring.boot.application.endpoints.error.failed.to.retrieve.endpoint.data.detailed=<html>无法检索 ''{0}'' 端点数据\:<br>{1}</html>
spring.boot.application.endpoints.error.actuator.starter.disabled=<html>Spring Boot Actuator 未启用。<br>向 spring-boot-starter-actuator 添加依赖关系以启用它。</html>

spring.boot.properties.no.resources.roots=在模块 ''{0}'' 中未找到资源根
spring.boot.properties.no.json.metadata.popup=为 ''{0}'' 创建元数据文件于
spring.boot.properties.no.json.metadata.hint=未找到其他元数据文件。将创建一个新文件
spring.boot.properties.json.metadata.create=为 ''{0}'' 创建 Spring Boot 元数据文件
spring.boot.properties.invalid.json=''{0}'' 中有无效的 JSON 结构

spring.boot.customization.action.name=自定义 Spring Boot...
spring.boot.customization.action.description=自定义 Spring Boot 自动检测到的上下文
spring.boot.customization.dialog.title=Spring Boot 上下文 ''{0}''
spring.boot.config.chooser.dialog.title=选择自定义配置文件
spring.boot.customization.dialog.no.configs=未找到与模式 ''{0}'' 匹配的配置文件
spring.boot.customization.dialog.config.tree.tooltip=取消选中可移除自定义配置文件
spring.boot.customization.add.config.files.action=添加自定义配置文件

spring.boot.settings.configuration.metadata.files=配置元数据文件
spring.boot.settings.show.notification.panel=显示通知面板(&N)
spring.boot.settings.show.notification.panel.tooltip=显示注释处理器可用性状态
spring.boot.settings.create.run.configuration=自动创建运行配置(&R)
spring.boot.settings.create.run.configuration.tooltip=(重新)导入时添加 Spring Boot 运行配置(如果尚不存在)
spring.boot.settings.reformat.code=重新格式化代码(&C)
spring.boot.settings.reformat.code.tooltip=创建后重新格式化模板文件
spring.boot.settings.endpoints.tab=运行配置\: 端点选项卡

# spring initializr: project parameters panel
title.label.mnemonic.name=名称(&M)
title.label.mnemonic.group=组(&G)
title.label.mnemonic.artifact=工件(&A)
title.label.mnemonic.version=版本(&V)\:
title.label.mnemonic.package=包(&K)
title.label.mnemonic.type=类型(&T)\:
title.label.mnemonic.language=语言(&L)
title.label.mnemonic.packaging=打包(&G)
title.label.mnemonic.java.version=Java 版本(&J)
title.label.mnemonic.description=描述(&D)

#spring initializr: other
label.title.spring.boot=Spring Boot
message.requires.specific.spring.boot.version=需要 Spring Boot 版本 {0}
description.for.spring.initializr.project.starter=使用 Spring Boot Starter 创建 <b>Spring Boot</b> 应用程序。
presentable.name.spring.initializr=Spring Initializr
message.java.version.not.supported.by.sdk=SDK 不支持所选 Java 版本 {0} (最高为 {1})

word.dependency.plural.capitalized=依赖
word.dependency.plural=依赖
word.dependency.capitalized=依赖项
word.dependency=依赖项

SpringBootConfigFileHighlightingUtil.deprecated=已弃用\: {0}
SpringBootConfigFileHighlightingUtil.deprecated.configuration.property=已弃用的配置属性 ''{0}''
SpringBootConfigFileHighlightingUtil.cannot.resolve.configuration.property=无法解析配置属性 ''{0}''
SpringBootReplacementTokenCompletionContributor.configure.replacement.tokens=配置替换令牌...
SpringBootReplacementTokenCompletionContributor.press.again.to.show.replacement.tokens=再次按 {0} 显示替换令牌

DefineLocalMetaConfigKeyFix=定义配置键 ''{0}''
DefineLocalMetaConfigKeyFix.define.configuration.key=定义配置键

runtime.beans.class.gutter.icon.name=运行时 bean
runtime.beans.xml.gutter.icon.name=运行时 bean (XML)

application.config.usage.type=Spring Boot 配置文件
additional.config.usage.type=Spring Boot 附加配置元数据

configuration.properties.gutter.icon.name=配置属性
configuration.properties.rerun.notification=重新运行 Spring Boot 配置注解处理器以更新生成的元数据
configuration.properties.not.configured.notification=未配置 Spring Boot 配置注释处理器
configuration.properties.hide.notification.action=隐藏通知
configuration.properties.open.documentation.action=打开文档...

additional.config.unresolved.config.key.reference=无法解析配置键引用 ''{0}''
additional.config.unresolved.provider=无法解析提供程序 ''{0}''

banner.unresolved.property=无法解析属性 ''{0}''

additional.params.table.name=名称
additional.params.table.value=值
additional.params.table.empty.text=未添加参数。
additional.params.table.add=添加参数
additional.params.table.quick.doc=应用程序属性快速文档

spring.boot.run.config.type.name=Spring Boot
spring.boot.run.config.type.description=Spring Boot 应用程序
spring.boot.multiple.run.config.notification=<html><body>检测到多个 Spring Boot 运行配置。<br>{0} 允许同时管理多个运行配置。<br><br><a href\="show">在 {0} 中显示运行配置</a><br><br><a href\="ignore">不再为此项目显示</a></body></html>
spring.boot.run.config.update.application=更新 ''{0}'' 应用程序
spring.boot.run.config.settings.background.compilation.enabled=已启用后台编译
spring.boot.run.config.settings.running.application.update.policies=运行应用程序更新策略
spring.boot.run.config.settings.active.profiles=活动配置文件
spring.boot.run.config.settings.on.update.action=执行“更新”操作时
spring.boot.run.config.settings.on.frame.deactivation=框架停用时

application.config.rename.option=Spring Boot 配置文件
application.config.rename.title=重命名 Spring Boot 配置文件
application.config.rename.description=重命名与 Spring 配置文件 ''{0}'' 匹配的 Spring Boot 配置文件

spring.boot.diagnostics.progress=正在收集 Spring Boot 诊断...
spring.boot.diagnostics.module.info.progress=正在收集模块信息...
spring.boot.diagnostics.config.keys.progress=正在检查配置键...
spring.boot.diagnostics.auto.config.progress=正在检查自动配置类...
spring.boot.diagnostics.conditional.on.progress=正在收集 @ConditionalOnXXX 注解...

#inspections
configuration.properties.prefix.must.be.specified=必须指定前缀
configuration.properties.prefix.must.be.non.empty=前缀不得为空
configuration.properties.prefix.must.be.in.canonical.form=前缀必须采用规范形式
configuration.properties.duplicated.prefix=前缀重复
configuration.properties.show.duplicates=显示重复项
configuration.properties.no.duplicates.found=未找到前缀 ''{0}'' 的重复项
configuration.properties.show.duplicates.for.prefix=前缀 ''{0}'' 的重复项
configuration.properties.related.config.file.line.marker.popup.title=Spring Boot 配置文件
configuration.properties.related.config.file.line.marker.tooltip=在 Spring Boot 配置文件中使用
configuration.properties.related.config.file.task.base.title=配置属性 ''{0}.{1}''
configuration.properties.related.config.file.task.title=正在搜索 {0} 的用法
configuration.properties.related.config.file.task.caption=<html><body><b>{0}</b> 的用法 ({1}) </body></html>
configuration.properties.related.config.file.task.details=目前已发现 {0}
configuration.properties.related.config.file.task.details.finished=已找到{0}

additional.config.text.should.end.with.dot=文本应以 '.' 结尾
additional.config.deprecated.property=属性 'deprecated' 应替换为 'deprecation'
additional.config.missing.required.property=缺少必需的 ''{0}''
additional.config.missing.required.parameter=缺少所需的 {0, choice, 1\#参数|1<参数}\: {1}

application.config.missing.map.key=缺少映射键
application.config.missing.closing.bracket=缺少结束 ']'
application.config.missing.index.value=缺少索引值
application.config.non.integer.index=索引值必须是整数
application.config.replacement.quick.fix=使用替换键 ''{0}''
application.config.replacement.quick.fix.family.name=使用替换键
application.config.spring.profiles.completion.tail=\ (为此文档定义配置文件)

spring.boot.application.in.default.package=默认包中的 Spring Boot 应用程序
spring.boot.application.attribute.in.wrong.annotation=应通过 @{0} 指定属性
spring.boot.application.redundant.declaration=冗余声明\: {0}
spring.boot.application.already.applies.annotation=@{0} 已应用 @{1}
spring.boot.application.already.applies.given.annotation=@{0} 已应用给定的 @{1}

spring.boot.reactor.hooks.on.debug.inspection=初始化 ReactorDebugAgent 时调用 Hooks.onOperatorDebug()
spring.boot.reactor.hooks.on.debug.quickfix=移除 Hooks.onOperatorDebug() 调用

spring.boot.application.yaml.inspection.key=Spring Boot application.yml
spring.boot.application.properties.inspection.key=Spring Boot application.properties
spring.boot.additional.config.metadata.inspection.key=Spring Boot additional-spring-configuration-metadata.json
spring.boot.application.setup.inspection.key=Spring Boot 应用程序设置
spring.boot.reactor.inspection.key=可疑的 Hooks.onOperatorDebug() 用法
spring.boot.config.properties.inspection.key=Spring Boot @ConfigurationProperties