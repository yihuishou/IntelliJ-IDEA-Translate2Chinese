title.method.parameters.group=方法/函数声明参数
title.method.arguments.group=方法/函数调用参数
title.closure.group=闭包
title.condition.clauses.group=条件子句
title.if.group='if' 语句
title.guard.group='guard' 语句
title.for.group='for' 语句
title.do.while.group='repeat … while' 语句
title.try.group='do' 语句
title.superclass.list.group=基类和采用的协议列表
title.colon.group=冒号周围
title.ternary=三元条件运算
title.in.ternary=在三元条件运算中
title.variable.groups=变量组

indent.multiline.strings=缩进多行字符串
indent.directives.title=指令
indent.directives.as.code=遵循代码缩进
indent.directives.children=缩进子项

checkbox.spaces.before.method.parentheses=方法/函数声明括号
checkbox.spaces.after.operator.in.function.declarations=函数声明中的运算符
checkbox.spaces.before.method.call.parentheses=方法/函数调用括号
checkbox.spaces.equality.operator=相等运算符 '\=\='
checkbox.spaces.shift.operators=移位运算符 (<<, >>)
checkbox.spaces.around.range.operators=范围运算符 (..., ..<)
checkbox.spaces.closure.arrow=闭包箭头(->)
checkbox.spaces.attribute.parameters=特性参数
checkbox.spaces.within.literal.brackets=数组和字典文字中括号
checkbox.spaces.within.method.parentheses=方法/函数声明括号
checkbox.spaces.within.empty.method.parentheses=空方法/函数声明括号
checkbox.spaces.within.method.call.parentheses=方法/函数调用括号
checkbox.spaces.within.empty.method.call.parentheses=空方法/函数调用括号
checkbox.spaces.attribute.parentheses=特性括号
checkbox.spaces.before.argument.colon=方法/函数调用中的冒号之前
checkbox.spaces.after.argument.colon=方法/函数调用中的冒号之后
checkbox.spaces.before.type.colon=类型注解中的冒号之前
checkbox.spaces.after.type.colon=类型注解中的冒号之后
checkbox.spaces.before.superclass.colon=类型继承子句中的冒号之前
checkbox.spaces.after.superclass.colon=类型继承子句中的冒号之后
checkbox.spaces.before.dictionary.type.colon=字典类型中的冒号之前
checkbox.spaces.after.dictionary.type.colon=字典类型中的冒号之后
checkbox.spaces.before.dictionary.literal.colon=字典文字 'key\:value' 对中的冒号之前
checkbox.spaces.after.dictionary.literal.colon=字典文字 'key\:value' 对中的冒号之后
checkbox.spaces.within.string.interpolations=字符串插值
checkbox.spaces.before.class.lbrace=类型声明左大括号
checkbox.spaces.before.method.lbrace=方法/函数左大括号
checkbox.spaces.before.semicolon=分号之前
checkbox.spaces.after.semicolon=分号之后

wrapping.align.when.multiline=多行时对齐
wrapping.align.in.columns=列中对齐
wrapping.else.on.new.line='else'在新行
wrapping.keep.control.statement.in.one.line=控制语句在同一行
wrapping.keep.simple.methods.in.one.line=方法和函数在同一行
wrapping.keep.simple.blocks.in.one.line=块和(尾随)闭包在同一行
wrapping.keep.simple.argument.blocks.in.one.line=闭包参数在同一行
wrapping.structures.in.one.line=空类型声明在同一行
wrapping.method.brace.placement=在方法和函数中
wrapping.array.literal=数组和字典文字
wrapping.array.new.line.after.left.bracket=新行后 '['
wrapping.array.right.bracket.on.new.line=将 ']' 置于新行
wrapping.classes.annotation=类型声明特性
wrapping.methods.annotation=方法特性
wrapping.fields.annotation=属性特性
wrapping.parameters.annotation=参数特性
wrapping.local.variables.annotation=局部变量特性
wrapping.closure.signature.on.next.line=多行时参数在新行上
wrapping.brace.placement.class.declaration=在类型声明中

blank.lines.around.class=在类型声明周围\:
blank.lines.around.field.in.protocol=在协议中的属性周围\:
blank.lines.around.field=围绕属性：
blank.lines.around.method.in.protocol=在协议中的方法/函数周围\:
blank.lines.around.method=在方法/函数周围\:
blank.lines.before.method.body=在方法/函数体之前\:

create.field.kind=&种类\:
create.file.title=Swift 文件
create.file.dialog.title=新建 Swift 文件
create.file.description=创建新的 Swift 文件
create.class.title=Swift 类型
create.class.dialog.title=新建 Swift 类型
create.type.dialog.title=新建 Swift {0}
create.class.description=创建新的 Swift 类型

goto.super.action=选择 {0}
goto.super.menu.action=超级 {0}(_U)
goto.super.typealias=类型别名或关联类型
goto.super.class=类或协议
goto.base.type=基类型

# suppress inspection "UnusedProperty"
override.implement.nothing.found=没有东西到{0}
# suppress inspection "UnusedProperty"
override.implement.not.allowed=无法 {0}
show.implement.action.title=显示要实现的成员
elements.to.implement.chooser.title=选择要实现的方法
elements.to.override.chooser.title=选择要重写的成员
elements.to.override.implement.chooser.title=选择要重写/实现的成员

override.implement.progress=正在处理要重写/实现的成员…
override.implement.show.optional.member=显示 1 个可选成员(&O)
override.implement.show.optional.members=显示 {0} 个可选成员(&O)
override.implement.show.no.optional.members=显示可选成员(无可选项)
override.implement.show.only.optional.members=显示可选成员(仅可选项)

hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=仅在主文件的第一行中允许 Hashbang 行
hashbang.line.is.allowed.only.in.the.first.line.of.the.file=仅在文件的第一行中允许 Hashbang 行
hashbang.line.is.allowed.only.in.the.main.file=仅在主文件中允许 Hashbang 行
0.is.not.allowed=不允许 ''{0}''
fix.it=应用 Fix-it
0.is.not.resolved=''{0}'' 未解析
unrecognized.platform.name.0=无法识别的平台名称 ''{0}''
must.handle.potential.future.platforms.with.asterisk=必须使用 '*' 处理潜在的未来平台
add.asterisk=添加 '*'
version.for.0.already.specified=已指定 ''{0}'' 的版本
case.condition.is.not.allowed=不允许 'case' 条件
syntax.error.typealias.without.assignment=类型别名声明缺少赋值

#error handling >>
rethrows.is.not.allowed.in.function.type.elements=函数类型元素中不允许 'rethrows'
rethrows.is.not.allowed.in.subscripts=下标中不允许 'rethrows'
rethrows.is.not.allowed.in.closures=闭包中不允许 'rethrows'
rethrows.function.must.take.a.throwing.function.argument='rethrows' 函数必须包含 throwing 函数参数
throws.is.not.allowed.in.subscripts=下标中不允许 'throws'
thrown.expression.type.0.does.not.conform.to.ErrorType=已引发的表达式类型 ''{0}'' 不符合 ''{1}''
try.cannot.appear.to.the.right='try' 不能出现在非赋值运算符右侧

call.can.throw.in.property.initializer=调用可以引发，但无法从属性初始值设定项中引发错误
call.can.throw.in.default.argument=调用可以引发，但无法从默认参数中引发错误

call.can.throw.not.marked.with.try=调用可以引发，但未使用 'try' 标记
call.can.throw.not.marked.with.try.not.handled=调用可以引发，但未使用 'try' 标记，错误未处理
call.can.throw.not.marked.with.try.not.exhaustive=调用可以引发，但未使用 'try' 标记，封闭 catch 不详尽
call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=调用可以引发，但在非引发自动闭包中执行
call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=调用可以引发，但未使用 'try' 标记，并且在非引发自动闭包中执行

operator.can.throw.not.marked.with.try=运算符可以引发，但表达式未使用 'try' 标记

errors.are.not.handled=从此处引发的错误未被处理
errors.are.not.handled.not.exhaustive=从此处引发的错误未被处理，因为封闭 catch 不详尽

error.is.not.handled=错误未被处理，因为封闭函数未声明 'throws'
error.is.not.handled.not.exhaustive=错误未被处理，因为封闭 catch 不详尽

rethrows.function.can.only.throw.parameter.call=声明 'rethrows' 的函数只能在其参数引发时引发
rethrows.function.can.only.throw.parameter.call.not.handled=调用可以引发，但错误未被处理; 声明 'rethrows' 的函数只能在其参数引发时引发
rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=调用可以引发，但未使用 'try' 标记，错误未被处理; 声明 'rethrows' 的函数只能在其参数引发时引发

mark.the.enclosing.function.as.throws=将 'throws' 添加到函数签名
add.try.to.expression=添加 'try'
suppress.call.error.with.try=使用 'try\!' 禁止错误
surround.with.do.catch=使用 'do/catch' 环绕
add.default.catch.clause=添加默认 'catch' 子句
add.catch.clause=添加 'catch' 子句
fix.try.cannot.appear.to.the.right=向左移动 'try'
intention.create.kind.{0}.from.usage.{1}=创建 {0} ''{1}''
intention.create.type.from.usage.{0}=创建类型 ''{0}''
intention.implement.members.error=类型 {0} 不符合 {1} {2}
# suppress inspection "UnusedProperty"
intention.implement.members.implement.missing.singular=实现 {0} 缺少的成员
# suppress inspection "UnusedProperty"
intention.implement.members.implement.missing.plural=实现 {0} 缺少的成员
# suppress inspection "UnusedProperty"
intention.access.control.error.access=无法访问 {0}\: 它在 {2} 中为 {1}
# suppress inspection "UnusedProperty"
intention.access.control.error.access.dynamic=无法访问 {0}\: 动态成员下标在 {2} 中为 {1}
intention.access.control.error.override=无法重写 {0}\: 它在 {2} 中为 {1}
intention.access.control.fix=在 {2} 中使{0} {1}
intention.access.control.remove.setter=从 {0} 移除 {1}
intention.redundant.attribute.error=特性 @{0} 冗余
intention.redundant.attribute.fix=移除冗余特性 @{0}
intention.redundant.return.error='return' 冗余
intention.redundant.return.fix=移除冗余 'return'
intention.replace.if.with.guard=将 'if' 替换为 'guard'
intention.replace.guard.with.if=将 'guard' 替换为 'if'
intention.add.explicit.type=添加显式类型
intention.remove.explicit.type=移除显式类型
intention.convert.to.multiline.string=转换为多行字符串文字
intention.convert.to.string=转换为单行字符串文字
intention.convert.to.decimal=Convert to Decimal
intention.convert.to.hex=转换为十六进制
intention.convert.to.octal=Convert to Octal
intention.convert.to.binary=Convert to Binary
intention.increase.string.escape.level=提高字符串转义级别
intention.decrease.string.escape.level=降低字符串转义级别
intention.add.digit.separators=添加数字分隔符
intention.remove.digit.separators=移除数字分隔符
intention.split.into.separate.declarations=拆分为单独的声明
intention.split.declaration.and.assignment=拆分为声明和赋值
intention.join.declaration.and.assignment=联接声明和赋值
intention.merge.else.if=Merge Else If
intention.split.else.if=Split Else If
intention.invert.if.statement=反转 if 语句
intention.demorganslaw=德摩根定律
intention.demorganslaw.format=用''{1}''替换''{0}''
intention.merge.nested.if=Merge Nested Ifs to ANDed Condition
intention.split.nested.if=拆分为嵌套的 if
intention.merge.conditions=合并条件
intention.split.condition=拆分为单独的条件
intention.negate.comparison=Negate Comparison
intention.negate.comparison.format=将 ''{0}'' 求反为 ''{1}''
intention.flip.binary.expression=Flip Binary Expression
intention.flip.binary.expression.format=Flip 'equals'
intention.flip.comparison=Flip Comparison
intention.unnecessary.parentheses=移除不必要的括号
intention.unnecessary.parentheses.error=括号不必要
intention.unnecessary.tuple.wrap=将单元素元组替换为类型
intention.unnecessary.tuple.wrap.error=单元素元组可以替换为类型
intention.flip.comparison.format=将 ''{0}'' 翻转为 ''{1}''
fix.return.type.text=使''{0}''返回''{1}''
#<< error handling

variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=具有多个变量的 'var' 声明不能具有显式 getter/setter
variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=具有多个变量的 'var' 声明不能具有隐式 getter 子句
variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=具有多个变量的 'var' 声明不能具有 willSet/didSet 子句
no.expression.found=未找到表达式

feature.are.not.supported.at.version=Swift {1}.{2} 不支持 {0}
feature.attribute=''@{0}'' 特性
feature.raw.strings=原始字符串文字
feature.diagnostic.directives=诊断指令
feature.compiler.version.directive.conditions=编译器版本检查指令

usages.base.member.warning.title=警告
usages.base.member.warning.message.implements={0} 实现了{3}中声明的{1}\n\n是否要查找协议{2}的用法?
usages.base.member.warning.message.override={0} 重写了{4}中声明的{1}\n\n是否要查找基{2}的用法?
usages.base.member.warning.message.override.implemented={0} 重写了{4}中声明的{1}并实现了{3}中声明的{1}\n\n是否要查找基和协议{2}的用法?
usages.base.member.warning.message.default.implementation={0} 是{3}中声明的{1}的默认实现\n\n是否要查找协议{2}的用法?

cannot.perform.refactoring=无法执行重构
extract.method.title.method=提取方法
extract.method.title.function=提取函数
extract.method.title.closure=提取闭包
extract.method.error.should.represent.expr.or.statements=选块应该代表一组语句或表达式
extract.method.error.cannot.determine.expr.type=无法确定所选表达式的类型
extract.method.error.cannot.extract.expr.with.var.declarations=无法从包含变量声明的表达式中提取
extract.method.error.cannot.determine.function.result.type=无法确定函数结果的类型
extract.method.error.multiple.exit.points=选定的代码片段有多个出口点。
extract.method.error.cannot.extract.with.returns=无法提取代码片段内包含返回指令的方法
extract.method.error.cannot.determine.parameters.type=无法确定参数类型
extract.method.error.fragment.should.be.inside.code.block=所选代码片段应在代码块内
extract.method.function.0.will.conflict.with.1.2=函数 ''{0}'' 将与 {1} {2} 冲突
extract.method.method.0.will.conflict.with.1.in.2.3=方法 ''{0}'' 将与{2} ''{3}'' 中的 {1} 冲突
extract.method.at.least.two.parameters.have.name.0=至少两个参数的名称为 ''{0}''
extract.method.variable.0.will.no.longer.be.accessible=变量 ''{0}'' 重构后不再可访问
extract.method.cannot.extract.mutable.value=无法提取可变值
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}'' 将被 {2} ''{1}'' 遮盖

converter.dialog.message=剪贴板包含 Objective-C 代码。要将其转换为 Swift 吗?
converter.dialog.title=将 Objective-C 转换为 Swift

swift.name.rename.init.is.not.supported=不支持重命名 Swift 初始值设定项
swift.name.rename.self.is.not.supported=不支持重命名自参数
swift.name.rename.title=Swift 名称重命名

swift.related.rename.dialog.title=重命名相关声明
swift.related.rename.dialog.description=将具有以下名称的相关声明重命名为\:
swift.related.rename.entity.name=相关声明

swift.containing.file.rename.dialog.title=重命名包含的文件
swift.containing.file.rename.dialog.description=将具有以下名称的包含文件重命名为\:
swift.containing.file.rename.entity.name=包含文件

generate.init.init.already.exists=初始值设定项已存在
generate.init.choose.super.init=选择超类初始值设定项
generate.init.choose.properties=选择要初始化的属性

generate.0.title=生成 {0}
generate.description.single.string.template=单字符串
generate.description.string.concatenation.template=包含串联的多个字符串(+)
generate.description.multi.string.template=多行字符串
generate.template.title=模板(&T)\:

generate.0.already.defined={0} {1,choice,1\#已|2\#已}定义。要将{1,choice,1\#其|2\#其}删除并继续吗?
generate.equals.hash=equals 和哈希
generate.equals.hash.choose.in.0=选择要包含在 {0} 中的属性
generate.single.expression.equals.template=单表达式
generate.if.statements.equals.template=多个 if 语句

generate.cannot.generate.0.for.1=无法为 {1} 生成 {0}
generate.preparing.generation.title=正在准备生成…

usage.type.type.parameter=类型参数
usage.type.extension=扩展
usage.type.requirement=要求中的用法
usage.type.type.alias=类型别名
usage.type.argument.label=参数标签
usage.type.key.path=键路径表达式
usage.type.function.declaration=函数声明
usage.type.operator.declaration=运算符声明
usage.type.precedence.group.declaration=优先组声明
usage.type.raw.value=原始值

color.settings.keyword=关键字和指令//关键字
color.settings.property=标识符//属性
color.settings.colon=括号和操作符//冒号
color.settings.module.name=类型//模块名称
color.settings.protocol=类型//协议
color.settings.class=类型//类
color.settings.type.alias=类型//类型别名
color.settings.struct.and.enum=类型//结构和枚举
color.settings.operator.sign=括号和运算符//运算符
color.settings.enum.case.value=标识符//枚举 case 值
color.settings.self.and.super.keywords=关键字和指令//'self' 和 'super'
color.settings.function.and.method.declaration=函数//函数和方法声明
color.settings.function.and.method.call=函数//函数和方法调用
color.settings.nested.function.declaration=函数//嵌套函数声明
color.settings.nested.function.call=函数//嵌套函数调用
color.settings.external.parameter.name=标识符//外部参数名称
color.settings.inline.closure.parameter=标识符//内联闭包参数
color.settings.anonymous.closure.parameter=标识符//匿名闭包参数
color.settings.wildcard=标识符//通配符
color.settings.type.parameter=类型//泛型参数
color.settings.attribute.name=特性//特性名称
color.settings.attribute.argument=特性//特性参数
color.settings.inline.hints.type.hint=内联提示//类型提示
color.settings.inline.hints.error.hint=内联提示//错误提示
color.conditionally.non.compiled=关键字和指令//有条件的未编译代码
color.settings.directive=关键字和指令//指令

introduce.variable.declare.with.var=使用 var 声明(&V)
introduce.variable.specify.type.explicitly=显式指定类型(&T)
introduce.variable.expression.will.be.ambiguous.without.explicit.type=表达式将不明确，<br/>无显式类型

code.generation=代码生成
swift.create.initializer=创建初始值设定项
renaming.swift.member.elements.in.objective.c.code.is.not.supported=不支持在 Objective-C 代码中重命名 Swift 成员元素
swift.rename=Swift - 重命名
sourcekit.inspections=SourceKit 检查
swift=Swift
swift.redundant.attribute.inspection=冗余特性
swift.rename.inheritors=重命名继承者
rename.inheritors.to=将继承者重命名为\:
swift.redundant.return.inspection=冗余 return
swift.unnecessary.parentheses.inspection=不必要的括号
swift.unnecessary.tuple.wrap.inspection=不必要的元组包装
new.swift.type.in.a.new.file=在新文件中新建 Swift 类型
create.new.swift.declaration=创建新的 Swift 声明
name.colon=名称\:
cannot.rename.dynamic.called.values=无法重命名动态调用值
are.you.sure.you.want.to.reload.all.swift.modules=确定要重新加载所有 Swift 模块吗?
reload.all.swift.modules=重新加载所有 Swift 模块
module.colon=模块\:
reload.module=重新加载模块

change.signature.initializer.will.conflict.with.0.in.1.2=初始值设定项将与 {1} ''{2}'' 中的 {0} 冲突
change.signature.subscript.will.conflict.with.0.in.1.2=下标将与 {1} ''{2}'' 中的 {0} 冲突
change.signature.dialog.title=更改签名
change.info.return.type.label=返回类型\:
change.info.name.label=名称\:
change.info.internal.name.label=内部名称\:
change.info.type.label=按类型分组\:
change.info.optional.label=可选\:
change.info.default.value.label=默认值\:
change.signature.target.not.found=脱字符号应位于函数、初始值设定项或下标处
change.signature.processed.elements.header=要更改签名的元素
change.signature.title=更改签名
