#
# Copyright 2000-2007 JetBrains s.r.o.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

########################################################################################################################
# Introduce variable
########################################################################################################################
introduce.variable.title=引入变量
only.in.groovy.files=此重构仅在 Groovy 文件中可用
selected.block.should.represent.an.expression=选块应该代表一个表达式.
refactoring.is.not.supported.in.the.current.context=当前上下文中不支持重构
refactoring.is.not.supported.in.method.parameters=闭包或方法参数中不支持重构
replace.all.occurrences=替换所有匹配项
declare.final=声明 final
press.escape.to.remove.the.highlighting=按逃到删除高亮显示
specify.the.type.explicitly=显式指定类型
variable.of.type=类型的变量\:
selected.expression.has.void.type=选定的表达式有空隙类型
selected.expression.in.command.expression=所选表达式是命令表达式的一部分
introduced.variable.conflicts.with.parameter.0=引入的变量与参数 {0} 冲突
introduced.variable.conflicts.with.variable.0=引入的变量与局部变量 {0} 冲突

########################################################################################################################
# Inline variable
########################################################################################################################
inline.variable.title=内联变量
variable.is.never.used.0=从未使用变量 ''{0}'' 
field.is.never.used.0=从未使用字段 ''{0}''
wrong.element.to.inline=脱字符号应置于 Groovy 方法或局部变量的名称处
cannot.find.a.single.definition.to.inline.local.var=无法找到内联局部变量的单一定义
cannot.find.a.single.definition.to.inline.field=没有初始化器出席现场
inline.local.command=内联变量
local.varaible.is.lvalue=要内联的变量在赋值中以左值形式出现
inline.local.variable.prompt.0.1=内联局部变量''{0}''？

########################################################################################################################
# Extract method
########################################################################################################################
extract.method.title=提取方法
selected.block.should.represent.a.statement.set=选块应该代表一组语句或表达式
multiple.output.values=所选代码段有多个输出值
selected.block.contains.invocation.of.another.class.constructor=选块包含调用另一个类的构造函数.
specify.type.label=显式指定返回类型(&T)
name.label=名称(&N)\:
signature.preview.border.title=签名预览
parameters.border.title=参数
visibility.border.title=可见性
method.border.title=方法
visibility.private=private
visibility.public=public
visibility.protected=protected
row.move.up=向上移动
row.move.down=向下移动
method.is.already.defined.in.class=方法 {0} 已在类 {1} 中定义。
method.is.already.defined.in.script=方法 {0} 已在脚本 {1} 中定义。

########################################################################################################################
# Inline method
########################################################################################################################
inline.refactoring.title=内联
inline.method.title=内联方法
inline.method.border.title=内联
inline.method.label=方法{0}
all.invocations.and.remove.the.method=内联所有调用并移除方法(&A)
all.invocations.in.project=内联项目中的所有调用(&A)
this.invocation.only.and.keep.the.method=仅内联此调用并保留方法(&T)
refactoring.cannot.be.applied.to.abstract.methods=重构不能应用于 abstract 方法
refactoring.cannot.be.applied.no.sources.attached=无法应用重构\: 未附加任何源
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=当 return 语句中断执行流时，不支持重构
refactoring.is.not.supported.for.recursive.methods=递归方法不支持重构
refactoring.cannot.be.applied.to.constructors=重构不能应用于构造函数
refactoring.is.not.supported.in.parameter.initializers=参数初始值设定项中不支持重构
inline.method.prompt.0=内联方法 ''{0}'' 调用?
refactoring.is.available.only.for.method.calls=重构仅适用于方法调用
method.is.not.accessible.form.context.0=不能从调用站点访问内联方法中使用的方法 {0}
field.is.not.accessible.form.context.0=不能从调用站点访问内联方法中使用的字段 {0}
super.reference.is.used=内联方法中使用的 super 调用在内联后将无效。

########################################################################################################################
# Inline method
########################################################################################################################
variable.conflicts.with.parameter.0=所选名称与参数 {0} 冲突
variable.conflicts.with.variable.0=所选名称与局部变量 {0} 冲突
variable.conflicts.with.field.0=所选名称与字段 {0} 冲突

########################################################################################################################
# Introduce Parameter
########################################################################################################################
introduce.parameter.title=引入参数
groovy.does.not.support.inner.classes.but.it.is.used.in.parameter.initializer=Groovy 不支持内部类，但它会在参数初始值设定项中使用。
groovy.does.not.support.anonymous.classes.but.it.is.used.in.parameter.initializer=Groovy 不支持匿名类，但它会在参数初始值设定项中使用。
error.wrong.caret.position.method.name=脱字符号应置于要重构的方法的名称处。

########################################################################################################################
# Change signature
########################################################################################################################
changeSignature.refactoring.name=更改签名
column.name.type=按类型分组
column.name.name=名称
column.name.default.initializer=初始值设定项
column.name.default.value=默认值
method.duplicate=具有签名 {0} 的方法已在 {1} 中定义
replace.setter.for.property=属性 ''{0}'' 的默认 setter 将被覆盖
replace.getter.for.property=属性 ''{0}'' 的默认 getter 将被覆盖
name.is.wrong=名称 ''{0}'' 不正确
incorrect.data=不正确的数据
return.type.is.wrong=返回类型错误
type.for.parameter.is.incorrect=参数 ''{0}'' 的类型不正确
specify.default.value=为参数 ''{0}'' 指定默认值或初始值设定项
changing.signature.of.0=改变签名的{0}
refactored.method.will.cover.closure.property=重构的方法将重写 {1} 中的闭包属性 ''{0}''
changeSignature.not.throwable.type=类型错误\: 异常的 ''{0}''，应扩展 java.lang.Throwable
changeSignature.wrong.type.for.exception=异常的错误类型\:''{0}''
changeSignature.no.type.for.exception=指定异常的类型
no.occurrences.found=未找到匹配项
expression.is.not.constant=所选表达式不是常量
class.does.not.exists=类 {0} 不存在
class.does.not.exist.in.the.module=模块中不存在类。是否要创建一个类?
closure.uses.external.variables=闭包使用外部非常量变量
expression.invokes.not.static.methods=表达式调用非 static 方法
class.language.is.not.groovy=目标类的语言不是 Groovy
implicit.getter.will.by.overriden.by.method=属性 {0} 的隐式 getter 将被方法 {1} 重写
implicit.setter.will.by.overriden.by.method=属性 {0} 的隐式 setter 将被方法 {1} 重写
usage.of.field.will.be.overriden.by.method=字段的用法将被方法 {0} 重写
usage.will.be.overriden.by.method=用法 {0} 将被方法 {1} 重写
target.class.is.not.specified=未指定目标类
is.not.class.name=''{0}'' 不是类名
target.class.must.not.be.script=目标类不得为脚本
rename.is.not.applicable.to.implicit.elements=无法重命名隐式元素
rename.member=重命名 {0}
rename.property=重命名属性 ''{0}''
cannot.introduce.field.in.script=范围内没有类
cannot.introduce.field.in.interface=无法在接口中引入字段
expression.contains.errors=表达式包含错误
field.0.is.already.defined=字段 {0} 已定义
access.to.created.field.0.will.be.overriden.by.method.1=对字段 {0} 的访问将被 {1} 重写
final.field.cant.be.initialized.in.cur.method=无法在当前方法中初始化最终字段
Field.cannot.be.final.because.replaced.variable.has.lhs.usages=所选变量用于写入
field.cannot.be.initialized.in.field.declaration=无法在声明中初始化字段
field.cannot.be.initialized.in.constructor(s)=无法在构造函数中初始化字段
selected.variable.is.used.for.write=所选变量用于写入
there.is.no.method.or.closure=没有包含方法或闭包
remove.parameter.0.no.longer.used=移除不再使用的参数''{0}''
convert.to.java.refactoring.name=转换为 Java
convert.to.java.can.work.only.with.groovy=转换为 Java 重构仅适用于 Groovy 文件
files.to.be.converted=要转换的文件
converting.files.to.java=正在将文件转换为 Java
convert.to.static.refactoring.name=转换为 @CompileStatic
convert.to.static.can.work.only.with.groovy=转换为 @CompileStatic 重构仅适用于 Groovy 文件
converting.files.to.static=正在将文件转换为 @CompileStatic
intention.converting.to.static=将转换应用于 @CompileStatic
intention.converting.to.static.family=转换为 @CompileStatic
rename.groovy.property=重命名 Groovy 属性(&G)
change.usages.of.var=更改变量 ''{0}'' 的用法?
reference.to.accessor.0.is.used=无法内联对访问器 <bold>{0}<bold> 的引用。
variable.is.accessed.for.writing=变量''{0}''可写.
introduce.closure.parameter.elements.header=正在将参数添加到闭包
extract.closure.title=提取闭包
cannot.process.usage.in.language.{0}=无法处理 {0} 中的用法
you.cannot.pass.as.parameter.0.because.you.remove.1.from.base.method=您无法将 ''{0}'' 作为参数传递，因为您从方法中移除了与其关联的参数 ''{1}''。您应当在参数表中取消选择“移除不再使用的参数 ''{0}''”或取消选择参数 ''{1}''。
rename.groovy.implicit.closure.parameter=重命名隐式闭包参数
rename.implicit.closure.parameter.to=将隐式闭包参数重命名为\:
implicit.closure.parameter=隐式闭包参数
selected.expression.should.not.be.lvalue=所选表达式不应位于赋值的左侧
column.name.use.any.var=使用任意变量
rename.groovy.method=重命名 Groovy 方法
cannot.inline.0.=无法内联 {0}
ref.0.will.not.be.resolved.outside.of.current.context=不会在当前上下文范围外解析引用 ''{0}''
cannot.rename.property.0=无法重命名重写方法 <bold>''{1}''</bold> 的属性 <bold>''{0}''</bold>
cannot.inline.reference.0=无法内联引用 ''{0}''
cannot.rename.script.class.to.0=无法将脚本类 ''{0}'' 重命名为 ''{1}''
