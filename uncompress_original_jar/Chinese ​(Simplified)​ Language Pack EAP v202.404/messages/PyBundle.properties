### Quick fixes ###
QFIX.optimize.imports=优化导入

QFIX.add.import.add.import=添加 "''{0}''"

QFIX.NAME.parameters=函数和方法的参数


QFIX.statement.effect.move.docstring=将文档字符串移至正确位置

QFIX.statement.effect.introduce.variable=引入变量

QFIX.unresolved.reference=将 ''{0}'' 替换为 ''{1}.{0}''

QFIX.unresolved.reference.add.param.$0=创建参数 ''{0}''
QFIX.unresolved.reference.add.param=创建引用参数

# UnresolvedRefCreateFunctionQuickFix
QFIX.unresolved.reference.create.function=创建函数
QFIX.NAME.unresolved.reference.create.function=创建函数 ''{0}''

#UnresolvedRefTrueFalseQuickFix
QFIX.unresolved.reference.replace.$0=替换为 {0}

#PyRenameUnresolvedRefQuickFix
QFIX.rename.unresolved.reference=重命名引用

#PyImplementMethodsQuickFix
QFIX.NAME.implement.methods=实现 abstract 方法

QFIX.NAME.change.signature=Change signature
QFIX.change.signature.of=更改{0}的签名

QFIX.NAME.rename.element=重命名元素

QFIX.create.function.in.module=在模块中创建函数
QFIX.ignore.unresolved.reference=忽略未解析的引用
QFIX.ignore.unresolved.reference.0=忽略未解析的引用 ''{0}''
QFIX.mark.all.unresolved.attributes.of.0.as.ignored=将所有未解析的 ''{0}'' 属性标记为已忽略
QFIX.fill.paragraph=填充段落
QFIX.add.qualifier=添加限定符
QFIX.create.class=创建类
QFIX.create.class.0=创建类 ''{0}''
QFIX.create.class.in.module=在模块 {1} 中创建类 ''{0}''
QFIX.remove.trailing.blank.lines=移除尾随的空白行
QFIX.generating.skeletons.for.binary.module=正在为二进制模块生成框架
QFIX.generate.binary.stubs=生成二进制存根
QFIX.replace.with.true.or.false=替换为 True 或 False
QFIX.reformat.file=重新格式化文件
QFIX.bold.html.text=<b>{0}</b>

# Intentions: INTN

# Conflict checker
CONFLICT.name.$0.obscured=名称 ''{0}'' 被局部定义遮掩
CONFLICT.name.$0.obscured.cannot.convert=名称 ''{0}'' 被遮掩。无法转换。
CONFLICT.occurrence.sing=匹配项
CONFLICT.occurrence.pl=匹配项

### Surround with templates ###
surround.with.whileelse.template=while / else
surround.with.return.template=返回
surround.with.try.except.template=try / except

##########################################################################################################################
# Unwrap
##########################################################################################################################
unwrap.if=解开 if...
unwrap.while=解开 while...
unwrap.for=解开 for...
unwrap.with=解开 with...
unwrap.try=解开 try...
unwrap.else=解开 else...
unwrap.elif=解开 elif...
remove.else=移除 else...
remove.elif=移除 elif...

INSP.GROUP.python=Python

# Refactoring
refactoring.will.not.be.accessible=成员，您在试图根据 ''{0}'' 移动，进行重构后将无法访问此对象
refactoring.error.file.exists=文件"{0}" 已存在
refactoring.error.directory.exists=目录 "{0}" 已存在

# introduce
refactoring.introduce.name.error=错误的名称
refactoring.introduce.selection.error=使用选定的元素不能执行重构

# introduce variable
refactoring.introduce.variable.dialog.title=提取变量
refactoring.introduce.variable.scope.error=名称与现有变量或参数冲突

# introduce constant
refactoring.introduce.constant.dialog.title=提取常量
refactoring.introduce.constant.scope.error=已在范围中声明名称

# introduce parameter
refactoring.introduce.parameter.dialog.title=提取字段

# pull up
refactoring.pull.up.dialog.title=向上拉取成员至
refactoring.pull.up.dialog.move.members.to.class=将成员移至类
refactoring.pull.up.dialog.members.to.be.moved=将移动以下成员
refactoring.pull.up.error.cannot.perform.refactoring.using.selected.elements=无法使用所选元素执行向上拉取成员
refactoring.pull.up.error.cannot.perform.refactoring.not.inside.class=无法执行向上拉取成员：不在此类中
refactoring.pull.up.error.cannot.perform.refactoring.no.base.classes=类 {0} 没有超级类，或者所有超类都不能用于重构

# push down
refactoring.push.down.dialog.title=从中向下推送成员
refactoring.push.down.error.cannot.perform.refactoring.using.selected.elements=无法使用所选元素执行向下推送成员
refactoring.push.down.error.cannot.perform.refactoring.not.inside.class=无法执行向下拉取成员：不在此类中

# inline
refactoring.inline.local.multiassignment=定义在链式赋值中

# inline function
refactoring.inline.function.title=内联函数
refactoring.inline.this.only=仅内联此调用并保留声明
refactoring.inline.function=内联函数 {0}
refactoring.inline.method=内联方法 {0}
refactoring.inline.all.keep.declaration=内联所有调用并保留声明
refactoring.inline.all.remove.declaration=内联所有调用并移除声明
refactoring.inline.function.is.decorator=函数 {0} 用作修饰器，无法内联。不会移除函数定义
refactoring.inline.function.is.reference=函数 {0} 用作引用，无法内联。不会移除函数定义
refactoring.inline.function.uses.unpacking=函数 {0} 用作参数解压缩，无法内联。不会移除函数定义
refactoring.inline.function.generator=无法内联生成器
refactoring.inline.function.async=无法内联异步函数
refactoring.inline.function.constructor=无法内联构造函数调用
refactoring.inline.function.builtin=无法内联内置函数
refactoring.inline.function.special.method=无法内联特殊方法
refactoring.inline.function.skeleton.only=无法从二进制模块内联函数
refactoring.inline.function.decorator=无法内联包含装饰器的函数
refactoring.inline.function.self.referrent=无法内联引用自身的函数
refactoring.inline.function.star=无法内联包含 * 参数的函数
refactoring.inline.function.overrides.method=无法内联覆盖其他方法的方法
refactoring.inline.function.is.overridden=无法内联被覆盖的方法
refactoring.inline.function.global=无法内联包含全局变量的函数
refactoring.inline.function.nonlocal=无法内联包含非局部变量的函数
refactoring.inline.function.nested=无法内联包含其他函数声明的函数
refactoring.inline.function.interrupts.flow=无法内联中断控制流的函数

# extract method
refactoring.extract.method=提取方法
refactoring.extract.method.error.bad.selection=无法使用所选元素执行提取方法
refactoring.extract.method.error.name.clash=方法名称与现有名称冲突
refactoring.extract.method.error.returns=无法提取代码片段内包含返回指令的方法
refactoring.extract.method.error.local.variable.modifications=无法从代码片段内包含局部变量修改的表达式执行重构
refactoring.extract.method.error.local.variable.modifications.and.returns=无法从代码片段内包含局部变量修改和返回指令的表达式执行重构
refactoring.extract.method.error.empty.fragment=无法从空代码片段执行重构

refactoring.extract.method.error.class.level=无法在类级别执行重构

# extract superclass
refactoring.extract.super.target.path.outside.roots=目标目录在项目外部。必须在内容根内
refactoring.extract.super.target.class.already.exists=此模块中已存在类 ''{0}''
refactoring.extract.super.name.0.must.be.ident=名称 ''{0}'' 无效。必须为有效的 Python 标识符
refactoring.extract.super.class.no.members.allowed=无法提取任何成员

# move
refactoring.move.choose.destination.file.title=选择目标文件
refactoring.move.error.destination.file.contains.class.$0=目标文件已包含名称为 ''{0}'' 的类
refactoring.move.error.destination.file.contains.function.$0=目标文件已包含名称为 ''{0}'' 的函数
refactoring.move.error.destination.file.contains.global.variable.$0=目标文件已包含名称为 ''{0}'' 的全局变量
refactoring.move.error.cannot.use.module.name.$0=无法在导入中使用模块名称 ''{0}''

# move module members (top-level)
refactoring.move.module.members=移动模块成员
refactoring.move.module.members.dialog.title=移动模块成员
refactoring.move.module.members.dialog.table.title=批量移动(&M)
refactoring.move.module.members.dialog.description.class=移动类 {0}
refactoring.move.module.members.dialog.description.function=移动函数 {0}
refactoring.move.module.members.dialog.description.variable=移动全局变量 {0}
refactoring.move.module.members.dialog.description.selection=移动选择的元素
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=无法将元素放入非 Python 文件中
refactoring.move.module.members.error.selection=使用选定的元素不能执行重构

# Make function top-level
refactoring.make.method.top.level.dialog.title=使之为顶层方法
refactoring.make.method.top.level.dialog.description=将方法 {0} 移至顶层

refactoring.make.local.function.top.level.dialog.title=使之为顶层局部函数
refactoring.make.local.function.top.level.dialog.description=将局部函数 {0} 移至顶层

refactoring.make.function.top.level.error.nonlocal.writes=无法移动包含非局部写入的函数
refactoring.make.function.top.level.error.self.reads=无法从外部范围移动包含 "self" 参数用法的函数
refactoring.make.function.top.level.error.outer.scope.reads=无法从外部范围移动引用名称的方法
refactoring.make.function.top.level.error.private.attributes=无法移动引用 private 实例属性的方法
refactoring.make.function.top.level.error.attribute.writes=无法移动写入实例属性的方法
refactoring.make.function.top.level.error.method.calls=无法移动调用同一类其他方法的方法
refactoring.make.function.top.level.error.special.usage.of.self=无法移动包含 "self" 参数特殊用法的方法



#change signature
refactoring.change.signature.usage.view.declarations.header=要重构的函数
refactoring.change.signature.dialog.validation.name.defined=范围中已定义名称
refactoring.change.signature.dialog.validation.function.name=函数名称不正确
refactoring.change.signature.dialog.validation.parameter.name=参数名称不正确
refactoring.change.signature.dialog.validation.multiple.star=不允许多个 * 参数
refactoring.change.signature.dialog.validation.multiple.double.star=不允许多个 ** 参数
refactoring.change.signature.dialog.validation.default.missing=缺少默认值
refactoring.change.signature.dialog.validation.parameter.missing=缺少参数名称
refactoring.change.signature.dialog.default.value.checkbox=在签名中使用默认值：
refactoring.change.signature.dialog.name.label=名称\:
refactoring.change.signature.find.usages.of.base.class={1} 的方法 {0}\n\
重写了 {2} 的方法。\n\
要重构该基方法吗？
refactoring.change.signature.error.wrong.caret.position.method.name=脱字符号应置于要重构的方法的名称处
refactoring.change.signature.error.lambda.call=脱字符号位于 lambda 调用
refactoring.change.signature.error.tuple.parameters=函数包含元组参数
refactoring.change.signature.error.not.under.source.root=函数不在源根下
refactoring.change.signature.suggested.callSite.value=调用站点的值
refactoring.change.signature.suggested.callSite.value.optional=调用站点的可选值

# convert module to package
refactoring.convert.module.to.package.title=将模块转换为包

# convert module
refactoring.convert.package.to.module.title=将模块转换为包
refactoring.convert.package.to.module.error.not.empty.package=包 "{0}" 非空

refactoring.occurrences.count={0}（{1} 个匹配项）
refactoring.introduce.field.setup.method=setUp() 方法
refactoring.introduce.field.cannot.be.used.in.static.methods=static 方法中不能使用引入字段重构
refactoring.introduce.field.not.in.class=无法引入字段：不在类中
refactoring.rename.containing.file.with.the.following.name.to=将具有以下名称的包含文件重命名为\:
refactoring.rename.containing.file.title=重命名包含文件
refactoring.rename.containing.file=重命名包含文件
refactoring.rename.parameter.in.hierarchy.to=以层次结构重命名参数\:
refactoring.rename.parameters.title=重命名参数
refactoring.rename.parameters.in.hierarchy=重命名层次结构中的参数
refactoring.rename=重命名
refactoring.rename.not.valid.identifier=名称 ''{0}'' 不是有效的 Python 标识符。无法更新 ''{1}'' 中的导入语句
refactoring.rename.inheritor.classes.with.the.following.names.to=将具有以下名称的继承者类重命名为：
refactoring.rename.inheritors.title=重命名继承者
refactoring.rename.inheritors=重命名继承者

### Annotators ###
ANN.default.except.must.be.last=默认 'except\:' 必须为最后一个

ANN.$0.both.global.and.param=名称 ''{0}'' 同时用作参数和全局变量

ANN.assignment.to.keyword=关键字赋值
ANN.cannot.assign.to.debug=无法分配给 __debug__
ANN.unparenthesized.assignment.expressions.are.prohibited.0=非父级赋值表达式禁止 {0}
ANN.assignment.expressions.within.a.comprehension.cannot.be.used.in.a.class.body=推导式中的赋值表达式不能在类主体中使用
ANN.ignore.errors.like.this=忽略这样的错误
ANN.function.cannot.be.async=函数 "{0}" 不能是异步函数
ANN.python.does.not.support.yield.from.inside.async.functions=Python 不支持在异步函数中使用 'yield from'
ANN.yield.outside.of.function='yield' 在函数外部
ANN.non.empty.return.inside.asynchronous.generator=异步生成器内部的 'return' 非空
ANN.return.outside.of.function='return' 在函数外部
ANN.can.t.use.starred.expression.here=这里不能使用星号表达式
ANN.illegal.target.for.variable.annotation=变量注解目标非法
ANN.variable.annotation.cannot.be.combined.with.tuple.unpacking=变量注解不能与元组解压缩相结合
ANN.variable.annotation.cannot.be.used.in.assignment.with.multiple.targets=变量注解不能用于具有多个目标的赋值

python.run.select.script=选择脚本
python.run.configuration=Python 运行配置
python.run.python=Python

testing.form.inspect.only.subclasses.of.unittest.testcase=仅检查 unittest.TestCase 的子类
python.testing.target.not.provided=未提供目标
python.testing.provide.qualified.name=提供函数、类或模块的限定名称”
python.testing.pattern.can.only.be.used=模式只能用于匹配文件夹中的文件。无法将模式用于文件。

runcfg.tests.cant_rerun=无法重新运行测试，因为无法解析测试 ID。尝试删除运行配置，并通过右键单击创建新配置。
runcfg.tests.empty_suite=空套件

### doctest run conf
runcfg.doctest.display_name=Doctest
runcfg.doctest.description=Python doctest 运行配置

### nosetests run conf
runcfg.nosetests.display_name=Nosetest
runcfg.nosetests.description=Python nosetest 运行配置

### nosetests run configuration custom options
python.testing.nose.custom.options.regex.pattern=正则表达式模式\:
python.testing.nose.custom.options.keywords=关键字\:
python.testing.nose.custom.options.parameters=参数\:
python.testing.nose.custom.options.additional.arguments=其他参数\:

### pytest run conf
runcfg.pytest.display_name=pytest
runcfg.pytest.description=pytest 运行配置
runcfg.pytest.target=目标(&T)\:
runcfg.pytest.parameters=选项(&O)\:
runcfg.pytest.keywords=关键字(&K)\:

### trial run conf
runcfg.trial.display_name=Twisted Trial

### test run configuration
runcfg.test.display_name=Python 测试
runcfg.test.description=PyCharm 支持 Python 框架

### tox
runcfg.tox.runner=tox 运行程序
runcfg.tox=tox

### unittest run configuration
runcfg.unittest.display_name=Unittest
runcfg.unittest.description=Python unittest 运行配置
runcfg.unittest.no_script_name=请指定脚本名称
runcfg.unittest.no_module_name=请指定模块限定名称
runcfg.unittest.no_class_name=请指定类名
runcfg.unittest.no_method_name=请指定方法名称
runcfg.unittest.no_folder_name=请指定包含测试的文件夹
runcfg.unittest.incorrect.script=测试脚本名称应以 "test" 前缀开头
runcfg.unittest.dlg.tests_group_title=测试\:
runcfg.unittest.dlg.test_script_label=脚本\:
runcfg.unittest.dlg.class_label=类\:
runcfg.unittest.dlg.method_label=方法\:
runcfg.unittest.dlg.function_label=函数\:
runcfg.unittest.dlg.folder_path=文件夹：
runcfg.unittest.dlg.test_type_title=测试\:
runcfg.unittest.dlg.all_in_folder_title=全部在文件夹中
runcfg.unittest.dlg.all_in_script_title=脚本
runcfg.unittest.dlg.test_class_title=类
runcfg.unittest.dlg.test_method_title=方法
runcfg.unittest.dlg.folder_title=测试文件夹：
runcfg.unittest.no_valid_sdk=请选择有效的 Python 解释器
runcfg.unittest.no_module_sdk=请选择包含有效 Python SDK 的模块
runcfg.unittest.no_sdk=请指定 Python SDK
runcfg.unittest.dlg.select.folder.path=选择文件夹路径：
runcfg.unittest.dlg.select.script.path=选择脚本路径：
runcfg.unittest.dlg.interpreter_options_title=解释器选项：
runcfg.unittest.dlg.messages.working.dir=工作目录\:
runcfg.labels.script_parameters=参数 (&P)\:
runcfg.labels.script=脚本(&S)\:
runcfg.labels.environment_variables=环境变量(&E)：
runcfg.labels.interpreter=使用指定的解释器(&U)：
runcfg.labels.use.sdk.of.module=使用模块 SDK：
runcfg.labels.interpreter_options=解释器选项(&O)：
runcfg.labels.working_directory=工作目录(&W)\:
runcfg.captions.script_parameters_dialog=输入脚本参数
runcfg.captions.interpreter_options_dialog=输入解释器选项
runcfg.labels.python.interpreter=Python 解释器(&P)：
runcfg.labels.add.content.roots.to.pythonpath=将内容根添加到 PYTHONPATH
runcfg.labels.add.source.roots.to.pythonpath=将源根添加到 PYTHONPATH
runcfg.labels.path.mappings=路径映射
runcfg.labels.project=项目(&J)\:
runcfg.labels.script.path=脚本路径
runcfg.labels.module.name=模块名称
runcfg.labels.custom.name=自定义
runcfg.labels.execution=执行
sdk.error.invalid.interpreter.name.$0=Python 解释器名称 ''{0}'' 无效！
sdk.select.path=选择 Python 解释器
runcfg.unittest.dlg.pattern=模式\:

runcfg.testing.no.test.framework=在选定的解释器中找不到 {0} 运行程序

# Consoles messages
python.console=Python 控制台
python.console.history.root=Python 控制台
python.console.run.anything.provider=运行 Python 控制台

# UI messages
MSG.title.bad.sdk=无效的 Python SDK
MSG.cant.setup.sdk.$0=无法\n\
在 {0} 设置 python SDK。\n\
此 SDK 似乎无效。


#Buildout
buildout=Buildout
buildout.unresolved.part.inspection=Buildout 配置未解析的元件检查
buildout.unresolved.part.inspection.msg=未解析的元件引用
buildout.configurable.enable.buildout.support.checkbox.text=启用 buildout 支持 (&E)
runcfg.unittest.dlg.test_function_title=函数
runcfg.unittest.dlg.keywords=关键字\:
run.configuration.remote.debug.name=Python 远程调试
run.configuration.remote.debug.visible.name=Python 调试服务器
run.configuration.type.description=启动服务器进行远程调试
run.configuration.show.command.line.action.name=显示调试控制台

unable.to.stop=无法停止当前正在运行的进程。先手动终止此进程。

#Debug

debug.popup.title.step.into.function=单步进入函数

debug.notification.group=Python 调试器
debug.notification.title.connection.failed=连接 Python 调试器失败

remote.debug.info=信息
remote.debug.server.hint=启动此调试配置以启动调试服务器。
remote.debug.server.hint1.5=更新脚本：
remote.debug.server.hint2=1. 将 pydevd-pycharm.egg 从 PyCharm 安装目录添加到 Python 路径或执行：
remote.debug.server.hint3=pip 安装 pydevd-pycharm
remote.debug.server.hint4=2. 添加以下命令以连接至调试服务器：
remote.debug.settings=设置
remote.debug.remote.host=远程主机
remote.debug.port=端口
remote.debug.use.path.mapping=使用路径映射
remote.debug.remote.root.folder=远程路径前缀：
remote.debug.local.root.folder=本地路径前缀：
remote.debug.local.host=IDE 主机名：
remote.debug.redirect.output=将输出重定向到控制台
remote.debug.suspend.on.connect=连接后挂起

python.sdk.getting.remote.interpreter.version=正在获取远程解释器版本
python.sdk.directory.macro.description=此目录包含为项目选择的 Python 解释器
python.sdk.run.wait=稍候...
python.sdk.scanning.installed.packages=正在扫描已安装的包...
python.sdk.updater.notifications.group.title=Python SDK 更新程序
python.sdk.updating.skeletons=正在更新框架...
python.sdk.updating.python.paths=正在更新 Python 路径
python.sdk.unpacking.pre.generated.skeletons=正在解压缩预生成的框架...
python.sdk.popup.interpreter.settings=解释器设置...
python.sdk.popup.add.interpreter=添加解释器...
python.sdk.switch.to=切换到 {0}
python.sdk.installing=正在安装 {0}
python.sdk.downloading=下载中{0}
python.sdk.running=正在运行 {0}
python.sdk.installing.windows.warning=Windows 可能需要您批准后才能安装 Python。请检查任务栏。
python.sdk.select.conda.path.title=选择 Conda 可执行文件路径
python.sdk.conda.path=Conda 可执行文件：
python.sdk.select.location.for.conda.title=选择 Conda 环境的位置
python.sdk.creating.conda.environment.title=正在创建 Conda 环境
python.sdk.select.location.for.virtualenv.title=选择虚拟环境的位置
python.sdk.creating.virtualenv.title=正在创建虚拟环境
python.sdk.add.python.interpreter.title=添加 Python 解释器
python.sdk.python.interpreter.title.0=Python 解释器\: {0}
python.sdk.new.environment.kind=新 {0} 环境
python.sdk.next=下一个
python.sdk.previous=上一个
python.sdk.finish=完成
python.sdk.interpreter.field.is.empty=解释器字段为空
python.sdk.setting.up.pipenv.title=正在设置 Pipenv 环境
python.sdk.install.requirements.from.pipenv.lock=Pipfile.lock 中的安装要求
python.sdk.pipenv.executable.not.found=找不到 Pipenv 可执行文件
python.sdk.pipenv.executable=Pipenv 可执行文件：
python.sdk.pipenv.associated.object=已关联 {0}：
python.sdk.pipenv.execution.exception.no.project.message=无法找到与此 Pipenv 环境关联的项目
python.sdk.pipenv.execution.exception.no.pipenv.message=无法找到 Pipenv
python.sdk.pipenv.execution.exception.error.running.pipenv.message=运行 Pipenv 时出错
python.sdk.pipenv.quickfix.fix.pipenv.name=修复 Pipenv 解释器
python.sdk.pipenv.quickfix.use.pipenv.name=使用 Pipenv 解释器
python.sdk.pipenv.pip.file.lock.not.found=未找到
python.sdk.pipenv.pip.file.lock.out.of.date=已过期
python.sdk.pipenv.pip.file.notification.content=运行 <a href\='\#lock'>pipenv lock</a> 或 <a href\='\#update'>pipenv update</a>
python.sdk.pipenv.pip.file.notification.locking=正在锁定 {0}
python.sdk.pipenv.pip.file.notification.updating=正在更新 Pipenv 环境
python.sdk.pipenv.pip.file.watcher={0} 观察程序

python.sdk.file.not.found=找不到文件 {0}
python.sdk.cannot.execute=无法执行 {0}
python.sdk.pipenv.has.been.selected=已添加 Pipenv 解释器，选择解释器列表中的 ''{0}''
python.sdk.there.is.no.interpreter=无解释器
python.sdk.no.interpreter.configured.warning=未为此项目配置 Python 解释器
python.sdk.no.interpreter.selection=未选择 Python 解释器
python.sdk.choose.valid.interpreter=选择有效的 Python 解释器
python.sdk.common.options.environment=环境
python.sdk.rendering.project.default=项目默认设置
python.sdk.rendering.project.default.0=项目默认值 ({0})
python.sdk.failed.to.install.title=无法安装 {0}
python.sdk.installation.has.been.cancelled.title={0} 安装已被取消
python.sdk.failed.to.create.interpreter.title=无法创建解释器

# SDK / skeletons
sdk.some.skeletons.failed=无法生成某些框架
sdk.error.dialog.problems=框架生成问题
sdk.gen.cleaning.up=正在清理框架...
sdk.gen.launching.generator=正在启动框架生成器...
sdk.gen.reloading=正在重新加载生成的框架...
sdk.gen.unpacking.prebuilt=正在解压缩预建框架...
sdk.gen.updating.interpreter=正在更新 Python 解释器
sdk.scanning.installed.packages=正在扫描已安装的包
sdk.gen.stubs.for.binary.modules=生成二进制模块 {0} 的存根
sdk.gen.failed.notification.title=无法刷新远程解释器的框架

# Active SDK configurable and related dialogs
active.sdk.dialog.show.all.item=全部显示...
active.sdk.dialog.project.interpreter=Python 解释器：
active.sdk.dialog.project.interpreter.path.mappings=路径映射：
active.sdk.dialog.project.interpreter.path.mappings.default.project.error=打开或创建项目以配置映射

sdk.details.step.add=添加...
sdk.details.step.create.virtual.env=创建 VirtualEnv
sdk.details.step.create.conda.env=创建 Conda 环境
sdk.details.step.show.all=全部显示...

sdk.details.dialog.title=Python 解释器
sdk.details.dialog.hide.all.virtual.envs=隐藏与其他项目关联的虚拟环境
sdk.details.dialog.show.interpreter.paths=显示所选解释器的路径
sdk.details.dialog.error.duplicate.name=请为解释器指定唯一的名称

sdk.edit.dialog.title=编辑 Python 解释器
sdk.edit.dialog.associate.virtual.env.with.path=关联此虚拟环境与 {0}
sdk.edit.dialog.associate.virtual.env.current.project=关联此环境与当前项目
sdk.edit.dialog.specify.interpreter.path=指定解释器路径

sdk.paths.dialog.title=解释器路径
sdk.paths.dialog.reload.paths=重新加载路径列表
sdk.paths.dialog.added.by.user.suffix=（用户已添加）
sdk.paths.dialog.removed.by.user.suffix=（用户已移除）

sdk.create.venv.dialog.creating.venv=正在创建虚拟环境
sdk.create.venv.dialog.make.available.to.all.projects=可用于所有项目
sdk.create.venv.dialog.select.venv.location=选择虚拟环境的位置
sdk.create.venv.dialog.error.not.empty.directory=目录不为空
sdk.create.venv.dialog.error.empty.venv.name=VirtualEnv 名称不能为空
sdk.create.venv.dialog.error.empty.venv.location=目标目录路径不能为空
sdk.create.venv.dialog.error.invalid.directory.name=无效目录名称
sdk.create.venv.dialog.error.failed.to.create.venv=创建虚拟环境失败

sdk.create.venv.dialog.title=创建虚拟环境
sdk.create.venv.dialog.label.name=名称\:
sdk.create.venv.dialog.label.location=位置\:
sdk.create.venv.dialog.label.base.interpreter=基本解释器：
sdk.create.venv.dialog.label.inherit.global.site.packages=继承全局站点包
sdk.create.venv.dialog.error.no.base.interpreter=选择基本解释器

sdk.create.venv.conda.dialog.title=创建 Conda 环境
sdk.create.venv.conda.dialog.error.no.python.version=选择 python 版本
sdk.create.venv.conda.dialog.label.location=位置\:
sdk.create.venv.conda.dialog.label.python.version=Python 版本：

# remote interpreters
remote.interpreter.add.title=添加远程解释器
remote.interpreter.configure.title=配置远程 Python 解释器
remote.interpreter.configure.path.title=选择 Python 解释器
remote.interpreter.configure.temp.files.path.title=为 PyCharm 帮助程序选择文件夹
remote.interpreter.default.interpreter.path=/usr/bin/python
remote.interpreter.docker.default.interpreter.path=python
remote.interpreter.unspecified.interpreter.path=指定 Python 解释器路径
remote.interpreter.unspecified.temp.files.path=为 PyCharm 帮助程序指定路径
remote.interpreter.configure.path.label=Python 解释器路径：
remote.interpreter.configure.temp.files.path.label=PyCharm 帮助程序路径：
remote.interpreter.error.plugin.missing=缺少远程主机访问插件。请在 {0} 中启用此插件。
remote.interpreter.configure.ssh.run_as_root_via_sudo.checkbox=使用此解释器通过 sudo 以根权限执行代码
remote.interpreter.configure.ssh.run_as_root_via_sudo.help=仅在通过 SSH 连接启动远程解释器时才调用 Sudo。这些文件将通过用户权限被复制到远程服务器。
remote.interpreter.unsupported.python.sdk.type=不受支持的 Python SDK 类型
remote.interpreter.support.is.not.available={0} 支持不可用。\n\
请检查相应插件。
remote.interpreter.remote.server.permissions=无法浏览远程服务器。请确保您具备权限。

# CommandLine
commandLine.inspection.name=命令行检查
commandLine.inspection.badCommand=命令错误或未知。确保此命令真正存在。
commandLine.inspection.badOption=选项错误或未知。确保此选项真正存在。
commandLine.inspection.badArgument=参数不能具有此值。使用自动补全检查可能值的列表。
commandLine.inspection.excessArgument=参数过多或此处无法使用参数
# What to display if argument is available here, but no name provided
commandLine.argumentHint.defaultName=参数
# What to display of user entered junk
commandLine.commandNotFound={0}：找不到命令

# Window with actions
# "X" button title
windowWithActions.closeWindow=关闭窗口
# "Stop" button title
windowWithActions.stopProcess=停止当前运行的进程

formatter.imports.panel.title=导入
formatter.imports.panel.optimize.imports=优化导入
formatter.imports.panel.sort.imports=对导入语句排序
formatter.imports.panel.sort.names.in.from.imports=对 "from" 导入中的导入名称排序
formatter.imports.panel.from.imports.structure.title="from" 导入结构
formatter.imports.panel.from.imports.leave.as.is=保持原样
formatter.imports.panel.from.imports.join.with.same.source=使用相同的源联接导入
formatter.imports.panel.from.imports.always.split=始终拆分导入
formatter.imports.panel.sort.by.type=在组中分别对 plain 导入和 "from" 导入进行排序
formatter.imports.panel.sort.case.insensitively=不区分大小写排序

formatter.panel.dict.alignment.label=字典对齐：
formatter.panel.add.trailing.line.feed=在文件末尾添加换行

formatter.panel.use.continuation.indent.for.title=为此内容使用继续缩进
formatter.panel.use.continuation.indent.for.arguments=方法调用参数
formatter.panel.use.continuation.indent.for.collection.literals=集合和推导

formatter.left.bracket = 左中括号
formatter.around.eq.in.named.parameter = 在命名参数中的 \= 周围 
formatter.around.eq.in.keyword.argument = 在关键字参数中的 \= 周围
formatter.braces = 大括号
formatter.before.backslash = '\' 之前
formatter.before.hash = '\#' 之前
formatter.after.hash = '\#' 之后
formatter.around.top.level.imports = 在顶层导入后：
formatter.after.local.imports=在本地导入后面：
formatter.before.first.method=在第一个方法前面：
formatter.around.top.level.classes.and.function=围绕顶层类和函数：
formatter.around.multiplicative.operators=乘法运算符 (*, @, /, %)
formatter.around.power.operator=幂运算符 (**)
formatter.single.clause.statements=单子句语句
formatter.multi.clause.statements=多子句语句
formatter.force.new.line.after.colon=在冒号后强制使用新行
formatter.align.when.multiline=多行时对齐
formatter.collections.and.comprehensions=集合和推导
formatter.from.import.statements="From" 导入语句
formatter.from.import.statements.force.parentheses.if.multiline=如有多行，强制使用括号
formatter.from.import.statements.force.comma.if.multline=如有多行，强制使用尾随逗号
formatter.dictionary.literals=字典文字
formatter.hang.closing.brackets=挂起右中括号

smartKeys.insert.backslash.in.statement.on.enter=在语句内按 Enter 时插入反斜杠
smartKeys.insert.self.in.method=定义方法时插入 'self'
smartKeys.insert.type.placeholder.in.docstring.stub=在文档注释存根中插入类型占位符

show.expression.type.no.expression.found=未找到表达式
runcfg.labels.module=模块\:
remote.interpreter.wsl.default.interpreter.path=/usr/bin/python
remote.interpreter.failed.to.obtain.credentials=无法获取 Python SDK {0} 的连接凭据

action.SetNextStatement.text=跳转到光标(&J)
action.SetNextStatement.description=跳转到脱字符号所在的行
action.StepIntoMyCode.text=单步执行我的代码
action.StepIntoMyCode.description=跳到已执行的下一行，并忽略库
action.PyConvertPackageToModuleAction.text=转换为 Python 模块
action.PyConvertPackageToModuleAction.description=创建同名模块，并将 __init__.py 的内容移至该模块
action.PyConvertModuleToPackage.text=转换为 Python 包
action.PyConvertModuleToPackage.description=创建同名的包，并将模块内容移至其 __init__.py
action.PyDebugger.ViewAsGroup.text=作为...查看
action.PyDebugger.ViewArray.text=作为数组查看
action.PythonGenerateDictionaries.text=生成 Python 拼写检查器字典
group.PyPackagingMenu.text=打包
action.CleanPyc.text=清除 Python 编译文件
action.CleanPyc.description=删除所选目录及其子目录中已编译的字节码文件
action.PySyncPythonRequirements.text=同步 Python 要求...
action.PySyncPythonRequirements.description=同步 Python 要求文件与项目中使用的包
action.CompuleQrc.text=编译 .qrc 文件
action.NewPythonPackage.text=Python 包
action.NewPythonPackage.description=在其中创建新目录和 __init__.py
action.PyConsoleRenameAction.text=重命名控制台
action.ExecuteInPyConsoleAction.text=在控制台中执行所选内容
action.ExecuteInPyConsoleAction.description=在 Python/Django 控制台中执行选定的代码片段
action.com.jetbrains.python.console.RunPythonOrDebugConsoleAction.text=Python 或调试控制台
action.com.jetbrains.python.console.RunPythonOrDebugConsoleAction.description=允许在运行调试会话时快速运行 Python 控制台或调试控制台
action.ForceStepInto.text=强制单步执行 (_R)
action.ForceStepInto.description=步入，忽略库，构造器等的步进过滤器。
configurable.Tab.display.name=Buildout
configurable.PyConsoleOptionsConfigurable.display.name=控制台
configurable.PyConsoleOptionsConfigurable.child.display.name=Python 控制台
configurable.BuildoutConfigurable.display.name=Buildout
configurable.BuildoutModulesConfigurable.display.name=Buildout 支持
configurable.PySmartKeysOptions.display.name=Python
configurable.PyContentEntriesModuleConfigurable.display.name=项目结构
configurable.PythonContentEntriesConfigurable.display.name=项目结构
configurable.PyDependenciesConfigurable.display.name=项目依赖项
configurable.PyIntegratedToolsConfigurable.display.name=Python 集成工具
configurable.PyIntegratedToolsModulesConfigurable.display.name=Python 集成工具
configurable.PythonSdkEditorTab.display.name=Python SDK
configurable.PyDebuggerConfigurable.display.name=Python 调试器
configurable.PyActiveSdkModuleConfigurable.python.interpreter.display.name=Python 解释器
flask.name=Flask
settings.default.remote.interpreter=默认 Python 远程解释器
action.DumbAware.PydevConsoleRunnerImpl.text.stop.console=停止控制台
action.DumbAware.PydevConsoleRunnerImpl.description.stop.python.console=停止 Python 控制台
action.DumbAware.ConcurrencyToolWindowPanel.text.stop.process=停止进程
action.DumbAware.ConcurrencyToolWindowPanel.description.stop.process=停止进程
action.AnActionButton.text.use.conda.package.manager=使用 Conda 包管理器
action.AnActionButton.text.show.early.releases=显示早期版本
action.PyManagePackages.text=管理 Python 包...
action.RunPythonToolwindowAction.text=Python 控制台

# qt actions
qt.error.failed.run.qt.designer=无法运行 Qt 设计器：{0}
qt.qrc.compiler.select.output.path=选择输出目录\:
qt.qrc.compile.files=编译 {0} .Qrc 文件
qt.qrc.compile=编译 {0}
qt.compile.qrc.file=编译 .Qrc 文件
qt.run.error=运行 {0} 出错：{1}
qt.cannot.find.pyrcc4.or.pysidercc=找不到所选 Python 解释器的 pyrcc4 或 pyside-rcc
qt.run.designer.error=错误

python.module.name=Python 模块
python.module.description=Python 模块用于开发 <b>Python</b> 应用程序。
python.module.description.extended=支持的技术包括 <b>Django、Google App Engine、Mako、Jinja2</b> 等等。

action.create.python.file.title=Python 文件
action.create.python.file.description=从指定的模板创建 Python 文件
acton.run.file.in.python.console.title=运行 Python 控制台中的文件
action.run.file.in.python.console.description=运行 Python 控制台中的当前文件
action.cleaning.up.pyc.files=正在清理 .Pyc 文件...

buildout.facet.title=Buildout 支持
buildout.configurable.choose.a.buildout.script=选择 Buildout 脚本
buildout.configurable.select.the.target.script=选择将调用代码的目标脚本
buildout.color.comment=注释
buildout.color.key.value.separator=键值分隔符
buildout.color.value=值
buildout.color.key=键
buildout.color.section.name=节名
buildout.config=Buildout 配置
buildout.config.language=Buildout 配置
buildout.config.script.name.validation.error.message=请指定 Buildout 脚本
buildout.config.script.file.invalid.message=无效脚本文件 ''{0}''

code.insight.select.methods.to.override=选择要重写的方法
code.insight.select.methods.to.implement=选择实现的方法
code.insight.stub.package.advertiser.notifications.group.title=Python 存根包广播程序
code.insight.create.test=创建测试
code.insight.select.target.directory=选择目标目录
code.insight.encoding.comment.format=编码注释格式：
code.insight.select.default.encoding=选择默认编码： 
code.insight.stub.forced.packages.are.not.installed.message=存根{0,choice,1\#包|2\#包} {1} {0,choice,1\#未|2\#未}安装。{0,choice,1\#它|2\#它们}{0,choice,1\#包含|2\#包含}提升代码洞察所需的类型提示。
code.insight.stub.checked.packages.are.not.installed.message=存根{0,choice,1\#包|2\#包} {1} {0,choice,1\#未|2\#未}安装。
code.insight.stub.packages.ignored.notification.content=建议的 {0} {1,choice,1\#与|2\#与}您的当前环境不兼容。\n\
{1,choice,1\#此|2\#这些}存根{1,choice,1\#包|2\#包}将被移除和忽略，直到新版本发布。
code.insight.stub.packages.install.requirements.fix.name=安装存根{0,choice,1\#包|2\#包}
code.insight.type.hints.are.not.installed=未安装类型提示
code.insight.install.type.hints.content=它们可以使代码洞察更出色。
code.insight.install.type.hints.action=安装存根包
code.insight.ignore.type.hints=忽略更改
code.insight.ignore.packages.qfix=忽略 {0,choice, 1\# 个包|2\# 个包}
configurable.pipenv.auto.detected=已自动检测：{0}
configurable.choose.path.to.the.package.requirements.file=选择包需求文件的路径：
configurable.choose.working.directory=请选择工作目录：
configurable.select.working.directory=选择工作目录

console.waiting.execution.result=正在等待执行结果
console.getting.from.runtime=正在从 Python 运行时获取{0}
console.getting.completion=补全
console.getting.documentation=文档
console.getting.frame.variables=框架变量
console.getting.variable.value=变量值
console.getting.array=数组
console.evaluating.expression.in.console=正在控制台中评估表达式
console.connecting.to.debugger=连接到调试器
console.changing.variable=正在更改变量
console.interrupting.execution=正在中断执行
console.close.console.communication=关闭控制台通信
console.executing.code.in.console=正在执行控制台中的代码...
console.new.console.description=创建新的 python 控制台
console.new.console=新建控制台
console.error.connecting.debugger=连接调试器出错
console.cannot.connect.to.debugger=无法连接到调试器
console.attach.debugger.description=对控制台中执行的代码启用追踪
console.attach.debugger=附加调试器
console.restarting.console=正在重启控制台
console.stopping.console=正在停止控制台
console.command.executor=Python 控制台命令执行器
connecting.to.console.progress=正在连接控制台...
connecting.to.console.title=连接控制台
console.show.variables.title=显示变量
console.show.variables.description=显示活动控制台变量

form.debugger.save.call.signatures=保存调用签名

compile.cython.extensions.title=编译 Cython 扩展
compile.cython.extensions.help=工作原理
compile.cython.extensions.install=安装
compile.cython.extensions.notification=Python 调试器扩展可用

create.python.file.action.new.python.file=新建 Python 文件
create.python.file.action.python.file=Python 文件
create.python.file.action.python.unit.test=Python 单元测试
create.python.file.action.python.stub=Python 存根
create.python.file.script.action=创建 Python 脚本 {0}

debugger.attach.to.process.filter.names=<html>为<b>附加到进程</b>显示名称中包含这些内容的进程：</html>
debugger.watch.return.values.description=启用监视，以查看所执行函数返回的值
debugger.exception.breakpoint.ignore.library.files=忽略库文件
debugger.exception.breakpoint.on.raise=引发时
debugger.exception.breakpoint.on.termination=终止时
debugger.exception.breakpoint.type=Python 异常断点
debugger.exception.breakpoint.activation.policy=激活策略
debugger.delete.signature.cache=删除缓存
debugger.cleaning.signature.cache=清理动态收集类型的缓存
debugger.simplified.view.description=禁用监视类、函数和模块对象
debugger.simplified.view.text=简化变量视图
debugger.data.view.colored=已着色
debugger.data.view.close.selected.viewer=关闭所选查看器
debugger.data.view.close.viewer=关闭查看器
debugger.data.view.open.new.container.viewer=打开新容器查看器
debugger.data.view.view.new.container=查看新容器
debugger.data.view.data=数据
debugger.data.view.close=关闭
debugger.data.view.resize.automatically=自动调整大小
debugger.data.view.colored.cells=已着色单元
debugger.numeric.view.as.dataframe=作为 DataFrame 查看
debugger.numeric.view.as.array=作为数组查看
debugger.numeric.view.as.series=作为系列查看
debugger.stepping.filter=步进筛选器
debugger.stepping.filter.specify.pattern=指定 glob 模式（允许使用 '*'、'?' 和 '[seq]'，分号 ';' 用作名称分隔符）：
debugger.stepping.no.script.filters=未配置脚本筛选器
debugger.sending.close.message=正在向 Python 控制台发送关闭消息...
debugger.waiting.to.finish=正在等待 Python 控制台进程结束...
debugger.variables.loading.policy=变量加载策略
debugger.variables.loading.synchronously.text=同步
debugger.variables.loading.synchronously.description=同步加载变量值
debugger.variables.loading.asynchronously.text=异步
debugger.variables.loading.asynchronously.description=异步加载变量值
debugger.variables.loading.on.demand.text=按需
debugger.variables.loading.on.demand.description=按需加载变量值
debugger.variables.view.loading.timed.out=加载超时
debugger.variables.view.switch.to.loading.on.demand=切换为按需加载
debugger.variables.view.warning.message=无法加载多个变量的值  
debugger.exception.breakpoint.select.exception.class=选择异常类
debugger.watch.show.return.values=显示返回值
debugger.data.view.connected.to.python.console=已连接到 Python 控制台
debugger.data.view.connected.to.debug.session=已连接到调试会话 ''{0}''
debugger.data.view.empty.text=运行 Python 控制台或调试器以查看可用数据
debugger.stack.frame.special.variables=特殊变量
debugger.stack.frame.return.values=返回值
debugger.test.failed.caption=测试失败
debugger.error.in.test.setup.or.teardown.caption=设置或删除测试时出错

pydev.console.runner.settings=设置
pydev.console.runner.error.running.console=运行控制台出错
pydev.console.runner.python.console.debugger=Python 控制台调试器
pydev.console.runner.unknown.error=未知错误
pydev.console.console.process.terminated.with.error=控制台进程因错误而终止：\n\
{0}{1}
pydev.console.console.process.terminated.with.exit.code=控制台进程终止，退出代码为 {0}，输出：{1}
pydev.console.couldnt.connect.to.console.process=无法连接到控制台进程。
pydev.console.debugger.connected=\n\
调试器已连接。\n\

pydev.console.couldnt.read.integer.value.from.stream=无法读取流中的整数值
pydev.console.python.interpreter.is.not.selected=未选择 Python 解释器。请先安装 Python 解释器。

external.documentation.python.plugin=Python 外部文档
external.documentation.pycharm=外部文档
external.documentation.edit.documentation.url=编辑文档 URL
external.documentation.title=Python 外部文档
external.documentation.configure.description=模块 {0} 未配置外部文档 URL。\n\
现在要配置吗？


python.colors.python=Python
python.colors.type.annotation=类型注解
python.colors.class.definition=类定义
python.colors.decorator=装饰器
python.colors.built.in.name=内置名称
python.colors.special.names.usage=特殊名称//用法
python.colors.special.names.definition=特殊名称//定义
python.colors.keyword.argument=关键字参数
python.colors.parameters.self.parameter=参数//'self' 参数
python.colors.parameters.parameter=参数//参数
python.colors.functions.method.call=函数//方法调用
python.colors.functions.function.call=函数//函数调用
python.colors.functions.function.definition=函数//函数定义
python.colors.braces.and.operators.dot=大括号和运算符//圆点
python.colors.braces.and.operators.comma=大括号和操作符//逗号
python.colors.braces.and.operators.braces=括号和运算符//花括号
python.colors.braces.and.operators.brackets=大括号和操作符//中括号
python.colors.braces.and.operators.parentheses=大括号和运算符//括号
python.colors.braces.and.operators.operation.sign=大括号和操作符//操作符号
python.colors.docstring.tag=文档字符串//标签
python.colors.docstring.text=文档字符串//文本
python.colors.string.f.string.format.specifier.start=字符串//格式化字符串//格式说明符开始
python.colors.string.f.string.type.conversion=字符串//格式化字符串///类型转换
python.colors.string.f.string.expression.braces=字符串//格式化字符串///表达式大括号
python.colors.string.escape.sequence.invalid=字符串//转义序列//无效
python.colors.string.escape.sequence.valid=字符串//转义序列//有效
python.colors.string.text.unicode=字符串//文本 (unicode)
python.colors.string.binary.bytes=字符串//二进制（字节）
python.colors.line.comment=行注释
python.colors.keyword=关键字
python.colors.number=数字

python.new.project.synchronization.not.configured=未配置同步
python.new.project.remote.path.not.provided=未提供远程路径
python.new.project.more.settings=更多设置(&E)
python.new.project.install.failed.title=安装 {0} 失败

python.project.view.remote.libraries=远程库
python.project.view.py.skeletons=二进制框架
python.project.view.typeshed.stubs=Typeshed 存根
python.project.view.user.skeletons.node=扩展定义

python.packaging.installing.packaging.tools=正在安装打包工具...
python.packaging.installing.packages=正在安装包...
python.packaging.warning=警告
python.packaging.create.setup.py=创建 setup.py
python.packaging.failed.to.run.task=无法运行任务：{0}
python.packaging.run.setup.py.task=运行 setup.py 任务...
python.packaging.expand.options=展开选项 >>
python.packaging.collapse.options=<< 折叠选项
python.packaging.run.setup.task.0=运行安装任务 {0}
python.packaging.command.line=命令行
python.packaging.install=安装
python.packaging.choose.packages.to.install=选择要安装的包
python.packaging.removing.conda.channel=移除 Conda 通道
python.packaging.adding.conda.channel=添加 Conda 通道
python.packaging.failed.to.install.packaging.tools.title=无法安装 Python 打包工具

# Example of produced message:
#    You are attempting to uninstall MarkupSafe package which is required for Jinja2 package
#
#    Do you want to proceed?
python.packaging.dialog.description.attempt.to.uninstall.for.one.dependent.package.single.package.description={1} 所需的 {0} 包
python.packaging.dialog.description.attempt.to.uninstall.for.one.dependent.package=您将要卸载 {0} {1, choice, 1\#包|2\#包}\n\
\n\
是否继续?

# Example of produced message:
#    You are attempting to uninstall packages which are required for another packages.
#
#    Jinja2 -> Flask
#    muffin -> muffin-jinja2
#
#    Do you want to proceed?
python.packaging.dialog.description.attempt.to.uninstall.for.several.dependent.packages.single.package.description={0} -> {1}
python.packaging.dialog.description.attempt.to.uninstall.for.several.dependent.packages=您将要卸载其他包所需的包。\n\
\n\
{0}\n\
\n\
是否继续?

python.packaging.notification.description.details.link=详细信息…
python.packaging.notification.description.installed.all.requirements=已安装所有要求
python.packaging.notification.description.installed.packages=已安装包\: {0}
python.packaging.notification.description.installed.python.packaging.tools=已安装 Python 打包工具
python.packaging.notification.description.uninstalled.packages=已卸载包\: {0}
python.packaging.notification.title.error.occurred={0}\: 发生错误。
python.packaging.notification.title.install.packages.failed=安装包失败
python.packaging.notification.title.packages.installed.successfully=已成功安装包
python.packaging.notification.title.packages.uninstalled.successfully=已成功卸载包
python.packaging.notification.title.uninstall.packages.failed=卸载包失败
python.packaging.progress.text.installing.specific.package=正在安装包 ''{0}''…
python.packaging.progress.title.installing.packages=正在安装包
python.packaging.progress.title.uninstalling.packages=正在卸载包

python.unresolved.reference.inspection.install.package=安装包 {0}

# UI forms

form.qt.compile.qrc.output.file=输出文件：
form.buildout.config.set.to.buildout.dir.bin.django.py.for.proper.django.support=设置为 <buildout-dir>/bin/django.py 以获取适当的 Django 支持 
form.buildout.config.use.paths.from.script=使用脚本中的路径(&S)\: 
form.auto.import.from.module.import.name=从 <module> 导入 <name>
form.auto.import.import.module.name=导入 <module>.<name>
form.auto.import.preferred.import.style=首选的导入样式：
form.auto.import.python=Python
form.auto.import.auto.import.show.popup=显示导入弹出窗口
form.create.test.target.directory=目标目录
form.create.test.test.class.name=测试类名
form.create.test.test.file.name=测试文件名
form.edit.sdk.associate.this.virtual.environment.with.current.project=关联此虚拟环境与当前项目(&A)
form.edit.sdk.interpreter.path=解释器路径(&I)\:
form.edit.sdk.label.create.connection.pool.options.name=名称(&N)\:
form.edit.sdk.html.href.remove.association=<html><a href\=\"\#\">移除关联</a>
form.edit.smart.indent.pasted.lines=智能缩进粘贴行
form.integrated.tools.analyze.python.code.in.docstrings=分析文档字符串中的 Python 代码
form.integrated.tools.default.test.runner=默认测试运行程序：
form.integrated.tools.docstring.format=文档字符串格式：
form.integrated.tools.package.requirements.file=包需求文件：
form.integrated.tools.path.to.pipenv.executable=Pipenv 可执行文件路径：
form.integrated.tools.render.external.documentation.for.stdlib=渲染 stdlib 的外部文档
form.integrated.tools.sphinx.working.directory=Sphinx 工作目录：
form.integrated.tools.treat.txt.files.as.restructuredtext=将 *.txt 文件视为 reStructuredText
form.console.options.always.show.debug.console=始终显示调试控制台
form.console.options.settings.title.system.settings=常规设置
form.console.options.show.console.variables.by.default=默认显示控制台变量
form.console.options.use.existing.console.for.run.with.python.console=为“通过 Python 控制台运行”使用现有控制台
form.console.options.use.ipython.if.available=使用 IPython（如有）
form.console.specific.options.starting.script=正在启动脚本
form.debugger.for.attach.to.process.show.processes.with.names.containing=为“附加到进程”显示名称中包含这些内容的进程：
form.debugger.attach.to.subprocess.automatically.while.debugging=调试时自动附加到子进程
form.debugger.clear.caches=清除缓存
form.debugger.clear.caches.action=清除缓存
form.debugger.collect.run.time.types.information.for.code.insight=收集运行时类型信息以获取代码洞察
form.debugger.gevent.compatible=Gevent 兼容
form.debugger.drop.into.debugger.on.failed.tests=在失败的测试中放入调试器
form.debugger.pyqt.compatible=PyQt 兼容
form.debugger.remote.interpreter.docker.default.interpreter.path=python
form.data.viewer.current.slice=当前切片。
form.data.viewer.dialog.show.svn.map.table.header.column.format.title=格式
form.data.viewer.format=格式\:
form.debugger.stepping.checkbox.text.do.not.step.into.library.scripts=不要单步执行库脚本
form.debugger.stepping.do.not.step.into.scripts=不单步执行脚本\:
form.debugger.stepping.always.do.smart.step.into=始终进行智能单步执行
form.documentation.entry.insert=插入(&I)
form.documentation.entry.module.name=模块名称 (&M)：
form.documentation.entry.url.path.pattern=URL/路径模式 (U)：
form.documentation.entry.available.macros=可用的宏
form.remote.path.remote.project.location=远程项目位置：
form.introduce.name=名称(&N)\:
form.introduce.field.initialize.in=初始化在(&I)
form.move.module.members.from=从\:
form.move.module.members.to=到\:
form.python.run.configuration.emulate.terminal.in.output.console=模拟输出控制台中的终端
form.python.run.configuration.redirect.input.from=重定向输入自\:
form.python.run.configuration.run.with.python.console=使用 Python 控制台运行
form.test.shared.target=目标\:
form.test.shared.test=测试
form.test.run.configuration.params=参数\:
form.test.run.configuration.specify.nosetests.command.line.options=指定 nosetest 命令行选项
form.test.run.configuration.unittest=Unittest
form.pytest.legacy.path.to.a.file.or.directory.that.contains.the.tests.to.be.executed=包含待执行测试的文件或目录的路径
form.pytest.legacy.py.tests=py.tests
form.pytest.legacy.specify.py.tests.command.line.options=指定 py.tests 命令行选项
form.pytest.legacy.specify.the.keywords.to.search.for.the.required.tests.k.command.line.option.in.py.tests=指定要为所需测试搜索的关键字。py.tests 中的 -k 命令行选项
form.tox.configuration.arguments=参数
form.tox.configuration.run.only.environment=仅运行环境
form.tox.configuration.runcfg.tox=tox
py.module.dependencies.configurable.list.title=项目取决于这些项目：
py.sdk.editor.python.interpreter.label.text=Python 解释器：
# Python reStructuredText forms
rest.configuration.editor.open.output.file.in.browser.label.text=在浏览器中打开输出文件
sphinx.ask.for.working.directory.label.text=Sphinx 工作目录



pure.python.project=纯 Python
project.cannot.be.generated=无法生成项目
error.in.project.generation=项目生成出错

sdk.has.been.configured.as.the.project.interpreter={0} 已配置为项目解释器
configure.python.interpreter=配置 Python 解释器...
configuring.python.interpreter=正在配置 Python 解释器
configuring.interpreters.link=<html><a href\="\#">配置解释器
looking.for.previous.interpreter=正在查找以前用过的解释器
looking.for.related.venv=正在查找与项目相关的虚拟环境
looking.for.pipfile=正在查找 Pipfile
install.packages.from.pipfile=安装 Pipfile 中的包
looking.for.default.interpreter=正在查找新项目的默认解释器设置
looking.for.previous.system.interpreter=正在查找以前用过的系统级解释器
looking.for.system.interpreter=正在查找系统级解释器
looking.for.shared.conda.environment=正在查找共享的 Conda 环境
current.interpreter=当前解释器：{0}
switch.python.interpreter=切换 Python 解释器
python.facet.name=Python
choose.packages.to.install=选择要安装的包：
manage.python.packages=管理 Python 包
interpreter=解释器：
base.interpreter=基本解释器：
available.to.all.projects=可用于所有项目


framework.support.python.sdk.combobox.label=Python SDK\:
integrated.tools.configurable.docstrings=文档字符串
integrated.tools.configurable.restructuredtext=reStructuredText
integrated.tools.configurable.packaging=打包
integrated.tools.configurable.testing=测试
integrated.tools.configurable.pipenv=Pipenv
command.line.parser.error.message=参数与其值之间的空格异常

python.package.installation.notification.message={0} 将安装在选定的解释器上
python.package.and.packaging.tools.installation.notification.message=Python 打包工具和 {0} 将安装在选定的解释器上

python.execute.selection.action.execute.selection.in.console=执行 Python 控制台中的选定内容
python.execute.selection.action.execute.line.in.console=执行 Python 控制台中的代码行

python.add.sdk.panel.name.conda.environment=Conda 环境
python.add.sdk.panel.name.existing.environment=现有环境
python.add.sdk.panel.name.existing.interpreter=现有解释器
python.add.sdk.panel.name.new.environment.using=使用此工具新建环境
python.add.sdk.panel.name.new.environment=新环境
python.add.sdk.panel.name.new.project.interpreter=新项目解释器
python.add.sdk.panel.name.pipenv.environment=Pipenv 环境
python.add.sdk.panel.name.system.interpreter=系统解释器
python.add.sdk.panel.name.virtualenv.environment=Virtualenv 环境

python.requirements.version.label=需求版本：
python.requirements.version.separator.no.version=不指定版本
python.requirements.version.separator.strong.eq=强相等
python.requirements.version.separator.gte=大于或等于
python.requirements.version.separator.compatible=兼容版本
python.requirements.remove.unused=移除未使用的需求
python.requirements.modify.base.files=修改基本文件（使用 -r 或 --requirement 定义的文件）
python.requirements.keep.matching.specifier=如果现有版本与当前版本相匹配，则保留现有版本说明符
python.requirements.analyzing.imports.title=正在分析项目中的导入
python.requirements.action.name=同步 Python 需求
python.requirements.error.ends.with.slash=解析需求出错：文件以 '/' 符号结尾。
python.requirements.error.no.packages=检索包列表时出错。
python.requirements.error.no.interpreter=已配置同步需求所需的解释器。
python.requirements.warning.unhandled.lines=无法分析需求文件中的条目：{0}
python.requirements.info.file.ref.dropped=基本文件中的某些需求未更新：{0}
python.requirements.balloon=同步 Python 需求

toolwindow.stripe.SciView=SciView
toolwindow.stripe.Python_Console=Python 控制台
python.long.string.literals=长字符串文字
python.long.collection.literals=长集合文字
python.sequential.comments=顺序注释
python.provide.a.qualified.name.of.a.module=提供模块的限定名称
python.input.file.doesn.t.exist=输入文件不存在
python.call.graph=调用图
python.select.locale=选择区域设置
python.locales=区域设置
python.buildout.failed.to.extract.path=无法从 {0} 提取路径
python.debugger.collection.signatures.deleted=收集的签名已被删除
python.debugger.nothing.to.delete=没有要删除的内容
python.rename.processor.override.message=类 {1} 的方法 {0}\n\
重写了类 {2} 的方法。\n\
要重命名基方法吗?
python.rename.processor.property=是否要重命名属性 ''{0}'' 而不是其访问器函数 ''{1}''?
python.configuration.choose.target.to.run=选择要运行的目标
python.vagrant.refresh.skeletons=启动 vagrant 并刷新框架
python.concurrency.visualizer.scroll.end=滚动到结尾
python.execute.cell.in.console=在控制台中执行单元
python.template.select.file.type=选择文件类型
python.execution.is.still.running=上一个执行仍在运行

INSP.settings.pep8.ignore.errors=忽略错误
INSP.settings.bdd.behave.specific=BDD 行为特定的检查
INSP.settings.bdd.step.definition.arguments=BDD 步骤定义参数检查

python.compatibility.inspection.advertiser.notifications.group.title=Python 兼容性检查广播程序
python.compatibility.inspection.advertiser.notifications.title=Python 版本兼容性

python.compatibility.inspection.advertiser.using.future.imports.warning.message=您的源代码包含 __future__ 导入。<br/>要启用代码兼容性检查吗?<br/><a href\="\#yes">是</a>\\&nbsp;\\&nbsp;<a href\="\#no">否</a>

python.compatibility.inspection.advertiser.using.six.warning.message=您的源代码导入了 'six' 包。<br/>要启用代码兼容性检查吗?<br/><a href\="\#yes">是</a>\\&nbsp;\\&nbsp;<a href\="\#no">否</a>

# Both placeholders are Python versions like 2.7, 3.7, etc.
python.compatibility.inspection.advertiser.version.stale.python3.version.warning.message=已为最高 {0} 的 Python 版本配置了代码兼容性检查。<br/>要为 Python {1} 启用吗?<br/><a href\="\#yes">是</a>\\&nbsp;\\&nbsp;<a href\="\#no">否</a>

python.install.framework.ensure.installed=正在确保 {0} 已安装
python.install.framework.checking.is.installed=正在检查 {0} 是否安装…
python.install.framework.installing=正在安装 {0}...
py.commandline.configure=为项目配置 Python SDK