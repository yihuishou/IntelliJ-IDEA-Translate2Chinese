#
# Copyright 2000-2006 JetBrains s.r.o.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#config
google.web.toolkit.title=Google Web 工具包

#module
module.descriptor=GWT 应用程序的模板

#actions
dialog.title.google.web.toolkit=Google Web 工具包
error.class.not.found.in.jar=在 ''{1}'' 中找不到类 ''{0}''
error.file.not.found.message=文件 ''{0}'' 不存在
error.invalid.gwt.installation.message=''{0}'' 不是有效的 GWT 安装\: {1}
error.message.path.to.gwt.sdk.must.not.contain.character=GWT SDK 路径不得包含 '\!' 字符
fix.download.gwt=下载 GWT...

new.service.menu.action.text=GWT RemoteService
new.service.menu.action.description=创建新的 GWT RemoteService
new.service.dlg.prompt=输入新 GWT RemoteService 的名称
new.service.dlg.title=新 GWT RemoteService
new.service.progress.text=创建 GWT 远程服务 ''{0}''

new.serial.dlg.prompt=创建新的 GWT 可序列化类的名称
new.serial.dlg.title=新的 GWT 可序列化类
new.serial.menu.action.text=新的 GWT 可序列化类
new.serial.menu.action.description=创建新的 GWT 可序列化类
new.serial.progress.text=创建 GWT 可序列化类 ''{0}''

new.module.dlg.prompt=输入新 GWT 模块的名称(&E)
new.module.dlg.title=新 GWT 模块
new.module.menu.action.text=GWT 模块
new.module.menu.action.description=创建新的 GWT 模块
new.module.progress.text=创建 GWT 模块 ''{0}''

new.entry.point.dlg.prompt=输入新 GWT EntryPoint 的名称
new.entry.point.dlg.title=新 GWT EntryPoint
new.entry.point.menu.action.text=GWT EntryPoint
new.entry.point.menu.action.description=创建新的 GWT EntryPoint
new.entry.point.progress.text=创建 GWT 入口点 ''{0}''


problem.description.unknown.css.class=未知 CSS 类 ''{0}''
quickfix.name.create.css.class.0=创建 CSS 类 ''{0}''
quickfix.family.name.create.css.class=创建 CSS 类
quickfix.name.create.local.css.class.0=创建局部 CSS 类 ''{0}''
quickfix.family.name.create.local.css.class=创建局部 CSS 类
inspection.unresolved.references.to.css.classes.display.name=对 CSS 类的引用未解析
group.gwt.inspections.name=Google Web 工具包
css.usages.variable=变量

problem.description.methods.of.async.remote.service.0.isn.t.synchronized.with.1=异步远程服务 ''{0}'' 的方法与 ''{1}'' 不一致
problem.description.remote.service.0.does.not.have.corresponding.async.variant=远程服务 ''{0}'' 没有相应的异步变体
problem.description.async.remote.service.0.does.not.define.corresponding.method=异步远程服务 ''{0}'' 未定义相应的方法
inspection.name.inconsistent.gwt.remote.service=不一致的 GWT 远程服务
quick.fix.name.synchronize.all.methods.of.0.with.1=将 ''{0}'' 的所有方法与 ''{1}'' 同步
quickfix.name.create.async.method.for.sync.0=为方法 ''{0}'' 创建异步变体
quickfix.family.name.create.async.variant=创建异步变体
problem.description.async.method.does.not.have.sync.variant=方法 ''{0}'' 没有相应的同步变体
quickfix.name.create.sync.method.for.async.0=为方法 ''{0}'' 创建同步变体
quickfix.family.name.create.sync.variant=创建同步变体
problem.description.the.asynchronous.version.of.method.0.must.have.a.return.type.void=方法 ''{0}'' 的异步版本必须具有返回类型 ''void''、\n''com.google.gwt.http.client.Request'' 或 ''com.google.gwt.http.client.RequestBuilder''
quickfix.name.make.0.return.void=令 ''{0}'' 返回 ''void''
quickfix.family.name.make.method.return.void=令方法返回 'void'

problem.description.type.is.not.serializable=类型 ''{0}'' 不可序列化
problem.description.type.of.collection.elements.is.not.specified=未指定 ''{0}'' 元素的类型
problem.description.gwt.serializable.type.0.should.implements.marker.interface.1=类型 ''{0}'' 未实现标记接口 {1}
text.0.or.1=''{0}'' 或 ''{1}''
problem.description.0.is.not.a.checked.exception=''{0}'' 不是检查过的例外
quickfix.name.create.interface.0=创建接口 ‘’{0}''
quickfix.family.name.create.interface=创建接口
inspection.name.non.serializable.service.method.parameters=服务方法的参数类型或返回类型不可序列化
problem.description.generics.isnt.supported.in.gwt.before.1.5.version=1.5 版之前的 GWT 不支持泛型
checkbox.text.report.interfaces=报告接口

label.choose.module.text=模块(&M)\:
run.gwt.configuration.display.name=GWT 配置
run.gwt.configuration.description=GWT 配置
default.gwt.run.configuration.name=未命名
error.text.gwt.facet.not.configured.in.module.0=未为模块 ''{0}'' 配置 GWT Facet
error.text.gwt.sdk.is.not.specified.correctly=在模块 ''{0}'' 的 GWT Facet 设置中未正确指定 GWT SDK 路径
error.text.no.gwt.modules.in.module.0=在 ''{0}'' 中找不到 GWT 模块
question.text.gwt.facet.is.not.configured.for.module.0.do.you.want.to.create.it=没有为模块 ''{0}'' 配置 GWT Facet。是否要创建?

inspection.name.unresolved.references.to.html.tags=对 html 标签的引用未解析
problem.description.html.tag.with.id.0.is.not.found=找不到 ID 为 ''{0}'' 的 HTML 标签
quick.fix.name.rename.reference=重命名引用

inspection.name.classes.not.from.jre.emulation.library.in.client.code=这些类不是来自客户端代码中的 JRE 仿真库
problem.description.class.0.is.not.presented.in.jre.emulation.library=JRE 仿真库中不存在类 ''{0}''，因此不能在 ''{1}'' GWT 模块的客户端代码中使用
problem.description.method.0.is.not.presented.in.jre.emulation.library=JRE 仿真库中不存在方法 ''{0}''，因此不能在 ''{1}'' GWT 模块的客户端代码中使用
problem.description.class.0.is.defined.in.module.1.which.is.not.inherited.in.module.2=类 ''{0}'' 在模块 ''{1}'' 中定义，而该模块在模块 ''{2}'' 中没有继承
quickfix.name.inherit.module.0.from.1=从 ''{1}'' 集成模块 ''{0}''
quickfix.family.name.inherit.module=继承模块

inspection.name.client.class.from.non.inherited.module.usage=客户端类来自于非继承的 GWT 模块用法

inspection.name.gwt.remote.service.is.not.registered.in.web.xml=GWT 远程服务未在 web.xml 中注册
problem.description.remote.service.is.not.registered.as.a.servlet.in.web.xml=远程服务 ''{0}'' 未在 web.xml 中注册为 Servlet。
quickfix.name.register.remote.service.0.in.web.xml=在 ''web.xml'' 中注册远程服务 ''{0}''
quickfix.family.name.register.remote.service.in.web.xml=在 'web.xml' 中注册远程服务
problem.description.correct.servlet.mapping.is.not.specified.for.remote.service.0=没有为远程服务 ''{0}'' 指定正确的 servlet 映射
quickfix.name.add.servlet.mapping.for.remote.service.0=为远程服务 ''{0}'' 添加 servlet 映射
quickfix.family.name.add.servlet.mapping.for.remote.service=添加用于远程服务的 servlet 映射
problem.description.incorrect.servlet.mapping.for.remote.service.0=远程服务 ''{0}'' 的 url 格式不正确
quickfix.name.set.correct.servlet.mapping.for.remote.service.0=为远程服务 ''{0}'' 设置正确的 URL 模式
quickfix.family.name.set.servlet.mapping.for.remote.service=为远程服务设置正确的 url 格式
quickfix.name.create.web.facet.and.register.remote.service.0.in.web.xml=创建 Web facet 并在 ''web.xml'' 中注册远程服务 ''{0}''
quickfix.family.name.create.web.facet.and.register.remote.service.in.web.xml=创建 Web facet 并在 'web.xml' 中注册远程服务
quickfix.name.connect.gwt.facet.to.0.facet.and.register.remote.service.1.in.web.xml=将 GWT facet 连接到 ''{0}'' facet，并在 ''web.xml'' 中注册远程服务 ''{1}''
quickfix.family.name.connect.gwt.facet.and.register.remote.service.in.web.xml=连接 GWT facet 并在 'web.xml' 中注册远程服务

file.template.group.title.gwt=Google Web 工具包

action.group.gwt.title=Google Web 工具包
action.group.gwt.description=Google Web 工具包

label.text.path.to.gwt.installation=GWT 安装目录路径(&P)\:
gwt.installation.chooser.title=GWT 安装目录路径
gwt.installation.chooser.description=请指定 GWT 安装目录的路径
error.message.gwt.user.jar.library.not.found.in.dependencies.of.module=在模块的依赖项中找不到 gwt-user.jar 库
error.message.gwt.user.jar.in.library.0.does.not.correspond.to.selected.gwt.installation=库 ''{0}'' 中的 gwt-user.jar 与所选的 GWT 安装不相符
label.select.script.output.style.text=JavaScript 输出样式(&O)\:
label.select.web.facet.text=目标 Web Facet(&W)\:
label.text.gwt.compiler.heap.size=编译器最大堆大小 (Mb)(&H)\:
table.column.name.gwt.module=GWT 模块
table.column.name.output.relative.path=输出相对路径
label.text.additional.compiler.parameters=附加编译器 VM 选项(&A)\:
label.text.gwt.compiler.parameters=编译器参数(&C)\:
label.html.to.open.text=起始页面(&P)\:
dialog.caption.vm.parameters=VM 选项
label.text.vm.parameters=虚拟机选项(&V)\:
label.text.gwt.dev.mode.parameters=开发模式参数(&D)\:
dialog.caption.gwt.dev.mode.parameters=GWT 开发模式参数
checkbox.text.use.custom.web.xml=使用自定义 'web.xml' 描述符的内容(&W)
choose.text.select.gwt.module=选择 GWT 模块\: 
dialog.title.choose.gwt.module=GWT 模块
label.text.gwt.module.to.load=要加载的 GWT 模块(&G)\:
text.gwt.modules.to.load.all=所有
text.gwt.modules.to.load.none=无

i18n.interface.method.gutter.tooltip=<html><body>方法在 {0} {0, choice, 1\#个文件|2\#个文件}中有关联的属性
i18n.goto.property.popup.title=<html><body>选择 <b>{0}</b> 的本地化(找到 {1} 个文件)</body></html>
i18n.class.gutter.tooltip.text=类有 {0} 个关联的属性 {0, choice, 1\#文件|2\#文件}

inspection.name.inconsistent.gwt.localizable.interface=不一致的 GWT 本地化接口
problem.description.property.0.does.not.have.corresponding.method.in.1=属性 ''{0}'' 在 ''{1}'' 中没有对应的方法
quickfix.name.create.method.for.property.0.in.1=为 ''{1}'' 中的属性 ''{0}'' 创建方法
quickfix.name.synchronize.all.methods.in.0=将所有缺少的方法添加到 ''{0}'' 
quickfix.family.name.create.missing.methods=创建缺少的方法
problem.description.method.0.does.not.have.corresponding.property=方法 ''{0}'' 没有相应的属性
quickfix.name.create.property.0=创建属性 ''{0}''
quickfix.family.name.create.property=创建属性
quickfix.popup.title.choose.properties.file=选择属性文件

quickfix.name.change.0.type.to.1=''{0}'' 类型更改为 ''{1}''
quickfix.family.name.change.field.type=更改字段类型

quickfix.name.create.def.declaration.for.0=为 ''{0}'' 创建 ''@def'' 声明
quickfix.family.name.create.def.declaration=创建 '@def' 声明

quickfix.name.register.0.subpackage.as.1.path=将 ''{0}'' 子包注册为 {1} 路径
quickfix.family.name.register.subpackage=注册子包

quickfix.name.create.0.method=创建 ''{0}'' 方法

quickfix.name.replace.0.with.1=用''{1}''替换''{0}''
quickfix.family.name.replace.listener.with.handler=将侦听器替换为处理程序

inspection.name.incorrect.serializable.class=不正确的可序列化类
problem.description.field.0.is.not.serializable=类型 ''{0}'' 不可序列化
problem.description.serializable.class.should.provide.public.no.args.constructor=可序列化的类应提供 public 无参数构造函数
inspection.name.method.with.parameters.in.interface.extending.constants=接口扩展 Constants 中的方法带有参数
problem.description.methods.with.parameters.are.not.allowed.in.an.interface.extending.constants=接口扩展 Constants 中不允许使用带有参数的方法
problem.description.properties.with.parameters.are.not.allowed.if.the.associated.interface.extends.constants=如果相关接口扩展 Constants，则不允许使用带有参数的属性
quickfix.name.inherit.0.from.messages.instead.of.constants=从消息而不是 Constants 继承 ''{0}''
quickfix.family.name.inherit.from.messages.instead.of.constants=将 Constants 替换为 Messages

inspection.name.unresolved.references.in.jsni.methods=JSNI 方法中的引用未解决
inspection.name.unresolved.references.in.ui.xml.files=ui.xml 文件中的引用未解析
problem.description.cannot.resolve.0=无法解析 ''{0}''
problem.description.cannot.resolve.symbol.0.in.1=无法解析 ''{1}'' 中的符号 ''{0}''
problem.description.ambiguous.wildcard.match=模糊的通配符匹配\: ''{2}'' 中的 ''{0}'' 和 ''{1}'' 都匹配 ''{3}'' 
problem.description.class.is.not.widget=类 ''{0}'' 未实现 ''IsWidget'' 接口

problem.description.inconsistent.element.type=UiBinder 接口参数与 ''{0}'' 标签不一致。应为 ''{1}'' 或其超类
problem.description.ui.xml.not.found=UiBinder 接口没有相应的 ui.xml 文件
problem.description.ui.xml.root.not.found=无法在相应的 ui.xml 文件中检测到根标记
problem.description.ui.xml.root.ambiguity=在相应的 ui.xml 文件中检测到太多根标记

inspection.name.incorrect.java.methods.calls.in.js=对 JavaScript 代码中的 Java 方法的调用错误
problem.description.cannot.call.instance.method.without.object.instance=没有对象实例，无法调用实例方法 ''{0}'' 
problem.description.incorrect.number.of.arguments.for.method=''{0}'' 方法的参数数目不正确\: 应为 {1}，但发现为 {2}

inspection.name.overlay.type.restrictions.violated=违反覆盖类型限制
problem.description.constructor.in.overlay.type.cannot.have.parameters=覆盖类型的构造函数不能有参数
problem.description.constructor.in.overlay.type.must.be.protected=覆盖类型中的构造函数必须为 protected
problem.description.constructor.in.overlay.type.must.have.empty.body=覆盖类型的构造函数的主体必须为空
problem.description.overlay.type.must.have.protected.empty.no.arg.constructor=覆盖类型必须具有不带参数的 protected 空构造函数
problem.description.overlay.type.cannot.have.instance.fields=覆盖类型不能包含实例字段
problem.description.inner.classes.in.overlay.type.must.be.static=覆盖类型的内部类必须为 static
problem.description.instance.methods.in.overlay.type.must.be.final=覆盖类型的实例方法必须为 final

inspection.name.obsolete.gwt.type.args.tag.in.javadoc.comments=JavaDoc 注释中已弃用 @gwt.typeArgs 标签 
problem.description.gwt.type.args.tag.is.obsolete.in.gwt.1.5=GWT 1.5 已弃用 @gwt.typeArgs 标签
quickfix.name.generify.types.in.method.0.instead.of.using.gwt.type.args.tags=在方法 ''{0}'' 中使用参数化类型，不使用 ''@gwt.typeArgs'' 标签
quickfix.family.name.generify.types.in.method=使用参数化类型
gwt.searching.for.implementations=寻找实现...

quickfix.name.set.provided.to.true=将 'provided' 属性设置为 'true'

inspection.name.raw.use.of.async.callback.in.asynchronous.service.interfaces=在异步服务接口中原始使用 AsyncCallback
problem.description.raw.use.of.async.callback.interface=在方法 ''{0}'' 中原始使用 AsyncCallback 接口 
quickfix.name.replace.async.callback.by.async.callback.0=将 ''AsyncCallback'' 替换为 ''AsyncCallback<{0}>''
quickfix.family.name.replace.async.callback.by.generic.async.callback=泛化 'AsyncCallback'

inspection.name.redundant.set.service.entry.point.methods.calls=冗余的 'setServiceEntryPoint()' 方法调用
error.message.set.service.entry.point.method.call.can.be.replaced.by.remote.service.relative.path.annotation='setServiceEntryPoint()' 方法调用可以替换为\n'@RemoteServiceRelativePath' 注释
error.message.set.service.entry.point.method.call.is.redundant='setServiceEntryPoint()' 方法调用冗余，因为入口点\n由 '@RemoteServiceRelativePath' 注释指定

inspection.name.incorrect.argument.of.gwt.create.method=GWT.create() 方法的参数不正确
problem.description.only.class.literals.may.be.used.as.arguments.to.gwt.create=只能将类文字用作 GWT.create() 的参数

error.message.this.action.is.allowed.only.for.client.side.packages.of.a.gwt.module=此操作仅适用于 GWT 模块的客户端程序包

border.title.gwt.compilation=GWT 编译
framework.title.google.web.toolkit=Google Web 工具包(&G)
inspection.name.deprecated.gwt.key.tag.in.javadoc.comments=JavaDoc 注释中已弃用 @gwt.key 标签
problem.description.gwt.key.tag.is.deprecated.in.gwt.1.5=@gwt.key 标签在 GWT 1.5 被弃用
quickfix.name.replace.gwt.key.tag.with.key.annotation.in.method.0=将 @gwt.key 标签替换为方法 ''{0}'' 中的 @Key 注释
quickfix.family.name.replace.gwt.key.tag.with.key.annotation=将 @gwt.key 标签替换为 @Key 注释
action.name.create.gwt.test.case=GWT 测试用例
action.description.creates.new.gwt.test.case=创建新的 GWT 测试用例
dialog.promt.enter.name.for.gwt.test.case=输入 GWT 测试用例名称
dialog.title.new.gwt.test.case=新的 GWT 测试用例
action.progress.creating.gwt.test.case.0=创建 GWT 测试用例 ''{0}''

ant.target.description.compile.gwt.modules.in.module.0=编译模块 {0} 中的所有 GWT 模块
ant.target.name.run.gwt.compiler=运行 GWT 编译器
ant.target.comment.run.gwt.compiler.for.gwt.module.0=为 GWT模块 {0} 运行 GWT 编译器
quickfix.name.replace.set.service.entry.point.call.by.annotation=将 'setServiceEntryPoint()' 调用替换为注释
quickfix.name.remove.redundant.set.service.entry.point.call=移除冗余的 'setServiceEntryPoint()' 调用
error.message.0.is.not.under.public.roots.of.gwt.modules.nor.under.web.roots=''{0}'' 不在 GWT 模块的 ''public'' 根目录下，也不在 Web 根目录下，因此无法在托管模式浏览器中打开。
create.gwt.uibinder.action.name=GWT UiBinder 和 ui.xml 文件
create.gwt.uibinder.action.description=创建 GWT UiBinder 和 ui.xml 文件
error.message.uibinder.is.supported.in.gwt.2.0.or.later=GWT 2.0 或更高版本支持 UiBinder
label.text.enter.name.for.new.gwt.uibinder.class.and.ui.xml.file=输入新的 GWT UiBinder 类和 ui.xml 文件的名称(&E)\:
dialog.title.create.new.gwt.uibinder.class.and.ui.xml.file=创建新的 GWT UiBinder 类和 ui.xml 文件
action.name.create.gwt.uibinder.0.and.1.ui.xml.file=创建 GWT UiBinder ''{0}'' 和 ''{1}.ui.xml'' 文件
create.gwt.uirenderer.action.name=GWT UiRenderer 和 ui.xml 文件
create.gwt.uirenderer.action.description=创建 GWT UiRenderer 和 ui.xml 文件
error.message.uirenderer.is.supported.in.gwt.2.5.or.later=GWT 2.5 或更高版本支持 UiRenderer
label.text.enter.name.for.new.gwt.uirenderer.class.and.ui.xml.file=输入新的 GWT UiRenderer 类和 ui.xml 文件的名称(&E)\:
dialog.title.create.new.gwt.uirenderer.class.and.ui.xml.file=创建新的 GWT UiRenderer 类和 ui.xml 文件
action.name.create.gwt.uirenderer.0.and.1.ui.xml.file=创建 GWT UiRenderer ''{0}'' 和 ''{1}.ui.xml'' 文件
label.text.select.root.element.type=指定根元素的类型(&S)\:

create.gwt.event.with.handler.action.name=GWT 事件和处理程序类
create.gwt.event.with.handler.action.description=创建 GWT 事件和处理程序类
dialog.title.create.gwt.event.with.handler=创建新的 GWT 事件和处理程序类
action.name.create.gwt.event.with.handler=创建 GWT 事件 ''{0}'' 及其处理程序类
error.message.gwt.event.not.supported=GWT 1.6 或更高版本支持 GwtEvent

popup.title.resource.method.goto=<html><body>为 <b>{0}</b> 选择文件(找到 {1} 个文件0</body></html>
tooltip.text.resource.method.gutter=方法{0, choice, 1\#有|2\#有} {0} 个关联的资源{0, choice, 1\#文件|2\#文件}

popup.title.css.class.method.goto=<html><body>为 <b>{0}</b> 方法选择文件(找到 {1} 个文件)</body></html>
tooltip.text.css.class.method.gutter=方法{0, choice, 1\#有|2\#有}  个关联的 css {0, choice, 1\#类|2\#类}
tooltip.text.css.declaration.method.gutter=方法{0, choice, 1\#有|2\#有}  个关联的 css {0, choice, 1\#元素|2\#元素}

popup.title.css.file.goto=<html><body>为 <b>{0}</b> 选择文件(找到 {1} 个文件)</body></html>
tooltip.text.css.file.gutter=类{0, choice, 1\#有|2\#有} {0} 个关联的 css {0, choice, 1\#文件|2\#文件}
label.text.event.class.name=事件类名(&E)\:
label.text.handler.class.name=处理程序类名(&H)\:
label.text.event.handler.method.name=处理方法名称(&M)\:

popup.title.ui.xml.file.goto=<html><body>为 <b>{0}</b> 选择 ui.xml 文件(找到 {1} 个文件)</body></html>
tooltip.text.ui.xml.file.gutter=类{0, choice, 1\#有|2\#有} {0} 个关联的 ui.xml {0, choice, 1\#文件|2\#文件}
popup.title.ui.tag.file.goto=<html><body>为 <b>{0}</b> 字段选择 ui.xml 文件(找到 {1} 个文件)</body></html>
tooltip.text.ui.tag.file.gutter=字段在 {0} 个 ui.xml {0, choice, 1\#文件|2\#文件}中{0, choice, 1\#有|2\#有} 个关联的{0, choice, 1\#标签|2\#标签}


gwt.intention.category=Google Web 工具包

exportable.GwtSdkManager.presentable.name=GWT SDK

checkbox.text.separate.methods=分隔每个字段的方法(&S)

gwt.insufficient.language.level={0} (由 GWT facet 配置)

gwt.notification.display.id=GWT
implementation.provided=由 GWT 提供实现

action.GWT.GenerateUiHandlerMethod.text=@UiHandler 方法...
action.GWT.NewSerialClass.text=GWT 可序列化类
action.GWT.NewSerialClass.description=创建新的 GWT 类实现 IsSerializable
action.GWT.NewRemoteService.text=GWT 远程服务
action.GWT.NewRemoteService.description=创建新的 GWT 接口扩展 RemoteService、相应的异步版本和实现类
action.GWT.GenerateCompileReport.text=生成 GWT 编译报告...
action.GWT.GenerateCompileReport.description=运行 GWT 编译器以生成编译报告，并在浏览器中打开结果

message.text.gwt.module.chooser.isn.t.available.while.updating.indices=在 {0} 更新索引时，GWT 模块选择器不可用
dialog.title.choose.gwt.modules.to.load=选择要加载的 GWT 模块
label.none.facet.selected=<无>
dialog.title.no.gwt.modules.found.in.the.project=在项目中找不到 GWT 模块
intention.text.create.uihandler.for.tag=为标签创建 @UiHandler
label.text.0.is.used=使用了 {0}
content.display.name.server=服务器
content.display.name.modules=模块
content.display.name.dev.mode=开发人员模式
psi.viewer.name.gwt.ui.xml.file=GWT ui.xml 文件
popup.step.title.select.artifact=选择构件
validation.result.gwt.compiler.output.is.not.included.in.an.artifact=GWT 编译器输出未包含在构件中
validation.result.gwt.servlet.jar.is.not.included.in.0.artifact=gwt-servlet.jar 不包含在 ''{0}'' 构件中
task.title.updating.gwt.dev.mode.resources=更新 GWT 开发人员模式资源
progress.indicator.copying.files=正在复制文件...
progress.indicator.deleting.obsolete.files=正在删除过时的文件...
progress.indicator.processing.files=正在处理文件...
task.title.preparing.war.directory.for.gwt.dev.mode=为 GWT 开发人员模式准备 WAR 目录
problem.descriptor.description.template.expected.0.but.1.found=应为 ''{0}''，但发现为 ''{1}''
problem.descriptor.description.template.uifield.0.should.not.be.private=@UiField ''{0}'' 不应为 ''private''
problem.descriptor.description.template.0.is.not.annotated.with.uifield=\ ''{0}'' 未使用 @UiField 进行注释
problem.descriptor.description.template.0.field.is.not.bound.to.tag.in.1.file=\ ''{0}'' 字段未绑定到 ''{1}'' 文件中的标签
problem.descriptor.description.template.duplicate.declaration.bound.to.0.field=绑定到 ''{0}'' 字段的声明重复
problem.descriptor.description.template.uibinder.class.not.found.for.0=找不到 ''{0}'' 的 UiBinder 类\n
problem.descriptor.description.template.cannot.resolve.0.field=无法解析 ''{0}'' 字段
problem.descriptor.description.template.handler.0.cannot.be.registered.methods.1.and.2.are.ambiguous=无法注册处理程序 ''{0}''\: 方法 ''{1}'' 和 ''{2}'' 不明确
problem.descriptor.description.template.field.0.does.not.have.addhandler.method.for.1=字段 ''{0}'' 没有用于 ''{1}'' 的 ''addHandler'' 方法
problem.descriptor.description.template.handler.method.0.signature.does.not.match.1.signature=处理程序方法 ''{0}'' 签名与 ''{1}'' 签名不匹配
problem.descriptor.description.template.handler.class.0.1=处理程序类 ''{0}'' {1}
problem.descriptor.description.template.cannot.get.eventhandler.type.for.0=无法获取 ''{0}'' 的 EventHandler 类型
problem.descriptor.description.template.cannot.get.eventhandler.type.for.02=无法获取 ''{0}'' 的 EventHandler 类型
problem.descriptor.description.template.parameter.0.is.not.an.event.subclass.of.gwtevent=参数 ''{0}'' 不是事件(GwtEvent 的子类)
problem.descriptor.description.template.uihandler.0.must.have.a.single.event.parameter.defined=@UiHandler ''{0}'' 必须只定义一个事件参数
problem.descriptor.description.template.uihandler.0.must.have.at.least.one.parameter.defined=@UiHandler ''{0}'' 必须至少定义一个参数
problem.descriptor.description.template.uihandler.0.should.not.be.private=''@UiHandler ''{0}'' 不应为 ''private''
intention.text.create.uifield.for.tag=为标签创建 @UiField
dialog.message.incorrect.number.of.type.parameters.in.0.class={0} 类中的类型参数数目不正确。
dialog.message.0.class.not.found=找不到 {0} 类。
action.ViewReportAction.text=查看报告
label.text.compile.report.was.generated.0.ago=编译报告于 {0} 年前生成
button.text.generate=生成
dialog.title.generate.gwt.compile.report=生成 GWT 编译报告
label.text.download.gwt=下载 GWT
label.text.gwt.sdk.path.not.specified=未指定 GWT SDK 路径。
task.title.looking.for.changed.classes=正在查找变更的类...
running.app.updater.description.update.0=更新 ''{0}''
dialog.message.root.element.type.is.not.specified=未指定根元素类型
dialog.message.cannot.create.sample.gwt.application.0=无法创建示例 GWT 应用程序\: {0}