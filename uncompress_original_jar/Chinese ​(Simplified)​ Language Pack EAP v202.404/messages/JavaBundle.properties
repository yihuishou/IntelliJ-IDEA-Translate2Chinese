abstract.class.not.allowed=不允许 abstract 类
access.static.via.instance=通过实例引用访问 static 成员
action.AnActionButton.text.select.annotation.used.for.code.generation=选择用于代码生成的注解
action.analyzing.cyclic.dependencies.in.scope={0}的循环依赖
action.create.new.class=创建新的类
action.create.new.class.description=创建新Java类
action.create.new.module-info.description=创建新的 module-info.java
action.create.new.module-info.title=module-info.java
action.create.new.package-info.description=创建新的package-info.java
action.create.new.package-info.title=package-info.java
action.cyclic.dependency.title=分析循环依赖
action.description.copy.whole.thread.dump.to.clipboard=将整个线程转储复制到剪贴板
action.description.group.by.scope=按范围类型分组 (产品, 测试, 库)
action.description.group.threads.with.identical.stacktraces=组合具有相同堆栈跟踪的线程
action.description.mark.directory.as.a.0.for.generated.files=为生成的文件将目录标记为{0}
action.description.mark.directory.as.an.ordinary.0=将目录标记为普通{0}
action.description.show.only.threads.containing.a.specific.string=仅显示包含特定字符串的线程
action.group.by.package=包
action.group.by.scope.type=按范围类型分组
action.implement.method=执行方法
action.implement.methods=执行方法
action.override.method=重写方法
action.override.methods=重写方法
action.text.0.on.parameter.1=在参数 ''{1}'' 上{0}
action.text.choose.class.in.0=选择 {0} 中的类…
action.text.copy.to.clipboard=复制到剪贴板
action.text.edit.template=编辑模板
action.text.enter.class.name=输入类名…
action.text.generated.root.0=生成的{0}
action.text.merge.identical.stacktraces=合并相同的堆栈跟踪
action.text.show.methods.to.implement=显示要实现的方法
action.text.show.quick.list=显示快速列表
action.text.unmark.generated.0=取消标记生成的{0}
annotate.intention.chooser.title=选择要添加的注释
assignment.to.declared.variable.problem.descriptor=变量''{0}''是自我赋值初始化
assignment.to.itself.problem.descriptor=变量''{0}''是分配给自己
assignment.to.itself.quickfix.name=除去自身赋值
bean.property=Bean属性
boolean.method.is.always.inverted.display.name=布尔方法总是反向的
boolean.method.is.always.inverted.problem.descriptor=布尔方法 <code>\#ref</code> 总是反向的
button.add.blank=添加空白
button.add.class=添加类...
button.add.package=添加包
button.add.pattern=添加模式...
button.annotations=<html>注释</html>...
button.base.method=基方法(&B)
button.code.patterns=代码模式…
button.current.method=当前方法(&C)
button.text.settings=设置...
cast.expression=强制转换表达式
cast.to.0=转换为''{0}''
change.color.command.text=改变颜色
change.uid.action.name=随机更改 'serialVersionUID' 初始值设定项
checkbox.after.description=在描述后
checkbox.after.parameter.descriptions=在参数描述后
checkbox.after.return.tag=在return后
checkbox.align.parameter.descriptions=对齐参数说明
checkbox.align.thrown.exception.descriptions=对齐抛出异常说明
checkbox.annotate.local.variables=注解局部变量
checkbox.collapse.annotations=<html>注释</html>
checkbox.collapse.anonymous.classes=<html>匿名类</html>
checkbox.collapse.closures=<html>"闭包"(匿名类实现一个方法)</html>
checkbox.collapse.end.of.line.comments=<html>行尾注释序列</html>
checkbox.collapse.generic.constructor.parameters=<html>通用构造函数和方法参数</html>
checkbox.collapse.i18n.messages=<html>I18n字符串</html>
checkbox.collapse.inferred.type=使用推断类型替换 'var'
checkbox.collapse.inner.classes=内部类
checkbox.collapse.multiline.comments=多行注释
checkbox.collapse.one.line.methods=<html>一行方法<html>
checkbox.collapse.simple.property.accessors=<html>简单属性访问器</html>
checkbox.collapse.suppress.warnings=<html>@SuppressWarnings</html>
checkbox.comments.and.javadoc.count.as.content=注释和 javadoc 计为内容
checkbox.deprecated.members=弃用的成员
checkbox.do.not.indent.top.level.class.members=不缩进顶层类成员
checkbox.do.not.wrap.after.single.annotation=单个注解后不换行
checkbox.do.not.wrap.one.line.comments=一行注释不分行
checkbox.enable.javadoc.formatting=启用JavaDoc格式
checkbox.enable.leading.asterisks=启用前导星号
checkbox.generate.p.on.empty.lines=在空行生成"<p/>"
checkbox.html.report.inaccessible.symbols=<html>报告无法访问的符号<br>(javadoc 工具可能无法创建超链接)
checkbox.ignore.fields.used.in.multiple.methods=忽略多个方法中使用的字段
checkbox.ignore.simple.setters=忽略简单的 setter
checkbox.insert.imports.for.inner.classes=插入导入到内部类
checkbox.iterate.unknown.stream.sources.via.stream.iterator=通过 Stream.iterator() 迭代未知的流源
checkbox.keep.empty.lines=保持空行
checkbox.keep.empty.param.tags=保持空 @param 标签
checkbox.keep.empty.return.tags=保持空 @return 标签
checkbox.keep.empty.throws.tags=保持空 @throws 标签
checkbox.keep.invalid.tags=保持无效标签
checkbox.make.generated.local.variables.final=将生成的局部变量设为 final
checkbox.make.generated.parameters.final=将生成的参数设为 final
checkbox.optimize.imports.on.the.fly=快速优化导入
checkbox.param.description.on.new.line=参数描述在新行
checkbox.param.indent.on.continuation=缩进连续线
checkbox.prefer.longer.names=提升较长的名称
checkbox.preserve.line.feeds=保留换行
checkbox.spaces.before.colon.in.foreach=在 foreach 中的冒号之前
checkbox.spaces.inside.one.line.enum=在一行枚举大括号内
checkbox.suggest.conversion.to.map.computeifabsent=建议转换为 Map.computeIfAbsent
checkbox.suggest.conversion.to.map.getordefault=建议转换为 Map.getOrDefault
checkbox.suggest.conversion.to.map.merge=建议转换为 Map.merge
checkbox.suggest.conversion.to.map.putifabsent=建议转换为 Map.putIfAbsent
checkbox.suggest.conversion.to.map.replaceall=建议转换为 Map.replaceAll
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=建议替换，即使 lambda 可能有副作用
checkbox.suppress.with.suppresswarnings=使用 @SuppressWarnings 禁止
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=将 'get(k) \!\= null' 视为与 'containsKey(k)' 相同 (可能更改语义)
checkbox.use.fully.qualified.class.names=使用全修饰类名
checkbox.use.single.class.import=使用单个类导入
checkbox.use.throws.rather.than.exception=用 @throws 而不是 @exception
checkbox.warn.if.only.foreach.replacement.is.available=只要 'forEach' 替换可用，就发出警告
checkbox.warn.if.the.loop.is.trivial=循环不重要时发出警告
checkbox.wrap.at.right.margin=在右页边距处换行
choose.class=选择类
chooser.text.choose.where.to.save.0=选择要保存 ''{0}'' 的位置
chooser.title.select.path.to.save.jar=选择要保存 Jar 的路径
class.decorator.or.has.default.constructor=''{0}'' 应具有默认构造函数或者实现 ''Decorator'' 模式
class.filter.editor.add.dialog.title=新的过滤器
class.filter.editor.choose.class.title=选择类
class.has.no.default.constructor=''{0}'' 没有默认的构造函数
class.is.not.a.subclass=''{0}'' 未分配到 ''{1}''
class.is.not.concrete=''{0}'' 不是一个具体类
class.is.not.public=''{0}'' 不为 public
class.not.found.error.message=未找到类 ''{0}''
code.style.generation.override.method.signature=重写方法签名
code.style.generation.repeat.synchronized.modifier=重复 synchronized 修饰符(&S)
code.style.generation.replace.null.check=将 null 检查替换为 Objects\:\:nonNull 或 Objects\:\:isNull
code.style.generation.use.class.isInstance=如果可能，请使用 Class\:\:isInstance 和 Class\:\:cast
code.style.generation.use.integer.sum=如果可能，请使用 Integer\:\:sum 等
combobox.paste.insert.imports=粘贴时插入导入(&I)\:
command.create.class.from.template=从模板创建类
command.create.new.subdirectory=创建新子目录
command.name.insert.block.statement=插入块语句
command.name.updating.package.statement=更新包语句
comment.the.class.will.be.created.in.the.package.0=类将在包 ''{0}'' 中创建
completion.class.name.hint.2=再次按{0}可以在搜索时忽略模块依赖关系
completion.no.suggestions.of.type=没有类型为{0}的建议
completion.smart.aslist.hint=再次按{0}查找{1}的集合(Array)
completion.smart.chain.hint=再次按{0}搜索方法的调用链
completion.smart.hint=按{0}仅显示适合类型的变量
completion.smart.toar.hint=再次按{0}查找{1}的集合
completion.smart.type.generate.anonymous.body=生成匿名体
completion.unknown.type=未知类型{0}
configurable.EqualsHashCodeTemplatesPanel.display.name=模板
configurable.GenerateToStringConfigurable.display.name=设置
configurable.TemplatesPanel.display.name=模板
configure.annotations.option=配置注释
convert.compareto.expression.to.equals.call=将 'compareTo()' 表达式转换为 'equals()' 调用
convert.compareto.expression.to.equals.call.may.change.semantics=将 'compareTo()' 表达式转换为 'equals()' 调用 (可能更改语义)
copy.abstract.method.intention.name=使用现有实现''{0}''
copy.abstract.method.no.existing.implementations.found=没有找到现有的实现
copy.abstract.method.popup.title=选择要复制的实现
copy.abstract.method.title=使用 abstract 方法实现
copy.paste.reference.notification=<html>已添加 {0} 个{0, choice, 1\#导入|2\#导入}<p><span><a href\=''show''>检查添加的导入…</a></span></html>
cyclic.dependencies.progress.text=正在构建依赖关系图
cyclic.dependencies.scope.dialog.module.button={0}模块''{1}'' (&M)
cyclic.dependencies.scope.dialog.project.button={0}整个项目 (&P)
cyclic.dependencies.scope.dialog.title=指定{0}范围
cyclic.dependencies.scope.include.test.sources.option=包含测试代码 (&T)
cyclic.dependencies.tree.cycle.node.text=循环
cyclic.dependencies.usage.view.initial.text=从左边树选择分析的包
cyclic.dependencies.usage.view.root.node.text=在包''{1}''里,包''{0}''的使用
dataflow.from.here=流出此处的数据流
dataflow.to.here=流入此处的数据流
deannotate.intention.action.text=取消注释
deannotate.intention.chooser.title=选择要删除的注释
default.file.template.description=默认文件模板
default.file.template.display.name=默认文件模板的使用
default.file.template.edit.template=编辑模板...
default.file.template.replace.with.actual.file.template=替换为实际文件模板
default.package.presentable.name=<默认>
dependencies.libraries.node.text=库
dependencies.tree.node.default.package.abbreviation=<默认包>
dialog.create.class.destination.package.label=目标包\:
dialog.create.class.label=创建 {0}\:
dialog.create.class.name=创建{0}{1}
dialog.create.class.package.chooser.title=选择目标包
dialog.create.field.from.parameter.already.exists.text=使用现有字段''{0}''？
dialog.create.field.from.parameter.already.exists.use.existing.button=使用现有字段
dialog.create.field.from.parameter.already.exists.title=字段已经存在
dialog.create.field.from.parameter.declare.final.checkbox=声明 final(&F)
dialog.create.field.from.parameter.field.name.label=名称\:
dialog.create.field.from.parameter.field.type.label=字段的类型\:
dialog.create.field.from.parameter.title=创建字段
dialog.edit.template.checkbox.smart.type.completion=智能类型完成(o)\r (&O)
dialog.edit.template.checkbox.use.static.import=尽可能使用静态导入(&I)
dialog.import.on.paste.title=选择要导入的类
dialog.import.on.paste.title2=选择要导入的元素
dialog.import.on.paste.title3=选择要移除的导入
dialog.message.0.update.existing.class={0}。更新现有的类?
dialog.message.create.test.in.the.same.source.root=在相同的源根中创建测试?
dialog.message.infer.nullity.annotations.requires.the.project.language.level=推断可空性注解需要将项目语言级别设置为 1.5 或更高。
dialog.message.jetbrains.annotations.library.is.missing=缺少 JetBrains 注解库。\n没有库，IntelliJ IDEA 将无法运行分析。要添加吗?
dialog.message.no.places.found.to.infer.nullable.notnull=未找到要推断 @Nullable/@NotNull 的位置
dialog.paste.on.import.text=<html>您所粘贴的代码片段使用的是不是在新的形势下,可以通过导入类。<br/>选择类,您要导入到新文件。</html>
dialog.paste.on.import.text2=<html>您所粘贴的代码片段使用,是不是在新的上下文访问的导入元件。<br/>选择元素,您想导入到新文件。</html>
dialog.paste.on.import.text3=<html>您粘贴的代码段在当前上下文中引入了新的导入。<br/>选择您想要消除的导入。</html>
dialog.title.choose.0.parameters=选择 {0} 参数
dialog.title.choose.class=选择类
dialog.title.configure.annotations=配置注释
dialog.title.configure.code.patterns=配置代码模式
dialog.title.create.class.in.package=在包中创建类
dialog.title.create.missed.tests=创建缺少的测试
dialog.title.edit.method.contract=编辑方法约定
dialog.title.edit.range=编辑范围
dialog.title.infer.nullity=推断可空性
action.description.infer.nullity.annotations=推断可空性注解
dialog.title.infer.nullity.results=推断可空性结果
dialog.title.no.test.roots.found=未找到测试根
dialog.title.process.duplicates=处理重复项
dialog.title.super.method.found=已找到 super 方法
do.not.import.inner.classes.for=按短名称排除内部类\:
do.not.import.inner.classes.no.classes=未定义内部类
edit.dependency.rules.family=编辑依赖关系规则
edit.dependency.rules.text=编辑依赖关系规则"{0} "
editbox.blanklines.around.initializer=围绕初始化\:
editbox.class.count.to.use.import.with.star=统计使用'*'导入的类个数\:
editbox.names.count.to.use.static.import.with.star=将静态导入与 '*' 搭配使用的名称数\:
element.of.class=类的
element.of.interface=接口的
enum.not.allowed=枚举不被允许
error.attempt.to.generate.constructor.for.anonymous.class=不能添加构造函数到匿名类
error.hint.no.expression.found=未找到表达式
error.package.already.contains.package-info=''package-info.java'' 的包已经存在“{0}”
error.package.already.contains.package.html=包“{0}”已经有一个 package.html 文件。创建“package-info.java”的呢?
error.package.html.found.title=发现“package.html”
error.text.this.is.not.a.valid.java.class.name=这不是有效的 Java 类名
exclude.0.from.completion=从补全中排除 ''{0}''
exclude.accessors=排除访问器(&E)
exclude.from.completion.group=从自动导入和补全中排除\:
exclude.from.imports.no.exclusions=添加类、包或成员
exclude.from.imports.no.exclusions.2=从自动导入和补全中排除
exclude.table.mask=类、包或成员
exclude.table.scope.column=范围
export.to.html.generate.hyperlinks.checkbox=生成超链接指向类 (&H)
external.annotation.prompt=外部注解提示
external.annotations.external.option=从外部添加 (&E)
external.annotations.in.code.option=添加代码 (&C)
external.annotations.root.chooser.description=外部注解将被保存在相应的文件夹
external.annotations.root.chooser.title=选择{0}的外部注解根
external.annotations.suggestion.message=<html><body>如果您的代码中不需要注解，可以使用外部存储。<br>要配置外部注解，请指定放置包含注解的文件的根目录</body></html>
find.field.accessors.prompt=搜索字段 ''{0}'' 的访问器?
find.field.accessors.title=已找到字段访问器
find.options.include.overloaded.methods.checkbox=包含重载方法 (&V)
find.parameter.usages.in.overriding.methods.prompt=您想搜索使用参数''{0}''在重写方法?
find.parameter.usages.in.overriding.methods.title=在重写方法里搜索
find.what.derived.classes.checkbox=派生类 (&D)
find.what.derived.interfaces.checkbox=派生接口 (&D)
find.what.fields.usages.checkbox=字段的用法 (&F)
find.what.group=查找
find.what.implementing.classes.checkbox=实现类 (&I)
find.what.implementing.methods.checkbox=实现方法 (&I)
find.what.implicit.to.string.checkbox=隐式调用(&M)
find.what.methods.usages.checkbox=方法的用法 (&M)
find.what.overriding.methods.checkbox=重写方法 (&R)
find.what.usages.checkbox=用法 (&U)
find.what.usages.of.classes.and.interfaces=类和接口的用法 (&C)
generate.button.title=生成
generate.constructor.fields.chooser.title=选择字段以便构造器初始化
generate.constructor.super.constructor.chooser.title=选择超级类构造器
generate.delegate.target.chooser.title=选择目标生成的代表
generate.equals.and.hashcode.already.defined.title=生成equals()和hashCode()
generate.equals.and.hashcode.already.defined.warning=对于类{0},方法''boolean equals(Object)'' 和 ''int hashCode()''已经定义,要继续删除它们吗?
generate.equals.and.hashcode.already.defined.warning.anonymous=对于这个匿名类,方法'boolean equals(Object)' 和 'int hashCode()'已经定义,要继续删除它们吗?
generate.equals.hashcode.accept.sublcasses=接受子类作为参数equals()方法(
generate.equals.hashcode.accept.sublcasses.explanation=<html><body>Object.equals() 不符合接受范围内<br>子类可能需要生成方法的正确工作<br>在框架中, 它生成的代理子类如Hibernate。</body></html>
generate.equals.hashcode.equals.fields.chooser.title=选择要被包含在equals()中的字段(f)\r (&F)
generate.equals.hashcode.hashcode.fields.chooser.title=选择要被包含在hashCode()中的字段(f)\r (&F)
generate.equals.hashcode.internal.error=内部错误
generate.equals.hashcode.non.null.fields.chooser.title=选择所有非空字段 (&F)
generate.equals.hashcode.template=模板(&T)\:
generate.equals.hashcode.use.getters=在代码生成过程中使用 &getters
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=hashCode()不支持数组
generate.equals.hashcode.wizard.title=生成equals()和hashCode()
generate.equals.template.title=Equals 模板\:
generate.equals.warning.equals.for.nested.arrays.not.supported=equals()不支持嵌套的数组
generate.equals.warning.generated.equals.could.be.incorrect=生成的Object[]的equals()可能不正确
generate.getter.fields.chooser.title=选择字段生成Getter
generate.getter.setter.title=选择字段生成Getter和Setter
generate.getter.template=Getter 模板(&G)\:
generate.hashcode.template.title=HashCode 模板\:
generate.record.constructor.title=生成记录构造函数
generate.setter.fields.chooser.title=选择字段生成Setter
generate.setter.template=Setter 模板(&S)\:
generate.tostring.already.exist.border=当方法已存在时
generate.tostring.available.implicit.variables.label=可用的隐式变量\:<br/>{0}
generate.tostring.exclude..transient=排除 transient 字段
generate.tostring.exclude.by.field.name=按名称排除字段 (reg exp)
generate.tostring.exclude.by.field.type=按类型名称排除字段 (reg exp)
generate.tostring.exclude.by.name=按名称排除方法 (reg exp)
generate.tostring.exclude.by.return.type=按返回类型名称排除方法 (reg exp)
generate.tostring.exclude.constant.fields=排除常量字段
generate.tostring.exclude.enum.fields=排除枚举字段
generate.tostring.exclude.logger=排除记录器字段 (Log4j、JDK 日志记录、Jakarta Commons 日志记录)
generate.tostring.exclude.static.fields=排除 static 字段
generate.tostring.fully.qualified.class.name=在代码生成中使用完全限定类名 ($classname)
generate.tostring.getters.in.generated.code=在代码生成中启用 getter ($methods)
generate.tostring.handle.exception.error.message=执行操作时引发不可恢复的异常 - 请参阅 IDEA 日志以获取详细信息 (堆栈跟踪应位于 idea.log 中)\:\n{0}
generate.tostring.handle.exception.plugin.warning.message=执行操作时引发 PluginException - 请参阅 IDEA 日志以获取详细信息 (堆栈跟踪应位于 idea.log 中)\:\n{0}
generate.tostring.handle.exception.velocity.error.message=生成代码时出现速度错误 - 请参阅 IDEA 日志以获取更多详细信息 (堆栈跟踪应位于 idea.log 中)\:\n{0}
generate.tostring.insert.border=在哪里插入?
generate.tostring.method.already.exists.dialog.me\=ssage=替换现有的 {0} 方法
generate.tostring.method.already.exists.dialog.title=方法已存在
generate.tostring.move.to.generated.checkbox=将脱字符号移动到生成的方法
generate.tostring.settings=设置
generate.tostring.sort.ascending=升序
generate.tostring.sort.checkbox=对元素进行排序
generate.tostring.sort.descending=降序
generate.tostring.sort.super=超类成员优先
generate.tostring.tab.title=toString() 生成设置
generate.tostring.template.label=模板\:
generate.tostring.title=生成 toString()
goto.super.class.chooser.title=选择父类或接口
group.javadoc.alignment=对齐
group.javadoc.blank.lines=空行
group.javadoc.invalid.tags=无效标签
group.javadoc.other=其他
gutter.implemented.method=已实现方法
gutter.implementing.method=实现方法
gutter.overridden.method=重写的方法
gutter.overriding.method=重写方法
gutter.service=服务
gutter.sibling.inherited.method=同级继承的方法
highlight.exceptions.thrown.chooser.title=选择异常类以高亮显示
highlight.imported.classes.chooser.title=选择导入高亮的类
highlight.imported.members.chooser.title=选择导入高亮的成员
highlight.overridden.classes.chooser.title=从...选择高亮重写方法的类
icon.preview=图标预览
ignore.imports.and.formatting=忽略导入和格式化
illegal.name.validation.info=非法名称\: {0}
import.layout.static.imports.separately=单独布局静态导入
import.statically=静态导入
include.accessors=包含访问器(&I)
infer.nullity.progress=正在对结果进行后期处理…
insert.override.annotation=插入 @Override 注释 (&O)
inspection.1.5.display.name=在配置的语言级别下,不可用的API用法
inspection.1.5.problem.descriptor=使用API文档作为 @since {0}
inspection.1.7.problem.descriptor=泛型的使用后,会造成1.6 API编译问题与JDK{0}
inspection.1.8.problem.descriptor=默认方法不重写.它会导致JDK编译问题 {1}
inspection.1.8.problem.single.descriptor=默认的方法 ''{0}'' 不重写。它会导致JDK编译问题 {1}
inspection.assert.quickfix=断言''{0}''
inspection.capturing.cleaner=已传递到 Cleaner.register() 的可运行对象捕获 ''{0}'' 引用
inspection.capturing.cleaner.description=清洗器捕获对象引用
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=更改变量类型并移除转换
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=将 ''{0}'' 的类型更改为 ''{1}'' 并移除转换
inspection.cast.can.be.removed.narrowing.variable.type.message=可以通过将 ''{0}'' 的类型更改为 ''{1}'' 来移除转换
inspection.cast.can.be.removed.narrowing.variable.type.name=太弱的变量类型导致不必要的转换
inspection.charset.object.can.be.used.display.name=可以使用标准字符集对象
inspection.charset.object.can.be.used.fix.family.name=使用字符集常量
inspection.charset.object.can.be.used.fix.name=替换为''{0}''
inspection.charset.object.can.be.used.message=可以改用{0}
inspection.collection.factories.fix.family.name=替换集合工厂回调
inspection.collection.factories.fix.name=替换为''{0}.of''回调
inspection.collection.factories.message=可以替换为''{0}.of''回调
inspection.collection.factories.option.ignore.non.constant=内容不确定时不要警告
inspection.collection.factories.option.suggest.ofentries=建议 'Map.ofEntries'
inspection.collection.used.as.vararg.display.name=可迭代对象用作可变参数
inspection.collection.used.as.vararg.message=可迭代对象作为可变参数传递\: 应为数组
inspection.comparator.result.comparison.display.name=比较方法的可疑使用
inspection.comparator.result.comparison.fix.family.name=修正比较结果
inspection.comparator.result.comparison.problem.display.name=比较方法的结果与特定常数对比
inspection.conditional.break.in.infinite.loop=将条件移动到循环中
inspection.conditional.break.in.infinite.loop.description=无限循环中存在条件中断
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=不建议替换为 'do while'
inspection.convert.to.local.quickfix=转换为当地
inspection.data.flow.display.name=恒定的条件和例外
inspection.data.flow.filter.notnull.quickfix=插入'filter(Objects\:\:nonNull)'步骤
inspection.data.flow.nullable.quickfix.option=<html><body>建议 @Nullable 标注为方法可能返回 null 和 <br>报告传递到非注解的参数为空的值</body></html>
inspection.data.flow.true.asserts.option=不报告条件静态证明始终为 <code>true</code> 的断言
inspection.data.flow.use.computeifpresent.quickfix=将 'compute' 替换为 'computeIfPresent'
inspection.dead.code.option.applet=小程序
inspection.dead.code.option.external=非 Java 文件中使用的类
inspection.dead.code.option.main=<html><code>void main(String args[])</code> 方法</html>
inspection.dead.code.option.servlet=Servlet
inspection.default.annotation.param=默认注解的参数值
inspection.dependency.configure.button.text=配置依赖规则
inspection.dependency.violator.problem.descriptor=依赖规则''{0}.''被违反
inspection.duplicate.branches.in.switch.default.message='switch' 中的分支是默认分支的重复项
inspection.duplicate.branches.in.switch.delete.fix.family.name=删除冗余 'switch' 分支
inspection.duplicate.branches.in.switch.delete.fix.name=删除冗余 'switch' 分支
inspection.duplicate.branches.in.switch.display.name='switch' 中存在重复分支
inspection.duplicate.branches.in.switch.merge.fix.family.name=合并 'switch' 中的重复分支
inspection.duplicate.branches.in.switch.merge.fix.name=与 ''{0}'' 合并
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=与默认的 'switch' 分支合并
inspection.duplicate.branches.in.switch.message='switch' 中存在重复分支
inspection.duplicate.expressions.complexity.threshold=表达式复杂性阈值
inspection.duplicate.expressions.display.name=同一表达式存在多个匹配项
inspection.duplicate.expressions.introduce.variable.fix.family.name=引入变量
inspection.duplicate.expressions.introduce.variable.fix.name=为 ''{0}'' 引入变量
inspection.duplicate.expressions.message=<code>\#ref</code> 的多个匹配项 \#loc
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=替换为表达式的其他可变匹配项
inspection.duplicate.expressions.replace.other.occurrences.fix.name=将 ''{0}'' 替换为 ''{1}'' 的其他匹配项
inspection.duplicate.expressions.reuse.variable.fix.family.name=重用变量
inspection.duplicate.expressions.reuse.variable.fix.name=为 ''{1}'' 重用变量 ''{0}''
inspection.empty.method.delete.quickfix=删除不必要的方法
inspection.empty.method.problem.descriptor=方法只调用它的超级
inspection.empty.method.problem.descriptor1=空方法重写空方法
inspection.empty.method.problem.descriptor2=该方法为空
inspection.empty.method.problem.descriptor3=该方法和所有它的derivables是空的
inspection.empty.method.problem.descriptor4=此方法的所有实现都为空
inspection.endless.stream.description=非短路操作消耗无限流
inspection.equals.hashcode.display.name=equals()和hashCode()没有配对
inspection.equals.hashcode.generate.equals.quickfix=生成 'equals()'
inspection.equals.hashcode.generate.hashcode.quickfix=生成 'hashCode()'
inspection.excessive.lambda.fix.family.name=常数替换lambda
inspection.excessive.lambda.fix.name=使用没有lambda的''{0}''方法
inspection.excessive.lambda.message=过度使用lambda
inspection.explicit.argument.can.be.lambda.fix.family.name=将显式参数替换为函数
inspection.explicit.argument.can.be.lambda.fix.name=使用包含函数参数的 ''{0}'' 方法
inspection.explicit.argument.can.be.lambda.message=显式参数可以转换为 lambda
inspection.explicit.array.filling.description=可以替换为单个 ''Arrays.{0}()'' 方法调用
inspection.explicit.array.filling.fix.family.name=将循环替换为 ''Arrays.{0}()'' 方法调用
inspection.explicit.array.filling.no.suggestion.for.set.all=不建议使用 'Arrays.setAll()'
inspection.explicit.array.filling.redundant.loop.description=新建数组的冗余初始化
inspection.explicit.array.filling.suggest.set.all=建议 'Arrays.setAll()'
inspection.export.results.callees=调用链
inspection.export.results.implicit.constructor=隐式的构造函数
inspection.export.results.overrides.library.methods=重写库方法
inspection.export.results.package=包
inspection.export.results.type.references=以下使用这种类型
inspection.field.can.be.local.display.name=可以为本地字段
inspection.field.can.be.local.problem.descriptor=字段可以被转换为一个局部变量
inspection.field.can.be.local.quickfix.constructor=将字段转换为构造函数中的局部变量
inspection.field.can.be.local.quickfix.initializer=将字段转换为初始值设定项部分中的局部变量
inspection.field.can.be.local.quickfix.one.method=将字段转换为方法 ''{0}'' 中的局部变量
inspection.fold.expression.fix.family.name=折叠表达式
inspection.fold.expression.into.stream.display.name=表达式可以折叠到流链中
inspection.fold.expression.into.stream.fix.name=将表达式折叠到流链中
inspection.fold.expression.into.string.display.name=表达式可以折叠到 'String.join' 中
inspection.fold.expression.into.string.fix.name=将表达式折叠到 'String.join' 中
inspection.forward.compatibility.name=前向兼容性
inspection.fuse.stream.operations.display.name=后续步骤可以融合到Stream API链中
inspection.fuse.stream.operations.fix.family.name=将更多的语句融入到Stream API链中
inspection.fuse.stream.operations.fix.name=将 {0} 融合到Stream API 链中
inspection.fuse.stream.operations.message=流可能被拓展替换 {0}
inspection.fuse.stream.operations.option.strict.mode=不建议使用 'toList()' 或 'toSet()' 收集器
inspection.handle.signature.change.type.fix.name=改变类型到''{0}''
inspection.handle.signature.field.cannot.resolve=无法解析字段''{0}''
inspection.handle.signature.field.not.static=字段 ''{0}'' 不为 static
inspection.handle.signature.field.static=字段 ''{0}'' 为 static
inspection.handle.signature.field.type=字段''{0}''的类型是''{1}''
inspection.handle.signature.method.abstract=方法 ''{0}'' 在 ''{1}'' 中是 abstract 方法
inspection.handle.signature.method.not.static=方法 ''{0}'' 不为 static
inspection.handle.signature.method.static=方法 ''{0}'' 为 static
inspection.handle.signature.name=MethodHandle/VarHandle 类型不匹配
inspection.handle.signature.not.subclass=调用者类 ''{0}'' 必须是 ''{1}'' 的子类
inspection.handle.signature.replace.with.fix.name=替换为''{0}''
inspection.handle.signature.use.constructor.fix.family.name=使用构造函数重载之一
inspection.handle.signature.use.constructor.fix.name=使用构造函数''{0}''
inspection.handle.signature.use.method.fix.family.name=使用方法重载之一
inspection.handle.signature.use.method.fix.name=使用方法''{0}''
inspection.idempotent.loop.body=幂等循环体
inspection.illegal.character=非法字符
inspection.insert.literal.underscores.display.name=不可读的数字文字
inspection.insert.literal.underscores.family.name=将下划线插入数字文字
inspection.javadoc.dialog.title=编辑附加的JavaDoc标签
inspection.javadoc.display.name=声明有Javadoc的问题
inspection.javadoc.label.text=附加的Javadoc标签：
inspection.javadoc.lint.display.name=Javadoc中的HTML问题(DocLint)
inspection.javadoc.method.problem.missing.param.tag=参数{0}缺少必需的标签 <code>@param</code>
inspection.javadoc.method.problem.missing.tag.description={0}标签说明已丢失
inspection.javadoc.option.ignore.deprecated=忽略标记为 @deprecated 的元素
inspection.javadoc.option.ignore.period=忽略期问题
inspection.javadoc.option.ignore.self.ref=忽略指向自己的Javadoc
inspection.javadoc.option.ignore.simple=忽略简单的属性访问器
inspection.javadoc.option.ignore.throws=忽略重复的'throws'标签
inspection.javadoc.option.tab.title=类
inspection.javadoc.option.tab.title.field=字段
inspection.javadoc.option.tab.title.inner.class=内部类
inspection.javadoc.option.tab.title.method=方法
inspection.javadoc.option.tab.title.module=模块
inspection.javadoc.option.tab.title.package=包
inspection.javadoc.problem.add.param.tag=为参数''{0}''添加标签 @param
inspection.javadoc.problem.add.param.tag.family=添加缺少的Javadoc参数标签
inspection.javadoc.problem.add.tag=添加标签 @{0}{1}
inspection.javadoc.problem.add.tag.family=添加缺少的 Javadoc 标签
inspection.javadoc.problem.cannot.resolve=无法解析符号{0}
inspection.javadoc.problem.descriptor=要求Javadoc不在
inspection.javadoc.problem.descriptor1=期在文档缺失.使用期间由工具生成的Javadoc注释的概述页面
inspection.javadoc.problem.disallowed.tag=此处不允许使用标签{0}
inspection.javadoc.problem.duplicate.param=重复 @param 标记参数''{0}''
inspection.javadoc.problem.duplicate.tag=重复的 @{0} 标记
inspection.javadoc.problem.duplicate.throws=重复 @throws 或 @exception 标记为异常''{0}''
inspection.javadoc.problem.inaccessible=无法从此处访问符号 {0}
inspection.javadoc.problem.missing.tag=需要标记{0}是缺失的
inspection.javadoc.problem.missing.tag.description={0}在 @{1} 标记之后丢失
inspection.javadoc.problem.name.expected=预期名字
inspection.javadoc.problem.pointing.to.itself=Javadoc指向本身
inspection.javadoc.problem.see.tag.expecting.ref=类/方法引用，引用文本或HTML链接，预计后 @see tag
inspection.javadoc.problem.wrong.tag=错误标签{0}
inspection.javadoc.ref.display.name=声明在Javadoc引用中有问题
inspection.javadoc.required.tags.option.title=要求标签
inspection.javadoc.throws.or.exception.option=@throws 或 @exception
inspection.join.declaration.and.assignment.display.name=赋值可与声明联接
inspection.join.declaration.and.assignment.fix.family.name=联接声明和赋值
inspection.join.declaration.and.assignment.message=赋值可与 ''{0}'' 的声明联接
inspection.labeled.switch.rule.redundant.code.block.display.name=标记的 switch 规则具有冗余代码块
inspection.labeled.switch.rule.redundant.code.block.message=标记规则的代码块冗余
inspection.labeled.switch.rule.redundant.code.fix.name=取消标记规则的代码块换行
inspection.lambda.to.method.call.fix.family.name=用方法调用替换lambda表达式
inspection.lambda.to.method.call.fix.name=用''{0}''替换lambda表达式
inspection.manual.min.max.calculation.description=可以替换为 ''Math.{0}'' 调用
inspection.manual.min.max.calculation.disable.for.non.integral=禁用 float 和 double
inspection.map.foreach.display.name=可以使用 Map.forEach()
inspection.map.foreach.option.no.loops=不要报告循环
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=匿名s \#ref \#loc 可以替换为方法引用
inspection.message.can.be.replaced.with.0.constructor=可以替换为 ''{0}'' 构造函数
inspection.message.can.be.replaced.with.files.readstring=可以替换为 'Files.readString()'
inspection.message.can.be.replaced.with.optional.of.nullable=可以替换为 Optional.ofNullable()
inspection.message.can.be.replaced.with.single.expression.in.functional.style=可以替换为函数样式的单个表达式
inspection.message.can.be.replaced.with.string.repeat=可以替换为 'String.repeat()'
inspection.message.lambda.parameter.type.is.redundant=Lambda 参数类型冗余
inspection.message.pseudo.functional.style.code=伪函数样式代码
inspection.message.redundant.default.parameter.value.assignment=冗余默认参数值赋值
inspection.message.replace.optional.with.if.statements=将 Optional 替换为 if 语句
inspection.no.jdk.error.message=JDK配置不正确为这个项目.不能进行检查.
inspection.no.modules.error.message=这个项目不包含模块.不能进行检查.
inspection.notnull.field.not.initialized.display.name=@NotNull 字段未初始化
inspection.notnull.field.not.initialized.option.implicit=忽略可以隐式初始化的字段
inspection.notnull.field.not.initialized.option.setup=忽略在 setUp() 方法中初始化的字段
inspection.null.value.for.optional.assigned.ignore.fix.name=将 Optional 与 null 比较时不发出警告
inspection.null.value.for.optional.assigned.message=Optional 值与 null 比较
inspection.null.value.for.optional.context.assignment=分配
inspection.null.value.for.optional.context.declaration=声明
inspection.null.value.for.optional.context.lambda=lambda表达式
inspection.null.value.for.optional.context.parameter=参数
inspection.null.value.for.optional.context.return=返回语句
inspection.null.value.for.optional.fix.family.name=替换空的可选方法
inspection.null.value.for.optional.message=Null用于{0}中的''可选''类型
inspection.null.value.for.optional.option.comparisons=报告 Optional 与 null 的比较
inspection.nullable.problems.display.name=@NotNull/@Nullable 问题
inspection.nullable.problems.ignore.external.notnull=忽略外部 @NotNull(&I)
inspection.nullable.problems.method.overrides.notnull.option=<html>报告 @NotNull 参数覆盖 @Nullable 和<br>@Nullable 方法覆盖 @NotNull</html> (&P)
inspection.nullable.problems.method.overrides.option=报告未注解的参数或方法重写 @NotNull (&A)
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=报告非注释setter参数或getter的注解字段 (&S)
inspection.nullable.problems.notnull.overrides.option=报告重写非注解对象的 @NotNull 参数(&P)
inspection.nullable.problems.notnull.parameters.with.null.literal.option=报告使用 null 文字参数的 @NotNull 参数
inspection.optional.get.without.is.present.message=<code>{0}.\#ref()</code> 未进行 ''isPresent()'' 检查
inspection.overflowing.loop.index.inspection.description=循环执行零次或数十亿次
inspection.overflowing.loop.index.inspection.name=循环执行零次或数十亿次
inspection.overwritten.key.map.message=重复的Map key
inspection.overwritten.key.set.message=重复的Set元素
inspection.parameter.can.be.local.display.name=参数可以是局部的
inspection.parameter.can.be.local.problem.descriptor=参数可以被转化为一个局部变量
inspection.pseudo.functional.style.add.methods.after.quick.fix=快速修复后\:
inspection.pseudo.functional.style.add.methods.before.quick.fix=快速修复前\:
inspection.pseudo.functional.style.add.methods.fully.qualified.class.name=完全限定类名\:
inspection.pseudo.functional.style.add.methods.method.name=方法名称\:
inspection.pseudo.functional.style.add.methods.stream.api.replacement=Stream API 替换\:
inspection.quickfix.assert.family=断言
inspection.raw.variable.type.can.be.generic.family.quickfix=向类型添加泛型参数
inspection.raw.variable.type.can.be.generic.name=原始类型可以是泛型
inspection.raw.variable.type.can.be.generic.quickfix=将 {0} 的类型更改为 {1}
inspection.redundant.array.creation.display.name=创建冗余阵列
inspection.redundant.array.creation.for.varargs.call.descriptor=创建冗余阵列叫可变参数的方法
inspection.redundant.array.creation.quickfix=移除数组创建显式
inspection.redundant.explicit.close=冗余 'close()'
inspection.redundant.null.check.always.fail.message=Null 检查始终失败\: {0} 永不为 null
inspection.redundant.null.check.fix.family.name=移除冗余 null 检查
inspection.redundant.null.check.fix.notnull.family.name=移除错误的 '\!\= null'
inspection.redundant.null.check.message=冗余 null 检查\: {0} 永不为 null
inspection.redundant.operation.on.empty.array.message=数组 <code>\#ref</code> 始终为空
inspection.redundant.operation.on.empty.collection.message=集合 <code>\#ref</code> 始终为空
inspection.redundant.operation.on.empty.container.display.name=空容器上存在冗余操作
inspection.redundant.operation.on.empty.map.message=映射 <code>\#ref</code> 始终为空
inspection.redundant.record.constructor.can.be.compact.message=规范构造函数可以转换为压缩形式
inspection.redundant.record.constructor.canonical.message=冗余规范构造函数
inspection.redundant.record.constructor.compact.message=冗余压缩构造函数
inspection.redundant.record.constructor.description=冗余记录构造函数
inspection.redundant.record.constructor.fix.family.name=将规范构造函数转换为压缩形式
inspection.redundant.record.constructor.statement.message=压缩构造函数中存在冗余字段赋值
inspection.redundant.stream.optional.call.explanation.at.most.one=流最多包含一个元素
inspection.redundant.stream.optional.call.explanation.distinct=链中已经存在一个'distinct'的调用
inspection.redundant.stream.optional.call.explanation.distinct.set=收集到集时，元素将保持不重复
inspection.redundant.stream.optional.call.explanation.filter=判定始终为 true
inspection.redundant.stream.optional.call.explanation.map.flatMap=上一个 'map' 调用可以替换 'flatMap' 步骤
inspection.redundant.stream.optional.call.explanation.parallel=后面的''{0}''调用覆盖了这个调用
inspection.redundant.stream.optional.call.explanation.parallel.single=从单个元素创建的流不会并行化
inspection.redundant.stream.optional.call.explanation.sorted=后面的''{0}''调用使排序无效
inspection.redundant.stream.optional.call.explanation.sorted.twice=之后再对流内容排序
inspection.redundant.stream.optional.call.explanation.unordered=链中已经存在一个'unordered'的调用
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=收集到 'LinkedHashSet'
inspection.redundant.stream.optional.call.fix.family.name=移除冗余的调用链
inspection.redundant.stream.optional.call.fix.name=移除''{0}''调用
inspection.redundant.stream.optional.call.message=冗余的''{0}''调用
inspection.redundant.stream.optional.call.option.streamboxing=报告Stream.map中无用的装箱
inspection.reflect.handle.invocation.argument.not.array=参数不是数组类型
inspection.reflect.handle.invocation.argument.not.exact=参数类型应该是''{0}''
inspection.reflect.handle.invocation.primitive.argument.null=类型''{0}''的参数不能为''null''
inspection.reflect.handle.invocation.receiver.incompatible=回调接收类型不兼容\: ''{0}''
inspection.reflect.handle.invocation.receiver.null=回调的接收是'null'
inspection.reflect.handle.invocation.result.not.assignable=应该被转换为''{0}''或其超类
inspection.reflect.handle.invocation.result.not.exact=应该被转换为''{0}''
inspection.reflect.handle.invocation.result.null=返回值总是'null'
inspection.reflect.handle.invocation.result.void=返回类型为'void'
inspection.reflection.invocation.argument.count={0,choice,0\#没有|1\#1个|1<{0}个}参数是预期的
inspection.reflection.invocation.argument.not.assignable=参数不能分配给''{0}''
inspection.reflection.invocation.array.not.assignable=数组项目具有不兼容的类型
inspection.reflection.invocation.item.count={0,choice,0\#空数组|1\#1个数组项|1<{0}个数组项}是预期的
inspection.reflection.invocation.item.not.assignable=数组项不能分配给''{0}''
inspection.reflection.invocation.name=反射调用参数不匹配
inspection.reflection.member.access.cannot.resolve.constructor.arguments=无法使用指定的参数类型解析构造函数
inspection.reflection.member.access.cannot.resolve.field=无法解析字段''{0}''
inspection.reflection.member.access.cannot.resolve.method=无法解析方法''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=无法使用指定的参数类型解析方法''{0}''
inspection.reflection.member.access.check.exists=检查该字段/方法是否存在于非 final 类中
inspection.reflection.member.access.check.exists.exclude=排除类
inspection.reflection.member.access.check.exists.exclude.chooser=类是排除的
inspection.reflection.member.access.constructor.not.public=构造函数不为 public
inspection.reflection.member.access.field.not.in.class=字段''{0}''未在类''{1}''中声明
inspection.reflection.member.access.field.not.public=字段 ''{0}'' 不为 public
inspection.reflection.member.access.fix.family.name=使用适当的反射方法
inspection.reflection.member.access.method.not.in.class=方法''{0}''未在类''{1}''中声明
inspection.reflection.member.access.method.not.public=方法 ''{0}'' 不为 public
inspection.reflection.member.access.name=反射访问不存在/不可见的类成员
inspection.reflection.visibility.name=跨模块问题的反射访问
inspection.remove.literal.underscores.display.name=数字文字中的下划线
inspection.remove.literal.underscores.family.name=从数字文字中移除下划线
inspection.replace.methodref.ternary.quickfix=替换为空检查的lambda
inspection.replace.ternary.quickfix=替换为''{0}\!\= null吗?''
inspection.replace.with.bulk.fix.family.name=替换大量方法调用
inspection.replace.with.bulk.fix.name=用大量的''{0}''调用替换迭代
inspection.replace.with.bulk.message=迭代可以用大量的''{0}''调用替换
inspection.replace.with.bulk.wrap.arrays=使用 Arrays.asList() 来包装数组
inspection.replace.with.enhanced.switch.statement.fix.name=替换为增强的 'switch' 语句
inspection.replace.with.old.style.switch.statement.fix.name=替换为旧式 'switch' 语句
inspection.replace.with.regular.string.literal.fix=替换为正则字符串文字
inspection.replace.with.switch.expression.fix.name=替换为 'switch' 表达式
inspection.replace.with.text.block.fix=替换为文本块
inspection.replace.with.trivial.lambda.fix.family.name=替换为普通 lambda
inspection.replace.with.trivial.lambda.fix.name=替换为返回 ''{0}'' 的 lambda
inspection.require.non.null=将 null 检查替换为 Objects/Stream static 调用
inspection.require.non.null.description=Null 检查可以替换为方法调用
inspection.require.non.null.message=用对象替换条件.{0}
inspection.require.non.null.no.warning.replacement.bigger=替换长度大于原始长度时不发出警告
inspection.return.separated.from.computation.descriptor=返回与 ''{0}'' 的值的计算分离
inspection.return.separated.from.computation.family.quickfix=将'返回'更接近结果的计算
inspection.return.separated.from.computation.name=返回与结果的计算分离
inspection.return.separated.from.computation.quickfix=将“return”更接近计算''{0}''的值
inspection.same.parameter.display.name=实际的方法的参数是相同的
inspection.same.parameter.fix.family.name=内联参数为常量值
inspection.same.parameter.fix.name=内联值''{1}''参数''{0}''
inspection.same.parameter.problem.descriptor=实际的参数值 ''{0}'' 永远是 ''{1}''
inspection.scope.for.title=范围
inspection.simplifiable.comparator.comparing.message=不必要的 ''{0}()'' 调用
inspection.simplifiable.comparator.display.name=可以简化比较运算符
inspection.simplifiable.comparator.entry.comparator.message=可以改用 ''{0}''
inspection.simplifiable.comparator.fix.comparing.family.name=移除冗余调用
inspection.simplifiable.comparator.fix.entry.comparator.family.name=使用预定义的 Map.Entry 比较运算符
inspection.simplifiable.comparator.fix.remove.name=移除 ''{0}()'' 调用
inspection.simplifiable.comparator.fix.replace.name=移除 ''{0}()'' 调用并使用 ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=简化将 'max' 替换为 'min' 的比较运算符
inspection.simplifiable.comparator.fix.reversed.name=替换为简化比较运算符的 ''{0}''
inspection.simplifiable.comparator.reversed.message=如果 ''{0}()'' 调用替换为 ''{1}()''，则可以简化比较运算符
inspection.simplify.collector.fix.family.name=简化级联器
inspection.simplify.collector.fix.name=使用''Collectors.{0}''收集
inspection.simplify.collector.message=可以使用''{0}''收集简化
inspection.simplify.foreach.display.name=可简化的 forEach() 调用
inspection.sorted.collection.with.non.comparable.keys.display.name=包含不可比较元素的排序集合
inspection.sorted.collection.with.non.comparable.keys.message=包含不可比较元素的排序集合的构造
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=不报告不可比较的类型参数
inspection.surround.if.family=环绕用if语句
inspection.surround.if.quickfix=环绕用''if({0}\!\= null)''
inspection.suspicious.list.remove.display.name=循环中的可疑 'List.remove()'
inspection.switch.expression.backward.expression.migration.inspection.name='switch' 表达式可以替换为旧式 'switch' 语句
inspection.switch.expression.backward.migration.inspection.name=新式 'switch' 可以替换为旧式语句
inspection.switch.expression.backward.statement.migration.inspection.name='switch' 语句可以替换为旧式 'switch' 语句
inspection.switch.expression.migration.inspection.name=语句可以替换为增强的 'switch'
inspection.switch.expression.migration.inspection.switch.description=Switch 语句可以替换为增强的 'switch'
inspection.switch.expression.migration.warn.only.on.expression=仅在可以转换为表达式时显示警告
inspection.switch.labeled.rule.can.be.code.block.display.name=标记的 switch 规则可以具有代码块
inspection.switch.labeled.rule.can.be.code.block.expression.message=标记规则的结果表达式可以使用代码块包装
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=使用代码块包装标记规则的结果表达式
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=使用代码块包装标记规则的语句
inspection.switch.labeled.rule.can.be.code.block.statement.message=标记规则的语句可以使用代码块包装
inspection.text.block.backward.migration.message=文本块可以转换为正则字符串文字
inspection.text.block.backward.migration.name=文本块可以替换为正则字符串文字
inspection.text.block.migration.message={0} 可以替换为文本块
inspection.text.block.migration.name=可以使用文本块
inspection.text.block.migration.suggest.literal.replacement=建议将字符串替换为换行符
inspection.undeclared.service.usage.message=服务 ''{0}'' 的使用未在模块信息中声明
inspection.undeclared.service.usage.name=服务的使用未在 'module-info' 中声明
inspection.unused.assignment.option=报告 ++i 何时可以替换为 (i + 1)
inspection.unused.assignment.option1=报告 i++ 变更后的值后不被使用
inspection.unused.assignment.option2=报告冗余初始化器
inspection.unused.assignment.problem.descriptor1=变量{0}从未使用
inspection.unused.assignment.problem.descriptor2=变量初始化{0}{1}是冗余的
inspection.unused.assignment.problem.descriptor3={0}的值分配给{1}是从未使用过
inspection.unused.assignment.problem.descriptor4=在{0}更改的值是不会被使用的
inspection.unused.assignment.remove.assignment.quickfix=删除冗余分配
inspection.unused.assignment.remove.quickfix=移除冗余的初始化器
inspection.unused.parameter.composer=参数 <code>\#ref</code> 不用于任何实现
inspection.unused.parameter.composer1=参数 <code>\#ref</code> 不用于此方法或其任何衍生方法
inspection.unused.parameter.delete.quickfix=删除未使用的参数
inspection.unused.return.value.display.name=未使用的方法返回值
inspection.unused.return.value.make.void.quickfix=使方法无效
inspection.unused.return.value.problem.descriptor=方法的返回值是从未使用过
inspection.unused.symbol.check.accessors=Getter/Setter
inspection.unused.symbol.check.classes=类\:
inspection.unused.symbol.check.fields=字段\:
inspection.unused.symbol.check.inner.classes=内部类\:
inspection.unused.symbol.check.localvars=检查局部变量(&L)
inspection.unused.symbol.check.methods=方法\:
inspection.unused.symbol.check.parameters=检查参数\:
inspection.variable.assigned.to.itself.display.name=变量是分配给自己
inspection.wrapper.type.may.be.primitive.fix.name=将包装器类型转换为基元类型
inspection.wrapper.type.may.be.primitive.name=类型可能是基元
intention.add.explicit.type.arguments.family=添加显式类型参数
intention.add.on.demand.static.import.family=添加按需静态导入
intention.add.on.demand.static.import.text=为 ''{0}'' 添加按需静态导入
intention.add.single.member.import.text=对''{0}''添加导入
intention.add.single.member.static.import.family=添加单成员静态导入
intention.add.single.member.static.import.text=为 ''{0}'' 添加静态导入
intention.assign.field.from.parameter.family=分配参数场
intention.assign.field.from.parameter.text=分配参数字段''{0}''
intention.bind.fields.from.parameters.family=绑定参数字段
intention.bind.fields.from.parameters.text={0}参数绑定到字段
intention.break.string.on.line.breaks.text=打破字符串 '\n'
intention.compose.function.family=用组合替换嵌套函数调用
intention.compose.function.text=替换嵌套函数调用和替换后的调用
intention.convert.color.representation.family=转换颜色表示
intention.convert.color.representation.text=转换为''新颜色{0}''
intention.convert.compact.constructor.to.canonical=将压缩构造函数转换为规范构造函数
intention.convert.to.basic.latin=转换为基本的拉丁
intention.convert.to.single.return.name=将正文转换成单个出口点形式
intention.create.field.from.parameter.family=创建字段参数
intention.create.field.from.parameter.text=创建字段参数''{0}''
intention.create.test.dialog.choose.super.class=选择超类
intention.create.test.dialog.class.name=类名\:
intention.create.test.dialog.fix.library=修复
intention.create.test.dialog.generate=生成\:
intention.create.test.dialog.java=Java
intention.create.test.dialog.library.not.found={0}库在该模块中未找到
intention.create.test.dialog.select.methods=生成的测试方法\:
intention.create.test.dialog.setUp=set&Up/@Before
intention.create.test.dialog.show.inherited=显示继承的方法
intention.create.test.dialog.super.class=超类\:
intention.create.test.dialog.tearDown=tear&Down/@After
intention.create.test.dialog.testing.library=测试库\:
intention.encapsulate.field.text=封装领域
intention.error.cannot.create.class.message=无法创建类''{0}''
intention.error.cannot.create.class.title=创建类失败
intention.extract.if.condition.family=提取if条件
intention.extract.if.condition.text=提取if({0})
intention.extract.map.step.family=提取分离映射方法
intention.extract.map.step.text=提取变量''{0}''到''{1}''操作
intention.extract.method.text=提取方法
intention.extract.set.from.comparison.chain.duplicates={0} 在此类中检测到 {1} 个可以使用新创建的集替换的代码{1,choice,1\#段|2\#段}。要替换{1,choice,1\#它|2\#它们}吗?
intention.extract.set.from.comparison.chain.family=从比较链提取Set集合 
intention.family.add.javadoc=添加 Javadoc
intention.family.convert.0.path.to.1=将 {0} 路径转换为 {1}
intention.family.copy.abstract.method.implementation=复制 abstract 方法实现
intention.family.create.a.class.in.package=在包中创建类
intention.family.edit.method.contract=编辑方法约定
intention.family.edit.range=编辑范围
intention.family.expand.static.import=展开静态导入
intention.family.fix.bounded.wildcards=修复有界通配符
intention.family.make.external.annotations.explicit=使外部注解为显式
intention.family.make.inferred.annotations.explicit=使推断的注解为显式
intention.family.move.it=移动它
intention.family.put.arguments.on.one.line=将参数放在同一行上
intention.family.put.arguments.on.separate.lines=将参数放在单独的行上
intention.family.put.parameters.on.one.line=将参数放在同一行上
intention.family.put.parameters.on.separate.lines=将参数放在单独的行上
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=将 Optional.isPresent() 条件替换为函数样式表达式
intention.family.sort.content=对内容进行排序
intention.family.swap.if.statements=交换 'if' 语句
intention.family.unimplement.interface.class=取消实现接口/类
intention.family.variable.access.from.inner.class=可变的 accessFromInnerClass
intention.implement.abstract.class.default.text=实现 abstract 类
intention.implement.abstract.class.family=实现 abstract 类或接口
intention.implement.abstract.method.command.name=实现方法
intention.implement.abstract.method.error.no.classes.message=没有发现这类方法可以实现
intention.implement.abstract.method.error.no.classes.title=没有找到的类
intention.implement.abstract.method.family=实现 abstract 方法
intention.implement.abstract.method.searching.for.descendants.progress=寻找的后代...
intention.implement.abstract.method.text=实现方法 ''{0}''
intention.inline.map.family=内联流映射方法
intention.inline.map.inline.text=内联''{0}''的内容进入下一个''{1}''的调用
intention.inline.map.merge.text=合并''{0}''的调用与''{1}''的调用
intention.introduce.variable.text=引入局部变量
intention.invert.if.condition=Invert 'if' condition
intention.merge.filter.family=合并过滤器
intention.merge.filter.text=合并过滤器链
intention.move.field.assignment.to.declaration=移动指派到字段声明
intention.move.initializer.to.constructor=移动到构造函数初始化器
intention.move.initializer.to.set.up=初始化设置移动方法
intention.override.method.text=重写方法 ''{0}''
intention.replace.cast.with.var.family=用变量替换转换
intention.replace.cast.with.var.text=用''{1}''替换''{0}''
intention.replace.concatenation.with.formatted.output.family=更换连接与格式化输出
intention.replace.concatenation.with.formatted.output.text=用'java.text.MessageFormat.format()'替换'+'
intention.split.declaration.assignment.text=拆分为声明和赋值
intention.split.declaration.family=拆分声明
intention.split.filter.family=拆分过滤器
intention.split.filter.text=拆分为过滤器链
intention.split.if.family=分裂如果
intention.split.if.text=拆分为 2 个 'if'
intention.split.switch.branch.with.several.case.values.copy.text=复制 'switch' 分支
intention.split.switch.branch.with.several.case.values.family=将包含多个 case 值的 switch 分支拆分成单独的 'switch' 分支
intention.split.switch.branch.with.several.case.values.split.text=拆分 'switch' 分支的值
intention.surround.resource.with.ARM.block=使用 try-with-resources 环绕
intention.surround.with.ARM.block.template=try-with-resources
intention.text.add.method.contract.to.0=将方法约定添加到 ''{0}''
intention.text.add.range.to.0=将范围添加到 ''{0}''
intention.text.annotate.externally=在外部注解
intention.text.collapse.repeating.annotations=折叠重复注解
intention.text.convert.path.to.0=将路径转换为 {0}
intention.text.create.a.class.in.0=在 ''{0}'' 中创建类
intention.text.edit.method.contract.of.0=编辑 ''{0}'' 的方法约定
intention.text.edit.range.of.0=编辑 ''{0}'' 的范围
intention.text.fix.method.0.parameters.with.bounded.wildcards=修复包含有界通配符的方法 ''{0}'' 参数
intention.text.generate.missed.test.methods=生成缺少的测试方法
intention.text.insert.0.annotation=插入 ''{0}''
intention.text.replace.implements.with.static.import=将实现替换为静态导入
intention.text.replace.static.import.with.qualified.access.to.0=将静态导入替换为 {0} 的限定访问
intention.text.unimplement.0=取消实现{0}
intention.unroll.loop.family=展开循环
intention.unwrap.else.branch=解开'else'分支
intention.unwrap.else.branch.changes.semantics=解开'else'分支 (变化的语义)
intention.use.single.member.static.import.text=对 ''{0}'' 使用静态导入
intention.wrap.with.unmodifiable=使用不可修改的集合或映射包装
intention.wrap.with.unmodifiable.list=使用不可修改的列表包装
intention.wrap.with.unmodifiable.map=使用不可修改的映射包装
intention.wrap.with.unmodifiable.set=使用不可修改的集包装
interface.not.allowed=不允许接口
java.auto.import.options.title=Java
java.line.markers=Java 行标记
java.preview.features.accept.notification.link=应用更改
java.preview.features.alert.title=实验性功能警报
java.preview.features.legal.notice=您必须接受测试版 Java 规范的法律通知条款才能启用对“{0}”的支持。<br/><br/><b>根据 Java Community Process (JCP) 开发的早期规范草案的实现仅用于测试和评估目的，与 JCP 的任何规范都不兼容。</b>{1}
java.preview.features.notification.message=较新的 IDE 版本可能会停止支持预览功能
java.preview.features.notification.title=Java 预览功能
java.preview.features.warning=Java {0} 发布时，对 {1} (预览) 语言级别的支持可能会下降
java.terms.annotation.interface=@接口
java.terms.class=类
java.terms.record=记录
java.terms.constructor=构造函数
java.terms.enum=枚举
java.terms.exception=异常
java.terms.expression=表达式
java.terms.instance.initializer=实例化初始器
java.terms.interface=接口
java.terms.label=标签
java.terms.module=模块
java.terms.of.annotation.type=注释类型{1}的{0}
java.terms.of.anonymous.class=匿名类的{0}
java.terms.of.class=类{1}的{0}
java.terms.of.enum=枚举{1}的{0}
java.terms.of.interface=接口{1}的{0}
java.terms.record.component=记录组件
java.terms.static.initializer=static 初始值设定项
java.terms.type.parameter=类型参数
java.terms.variable.of.method={0}of{1}
javadoc.candidates.not.found=<html>没有候选人发现方法调用<b>{0}</b>.</html>
javadoc.constructor.candidates=<html>新的候选 <b>{0}</b>() 是\:<br>{1}</html>
javadoc.deprecated=过时的
javadoc.description.copied.from.class=描述复制从类\:
javadoc.description.copied.from.field=描述复制从字段\:
javadoc.description.copied.from.interface=描述复制从接口\:
javadoc.generate.arguments=其它命令行参数 (&O)\:
javadoc.generate.exited=\njavadoc退出,退出代码$EXIT_CODE$\n
javadoc.generate.heap.size=最大堆大小(Mb) (&M)\:
javadoc.generate.include.jdk.library.sources.in.sourcepath.option=在 -sourcepath 中包含 JDK 和库源
javadoc.generate.link.to.jdk.documentation.option=链接到 JDK 文档 (使用 -link 选项)
javadoc.generate.locale=区域设置(&L)\:
javadoc.generate.no.classes.in.selected.packages.error=选定的范围不包含Java类
javadoc.generate.no.jdk.path=未指定JDK路径\n不能生成JavaDoc
javadoc.generate.open.in.browser=生成文档并用浏览器打开 (&G)
javadoc.generate.options.hierarchy=生成层次结构树
javadoc.generate.options.index=生成索引
javadoc.generate.options.index.per.letter=每个字母单独的索引
javadoc.generate.options.navigator=生成导航栏
javadoc.generate.output.directory=输出目录 (&D)\:
javadoc.generate.output.directory.browse=浏览输出目录
javadoc.generate.sources.progress=寻找资源来生成Javadoc
javadoc.generate.tag.list.deprecated=已废弃列表
javadoc.generate.temp.file.error=无法创建临时文件
javadoc.generate.title=生成JavaDoc
javadoc.method.in.class={0}在类{1}里边
javadoc.method.in.interface={0}在界面{1}里面
javadoc.method.overrides=重写\:
javadoc.method.specified.by=指定的\:
javadoc.option.automatically.insert.closing.tag.javadoc=自动插入结束标记
javadoc.option.javadoc.title=JavaDoc
javadoc.see.also=请参阅\:
javadoc.settings.title=Javadoc 问题
javadoc.since=自从\:
javadoc.author=作者\:
javadoc.version=版本：
javadoc.apiNote=API 说明\:
javadoc.implNote=实现说明\:
javadoc.implSpec=实现要求\:
javadoc.type.parameters=类型参数\:
jrt.node.short=[JRT]
label.add.math.max.0.count.to.avoid.possible.semantics.change=添加 Math.max(0, count) 以避免可能的语义变更
label.class.filter.editor.add.dialog.filter.pattern=输入过滤器模式\:
label.contract=约定\:
label.enter.fully.qualified.class.name=输入完全限定类名
label.entry.points=入口点\:
label.forbid.api.usages=禁止使用 API\:
label.from.inclusive=起始 (包含)\:
label.implementation=实现\:
label.implements.method.of_class_or_interface.name=实现{0} {1} ''{2}''。
label.implements.method.of_interfaces=以下类/接口的实现方法\:
label.maximal.reported.method.visibility=报告方法最大可见性\:
label.method=''{0}''方法
label.minimal.reported.method.usage.count=报告方法最小使用计数\:
label.minimal.reported.method.visibility=最小报告方法可见性\:
label.mutates=变异\:
label.name.prefix=名称前缀\:
label.name.suffix=名称后缀\:
label.naming.field=字段\:
label.naming.local.variable=局部变量\:
label.naming.parameter=参数\:
label.naming.static.field=static 字段\:
label.naming.subclass=子类\:
label.naming.test.class=测试类\:
label.overrides.method.of_class_or_interface.name=重写{0} {1} ''{2}''。
label.show.import.popup.for=为下列对象显示导入弹出窗口\:
label.to.inclusive=结束 (包含)\:
label.unused.declaration.reachable.from.tests.option=当入口点位于测试源中时，将被调用方标记为\:
line.marker.recursive.call=递归调用
line.marker.type.external.annotations=外部注释
line.marker.type.inferred.contract.annotations=推断约定注解
line.marker.type.inferred.nullability.annotations=推断可空性注解
listbox.import.package=包
listbox.import.static=static
listbox.import.with.subpackages=以及子包
macro.array.variable=arrayVariable()
macro.cast.to.left.side.type=castToLeftSideType()
macro.class.name=类名
macro.classname=类名()
macro.classpath.entry=该元素所属的类路径中的条目
macro.component.type.of.array=componentTypeOf(Array)
macro.current.package=currentPackage()
macro.descendant.classes.enum=descendantClassesEnum(String)
macro.expected.type=expectedType()
macro.expression.type=expressionType(Expression)
macro.file.fully.qualified.package=文件完全合格包
macro.file.package=文件包
macro.guess.element.type.of.container=guessElementType(Container)
macro.iterable.component.type=iterableComponentType(ArrayOrIterable)
macro.iterable.variable=iterableVariable()
macro.javadoc.output.directory=JavaDoc输出目录
macro.method.parameters=methodParameters()
macro.methodname=methodName()
macro.project.classpath=项目的类路径
macro.qualified.class.name=qualifiedClassName()
macro.right.side.type=rightSideType()
macro.suggest.first.variable.name=suggestFirstVariableName()
macro.suggest.index.name=suggestIndexName()
macro.suggest.variable.name=suggestVariableName()
macro.variable.of.type=variableOfType(Type)
methods.to.implement.chooser.title=选择实现的方法
methods.to.override.chooser.title=选择要重写的方法
methods.to.override.implement.chooser.title=选择覆盖/实施的方法
module.not.in.requirements=要求模块''{0}''中不能存在模块''{1}''
module.package.not.exported=模块''{0}''不会将包''{1}''导入到模块''{2}''
module.package.not.open=模块''{0}''不会打开模块''{2}''的包''{1}''
module.type.java.description=Java模块用于开发<b>基于JVM的</b>桌面和Web应用程序, 包括应用程序,使用<b>Java EE</b>和其它企业的开发框架.
module.type.java.name=Java模块
navigate.to.duplicate.fix=导航到重复位置
no.methods.overriding.0.are.found=没有重写方法 {0, choice, 0\#|1\# ''{1}''|2\#这些类} 被发现
no.patterns=没有类模式配置
node.call.hierarchy.unknown.jsp=未知的jsp
node.hierarchy.java.lang.object=所有类都派生自java.lang.Object
notification.navigation.to.overriding.classes=索引更新时无法导航到重写类
notification.navigation.to.overriding.methods=索引更新时无法导航到重写方法
notification.text.full.thread.dump.was.successfully.copied.to.clipboard=已成功将完整线程转储复制到剪贴板
nullable.notnull.annotations.panel.title={0}注解
nullable.notnull.annotations.runtime.instrumentation.tooltip=为非空注解的方法和参数添加运行时断言
nullable.notnull.configuration.dialog.title=可空/非空配置
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=导航到'null'参数用法
nullable.stuff.inspection.navigate.null.argument.usages.view.name=''null'' 参数{0}的参数用法
offline.inspections.jdk.not.found={0}未找到
offline.inspections.library.urls.were.not.resolved=未解析模块 ''{2}'' 中库 ''{1}'' 的根 {0}
offline.inspections.library.was.not.resolved=请配置库''{0}''用于模块''{1}''
offline.inspections.no.source.roots=未检测到模块 ''{0}'' 的源根
options.java.attribute.descriptor.abstract.class=类和接口//abstract 类
options.java.attribute.descriptor.abstract.method=方法//abstract 方法
options.java.attribute.descriptor.annotation.attribute.name=注解//注解属性名称
options.java.attribute.descriptor.annotation.name=注解//注解名称
options.java.attribute.descriptor.anonymous.class=类和接口//匿名类
options.java.attribute.descriptor.class=类和接口//类
options.java.attribute.descriptor.constructor.call=方法//构造函数调用
options.java.attribute.descriptor.constructor.declaration=方法//构造函数声明
options.java.attribute.descriptor.enum=类和接口//枚举
options.java.attribute.descriptor.implicit.anonymous.parameter=参数//隐式的匿名类参数
options.java.attribute.descriptor.inherited.method=方法//继承的方法
options.java.attribute.descriptor.instance.field=类字段//实例字段
options.java.attribute.descriptor.instance.final.field=类字段//实例 final 字段
options.java.attribute.descriptor.interface=类和接口//接口
options.java.attribute.descriptor.javadoc.comment=注释//JavaDoc//文本
options.java.attribute.descriptor.javadoc.markup=注释//JavaDoc//标记
options.java.attribute.descriptor.javadoc.tag=注释//JavaDoc//标签
options.java.attribute.descriptor.javadoc.tag.value=注释//JavaDoc//标签值
options.java.attribute.descriptor.lambda.parameter=参数//Lambda参数
options.java.attribute.descriptor.method.call=方法//方法调用
options.java.attribute.descriptor.method.declaration=方法//方法声明
options.java.attribute.descriptor.method.imported.call=方法//static 导入方法调用
options.java.attribute.descriptor.reassigned.local.variable=变量//重新分配局部变量
options.java.attribute.descriptor.reassigned.parameter=参数//重新分配参数
options.java.attribute.descriptor.static.field=类字段//static 字段
options.java.attribute.descriptor.static.final.field=类字段//常量(static final 字段)
options.java.attribute.descriptor.static.final.imported.field=类字段//常量 (static final 导入字段)
options.java.attribute.descriptor.static.imported.field=类字段//静态导入字段
options.java.attribute.descriptor.static.method=方法//static 方法
options.java.attribute.descriptor.type.parameter=类和接口//类型参数
options.java.display.name=Java
override.implement.broken.file.template.message=请更正“重写/实现的方法体”模板
override.implement.broken.file.template.title=文件模板错误
package.dependencies.production.node.text=生产类
package.dependencies.test.node.text=测试类
paste.class.command.name=粘贴类 ''{0}''
please.report.a.bug=请报告错误
popup.title.choose.framework=选择框架
popup.title.choose.test=选择测试
popup.title.select.a.jar.file=选择 JAR 文件
popup.title.select.qualified.name=选择限定名称
postfix.template.language.level.title=最低语言级别\:
press.0.to.see.inheritors.of.1=按 {0} 以查看 {1} 的继承者
press.0.to.see.non.imported.classes=按 {0} 以查看未导入的类
pressing.0.twice.without.a.class.qualifier=不使用类限定符，按 {0} 两次会显示所有可访问的 static 方法
project.problems.hint.text={0} 个相关{0, choice, 0\#问题|2\#问题}
project.problems.window.title={0} 的相关问题
project.problems.fix.text=显示相关问题
project.problems.fix.description=发现与 ''{0}'' 相关的问题
project.problems.title=相关问题
project.problems.settings=设置...
progress.creating.class=创建类{0}
progress.title.check.applicability=检查可用性…
progress.title.download.library.descriptor=下载库描述符
progress.title.find.references.in.implement.extends.lists=在实现/展开列表中查找引用…
progress.title.finding.cause=正在查找原因
progress.title.looking.for.jdk.locations=正在查找 JDK 位置…
progress.title.looking.for.libraries=正在查找库
progress.title.optimize.imports=优化导入...
progress.title.preprocess.usages=预处理用法
progress.title.search.for.overriding.methods=搜索重写方法…
progress.title.searching.for.sub.classes=正在搜索子类
prompt.choose.base.class.of.the.hierarchy=选择层次结构基类,搜索
prompt.create.non.existing.package=包{0}不存在,是否创建它?
prompt.delete.class=个类
prompt.delete.field=个字段
prompt.delete.interface=个接口
prompt.delete.method=个方法
prompt.delete.package=个包
prompt.delete.type.parameter=个类型参数
prompt.do.you.want.to.action_verb.the.method.from_class=要改为{0}基{1,choice,1\#方法|2\#方法}吗?
psi.search.overriding.progress=搜索覆盖方法
quickfix.add.variable.family.name=初始化变量
quickfix.add.variable.text=初始化变量 ''{0}''
quickfix.family.avoid.mutation.using.stream.api=使用 Stream API 避免变异
quickfix.family.change.javadoc.to=更改为 ...
quickfix.family.find.cause=查找原因
quickfix.family.remove.javadoc.tag=移除标记
quickfix.family.remove.redundant.parameter=删除冗余参数
quickfix.family.remove.redundant.parameter.types=删除冗余参数类型
quickfix.family.replace.cast.type=替换转换类型
quickfix.family.replace.inefficient.stream.count=替换低效的 Stream.count()
quickfix.family.replace.optional.chain.with.if.statements=将 Optional 链替换为 if 语句
quickfix.family.replace.stream.api.chain.with.loop=将 Stream API 链替换为循环
quickfix.family.replace.with.java.stream.api.pipeline=替换为 Java Stream API 管道
quickfix.family.replace.with.magic.constant=替换为魔术常量
quickfix.family.replace.with.method.reference=替换为方法引用
quickfix.family.replace.with.optional.of.nullable.chain=替换为 Optional.ofNullable() 链
quickfix.family.replace.with.stream.api.equivalent=替换为 Stream API 对等项
quickfix.family.simplify.foreach.lambda=简化 forEach lambda
quickfix.family.simplify.stream.call.chain=简化流调用链
quickfix.family.use.flatmap=使用 'flatMap'
quickfix.family.wrap.with.mutable.collection=使用可变集合包装
quickfix.name.find.jar.on.web=在 web 上查找 JAR
quickfix.text.0.may.not.work.before.jdk.11.0.2={0} (可能无法在 JDK 11.0.2 之前的版本上运行)
quickfix.text.avoid.mutation.using.stream.api.0.operation=使用 Stream API ''{0}'' 操作避免变异
quickfix.text.remove.javadoc.0.1=移除 @{0} {1}
quickfix.text.remove.not.null.annotation=移除非空注解
quickfix.text.replace.0.stream.with.1.2=将 {0}.stream() 替换为 {1}.{2}()
quickfix.text.replace.collect.0.with.1.2=将 ''collect({0}())'' 替换为 ''{1}''{2}
quickfix.text.replace.filter.0.is.present.with.any.match=将 ''filter().{0}().isPresent()'' 替换为 ''anyMatch()''
quickfix.text.replace.stream.0.with.1.2=将 ''stream().{0}()'' 替换为 ''{1}()''{2}
quickfix.text.suffix.may.change.semantics=\ (可能更改语义)
quickfix.text.wrap.0.with.1=用 ''{1}'' 包装 ''{0}''
radio.button.higher.than=高于\:
radio.button.respecting.to.project.language.level.settings=遵循项目语言级别设置
radio.button.subclass.of.0=''{0}'' 的子类
radio.button.unused.declaration.unused.option=未使用
radio.button.unused.declaration.used.option=已使用
radio.button.with.provider.method=带有 'provider()' 方法
radio.use.fully.qualified.class.names.in.javadoc=使用Javadoc中完全合格的类名\:
radio.use.fully.qualified.class.names.in.javadoc.always=始终
radio.use.fully.qualified.class.names.in.javadoc.if.not.imported=如果尚未导入
radio.use.fully.qualified.class.names.in.javadoc.never=切勿使用短名称添加导入
scope.hierarchy={0}的层次结构
sdk.cannot.create=无法创建SDK
sdk.java.no.classes=无法在''{0}''中找到JDK classes
section.title.inspection.suspicious.names.ignore.methods=忽略方法
set.language.level=设置语言级别
set.language.level.to.0=设置语言级别为{0}
settings.inlay.java.annotations=<html>注释</html>
settings.inlay.java.builder.like.methods=类似于构建器的方法
settings.inlay.java.complex.expressions.binary.functional.array.access.and.other=复杂的表达式\: 二进制、函数、数组访问以及其他
settings.inlay.java.enum.constants=枚举常量
settings.inlay.java.external.annotations=外部注释
settings.inlay.java.inferred.annotations=推断注释
settings.inlay.java.inheritors=继承者
settings.inlay.java.insert.annotation=插入注解
settings.inlay.java.method.chains=方法链
settings.inlay.java.implicit.types=隐式类型
settings.inlay.java.methods.with.same.named.numbered.parameters=包含相同名称的编号参数的方法
settings.inlay.java.minimal.unique.type.count.to.show.hints=显示提示的最小唯一类型计数
settings.inlay.java.new.expressions='New' 表达式
settings.inlay.java.non.literals.in.case.of.multiple.parameters.with.the.same.type=在具有相同类型的多个参数的情况下的非文字
settings.inlay.java.parameters.with.names.that.are.contained.in.the.method.name=具有方法名称中包含的名称的参数
settings.inlay.java.show.hints.for=显示提示\:
settings.inlay.java.show.parameter.hints.for=为以下对象显示参数提示\:
settings.inlay.java.show.parameter.hints.when.expression.type.is.clear.description=数组初始值设定项、switch、条件、引用、实例、赋值、调用、限定、类型转换、类对象访问表达式。
settings.inlay.java.turn.off.external.annotations=关闭外部注解
settings.inlay.java.turn.off.inferred.annotations=关闭推断注解
settings.inlay.java.usages=用法
show.import.popup.for.classes=&类
show.import.popup.for.static.methods.and.fields=Static 方法和字段(&S)
exclude.import.wildcard.comment=使用 * 通配符排除指定类或包的所有成员
special.annotations.annotations.list=额外的特别注释
special.annotations.list.add.annotation.class=添加注解类
special.annotations.list.annotation.class=注解类
special.annotations.list.annotation.pattern=添加注解模式
spi.extension.error.message=注册的扩展应实现{0}
spi.file.type.description=服务提供程序接口
spi.no.provider.error.message=未找到服务提供程序“{0}”
status.bar.overridden.methods.highlighted.message=找到{0}重写方法  (按{1}再次移除高亮显示, Esc移除所有高亮)
surround.with.dowhile.template=do / while
surround.with.for.template=for
surround.with.ifelse.expression.template=if (expr) {...} else {...}
surround.with.not.instanceof.template=\!(表达式实例类型)
surround.with.runnable.template=Runnable
surround.with.synchronized.template=同步
surround.with.try.catch.finally.template=try / catch / finally
surround.with.try.catch.incorrect.template.message=无效的文件模板,用于catch body
surround.with.try.catch.incorrect.template.title=环绕用try-catch
surround.with.try.catch.template=try / catch
tab.title.entry.points=入口点
tab.title.members.to.report=要报告的成员
table.cell.constructors=构造函数
title.cannot.create.class=无法创建类
title.import.layout=导入布局
title.javadoc=JavaDoc
title.naming=命名
title.naming.final.modifier=final 修饰符
title.naming.functional.expressions=Lambda 正文
title.package.not.found=包未找到
title.packages=包
title.packages.to.use.import.with=使用‘*’导入包
to.import.a.method.statically.press.0=要静态导入方法，请按 {0}
unscramble.detect.analyze.threaddump.from.clipboard.item=自动检测和分析复制到 IntelliJ IDEA 以外的剪贴板的线程转储
unscramble.log.path.label=日志文件\: (&L)
unscramble.no.unscrambler.item=<不整理>
unscramble.normalize.button=标准化 (&N)
unscramble.stacktrace.caption=把一个堆栈跟踪或一个完整的线程堆转储在这里\:
unscramble.unscrambled.deadlock.tab=<死锁>
unscramble.unscrambled.stacktrace.tab=<堆栈跟踪>
unscramble.unscrambled.threaddump.tab=<线程>
unscramble.unscrambler.combobox=解码器\: (&S)
unscramble.use.unscrambler.checkbox=堆栈跟踪 (&U)
unwrap.anonymous=开启 'anonymous...'
unwrap.array.initializer=开启数组初始值设定项
unwrap.conditional=开启 'f ? a \: b'
unwrap.lambda=取消 'lambda...' 换行
unwrap.synchronized=解开 'synchronized...'
usage.target.exception=异常
usage.target.package.in.directory={0} (在 {1} 中)
use.external.annotations=使用外部注释 (&E)
wrapping.annotation.parameters=注解参数
wrapping.record.components=记录组件
wrapping.text.blocks=文本块
wrong.package.statement=错误的包语句
title.lenses=Code Vision
highlight.throws.popup.throwing.places=引发 {0} 的位置
highlight.throws.popup.usages={0} 的用法
psi.error.incorrect.class.template.message=不能创建{0} - {1}模板不正确。
presentable.text.anonymous.class=匿名类
presentable.text.code.from.context=代码从{0}
presentable.text.code.display=代码
progress.text.0.1.resolving.2={0}/{1}\: 正在解析 {2}
progress.title.resolving.files=正在解析文件…
inspection.simplify.for.each.replace=替换为 {0}
inspection.simplify.for.each.extract.intermediate.operations=提取中间操作
inspection.message.can.be.replaced.with.files.writestring=可以替换为 'Files.writeString()'
inspection.notnull.field.not.initialized.message=必须初始化 {0} 字段
highlight.throws.class.name=高亮显示 Throws {0}
class.patterns.panel.add.class=添加类
multiple.usages.of.static.import.found=已找到静态导入的多个用法
external.annotations.roots=注解根
inspection.stream.api.migration.can.be.replaced.with.call=可以替换为 ''{0}'' 调用
highlight.suppressed.warnings.choose.inspections=选择检查以高亮显示此项中的已抑制问题
inspection.magic.constants.should.be.one.of.values=应当为以下之一\: {0}{1,choice,0\#|1\#或其组合}
live.template.context.consumer.function=使用者函数
live.template.context.statement=声明
live.template.context.expression=表达式
live.template.context.declaration=声明
inspection.unused.display.name=未使用的声明
inspection.empty.method.display.name=空方法
inspection.unused.assignment.display.name=未使用的赋值
inspection.dependency.display.name=非法的包依赖关系
inspection.unchecked.warning.display.name=未经检查的警告
inspection.convert.2.streamapi.display.name=可以通过 Stream API 折叠循环
inspection.optional.to.if.display.name=Optional 可以替换为 if 语句的序列
inspection.stream.to.loop.display.name=Stream API 调用链可以替换为循环
inspection.anonymous.2.method.ref.display.name=匿名类型可以替换为方法引用
inspection.convert.2.method.ref.display.name=lambda 可以替换为方法引用
inspection.lambda.can.be.method.call.display.name=lambda 可以替换为方法调用
inspection.functional.expression.can.be.folded.display.name=函数表达式可以折叠
inspection.trivial.functional.expression.usage.display.name=函数表达式的普通用法
inspection.magic.constant.display.name=魔术常量
inspection.static.pseudo.functional.style.method.display.name=使用 static 类的伪函数表达式
inspection.overwritten.key.display.name=覆盖的 Map 键或 Set 元素
inspection.collection.add.all.can.be.replaced.with.constructor.display.name=冗余的 'Collection.addAll()' 调用
inspection.manual.min.max.calculation.display.name=手动最小值/最大值计算
inspection.explicit.array.filling.display.name=显式数组填充
inspection.java.8.collection.remove.if.display.name=循环可以替换为 Collection.removeIf()
inspection.java.8.map.api.display.name=可以使用单个 Map 方法
inspection.string.repeat.can.be.used.display.name=可以使用 String.repeat()
inspection.read.write.string.can.be.used.display.name=可以使用 'Files.readString()' 或 'Files.writeString()'
inspection.java.9.collection.factory.display.name=不可变集合创建可以替换为集合工厂调用
inspection.explicit.argument.can.be.lambda.display.name=显式参数可以是 lambda
inspection.excessive.lambda.usage.display.name=过度使用lambda
inspection.redundant.stream.optional.call.display.name=Stream 或 Optional 调用链中存在冗余步
inspection.obvious.null.check.display.name=使用明显非空参数调用 null 检查方法
inspection.simplify.stream.api.call.chains.display.name=可以简化 Stream API 调用链
inspection.simplify.optional.call.chains.display.name=可以简化 Optional 调用链
inspection.simplify.collector.display.name=可以简化收集器
inspection.use.bulk.operation.display.name=可以使用批量操作代替迭代
inspection.comparator.combinators.display.name=可以使用 Comparator 连结符
inspection.replace.inefficient.stream.count.display.name=以 count() 结尾的低效 Stream API 调用链
inspection.redundant.lambda.parameter.type.display.name=冗余 lambda 参数类型
inspection.wrapper.type.may.be.primitive.display.name=包装器类型可能是基元
inspection.optional.get.without.is.present.display.name=在不进行 isPresent() 检查的情况下调用 Optional.get()
inspection.optional.is.present.display.name=Optional.isPresent() 可以替换为函数样式表达式
inspection.conditional.can.be.optional.display.name=条件可以替换为 Optional
inspection.optional.assigned.to.null.display.name=Optional 类型的 null 值
inspection.excessive.range.check.display.name=过度范围检查
inspection.condition.covered.by.further.condition.display.name=条件由进一步的条件覆盖
inspection.move.field.assignment.to.initializer.display.name=字段赋值可以移动到初始值设定项中
inspection.test.failed.line.display.name=在测试中高亮显示问题行
inspection.frequently.used.inheritor.inspection.display.name=类可以扩展常用的基类
slice.filter.parse.error.null.filter.not.applicable.for.primitive.type=''null'' 筛选器不适用于基元类型 {0}
slice.filter.parse.error.not.null.filter.not.applicable.for.primitive.type=''\!null'' 筛选器不适用于基元类型 {0}
slice.filter.parse.error.enum.constant.not.found=未找到枚举常量\: {0}
slice.filter.parse.error.incorrect.expression=表达式不正确\: {0}
slice.filter.parse.error.incorrect.constant.type=常量类型不正确(所需类型\: {0})
slice.filter.parse.error.expression.must.evaluate.to.constant=表达式必须评估为常量\: {0}
slice.filter.parse.error.incorrect.constant.expected.number=常量不正确(应为数字)\: {0}
action.dfa.from.stacktrace.text=查找 ''{0}'' 可以是 {1} 的原因
slice.usage.message.assertion.violated=(违反断言\!)
slice.usage.message.in.file.stopped.here=(在 {0} 文件中 - 在此处停止)
slice.usage.message.tracking.container.contents=(正在跟踪容器 ''{0}{1}'' 内容)
slice.usage.message.location=在 {0} 中
intention.name.move.into.if.branches=上移至 'if' 语句分支
intention.name.collapse.into.loop=折叠至循环