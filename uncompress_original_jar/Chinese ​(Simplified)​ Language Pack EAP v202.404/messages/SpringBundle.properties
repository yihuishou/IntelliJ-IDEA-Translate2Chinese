model.property.error.message=无法解析属性 ''{0}''
model.create.factory.method.quickfix.message=创建工厂方法 ''{0}''
model.create.factory.method.quickfix.family.name=创建工厂方法
model.add.constructor.args.for.method.quickfix.message=为 ''{0}'' 添加 <constructor-arg>
model.add.constructor.args.for.method.quickfix.message.family.name=添加 <constructor-arg>
model.method.signature.parse.error.message=无法解析签名 ''{0}''
model.method.resolve.class.error.message=无法解析类 ''{0}''
model.bean.not.found.error.message=未找到名称为 ''{0}'' 的 Bean
model.method.choose.method=选择方法

model.bean.quickfix.message=创建新 Bean ''{0}''
model.bean.quickfix.message.family.name=创建新 Bean

model.inspection.display.name=Spring 模型
model.inspection.display.bean.name.convention=Spring Bean 名称惯例
model.inspection.bean.property.value=注入值类型
model.inspection.bean.constructor.arg=Constructor 标记注入
model.inspection.bean.autowiring=Spring Bean 自动装配
model.inspection.bean.dependency.check=Spring Bean 依赖关系检查
model.inspection.validator.progress.text=正在验证 Spring 模型...

scopes.inspection.display.name=Spring 范围

inspection.group.code=代码
inspection.group.setup=安装
inspection.group.xml=XML文件

model.inspection.invalid.identifier.message=''{0}'' 未遵循 bean 命名惯例
model.inspection.invalid.lowercase.name.message=''{0}'' 应以小写字母开头

model.inspection.bean.factory.method=Spring Bean 工厂方法
model.inspection.bean.public.factory.method=Spring Bean public 工厂方法
method.must.be.static=工厂方法 ''{0}'' 必须为 static
method.must.not.be.static=工厂方法 ''{0}'' 不得为 static
method.must.be.public=工厂方法 ''{0}'' 应为 public
method.cannot.instantiate.bean=工厂方法  ''{0}'' 无法实例化 Bean

bean.dependency.check.message=您必须设置 Bean 属性({0})或为此 Bean 禁用依赖关系检查

bean.autowiring.by.type.none=无法自动装配。未找到 ''{0}'' 类型的 Bean。
bean.autowiring.by.type.no.beans=无法自动装配。未找到 ''{0}'' 或 ''{1}'' 类型的 Bean。
bean.autowiring.by.type=无法自动装配。存在多个 ''{0}'' 类型的 Bean。Bean\: {1}。属性\: ''{2}''
bean.class.autowired.by.type=无法自动装配。存在多个 ''{0}'' 类型的 Bean。
bean.autowiring.by.type.no.parameter.for.autowired.method= 无参数自动装配 {0}
bean.class.autowired.incorrect.qualifier.type=无法自动装配。限定 Bean 必须为 ''{0}'' 类型。
bean.class.unknown.qualifier.bean=找不到具有限定符 ''{0}'' 的 Bean

bean.must.be.public=Bean 必须为 public
bean.bad.property.type=''{0}'' 类型的属性不能由 ''{1}'' 注入
idref.cannot.be.added.in.collection=不能添加到 ''{0}'' 类型的集合中
timeout.parsing.bean=自定义 Bean 解析时间过长
process.unexpectedly.terminated=进程意外终止{0}
try.parsing.custom.beans=尝试解析自定义 Bean

cannot.find.bean.constructor.with.parameters.count=在类 ''{0}'' 中未找到匹配的构造函数
cannot.find.factory.method.with.parameters.count=在类中未找到匹配的工厂方法

cannot.find.constructor.arg.index=找不到具有参数索引 {0} 的构造函数
cannot.find.constructor.arg.index.in.class=在类 {1} 中找不到具有参数索引 {0} 的构造函数
cannot.find.factory.method.index=在类 {1} 中找不到具有参数索引 {0} 的工厂方法

incorrect.constructor.arg.index.not.unique=索引必须唯一
constructor.arg.incorrect.value.type=注入的值类型必须对应构造函数参数类型

spring.bean=Spring Bean
spring.property=Spring 属性
spring=Spring

config.display.name=配置
config.no.contexts.defined=未定义应用程序上下文

spring.beans.dependencies=依赖

spring.bean.class.tooltip.navigate.declaration=导航到 Spring Bean 声明
navigate.to.autowired.dependencies=导航到自动装配的依赖关系
navigate.to.by.name.autowired.dependencies=导航到 'byName' 自动装配的依赖关系

spring.bean.show.beans.candidates.title=Bean 候选项

gutter.navigate.no.matching.beans=未找到匹配 Bean
spring.bean.class.navigate.choose.class.title=选择 Bean
spring.bean.property.tooltip.navigate.declaration=导航到 Spring Bean 属性
spring.bean.property.navigate.choose.class.title=选择包含属性的 Bean
spring.bean.constructor.tooltip.navigate.declaration=导航到 Spring Bean
spring.bean.constructor.navigate.choose.class.title=选择包含构造函数的 Bean
spring.bean.methods.tooltip.navigate.declaration=导航到 Spring Bean 方法声明
spring.bean.method.tooltip.navigate.declaration=导航到 Spring Bean {0} 方法声明
spring.bean.filter.tooltip=开始输入以筛选元素

config.file.not.found=找不到文件 
config.files.not.found=没找到文件
config.file.is.not.spring=此文件未识别为 Spring 配置
config.unmapped.configs.popup.title=在 {0} 中未映射的 Spring 配置文件
spring.bean.lookup.method.inspection=Lookup 方法
spring.bean.lookup.method.incorrect.return.type=Lookup 方法返回类型不正确
spring.bean.lookup.method.constructor.not.allowed=此处不允许使用构造函数
spring.bean.lookup.method.return.type.mismatch=Lookup 方法返回类型与 ''{0}'' Bean 类不匹配
spring.bean.lookup.method.bean.has.no.class=''{0}'' Bean没有类
spring.bean.lookup.method.must.be.public.or.protected=方法必须为 public 或 protected
spring.bean.lookup.method.must.have.no.parameters=方法不得有参数
spring.bean.lookup.method.must.be.not.static=此处不允许使用 static 方法

model.inspection.injection.value.style=Spring 注入值样式
model.inspection.injection.value.style.message=显式 <value> 元素的用法
model.inspection.injection.value.style.value.fix=将 <value> 元素替换为 "{0}" 属性
model.inspection.injection.value.style.value.fix.family.name=将 <value> 元素替换为属性
model.inspection.injection.value.style.ref.fix=将 <ref> 元素替换为 "{0}" 属性
model.inspection.injection.value.style.ref.fix.family.name=将 <ref> 元素替换为属性
model.inspection.injection.value.style.ref.message=显式 <ref> 元素的用法

model.intention.string.constant.move.to.placeholder=移动到占位符

spring.bean.property=特性
spring.bean.constructor.arg=构造函数参数
spring.bean.map.entry=映射条目

model.inspection.injection.value.consistency=注入值一致性
model.inspection.injection.value.message={0} 必须指定一个引用或值
spring.bean.property.value.inconsistency.ref.or.value.sub.element.must.defined=仅允许 {0} 包含 "ref" 属性或 "value" 属性或子元素
spring.bean.property.value.inconsistency.more.one.sub.element ={0} 不得包含多个子元素
spring.bean.ref.attributes.inconsistency=<ref> 标记只能包含 "bean" 属性或 "local" 属性或 "parent" 属性
spring.bean.ref.attributes.must.specify=<ref> 标记必须指定 Bean
spring.bean.idref.attributes.inconsistency=<idref> 标记只能包含 "bean" 属性或 "local" 属性
spring.bean.idref.attributes.must.specify=<idref> 标记必须指定 Bean
model.inspection.injection.value.entry.key=映射条目必须指定键
spring.bean.property.value.inconsistency.key=映射条目只能包含 "ref" 属性或 "key-ref" 属性或 <key> 子元素

model.inspection.injection.value.add.ref=添加 "ref" 属性
model.inspection.injection.value.add.list=添加 <list> 标记
model.inspection.injection.value.add.set=添加 <set> 标记
model.inspection.injection.value.add.array=添加 <array> 标记
model.inspection.injection.value.add.map=添加 <map> 标记


spring.bean.abstract.bean.references.inspection=abstract Bean 引用
spring.bean.referenced.by.abstract.bean=此处无法使用 abstract Bean

spring.bean.autowire.escape.inspection.name=自动装配的依赖关系
spring.bean.use.autowire=不必要使用自动装配的依赖关系
spring.bean.autowire.escape=将自动装配的依赖关系设为显式

spring.bean.duplicated.bean.name.inspection=重复的 Bean 名称
spring.bean.duplicate.bean.name=Bean 名称重复

spring.bean.instantiation.by.factory=Spring Bean (已由工厂 Bean 实例化)
spring.bean.instantiation.using.factory.method=Spring Bean (由 static 工厂方法实例化)
spring.import=导入
spring.generate.properties=属性...
spring.generate.setter.dependencies=Setter 依赖关系...
spring.generate.constructor.dependencies=构造函数依赖关系...
action.Spring.Beans.Generate.Setter.Dependency.Action.text=Spring Setter 依赖项...
action.Spring.Beans.Generate.Constructor.Dependency.Action.text=Spring 构造函数依赖项...
spring.bean.properties.chooser.title=选择属性
spring.bean.dependencies.chooser.title=选择 Bean
spring.beans.chooser.show.context.files=显示上下文文件
spring.beans.chooser.all.context.files=所有 Bean
spring.beans=Bean
show.properties.and.constructor.args=显示属性和构造函数参数
util.schema.inspection.name=Util 架构
util.required.class.message=类必须为 ''{0}'' 的继承者

spring.bean.instantiation.inspection=Spring Bean 实例化
mark.bean.as.abstract=将 Bean 标记为 abstract
abstract.class.not.allowed=abstract 类不允许用于非 abstract Bean
interface.not.allowed=非抽象 Bean 不允许接口

spring.parent.bean.tooltip=导航到子声明

spring.template.beans=模板 Bean

spring.patterns=框架/技术
spring.patterns.hibernate=Hibernate
spring.patterns.jdo=JDO
spring.patterns.toplink=Toplink
spring.patterns.ibatis=iBatis
spring.patterns.quartz.scheduler=OpenSymphony 计划程序
spring.patterns.jdk.timer=JDK 定时器

spring.patterns.aop.group.name=Aop
spring.patterns.data.access.group.name=数据访问
spring.patterns.integration.group.name=集成
spring.patterns.scheduling.group.name=计划
spring.patterns.common.beans.group.name=通用 Bean
spring.patterns.data.access.hibernate.session.factory=休眠会话工厂
spring.patterns.data.access.hibernate.transaction.manager=Hibernate 事务管理器

spring.patterns.data.access.jdo.persistence.manager=JDO 持久性管理器工厂
spring.patterns.data.access.jdo.jpox.persistence.manager=JPOX 持久性管理器工厂
spring.patterns.data.access.jdo.persistence.manager.proxy=JDO 持久性管理器代理
spring.patterns.data.access.jdo.transaction.manager=JDO 事务管理器

spring.patterns.data.access.toplink.session.factory=Toplink 会话工厂
spring.patterns.data.access.toplink.transaction.aware.session.adapter=Toplink 事务感知会话适配器
spring.patterns.data.access.toplink.transaction.manager=Toplink 事务管理器
spring.patterns.data.access.ibatis.client.factory=iBatis SqlMapClient 工厂

spring.patterns.data.access.data.source=数据源
spring.patterns.data.access.jndi.data.source=Jndi 数据源
spring.patterns.data.access.transaction.manager=事务管理器

spring.patterns.aop.auto.proxy.creator=AspectJ 自动代理创建者
spring.patterns.aop.auto.proxy=Aop\: AspectJ 自动代理

spring.patterns.integration.opensymphony.job.detail.bean=OpenSymphony 作业详细信息 Bean
spring.patterns.integration.opensymphony.method.invoking.factory.bean=OpenSymphony 方法调用工厂
spring.patterns.integration.opensymphony.simple.trigger=OpenSymphony 简单触发器
spring.patterns.integration.opensymphony.cron.trigger=OpenSymphony Cron 触发器
spring.patterns.integration.opensymphony.scheduler=OpenSymphony 计划程序工厂 Bean

spring.patterns.integration.jdk.scheduled.timer.task=JDK 计划的定时器任务
spring.patterns.integration.jdk.timer.factory.bean=JDK 定时器工厂 Bean
spring.patterns.integration.jdk.method.invoking.factory.bean=JDK 方法调用定时器任务工厂

spring.patterns.integration.ejb.local.stateless.session.bean=EJB 本地无状态会话 Bean
spring.patterns.integration.ejb.remote.stateless.session.bean=EJB 远程无状态会话 Bean
spring.patterns.integration.free.marker.factory.bean=Free Marker 配置工厂 Bean

spring.patterns.common.beans.placeholder=属性占位符配置器
spring.patterns.common.beans.property.override.configurer=属性覆盖配置器
spring.patterns.factory.beans.resource=资源工厂 Bean
spring.patterns.factory.beans.commons.log=通用日志工厂 Bean
spring.patterns.factory.beans.set=Set 工厂 Bean
spring.patterns.factory.beans.list=List 工厂 Bean
spring.patterns.factory.beans.map=Map 工厂 Bean
spring.patterns.factory.beans.properties=属性工厂 Bean
spring.patterns.factory.beans.field.retrieving=字段检索工厂 Bean

spring.choose.bean.templates.dialog.title=添加 {0} Bean
spring.choose.bean.templates.dialog.beans=Bean

facet.context.default.name=Spring 应用程序上下文

facet.context.xml.files=基于 XML 的配置
facet.context.code.files=基于代码的配置
facet.context.properties.files=附加属性文件
facet.context.other.files=其他文件
facet.context.autodetected.suffix= (已自动检测)
facet.context.autoconfigured.suffix= (已自动配置)

facet.context.new.title=新建应用程序上下文
facet.context.edit.title=编辑应用程序上下文 ''{0}''
facet.context.edit.name.label=名称\:
facet.context.edit.parent.label=父上下文(&P)\:
facet.context.edit.parent.none.selected=<无>
facet.context.edit.name.validation.not.empty=名称不得为空
facet.context.edit.name.validation.already.exists=具有此名称的上下文已存在。如果已删除具有此名称的现有上下文，则必须首先使用“应用”。
facet.context.edit.add.file.choose.type=选择类型

facet.context.remove.title=移除
facet.context.remove.message=是否确实要移除应用程序上下文 "{0}"? (不会删除任何文件)

config.new.file=Spring 配置
config.new.file.name=&文件名称\:
config.new.file.directory=&目录\:
create.new.spring.configuration.file=创建新的 Spring 配置文件

spring.java.configuration.inspection.cannot.find.external.bean=找不到外部 Bean
spring.java.configuration.inspection.class.type.expected=类型应为类
spring.java.configuration.inspection.incorrect.return.type.of.external.bean=返回类型不正确。应为 {0}

spring.java.configuration.inconsistency.inspection.name=Java 配置
spring.java.configuration.inspection.name=Java 配置的 @ExternalBean

framework.title.spring=&Spring

spring.facet.inspection=Spring facet XML 配置
spring.facet.code.inspection=Spring facet 代码配置
spring.facet.programmatic.inspection=Spring facet 编程配置

spring.facet.inspection.create.facet=创建 Spring facet
spring.facet.inspection.context.choose=选择应用程序上下文
spring.facet.inspection.context.create=新建应用程序上下文...
spring.facet.inspection.context.not.configured.for.file=没有为此文件配置应用程序上下文
spring.facet.inspection.configure.context.for.file=配置应用程序上下文
spring.facet.inspection.check.test.files=检查测试文件

introduce.bean.intention=引入 Bean

parse.custom.bean.intention=解析自定义 Bean
parsing.custom.bean=正在运行自定义 Spring Bean 处理程序...
parse.custom.bean.error=解析自定义 Bean 时出错
parse.custom.bean.success=自定义处理程序已成功完成
parse.no.custom.beans=解析器未生成 Bean
parse.only.infrastructure.beans=解析器仅生成架构 Bean
parse.these.beans=自定义命名空间处理程序已生成以下 Bean 定义\:\n\
{0}
parse.these.beans.induct=自定义命名空间处理程序生成以下 Bean 定义\:\n\
{0}\n\
\n\
是否要假设名称空间 ''{1}'' 中 \n\
本地名称为 ''{2}'' 的所有 Bean 具有\n\
相同的类并且从 ''{3}'' 属性获得 ID?
parse.these.beans.induct.only.this=否，仅此 Bean(&N)
parse.no.namespace.handler=找不到命名空间 ''{0}'' 的自定义处理程序
unparsed.custom.bean.inspection=未解析的自定义 Spring Bean
unparsed.custom.bean.message=尚未解析此自定义 Spring Bean
custom.bean.no.id=IntelliJ IDEA 在配置文件中找不到此 Bean 的 ID。重命名可能会生成\n\
错误的代码。是否要继续?
custom.bean.no.id.title=警告

spring.refactoring=Spring 重构
do.you.want.to.move.bean.to.the.top.level=是否要将该 Bean 移动到顶层?
move.bean.to.the.top.level=将 Bean 移动到顶层
move.bean=移动 Bean
update.schema.intention=转换为 Spring XML 架构
use.p.namespace=转换为 p-namespace
xml.schema.will.be.updated=XML 架构将更新为 spring-beans.xsd。\n\
是否要继续?
xml.schema.update.is.required=需要 XML 架构更新

model.qualifiers.in.class.inspection.display.name=自动装配 Bean 类
java.class.constructor.autowiring.inspection.display.name=Spring Bean 类构造函数中的自动装配问题
required.properties.inspection=所需注释
required.property.not.mapped=未注入所需属性 ''{0}''
create.missing.mappings=为 ''{0}'' 创建缺少的映射
create.missing.mappings.family.name=创建缺少的映射

spring.required.property.inspection=所需属性
required.properties.missed=缺少所需属性\: ''{0}''
create.missing.properties=创建缺少的属性
cannot.find.bean.qualified.by=找不到使用 {0} 限定的 Bean
cannot.autowire.bean.of.type=无法自动装配。Bean 必须为 ''{0}'' 类型
java.configuration.cannot.be.final=@Configuration 类可能不是 final
java.configuration.must.have.default.constructor=配置类必须具有默认/no-arg 构造函数
java.configuration.autowired.constructor.param=@Configuration 类可能未使用自动装配的构造函数
java.config.bean.method.cannot.return.void=@Bean 方法必须为非 void
java.config.bean.method.cannot.be.final=@Bean 方法必须为非 final
java.config.bean.method.cannot.be.private=\=@Bean 方法必须为非 private
java.config.bean.method.cannot.has.arguments=@Bean 方法可能不接受任何参数
java.config.bean.must.be.declared.inside.configuration=@Bean 方法仅在 @Configuration 注释类中声明时才有效
required.spring.bean.type.inspection=必需的 Bean 类型
placeholders.inspection.display.name=Spring 占位符

spring.incorrect.resource.type.inspection=资源类型不正确
SpringIncorrectResourceTypeInspection.incorrect.resource.type=资源类型不正确
SpringIncorrectResourceTypeInspection.expected.resource.types=资源类型不正确。预期类型\: {0}
spring.import.resource.inspection.display.name=@ImportResource 位置警告
spring.property.source.inspection.display.name=@PropertySource 和 @TestPropertySource 位置警告
spring.configuration.proxy.methods.display.name=@Configuration proxyMethods 用法警告
spring.context.configuration.inspection.display.name=@ContextConfiguration 和 @SqlConfig 警告
spring.testing.sql.inspection.display.name=@Sql 和 @SqlGroup 警告
spring.transaction.inspection.display.name=未定义的 PlatformTransactionManager
spring.lookup.inspection.display.name=@Lookup
SpringContextConfigurationInspection.cannot.find.default.app.context=找不到默认应用程序上下文文件 {0}
SpringContextConfigurationInspection.create.nested.configuration.class=创建嵌套 ContextConfiguration 类
action.generate.autowired.dependencies.action.text=@Autowired 依赖项...
SpringAutowiringInspection.add.qualifier.fix=添加限定符
context.schema.inspection.name=上下文组件扫描
ContextComponentScanInconsistencyInspection.annotation.is.expected.here=此处应为注释
spring.import.resource.error.message.trailing.space=''{0}'' 中的尾随空格

spring.profile.expression.inspection=配置文件表达式不正确
spring.profile.expression.empty=配置文件表达式必须包含文本
spring.profile.expression.malformed=配置文件表达式格式不正确

editor.panel.profiles.tooltip=活动配置文件
editor.panel.profiles.tooltip.action.name=更改配置文件...

SpringInactiveProfilesHighlightingPass.inactive.profile=非活动配置文件
spring.dom.component.scan.stereotypes=选择 Stereotype
spring.dom.component.scan.stereotypes.title=导航到组件
ContextJavaBeanUnresolvedMethodsInspection.display.name=@Configuration 和 @Bean
ContextJavaBeanUnresolvedMethodsInspection.cannot.resolve.method=无法解析方法


ActivateSpringProfileIntentionAction.activate.profile=激活配置文件 ''{0}''
ActivateSpringProfileIntentionAction.activate.profile.family.name=激活配置文件
ActivateSpringProfileIntentionAction.deactivate.profile=停用配置文件 ''{0}''
ActivateSpringProfileIntentionAction.deactivate.profile.family.name=停用配置文件

spring.app.context.to.navigate=选择应用程序上下文
spring.app.context.navigate.tooltip=导航到应用程序上下文

SpringStaticMembersAutowiringInspection.display.name=static 成员自动装配
static.members.autowiring=不自动装配 static 成员

gutter.choose.autowired.candidates.title=选择自动装配的候选项
gutter.navigate.to.autowired.candidates.title=导航到自动装配的候选项
gutter.navigate.no.matching.autowired.candidates=未找到匹配的自动装配的候选项
process.explicitly.annotated.beans=显式处理已注释的 Bean
configuration.tab.additional.settings=附加设置

multiple.context.tooltip.text=活动上下文
multiple.context.description.in.module.text=<html><body>  在模块 <b>{0}</b> 中。</body></html>
multiple.context.description.label.text=<html><body>在 <b>{0} 上下文</b>中包含文件。</body></html>
multiple.context.description.in.modules.label.text=<html><body>在 <b>{1}</b> 模块的 <b>{0} 上下文</b>中包含文件。</body></html>
class.without.matching.constructor.for.autowiring=类不包含匹配的构造函数进行自动装配
multiple.autowiring.constructor=只有一个构造函数可以具有 @Autowired 注释
springAutowiredMembersInspection.inspection=已在无效 Spring Bean 中定义自动装配的成员
class.is.not.spring.bean.autowired=必须在有效 Spring Bean 中定义自动装配的成员(@Component|@Service|...)

model.inspection.inactive.profile=非活动配置文件高亮显示
spring.bean.attributes.inspection.key=Spring Bean 属性
component.scan.setup.inspection.key=@ComponentScan 设置
custom.namespace.registration.inspection.key=Spring 自定义命名空间注册

local.model.dependencies.diagram.title=Spring 模型依赖关系
gutter.dependencies.diagram.merged.action.title= Spring 图表...

spring.event.publisher.choose.title=选择事件发布器
spring.event.publisher.tooltip.text=转到事件发布器
spring.event.publisher.empty.tooltip.text=未找到事件发布器

spring.event.listener.choose.title=选择事件侦听器
spring.event.listener.tooltip.text=转到事件侦听器
spring.event.listener.empty.tooltip.text=未找到事件侦听器
spring.cacheable.annotations.inspection.display.name=@Cacheable、@CacheEvict、@CachePut、@CacheConfig 错误
spring.cacheable.names.inspection.display.name=缓存名称定义错误
spring.cacheable.and.cache.put.on.the.same.method.display.name=在同一方法中使用 @CachePut 和 @Cacheable

spring.cacheable.annotations.on.interfaces=已在接口/接口方法上定义 Cache* 注释
cacheable.annotations.should.be.defined.on.public.methods=应在 public 方法上定义缓存注解
cacheable.no.cache.could.be.resolved.for.cache.operation= 应为每个缓存操作至少提供一个非空缓存名称。
cacheable.should.be.defined.on.concrete.method=Spring 不建议使用 @Cache* 注释对接口方法进行注解
cacheable.and.cache.put.on.the.same.method=Spring 不建议在同一方法上使用 @CachePut 和 @Cacheable 注释
event.listener.method.parameters.count=方法必须最多只有一个参数
event.listener.method.visibility.public=使用 @EventListener 注解的方法必须为 public
event.listener.method.visibility.nonstatic=使用 @EventListener 注释的方法必须为非 static

spring.cacheable.element.choose.title=选择可缓存操作
spring.cacheable.element.tooltip.text=转到同名的可缓存操作

SpringAutowiredFieldsWarningInspection.inspection.display.name=字段注入警告
field.injection.is.not.recommended=不建议使用字段注入
field.injection.create.constructor.family.warning=更改字段注入。创建构造函数
field.injection.add.parameter.family.warning=更改字段注入。向构造函数添加参数
field.injection.create.constructor.injection=<html>创建构造函数\: {0}</html>
field.injection.add.parameters=<html>向构造函数添加参数\: {0}</html>
spring.testing.context.dirties.inspection.display.name=Spring 测试 @DirtiesContext 错误
spring.testing.transactional.inspection.display.name=Spring 测试 @Transactional 错误
spring.testing.model.dirties.method.mode.error.message=在已注释的测试类上设置方法模式没有意义。 对于类级别控件，请改为使用 classMode。
spring.testing.model.dirties.class.mode.error.message=在已注释的测试方法上设置类模式没有意义。 对于方法级别控件，请改为使用 methodMode。
spring.testing.model.dirties.hierarchy.mode.error.message= 当通过 @ContextHierarchy 将上下文配置为层次结构的一部分时，应使用 hierarchyMode
spring.testing.transactional.wrong.number.of.arguments.error.message=参数数量错误
spring.testing.transactional.void.method.return.type.error.message=方法返回类型应为 'void'
ScheduledMethodInspection.inspection.display.name=使用 @Scheduled 注释的方法应为 void 和 no-arg
method.parameters.removing.fix.family.name=移除方法参数
method.parameters.removing.fix.text=将 ''{0}'' 更改为 no-arg
AsyncMethodInspection.inspection.display.name=使用 @Async 注释的方法应返回 'void' 或 "Future-like" 类型
SpringEventListenerInspection.inspection.display.name=@EventListener 配置错误
# suppress inspection "UnusedProperty"
method.return.type.make.async.family.name=更改方法以返回 "Future-like" 值
method.return.type.make.async.fix.text=更改方法以返回 ''{0}''
ImplicitSubclassInspection.display.forClass.annotated=使用 ''@{0}'' 注解的类可以隐式子类化且不得为 final
ImplicitSubclassInspection.display.forMethod.annotated=使用 ''@{0}'' 注释的方法必须可覆盖
ImplicitSubclassInspection.display.bean.in.configuration=@Configuration 中的 @Bean 方法必须可覆盖
navigate.to.fileset.configuration=导航到应用程序上下文配置

bean.method.called.from.configuration.without.proxy=使用 @Bean 注释的方法直接在 proxyBeanMethods 设置为 false 的 @Configuration 中调用。将 proxyBeanMethods 设置为 true 或使用依赖关系注入。
bean.method.called.without.proxy=直接调用使用 @Bean 注释的方法。请改为使用依赖关系注入。

action.DumpSpringConfiguration.text=转储 Spring  配置
group.Internal.Spring.text=Spring
action.SpringChangeActiveProfiles.text=更改活动 Spring 配置文件...
action.Spring.Create.Context.File.text=Spring 配置
action.Add.JdkTimer.text=添加 JDK 计时器
action.Add.OpenSymphonyTimer.text=添加 OpenSymphony 计划程序
action.Add.Ibatis.Framework.text=添加 iBatis 框架
action.Add.Toplink.Framework.text=添加 Toplink 框架
action.Add.Jdo.Framework.text=添加 JDO 框架
action.Add.Hibernate.Framework.text=添加 Hibernate 框架
group.Spring.Patterns.ActionGroup.text=模式
action.Spring.Beans.Generate.Action.text=Spring Bean

action.JpaPatternAction.text=JPA 模式

spring.settings.common=通用
spring.settings.auto.configure=允许自动配置应用程序上下文
spring.settings.configuration.file.editor=配置文件编辑器
spring.settings.profiles.panel=显示配置文件面板(&P)
spring.settings.profiles.panel.tooltip=允许选择活动配置文件
spring.settings.multiple.context.panel=显示多个上下文面板(&M)
spring.settings.multiple.context.panel.tooltip=如果在多个上下文中使用文件，则允许选择活动上下文

diagram.actions.open.beans.dependencies.text=Bean 依赖关系
diagram.actions.open.beans.dependencies.popup=Bean 依赖关系(弹出窗口)
diagram.actions.open.application.context.dependencies.popup=应用程序上下文依赖关系(弹出窗口)
diagram.actions.open.application.context.dependencies=应用程序上下文依赖关系
diagram.actions.gutter.model.dependencies.graph=模型依赖关系图
diagram.actions.gutter.model.dependencies.graph.xml=模型依赖关系图(XML)

framework.support.provider.create.empty.spring.config=创建空 {0}
fileset.editor.help.label=<html>通过 <b>\\&lt;import .../\\&gt;</b> 或 <b>@Import</b> 引用的配置文件将隐式添加。<br/>用于测试的配置文件<em>不得</em>添加到上下文。</html>
fileset.circular.dependencies=上下文之间的循环依赖关系\:<br/>{0}<br/>{1}
fileset.contains.testing.configs.short=用于测试的{0, choice, 1\#配置文件|1<{0, number} 配置文件}<em>不得</em>添加到上下文
fileset.contains.testing.configs.full=用于测试的{0, choice, 1\#配置文件|1<{0, number} 配置文件}<em>不得</em>添加到上下文\:<br/>{1}
spring.facet.validation.help.action=显示帮助
spring.facet.validation.disable.action=关闭...
spring.facet.detection.will.be.disabled.for.whole.project=将为整个项目禁用检测。\n\
请注意，如果未执行 Spring facet 配置，将无法使用大多数 Spring 相关功能。\n\
\n\
项目结构 | Facet | 检测\n\
可用于仅排除以及重新启用特定文件/文件夹。
spring.facet.config.detection=Spring 配置检测
spring.facet/detection.disable.detection=禁用检测
spring.configuration.check=Spring 配置检查
unmapped.configuration.files.short={0, choice, 1\#未映射的 Spring 配置文件|1<{0, number} 未映射的 Spring 配置文件}
unmapped.configuration.files.full={0, choice, 1\#未映射的 Spring 配置文件|1<{0, number} 未映射的 Spring 配置文件}\:<br/>{1}
unmapped.configuration.is.not.available.during.index.update= 索引更新期间 ''{0}'' 不可用
unmapped.configuration.open.facet.configuration=打开 Facet 配置
unmapped.configuration.spring.configuration=Spring 配置
unmapped.configuration.autodetected.context.found.for=已找到 {0} 的自动检测到的上下文。\n\
请检查并设置其他手动上下文(如果需要)。
scanning.for.programmatic.contexts=正在扫描编程上下文...
checking.spring.configuration=正在检查 Spring 配置
searching.unmapped.configuration.files=正在搜索未映射的配置文件...
searching.for.stereotype.usages=正在搜索 stereotype 的使用...
searching.for.implicit.usages=正在搜索隐式用法...

spring.core.autowired.annotator.name=已自动装配
spring.core.bean.annotator.name=Bean
spring.core.component.scan.annotator.name=组件扫描
spring.core.dom.annotator.name=配置(XML)
spring.core.properties.annotator.name=属性
spring.core.test.configuration.annotator.name=测试配置
spring.core.cacheable.annotator.name=同名的可缓存操作
spring.core.event.listener.annotator.name=应用程序事件

spring.model.actions.dump.model.gathering.spring.models=正在收集 Spring 模型...
spring.model.actions.dump.model.scanning.spring.models=正在扫描 Spring 模型...
spring.model.actions.dump.model.generating.json=正在生成 JSON...
spring.model.actions.generate.beans=创建 Spring Bean
custom.namespace.quick.fixes.family.name=创建自定义命名空间 Bean
custom.namespace.quick.fixes.create.custom.namespace.bean=创建自定义命名空间 Bean ({0} 个变量)...
custom.namespace.quick.fixes.create.custom.namespace.bean.with.id=创建自定义命名空间 Bean {0}
custom.namespace.quick.fixes.create.name=创建 {0}
custom.namespace.quick.fixes.popup.title=创建自定义命名空间 Bean

use.existing.quick.fixes.use.existing.bean.family.name=使用现有 Bean
use.existing.quick.fixes.use.existing.bean.from.context=使用上下文 ''{0}'' 中的现有 Bean...
use.existing.quick.fixes.choose.fix.for=为 ''{0}'' 选择修复
use.existing.quick.fixes.add.dependency.to.context=为上下文 ''{0}'' 添加依赖关系
use.existing.quick.fixes.add.spring.xml.to.fileset.action=将 ''{0}'' 添加到上下文 ''{1}''
use.existing.quick.fixes.add.import.action=为 ''{0}'' 添加 <import>
use.existing.quick.fixes.open.spring.facet.settings=打开 Spring facet 设置...

setup.programmatic.context.quick.fix.setup.spring.context=设置 Spring 上下文...
setup.programmatic.context.quick.fix.settings.displayName=Spring
setup.programmatic.context.quick.fix.context.with.name=已创建名称为 ''{0}'' 的上下文。\n\
请使用检查抑制来禁用高亮显示。\n\
\n\
要对访问者上下文重新建模，请在 Spring facet 中将其删除并移除检查抑制。\n\
\n\
是否要立即打开 Spring facet?
spring.facet.programmatic.inspection.spring.context=编程 Spring 上下文
duplicated.bean.name.inspection.name.view.duplicates=查看重复项
duplicated.bean.quick.fix.popup.title=查看重复项
UnparsedCustomBeanInspection.unsupported.tag=命名空间 ''{1}'' 不支持标记 ''{0}'' ，请提交问题(帮助|{2})
spring.diagrams.dependency.type=依赖关系类型
spring.diagrams.choose.dependency.type=选择依赖关系类型
spring.diagrams.can.t.create.dependency.for.compiled.class=无法为已编译的类创建依赖关系
spring.diagrams.compiled.class.dependency=已编译的类依赖关系
spring.diagrams.add.bean.dependencies.action=添加 Spring Bean 依赖关系
spring.diagrams.remove.edge.action=移除边缘
change.active.profile.dialog.spring.profiles=更改活动 Spring 配置文件
change.active.profile.dialog.module=模块''{0}''
change.active.profile.dialog.context=上下文 ''{0}''
SpringUpdateSchemaIntention.spring.schema.update=Spring 架构更新
SpringUpdateSchemaIntention.schema.update.failed.for.invalid.file=针对无效文件 {0} 的架构更新失败
reference.injector.spring.resource.path=Spring 资源路径
reference.injector.spring.bean.name=Spring Bean 名称
reference.injector.spring.placeholder=Spring 占位符
SpringSpiRegistrationAnnotator.choose.registration=选择注册
SpringSpiRegistrationAnnotator.tooltip=在 spring.factories 中导航到注册
SpringSpiRegistrationAnnotator.spring.factories.registration=spring.factories 注册
SpringBeansView.show.implicit.beans=显示隐式 Bean
SpringBeansView.show.infrastructure.beans=显示架构 Bean
SpringBeansView.show.modules=显示模块
SpringBeansView.show.application.contexts=显示应用程序上下文
SpringBeansView.config.no.contexts.defined=未定义应用程序上下文

application.context.configuration=应用程序上下文配置
ChangeActiveProfileDialogUi.radio.button.project=项目
ChangeActiveProfileDialogUi.radio.button.module=模块
ChangeActiveProfileDialogUi.radio.button.context=上下文
ChangeActiveProfileDialogUi.radio.button.comment=逗号分隔的配置文件列表
ChangeActiveProfileDialogUi.radio.button.profiles=配置文件\:
ChangeActiveProfileDialogUi.radio.button.scope=范围\:

SpringBeanMoveHandler.no.other.files.found=未找到其他 Spring 文件
SpringBeanMoveHandler.choose.file=选择文件

message.navigation.available.during.indexing=编制索引期间导航不可用
category.name.local.context=本地上下文
spring.dependencies.uml.action.name=依赖
category.name.show.library.models=显示库模型
category.name.show.filesets.as.groups=将文件集显示为组
dependency.node.in.module.tail= (在模块 {0} 中)

spring.el.inspection.key=Spring EL
spring.el.static.field.inpsection.key=static 字段中的 Spring EL