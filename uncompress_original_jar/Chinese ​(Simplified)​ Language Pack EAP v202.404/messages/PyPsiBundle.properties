# Message we display for inspection if user uses custom class type members that do not exist
custom.type.mimic.name=动态类基于 {0}

### Refactoring

refactoring.extract.method.error.interrupted.execution.flow=执行流中断时无法执行重构
refactoring.extract.method.error.star.import=无法使用代码块内的 star 导入语句执行重构
refactoring.extract.method.error.yield=无法使用代码块内的 'yield' 语句执行重构

### Annotators ###
ANN.deleting.none=删除 None
ANN.assign.to.none=赋值给 None
ANN.cant.assign.to.call=无法分配给函数调用
ANN.cant.delete.call=无法删除函数调用
ANN.cant.aug.assign.to.generator=无法增强分配给生成器表达式
ANN.cant.aug.assign.to.tuple.or.generator=无法增强分配给元组文字或生成器表达式
ANN.cant.assign.to.generator=无法分配给生成器表达式
ANN.cant.assign.to.operator=无法分配给运算符
ANN.cant.assign.to.parens=无法分配给 ()
ANN.cant.aug.assign.to.list.or.comprh=无法增强分配给列表文字或推导式
ANN.cant.assign.to.comprh=无法分配给列表推导式
ANN.cant.assign.to.dict.comprh=无法分配给字典推导式
ANN.cant.assign.to.set.comprh=无法分配给集合推导式
ANN.cant.aug.assign.to.comprh=无法增强分配给列表推导式
ANN.cant.aug.assign.to.dict.comprh=无法增强分配给字典推导式
ANN.cant.aug.assign.to.set.comprh=无法增强分配给集合推导式
ANN.cant.assign.to.literal=无法分配给文字
ANN.cant.delete.literal=无法删除文字
ANN.cant.assign.to.lambda=无法分配给 lambda

ANN.break.outside.loop='break' 在循环外
ANN.continue.outside.loop='continue' 在循环外

ANN.$0.assigned.before.global.decl=在全局声明前已分配名称 ''{0}''

ANN.duplicate.param.name=重复的参数名称
ANN.starred.param.after.kwparam=* 参数在 ** 参数后面
ANN.regular.param.after.vararg=正则参数在 * 参数后面
ANN.regular.param.after.keyword=正则参数在 ** 参数后面
ANN.non.default.param.after.default=默认参数后面跟随非默认参数
ANN.named.parameters.after.star=bare * 后面必须跟随命名参数
ANN.named.parameters.before.slash=命名参数必须位于 bare / 前面
ANN.tuple.py3=Python 3 中不支持元组参数解压缩
ANN.multiple.args=不允许多个 * 参数
ANN.multiple.kwargs=不允许多个 ** 参数
ANN.multiple.slash=不允许多个 / 参数
ANN.slash.param.after.vararg=/ 参数必须在 * 参数前面
ANN.slash.param.after.keyword=/ 参数必须在 ** 参数前面

ANN.star.import.at.top.only=仅在模块级别允许 'import *' 

ANN.missing.closing.quote=缺少右引号 [{0}]
ANN.missing.closing.triple.quotes=缺少右三引号

ANN.method.$0.removed.use.$1=方法 ''{0}'' 已移除，改为使用 ''{1}''
ANN.method.$0.removed=方法 ''{0}'' 已移除

### parsing
PARSE.expected.expression=表达式是预期的
PARSE.expected.rbracket=']' 预期
PARSE.expected.expr.or.comma.or.bracket=预期为表达式、',' 或 ']'
PARSE.expected.in=预期为 'in'
PARSE.expected.for.or.bracket=预期为 ']' 或 'for'
PARSE.expected.comma=',' 预期
PARSE.expected.colon='\:' 预期
PARSE.expected.rpar=')' 是预期的
PARSE.expected.lpar='(' 预期
PARSE.expected.rbrace='}' 预期
PARSE.expected.tick=预期为 '`'（反引号）
PARSE.expected.name=预期名字
PARSE.expected.colon.or.rbracket=预期为 '\:' 或 ']'
PARSE.expected.comma.or.rpar=预期为 ',' 或 ')'
PARSE.expected.else=预期为 'else'

PARSE.expected.identifier=预期为标识符
PARSE.expected.comma.lpar.rpar=预期为 ',' 或 '(' 或 ')'
PARSE.expected.statement.break=预期语句中断
PARSE.expected.@.or.def=预期为 '@' 或 'def'
PARSE.expected.formal.param.name=预期为正式参数名称
PARSE.0.expected={0}是预期的
PARSE.expected.ellipsis='...' 是预期的
PARSE.string.literal.expected=预期为字符串文字
PARSE.expected.symbols=预期为 {0} 或 {1}
PARSE.declarator.should.be.empty=声明符应为空
PARSE.string.literal=字符串文字
PARSE.newline.expected=预期为新行
PARSE.eq.expected='\=' 是预期的
PARSE.from.expected=预期为 'from'
PARSE.gt.expected='>' 预期

statement.expected.found.0=预期为语句，发现为 {0}
unexpected.indent=异常缩进
unindent.does.not.match.any.outer.indent=取消缩进不匹配任何外部缩进级别
except.or.finally.expected=应为 'except' 或 'finally'
expected.statement=预期为语句
dedent.expected=预期为向左缩进
indent.expected=预期缩进
indented.block.expected=预期为缩进的块
cannot.assign.to.yield.expression=无法分配给 'yield' 表达式
end.of.statement.expected=预期为语句结束
import.expected=预期为 'import'
def.or.with.or.for.expected=预期为 'def' 或 'with' 或 'for'
rbracket.or.comma.expected=预期为 ']' 或 ','
unexpected.expression.syntax=异常的表达式语法
tuple.expression.expected=预期为元组表达式
value.expression.expected=预期为值表达式
unexpected.expression.part=异常的表达式部分
unexpected.f.string.token=异常的格式化字符串令牌
can.t.assign.to.await.expression=无法分配给 await 表达式
for.expected=预期为 'for'
rarrow.expected='->' 预期
unexpected.tokens=意外令牌
enable.in.python.3=在 Python 3+ 中启用

PARSE.function.type.annotations.py2=Python 2 不支持类型注解
PARSE.function.return.type.annotations.py2=Python 2 不支持返回类型注解

PARSE.console.multiline.magic.warn=多行魔术不能用作表达式
PARSE.console.identifier.expected=预期为标识符.
PARSE.console.help.request.warn=名称后面必须跟随帮助请求

### quick doc generator
QDOC.module.path.unknown=（模块路径未知）
QDOC.epydoc.python2.sdk.not.found=您需要配置好的 Python 2 SDK 来呈现 <a href\='http\://epydoc.sourceforge.net/'>Epydoc</a> 文档字符串
QDOC.local.sdk.not.found=您需要配置好的本地 Python SDK 来呈现文档字符串。
QDOC.assigned.to=已分配给：
QDOC.documentation.is.copied.from=文档复制自：
QDOC.accessor.kind=访问器种类：
QDOC.raises=引发：
QDOC.keyword.args=关键字参数：
QDOC.returns=返回\:
QDOC.params=参数\:

### Formatter
formatter.panel.dict.alignment.do.not.align=不对齐
formatter.panel.dict.alignment.align.on.colon=对齐冒号
formatter.panel.dict.alignment.align.on.value=对齐值

ignore.overridden.functions=忽略被覆盖的函数

### Intentions ###

INTN.replace.octal.numeric.literal=将八进制数字文字转换为支持的形式
INTN.convert.builtin.import=将内置模块导入转换为支持的形式

INTN.Family.convert.except.part=将 except 部分转换为支持的形式
INTN.Family.convert.set.literal=将集合文字转换为支持的形式
INTN.Family.convert.builtin=转换内置模块导入
INTN.Family.convert.dict.comp.expression=转换字典推导表达式
INTN.Family.convert.string=将单引号字符串转换为双引号字符串


INTN.convert.to.from.$0.import.$1=转换为 ''from {0} import {1}''
INTN.convert.to.import.$0=转换为 ''import {0}''
INTN.convert.except.to=将 'except exceptClass, Target' 转换为 'except exceptClass as Target'
INTN.convert.set.literal.to=将集合文字转换为 'set' 方法调用


INTN.alias.for.$0.dialog.title=''{0}'' 的别名：
INTN.add.alias.for.import.$0=添加别名到 ''{0}''
INTN.remove.alias.for.import.$0=移除别名 ''{0}''

INTN.Family.migration.to.python3=迁移到 Python 3

INTN.replace.noteq.operator=替换不等运算符
INTN.convert.dict.comp.to=将字典推导式转换为 'dict' 方法调用

INTN.remove.leading.$0=移除前导 {0}
INTN.remove.leading.prefix=移除前缀

INTN.replace.backquote.expression=替换反引号表达式
INTN.replace.raise.statement=将 raise 语句转换为支持的形式

INTN.replace.list.comprehensions=将列表推导式转换为支持的形式

# PyConvertToFStringIntention
INTN.convert.to.fstring.literal=转换为格式化字符串文字
INTN.replace.with.method=替换为 str.format 方法调用

# ConvertFormatOperatorToMethodIntention
INTN.format.operator.to.method=将格式运算符用法转换为 str.format 方法调用

INTN.Family.convert.import.unqualify=将 'import module' 转换为 'from module import'
INTN.Family.convert.import.qualify=将 'from 模块 import' 转换为 'import 模块'
INTN.Family.toggle.import.alias=切换导入别名

INTN.replace.list.comprehensions.with.for=将列表推导式转换为 for 循环

INTN.replace.method=替换当前 Python 版本中不支持的方法

INTN.split.if=拆分 if
INTN.split.if.text=拆分为 2 个 if

INTN.negate.comparison=求反比较
INTN.negate.$0.to.$1=将 ''{0}'' 求反为 ''{1}''

INTN.string.concatenation.to.format=将字符串串联替换为格式运算符
INTN.replace.plus.with.format.operator=将 + 替换为字符串格式化运算符
INTN.replace.plus.with.str.format=将 + 替换为 str.format 方法调用


INTN.flip.comparison=翻转比较
INTN.flip.$0=翻转 ''{0}''
INTN.flip.$0.to.$1=将 ''{0}'' 翻转为 ''{1}''

INTN.convert.string=将单引号字符串转换为双引号字符串

INTN.join.if=联接 if
INTN.join.if.text=联接两个 if

INTN.convert.dict.constructor.to.dict.literal=将 dict 构造函数转换为文字形式
INTN.convert.dict.literal.to.dict.constructor=将 dict 文字转换为 dict 构造函数

INTN.quoted.string=在单引号字符串和双引号字符串之间转换
INTN.quoted.string.single.to.double=将单引号字符串转换为双引号字符串
INTN.quoted.string.double.to.single=将双引号字符串转换为单引号字符串

INTN.convert.lambda.to.function=将 lambda 转换为函数

INTN.convert.variadic.param=将可变参数转换为正常参数

# PyConvertTripleQuotedStringIntention
INTN.triple.quoted.string=将三引号字符串转换为单引号字符串

# PyBaseConvertCollectionLiteralIntention
INTN.convert.collection.literal.family=将集合转换为 {0}
INTN.convert.collection.literal.text=将 {0} 转换为 {1}

# PyConvertTypeCommentToVariableAnnotation
INTN.convert.type.comment.to.variable.annotation.family=将类型注释转换为变量注解
INTN.convert.type.comment.to.variable.annotation.text=转换为变量注解


INTN.demorgan.law=德摩根定律 

# PyTransformConditionalExpressionIntention
INTN.transform.into.if.else.statement=将条件表达式转换为 if/else 语句

# PyGenerateDocstringIntention
INTN.doc.string.stub=插入文档字符串存根

#SpecifyTypeInDocstringIntention
INTN.specify.type=指定文档字符串中引用的类型
INTN.specify.return.type=指定文档字符串中的返回类型
INTN.add.parameters.to.docstring=添加参数到文档字符串

#SpecifyTypeInPy3AnnotationsIntention
INTN.specify.type.in.annotation=使用注解指定引用类型
INTN.specify.return.type.in.annotation=使用注解指定返回类型

#PyAnnotateTypesIntention/PyAnnotateVariableTypeIntention
INTN.add.type.hints.for.function.family=为函数添加类型提示
INTN.add.type.hints.for.function=为函数 ''{0}'' 添加类型提示
INTN.add.type.hint.for.variable.family=为变量添加类型提示
INTN.add.type.hint.for.variable=为变量 ''{0}'' 添加类型提示
INTN.add.type.hint.for.variable.PEP484.incompatible.type=类型 ''{0}'' 不能以 PEP 484 格式内联表示

#TypeAssertionIntention
INTN.insert.assertion=插入类型断言

#PyYieldFromIntention
INTN.yield.from=将包含 'yield 的显式迭代转换为 'yield from' 表达式

#PyConvertStaticMethodToFunctionIntention
INTN.convert.static.method.to.function=将 static 方法转换为函数

#PyConvertMethodToPropertyIntention
INTN.convert.method.to.property=将方法转换为属性

#PyConvertImportIntentionAction
INTN.convert.relative.to.absolute=将相对导入转换为绝对导入
INTN.convert.absolute.to.relative=将绝对导入转换为相对导入

INTN.add.alias.title=添加别名

### Quick fixes ###
QFIX.auto.import.family=导入
QFIX.auto.import.import.this.name=导入此名称
QFIX.auto.import.import.name=导入 ''{0}''
QFIX.local.auto.import.family=本地导入
QFIX.local.auto.import.import.locally=本地 {0}
QFIX.augment.assignment=将赋值替换为增强赋值
QFIX.NAME.remove.call=移除调用
QFIX.replace.equality=替换相等
QFIX.dict.creation=替换字典创建
QFIX.NAME.remove.dict.key=移除此键
QFIX.NAME.move.except.up=上移 except 子句
QFIX.add.field.to.class=添加字段到类
QFIX.added.constructor.$0.for.field.$1=添加了 __init__ 到类 <code>{0}</code><br/>，以适应新字段 <code>{1}</code>
QFIX.NAME.remove.parameter=删除参数
QFIX.rename.parameter.to.$0=重命名为 ''{0}''
QFIX.NAME.add.field.$0.to.class.$1=添加字段 ''{0}'' 到类 {1}
QFIX.NAME.remove.statement=移除语句
QFIX.NAME.remove.target.expr=移除目标表达式
QFIX.failed.to.add.field=<br/>无法添加字段！<br/><br/>
QFIX.redundant.parentheses=移除冗余括号
QFIX.simplify.boolean.expression=简化布尔表达式
QFIX.simplify.$0=将布尔表达式替换为 ''{0}''
QFIX.chained.comparison=简化链式比较
QFIX.move.from.future.import=将 'from __future__ import' 移至正确位置
QFIX.list.creation=替换列表创建
QFIX.add.super=添加超类调用
QFIX.NAME.remove.assignment=移除赋值
QFIX.NAME.remove.argument=移除参数
QFIX.add.parameter.self=添加参数 ''{0}''
QFIX.statement.effect=替换为函数调用
QFIX.remove.trailing.semicolon=移除尾随分号
QFIX.introduce.variable=为语句引入变量
QFIX.NAME.make.list=将元组替换为列表
QFIX.NAME.add.specifier=添加格式说明符
QFIX.NAME.wrap.in.exception=使用 Exception 调用包装
QFIX.add.global=添加全局语句
QFIX.create.property=创建属性
QFIX.replace.with.type.name=替换为类型名称
QFIX.remove.function.annotations=移除函数注解
QFIX.replace.with.target.name=替换为目标名称
QFIX.remove.generic.parameters=移除泛型参数
QFIX.replace.with.square.brackets=替换为方括号
QFIX.surround.with.square.brackets=用方括号环绕
QFIX.remove.square.brackets=移除方括号
QFIX.add.property=添加此字段的属性
QFIX.use.property=使用此字段的属性
QFIX.make.public=设为 public
QFIX.NAME.update.parameters=更新参数
QFIX.rename.parameter=重命名参数
QFIX.convert.to.new.style=转换为新样式类
QFIX.change.base.class=更改基类
QFIX.classic.class.transform=从对象继承
QFIX.NAME.rename.argument=重命名参数
QFIX.NAME.add.exception.base=添加 Exception 基类
QFIX.add.encoding=添加编码声明
QFIX.remove.trailing.suffix=移除尾随后缀
QFIX.action.failed=操作失败


#PyRemoveUnderscoresInNumericLiteralsQuickFix
QFIX.NAME.remove.underscores.in.numeric=移除数字文字中的下划线

# ReplaceFunctionWithSetLiteralQuickFix
QFIX.replace.function.set.with.literal=将函数调用替换为集合文字

#RemoveArgumentEqualDefaultQuickFix
QFIX.remove.argument.equal.default=移除等于默认值的参数

#PyDefaultArgumentQuickFix
QFIX.default.argument=替换可变默认参数

#PyMoveAttributeToInitQuickFix
QFIX.move.attribute=将属性移至 __init__ 方法

#DocstringQuickFix
QFIX.docstring.add.$0=添加文档字符串参数 ''{0}''
QFIX.docstring.remove.$0=移除文档字符串参数 ''{0}''
QFIX.docstring.insert.stub=插入文档字符串
QFIX.fix.docstring=修复文档字符串

#PyMakeMethodStaticQuickFix
QFIX.NAME.make.static=将方法设为 static

#PyMakeFunctionFromMethodQuickFix
QFIX.NAME.make.function=从方法中生成函数

#ConvertIndents
QFIX.convert.indents=转换缩进
QFIX.convert.indents.to.tabs=将缩进转换为制表符
QFIX.convert.indents.to.spaces=将缩进转换为空格

# ConvertDocstringQuickFix
QFIX.convert.single.quoted.docstring=将文档字符串转换为三/双引号字符串形式

# RemoveUnnecessaryBackslashQuickFix
QFIX.remove.unnecessary.backslash=移除表达式中不必要的反斜杠

#RemoveDecoratorQuickFix
QFIX.remove.decorator=移除装饰器

#PyMakeFunctionReturnTypeQuickFix
QFIX.NAME.make.$0.return.$1=使''{0}''返回''{1}''

# Add method quick fix
QFIX.NAME.add.method.$0.to.class.$1=添加方法 {0}() 到类 {1}
QFIX.failed.to.add.method=<br/>无法添加方法！<br/><br/>
QFIX.NAME.add.function.$0.to.module.$1=在模块 {1} 中创建函数 {0}() 
QFIX.failed.to.add.function=<br/>无法添加函数！<br/><br/>
QFIX.add.method.to.class=添加方法到类

# InstallAndImportQuickFix
QFIX.install.and.import.package=安装和导入包
QFIX.NAME.install.and.import.package=安装和导入包 ''{0}''


# Actions and associated commands
ACT.CMD.use.import=使用导入的模块
ACT.qualify.with.module=使用导入的模块进行限定
ACT.from.some.module.import=从...导入


python.docstring.file.type=python 文档字符串
python.function.type.annotation.file.type.description=Python PEP-484 函数类型注释
python.docstring.format=文档字符串格式：
python.docstring.select.type=选择 Docstring 类型

### Inspections: INSP ###
INSP.GROUP.python=Python

INSP.compatibility.this.syntax.available.only.since.py3=此语法仅在 py3 以上的版本中可用
INSP.compatibility.check.for.compatibility.with.python.versions=检查与 python 版本的兼容性：
INSP.abstract.class.set.as.metaclass=设置 ''{0}'' 为元类
INSP.abstract.class.add.to.superclasses=添加 ''{0}'' 至超类
INSP.pep8.naming=PEP 8 命名惯例违规
INSP.pep8.naming.excluded.base.classes=已排除的基类
INSP.pep8.naming.ignored.errors=已忽略的错误
INSP.shadowing.builtins=隐藏内置
INSP.calling.non.callable=尝试调用不可调用的对象
INSP.dataclass.definition.and.usages=数据类定义和用法
INSP.dunder.slots=类中 __slots__ 的定义
INSP.final.classes.methods.and.variables=final 类、方法和变量
INSP.global.undefined=模块级别未定义全局变量
INSP.inconsistent.indentation=缩进不一致
INSP.named.tuple=Namedtuple 定义
INSP.shadows.name.from.outer.scope=从外部范围隐藏名称 ''{0}''
INSP.trailing.semicolon=语句中的尾随分号
INSP.raising.string.exception=引发字符串异常
INSP.protected.member.ignore.annotations=忽略注解
INSP.protected.member.ignore.test.functions=忽略测试函数
INSP.docstring.types.fix.docstring=修复文档字符串
INSP.docstring.types.change.type=将 {0} 类型从 {1} 更改为 {2}
INSP.interpreter.configure.python.interpreter=配置 Python 解释器
INSP.interpreter.interpreter.settings=解释器设置
INSP.interpreter.use.interpreter=使用 {0}
INSP.interpreter.use.suggested.interpreter=使用建议的解释器
INSP.mandatory.encoding.encoding.comment.format=编码注释格式：
INSP.mandatory.encoding.select.default.encoding=选择默认编码： 
INSP.mandatory.encoding.no.encoding.specified.for.file=未为文件指定编码
INSP.method.parameters.metaclass.method.first.argument.name=元类方法第一个参数的名称
INSP.missing.type.hints.add.type.hints=添加类型提示
INSP.missing.type.hints.add.type.hints.for=为 ''{0}'' 添加类型提示
INSP.missing.type.hints.only.when.types.are.known.collected.from.run.time.or.inferred=仅当类型已知时（从运行时收集或推断）

INSP.package.requirements.requirements.have.been.ignored=已忽略需求
INSP.package.requirements.requirement.has.been.ignored=已忽略 ''{0}''
INSP.package.requirements.add.import=添加导入
INSP.package.requirements.administrator.privileges.required=需要管理员权限
INSP.package.requirements.administrator.privileges.required.description=将包安装到 ''{0}'' 需要具备管理员权限。\n\
\n\
将每个项目的虚拟环境配置为项目解释器，\n\
以避免将包安装到文件系统的受保护区域。
INSP.package.requirements.administrator.privileges.required.button.configure=配置
INSP.package.requirements.administrator.privileges.required.button.install.anyway=仍要安装
INSP.package.requirements.requirements.file.empty=需求文件为空
INSP.package.requirements.quickfix.family.name=将导入的包添加到需求中...
INSP.pep8.ignore.base.class=忽略基类
INSP.pep8.ignore.method.names.for.descendants.of.class=忽略类后代的方法名称
INSP.shadowing.builtins.ignore.shadowed.built.in.name=忽略有阴影的内置名称
INSP.stub.packages.compatibility.ignore=忽略 ''{0}'' 兼容性
INSP.stub.packages.compatibility.ignored.packages=已忽略的存根包
INSP.stub.packages.compatibility.incompatible.packages.message=''{0}{1}{2}'' 与 ''{3}{4}{5}'' 不兼容。预期 ''{6}'' 版本\: [{7}]
INSP.arguments.not.declared.but.provided.by.decorator=以下参数未声明，而是由修饰器提供：{0}
INSP.abstract.class=类必须实现所有 abstract 方法
INSP.assigning.function.call.that.doesnt.return.anything=分配不返回任何内容的函数调用
INSP.deprecated.function.class.or.module=已弃用函数、类或模块
INSP.mandatory.encoding=未为文件指定编码
INSP.missing.type.hints=缺少函数定义的类型提示
INSP.overloads.in.regular.python.files=常规 Python 文件中的重载
INSP.pep8.coding.style.violation=PEP 8 编码样式违规
INSP.protected.member=访问类或模块的 protected 成员
INSP.protocol.definition.and.usages=协议定义和用法
INSP.shadowing.names=正在从外部范围隐藏名称
INSP.stub.packages.compatibility=存根包兼容性检查
INSP.stub.packages=存根包广播程序
INSP.type.checker=类型检查器
INSP.type.hints=类型提示定义和用法
INSP.typed.dict=TypedDict 定义和用法

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=错误的调用参数
INSP.cannot.appear.past.keyword.arg=无法显示过去的关键字参数或 *arg 或 **kwarg
INSP.unexpected.arg=异常参数
INSP.unexpected.arg(s)=异常参数
INSP.parameter.$0.unfilled=参数 ''{0}'' 未填
INSP.parameter(s).unfilled=参数未填
INSP.possible.callees=可能的被调用方
INSP.func.$0.lacks.first.arg=函数 ''{0}'' 缺乏位置参数
INSP.expected.dict.got.$0=预期为字典，得到的是 {0}
INSP.expected.iter.got.$0=预期为迭代，得到的是 {0}
INSP.more.args.that.pos.params=多个值解析为一个位置参数
INSP.multiple.values.resolve.to.positional.$0=多个值解析为一个位置参数 ''{0}''
INSP.cannot.analyze=无法分析此参数列表

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=第一个参数有问题的方法
INSP.must.have.first.parameter=方法必须有第一个参数，通常叫做 ''{0}''
INSP.probably.mistyped.self=你不是指 'self' 吗？
INSP.usually.named.self=方法的第一个参数通常叫做 'self'
INSP.usually.named.$0=这些方法的第一个参数通常叫做 ''{0}''
INSP.first.param.must.not.be.tuple=非 static 方法的第一个参数不能是元组

# PyNestedDecoratorsInspection
INSP.NAME.nested.decorators=装饰器嵌套有问题
INSP.decorator.receives.unexpected.builtin=此装饰器不会收到所预期的可调用；内置装饰器返回特殊对象

# PyRedeclarationInspection
INSP.NAME.redeclaration=已重新声明无用法的名称
INSP.redeclared.name=已重新声明上文定义的无用法的 ''{0}''

# PyUnresolvedReferencesInspection
INSP.try.except.import.error=包含 ''except ImportError'' 的 try 块中的 ''{0}'' 也应在 except 块中定义
INSP.unused.import.statement=未使用的导入语句 <code>\#ref</code>

# PyInterpreterInspection
INSP.NAME.invalid.interpreter=配置的解释器无效

# ReturnValueFromInitInspection
INSP.NAME.init.return=返回值的 __init__ 方法
INSP.cant.return.value.from.init=无法从 __init__ 返回值

# PyUnreachableCodeInspection
INSP.NAME.unreachable.code=不可到达的代码
INSP.unreachable.code=此代码无法访问

# PyStringFormatInspection
INSP.NAME.str.format=字符串格式化操作出错
INSP.format.requires.no.mapping=格式无需映射
INSP.key.$0.has.no.arg=键 ''{0}'' 没有相应的参数
INSP.unexpected.type.$0=意外类型 {0}
INSP.too.few.keys=映射键太少
INSP.no.format.specifier.char=缺少格式说明符
INSP.format.requires.mapping=格式需要映射
INSP.too.many.args.for.fmt.string=格式字符串的参数太多
INSP.too.few.args.for.fmt.string=格式字符串的参数太少
INSP.incompatible.options=块 "{0}" 中的格式选项不兼容
INSP.unused.mapping = 映射键 "{0}" 未使用
INSP.unsupported.format.character=格式字符 ''{0}'' 不受支持
INSP.manual.to.auto.field.numbering=无法从手动字段规范切换到自动字段编号
INSP.auto.to.manual.field.numbering=无法从自动字段编号切换到手动字段规范

# PyMethodOverridingInspection
INSP.NAME.method.over=方法签名与被覆盖方法的签名不匹配
INSP.signature.mismatch=方法 ''{0}'' 的签名与类 ''{1}'' 中基本方法的签名不匹配

# PyInitNewSignatureInspection
INSP.NAME.new.init.signature=__new__ 和 __init__ 的签名不兼容
INSP.new.incompatible.to.init=签名不兼容 __init__
INSP.init.incompatible.to.new=签名不兼容 __new__

# PyTrailingSemicolonInspection
INSP.NAME.trailing.semicolon=语句中的尾随分号


# PyUnboundLocalVariableInspection
INSP.NAME.unbound=未绑定的局部变量
INSP.unbound.local.variable=局部变量 ''{0}'' 可能在赋值前引用
INSP.unbound.nonlocal.variable=非局部变量 ''{0}'' 必须绑定在外部函数范围中
INSP.unbound.name.undefined=可以未定义名称 ''{0}''
INSP.unbound.function.too.large=函数 ''{0}'' 太大，无法分析

# PyListCreationInspection
INSP.NAME.list.creation=列表创建可以通过列表文字重写

# PyTupleAssignmentBalanceInspection
INSP.NAME.incorrect.assignment=元组赋值 balance 不正确

# PyClassicStyleClassInspection
INSP.NAME.classic.class.usage=经典样式类用法
INSP.classic.class.usage.old.style.class=老式类
INSP.classic.class.usage.old.style.class.ancestors=老式类，因为它所继承的所有类都是老式类


# PyExceptionInheritance
INSP.NAME.exception.not.inherit=不是从标准 'Exception' 类集成异常

# PyDefaultArgumentInspection
INSP.NAME.default.argument=默认参数可变

# PyDocstringTypesInspection
INSP.NAME.docstring.types=文档字符串中的类型与推断的类型不匹配

# PyStatementEffectInspection
INSP.NAME.statement.effect=语句无效
INSP.NAME.statement.message=语句似乎无效

# PyStringExceptionInspection
INSP.NAME.raising.string.exception=引发字符串异常

# PySuperArgumentsInspection
INSP.NAME.wrong.super.arguments=用于调用 super 的参数错误
INSP.$0.is.not.superclass.of.$1=''{0}'' 不是 ''{1}'' 的实例或子类

# PynonAsciiCharInspection
INSP.NAME.non.ascii=文件包含非 ASCII 字符

# PyMandatoryEncodingInspection
INSP.NAME.mandatory.encoding=未为文件指定编码

# PyTupleItemAssignmentInspection
INSP.NAME.tuple.item.assignment=元组项目赋值
INSP.tuples.never.assign.items=元组不支持项目赋值

# PyPropertyAccessInspection
INSP.NAME.property.access=访问属性
INSP.property.$0.cant.be.set=无法设置属性 ''{0}''
INSP.property.$0.cant.be.read=无法读取属性 ''{0}''
INSP.property.$0.cant.be.deleted=无法删除属性 ''{0}''

# PyPropertyDefinitionInspection
INSP.NAME.property.definition=属性定义
INSP.doc.param.should.be.str=doc 参数应为字符串
INSP.strange.arg.want.callable=奇怪参数；预期为可调用
INSP.func.property.name.mismatch=函数和装饰器的名称不匹配；未创建属性访问器
INSP.getter.return.smth=Getter 应返回或生成某些内容
INSP.setter.should.not.return=setter 不应返回值
INSP.deleter.should.not.return=删除程序不应返回值
INSP.getter.signature.advice=Getter 签名应为 (self)
INSP.setter.signature.advice=Setter 签名应为 (self, value)
INSP.deleter.signature.advice=删除程序签名应为 (self)
INSP.accessor.first.param.is.$0=访问器的第一个参数通常称为 ''{0}''

# PyProtectedMemberInspection
INSP.protected.member.$0.access=保护成员的访问类 {0}
INSP.protected.member.$0.access.module=访问模块的 protected 成员 {0}

# PyOldStyleClassesInspection
INSP.NAME.oldstyle.class=老式类包含新式类功能
INSP.oldstyle.class.slots=老式类包含 __slots__ 定义
INSP.oldstyle.class.getattribute=老式类包含 __getattribute__ 定义
INSP.oldstyle.class.super=老式类包含对 super 方法的调用

# PyCompatibilityInspection
INSP.NAME.compatibility=代码兼容性检查

# PyUnnecessaryBackslashInspection
INSP.NAME.unnecessary.backslash=不必要的反斜杠

# PySingleQuotedDocstringInspection
INSP.NAME.single.quoted.docstring=单引号引用的文档字符串
INSP.message.single.quoted.docstring=应对文档字符串使用三-双引号引用的字符串。

# PyMissingConstructorInspection
INSP.NAME.missing.super.constructor=缺少对超类 __init__ 的调用
INSP.missing.super.constructor.message=缺少对超类 __init__ 的调用

# PySetFunctionToLiteralInspection
INSP.NAME.set.function.to.literal=函数调用可以替换为集合文字

# PyDecoratorInspection
INSP.NAME.decorator.outside.class=类外部方法中的特定于类的装饰器

# PyPackageRequirementsInspection
INSP.NAME.requirements=包要求

# PyClassHasNoInitInspection
INSP.NAME.class.has.no.init=类没有 __init__ 方法
INSP.class.has.no.init=类没有 __init__ 方法
INSP.parent.$0.has.no.init=父级 ''{0}'' 没有 __init__ 方法

#PyNoneFunctionAssignmentInspection
INSP.NAME.none.function.assignment=分配不返回任何内容  (None) 的函数调用
INSP.none.function.assignment=函数 ''{0}'' 不返回任何内容

# PyTestParametrizedInspection
INSP.NAME.pytest-parametrized=检查由 pytest 参数化装饰的函数是否有正确的参数

# PyUnusedLocalInspection
INSP.NAME.unused=未使用本地
INSP.unused.locals.parameter.isnot.used=未使用参数 ''{0}'' 值 
INSP.unused.locals.local.variable.isnot.used=未使用局部变量 ''{0}'' 值
INSP.unused.locals.replace.with.wildcard=替换为 _
INSP.unused.locals.local.function.isnot.used=未使用局部函数 ''{0}''
INSP.unused.locals.local.class.isnot.used=未使用局部类 ''{0}''

INSP.unused.locals.ignore.variables.starting.with=忽略以 '_' 开头的变量
INSP.unused.locals.ignore.range.iteration.variables=忽略范围迭代变量
INSP.unused.locals.ignore.lambda.parameters=忽略 lambda 参数
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=忽略元组解压缩时使用的变量

# PyChainedComparsonsInspection
INSP.NAME.chained.comparisons=可以简化链式比较

# PyAugmentAssignmentInspection
INSP.NAME.augment.assignment=赋值可以替换为增强赋值

# PyBroadExceptionInspection
INSP.NAME.too.broad.exception.clauses=异常子句太宽泛

# PyByteLiteralInspection
INSP.NAME.byte.literal=字节文字包含字符 > 255

# PyComparisonWithNoneInspection
INSP.NAME.comparison.with.none=使用相等运算符执行了与 None 比较

# PyDictCreationInspection
INSP.NAME.dict.creation=字典创建可以通过字典文字进行重写

# PyDictDuplicateKeysInspection
INSP.NAME.duplicate.keys=字典包含重复键

# PyFromFutureImportInspection
INSP.NAME.from.future.import=from __future__ import 必须是第一条可执行语句

# PyMethodFirstArgAssignmentInspection
INSP.NAME.first.arg.assign=方法的第一个参数重新赋值
INSP.first.arg.$0.assigned=方法参数 ''{0}'' 已重新赋值

# PyMethodMayBeStaticInspection
INSP.NAME.method.may.be.static=方法可能为 static
INSP.method.may.be.static=方法 <code>\#ref</code> 可能为 'static'

# PyAbstractClassInspection
INSP.NAME.abstract.class=类必须实现所有 abstract 方法
INSP.NAME.abstract.class.$0.must.implement=类 {0} 必须实现所有 abstract 方法

#PyAssignmentToLoopOrWithParameterInspection
INSP.NAME.assignment.to.loop.or.with.parameter.display.name=赋值给 'for' 循环或 'with' 语句参数
INSP.NAME.assignment.to.loop.or.with.parameter.display.message=已在上面的 ''for'' 循环或 ''with'' 语句中声明变量 ''{0}''
INSP.assignment.to.loop.or.with.parameter=赋值给 'for' 循环或 'with' 语句参数

# PyArgumentEqualDefaultInspection
INSP.NAME.argument.equal.default=传递给函数的实参等于默认参数值
INSP.argument.equals.to.default=实参等于默认参数值

#PyAsyncCallInspection
INSP.NAME.coroutine.is.not.awaited=未等待协同程序 ''{0}''
INSP.async.call=未等待协同程序

# PyAttributeOutsideInitInspection
INSP.NAME.attribute.outside.init=实例属性在 __init__ 外部定义
INSP.attribute.$0.outside.init=实例属性 {0} 在 __init__ 外部定义
INSP.attribute.outside.init=实例属性在 __init__ 外部定义

# PyCallByClassInspection
INSP.NAME.different.class.call=使用不同类的实例按类调用方法
INSP.instance.of.$0.excpected=预期为 {0} 的实例，而不是类本身
INSP.passing.$0.instead.of.$1=传递 {0} 而不是 {1}。这是有意为之吗？

# PyMissingOrEmptyDocstringInspection
INSP.NAME.missing.or.empty.docstring=缺少文档字符串或为空
INSP.no.docstring=缺少文档字符串
INSP.empty.docstring=文档字符串为空

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=未解析的引用
INSP.module.$0.not.found=找不到模块 ''{0}''
INSP.unresolved.ref.$0=未解析的引用 ''{0}''
INSP.unresolved.ref.$0.for.class.$1=类 ''{1}'' 的属性引用 ''{0}'' 未解析
INSP.cannot.find.$0.in.$1=在 ''{1}'' 中找不到引用 ''{0}''
INSP.unresolved.operator.ref=类 ''{0}'' 未定义 ''{1}''，所以不能对其实例使用 ''{2}'' 运算符
python.stub=Python 存根

# PyRedundantParenthesesInspection
INSP.NAME.redundant.parentheses=冗余括号
INSP.redundant.parens.ignore.empty.lists.of.base.classes=忽略基类的空列表
INSP.redundant.parens.ignore.tuples=忽略元组
INSP.redundant.parens.ignore.argument.of.operator=忽略 % 运算符的参数

# PySimplifyBooleanCheckInspection
INSP.NAME.check.can.be.simplified=可以简化布尔变量检查
INSP.expression.can.be.simplified=可以简化表达式
INSP.simplify.boolean.check.ignore.comparison.to.zero=忽略与零的比较

# PyIncorrectDocstringInspection
INSP.NAME.incorrect.docstring=错误的文档字符串
INSP.missing.parameter.in.docstring=文档字符串中缺少参数 {0}
INSP.unexpected.parameter.in.docstring=文档字符串中的参数 {0} 异常

# PyExceptClausesOrderInspection
INSP.NAME.bad.except.clauses.order=except 子句顺序错误
INSP.class.$0.already.caught=已捕获异常类 ''{0}''
INSP.class.$0.superclass.$1.already.caught=已捕获异常类 ''{1}'' 的超类 ''{0}''

#PyGlobalUndefinedInspection
INSP.NAME.global.undefined=全局变量在模块级别未定义
INSP.NAME.global.$0.undefined=全局变量 ''{0}'' 在模块级别未定义

# PyHighlightingAnnotator
INSP.python.trailing.suffix.not.support=Python 不支持尾随 ''{0}''

# PyInterpreterInspection
python.sdk.no.interpreter.configured.owner=未为 {0} 配置 Python 解释器

# PyInspectionsSuppressor
INSP.python.suppressor.suppress.for.function=对函数禁止
INSP.python.suppressor.suppress.for.class=对类禁止
INSP.python.suppressor.suppress.for.statement=对语句禁止

find.usages.unnamed=<未命名>
find.usages.keyword.argument=关键字参数
find.usages.variable=变量
find.usages.imported.module.alias=已导入模块别名
find.usages.class=类
find.usages.function=函数
find.usages.method=方法
find.usages.parameter=参数

python.find.usages=发现用法
python.find.usages.base.method.question=方法 {0} 覆盖类 {1} 的方法。\n\
是否要查找这种基本方法的用法？
python.find.usages.usage.in.superclass.list=超类列表中的用法
python.find.usages.usage.in.isinstance=isinstance() 中的用法
python.find.usages.untyped.probable.usage=无类型（可能）用法
python.find.usages.usage.in.import.statement=导入语句中的用法
