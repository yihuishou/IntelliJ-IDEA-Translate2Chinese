# Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

########################################################################################################################
# Groovy script template
########################################################################################################################
action.groovy.scripting.shell.text=Groovy IDE 脚本 Shell
action.Mvc.RunTarget.text=运行命令
action.Mvc.RunTarget.description=运行任意 Grails/Griffon 命令
action.Mvc.Upgrade.text=更改 SDK 版本
action.Mvc.Upgrade.description=更改 Grails/Griffon SDK 版本
group.Mvc.Actions.text=Grails/Griffon
action.Groovy.Shell.text=Groovy Shell...
action.Groovy.Shell.description=启动 Groovy shell
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=操作生成 propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=操作生成 propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() 和 hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=现在操作生成 equals 和 hashCode 
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=Getter 和 Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=生成 getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=生成 setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=生成 getter
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=构造函数
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=生成构造函数
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=生成 toString() 方法
action.ExcludeFromStubGeneration.text=从存根生成中排除
action.ExcludeFromStubGeneration.description=不要在编译时为该 Groovy 文件生成 Java 存根
action.DumpGroovyControlFlowAction.text=转储 Groovy 控制流
action.ConvertToCompileStatic.text=转换为 @CompileStatic
action.ConvertToCompileStatic.description=将 Groovy 文件转换为 @CompileStatic
action.ConvertGroovyToJava.text=转换为 Java
action.ConvertGroovyToJava.description=将 Groovy 文件转换为 Java
action.Groovy.NewScript.text=Groovy 脚本
action.Groovy.NewScript.description=创建新的 Groovy 脚本
action.Groovy.NewClass.text=Groovy 类
action.Groovy.NewClass.description=创建新的 Groovy 类
action.Groovy.CheckResources.Rebuild.text=重新构建资源 (_R)
action.Groovy.CheckResources.Rebuild.description=为资源根中所有 Groovy 文件运行编译器，以检查编译问题
action.Groovy.CheckResources.Make.text=构建资源 (_B)
action.Groovy.CheckResources.Make.description=为资源根中所有 Groovy 文件运行增量编译器，以检查编译问题
group.Groovy.CheckResources.text=Groovy 资源(_O)
group.Groovy.CheckResources.description=为资源根中所有 Groovy 文件运行编译器，以检查编译问题
action.Groovy.Shell.Execute.text=执行 Groovy 代码
action.Groovy.Shell.Execute.description=在控制台中执行 Groovy 代码

file.template.group.title.groovy=Groovy

groovy.term.class=类
groovy.term.interface=接口
groovy.term.trait=特征
groovy.term.enum=枚举
groovy.term.annotation=注解
groovy.term.method=方法
groovy.term.field=字段
groovy.term.property=属性
groovy.term.parameter=参数
groovy.term.variable=局部变量
groovy.term.binding=脚本绑定变量
groovy.term.label=标签
groovy.term.closure=结束
groovy.term.expression=表达式

newclass.dlg.title=新建 Groovy 类
newclass.menu.action.text=Groovy 类
newclass.menu.action.description=创建新的 Groovy 类
newscript.dlg.prompt=输入新的 Groovy 脚本名称
newscript.menu.action.text=Groovy 脚本
newscript.menu.action.description=创建新的 Groovy 脚本
##########################################################################################################################
# GDK & compilation
########################################################################################################################

cannot.compile=无法编译
debug.option=启用调试堆栈跟踪(&D)
groovy.debug.disable.specific.methods=不单步进入特定的 Groovy 类(&I)
groovy.debug.caption=Groovy

########################################################################################################################
# Parser error messages
########################################################################################################################
identifier.expected=预期为标识符
identifier.or.block.expected=应为标识符或代码块
string.end.expected=应为字符串结尾
try.without.catch.finally='try' 没有 'catch' 或 'finally'
expression.expected=表达式预期
duplicate.modifier=重复的修饰符 ''{0}''

########################################################################################################################
# Intentions & error messages
########################################################################################################################
cannot.resolve=不能解决符号 ''{0}''
cannot.access=对 ''{0}'' 的访问超出了其访问权限
cannot.reference.static=无法引用静态符号 ''{0}''，需要类限定符
cannot.reference.non.static=无法从 static 上下文引用非静态符号 ''{0}''
cannot.return.from.constructor=无法从构造函数返回对象
cannot.return.from.void.method=无法从返回 'void' 的方法返回对象
cannot.return.type=无法从返回 ''{1}'' 的方法返回 ''{0}''
cannot.apply.method.or.closure=''{0}'' 无法应用于 ''{1}''
cannot.apply.method1=''{1}'' 中的 ''{0}'' 无法应用于 ''{2}''
cannot.apply.constructor=''{1}'' 中的构造函数 ''{0}'' 不能应用于 ''{2}''
cannot.apply.default.constructor=无法将默认构造函数应用于类 ''{0}''
cannot.instantiate.abstract.class=无法实例化 abstract 类 ''{0}''
cannot.instantiate.interface=无法实例化接口 ''{0}''
missing.required.named.parameter=缺少必需的命名参数 ''{0}''
loss.of.precision=从 ''{0}'' 到 ''{1}'' 的精度可能会损失
cannot.assign=无法将 ''{0}'' 分配给 ''{1}''
cannot.cast=不能转换''{0}''为''{1}''
multiple.assignments.without.list.expr=在静态类型检查模式下，不支持右侧没有列表表达式的多个赋值
spread.operator.is.not.available=该延展操作符在进行静态类型检查时不能用作参数
replace.with.list.literal=替换为列表文字
replace.with.get.at=替换为索引访问
incorrect.number.of.values=值的数量不正确。应为\: {0}，实际为\: {1}
invalid.lvalue=要赋予的值无效
duplicate.class=重复类\: ''{0}''
duplicate.inner.class=重复类：''{0}''
script.generated.with.same.name=为脚本代码生成了一个合成类 ''{0}''
variable.already.defined=变量''{0}''已经在作用域内定义
field.already.defined=字段 ''{0}'' 已定义
import.what=导入 ''{0}''
import.class=导入类
create.class.family.name=创建类
create.class.text=创建类 {0}
create.interface.text=创建接口 {0}
create.annotation.text=创建注解 {0}
static.declaration.in.inner.class=内部类不能有 static 声明
constructors.are.not.allowed.in.anonymous.class=匿名类中不允许使用构造函数
no.such.property=属性 ''{0}'' 不存在
change.modifier=使 ''{0}'' 成为 {1}
change.modifier.not=将 ''{0}'' 设为非 {1}
change.modifier.family.name=更改修饰符
parameter.cast.fix=将第 {0,number,ordinal} 个参数转换为 {1}
action.convert.lambda.to.closure=将 lambda 转换为闭包
add.parenthesis.to.lambda.parameter.list=将括号添加到参数列表
# suppress inspection "UnusedProperty"
packageLocal.visibility.presentation=默认可见
# suppress inspection "UnusedProperty"
protected.visibility.presentation=protected
# suppress inspection "UnusedProperty"
private.visibility.presentation=private
# suppress inspection "UnusedProperty"
public.visibility.presentation=public
# suppress inspection "UnusedProperty"
abstract.visibility.presentation=abstract
# suppress inspection "UnusedProperty"
static.visibility.presentation=static
# suppress inspection "UnusedProperty"
final.visibility.presentation=final
# suppress inspection "UnusedProperty"
native.visibility.presentation=native
# suppress inspection "UnusedProperty"
synchronized.visibility.presentation=synchronized
# suppress inspection "UnusedProperty"
strictfp.visibility.presentation=strictfp
# suppress inspection "UnusedProperty"
transient.visibility.presentation=transient
# suppress inspection "UnusedProperty"
volatile.visibility.presentation=volatile
# suppress inspection "UnusedProperty"
def.visibility.presentation=def



# {0} - colspan, {1} - method name, {2} - class name, {3} - formal myParameters row, {4} - arguments row
########################################################################################################################
# Compiler
########################################################################################################################
class.already.exists=类 ''{0}'' 已存在

illegal.combination.of.modifiers=修饰符的组合非法
illegal.combination.of.modifiers.abstract.and.final=修饰符 'abstract' 和 'final' 的组合非法
modifier.volatile.not.allowed.here=此处不允许使用修饰符 'volatile'
modifier.transient.not.allowed.here=此处不允许使用修饰符 'transient'
modifier.0.not.allowed=此处不允许使用修饰符 ''{0}''
interface.cannot.have.modifier.final=接口不能具有修饰符 'final'
script.method.cannot.have.modifier.abstract=脚本方法不能具有修饰符 'abstract'
script.cannot.have.modifier.native=脚本不能具有修饰符 'native'
interface.must.have.no.static.method=接口不得有 static 方法
only.abstract.class.can.have.abstract.method=只有 abstract 类可以具有 abstract 方法
anonymous.class.cannot.have.abstract.method=匿名类不能具有 abstract 方法
illegal.combination.of.modifiers.volatile.and.final=修饰符 'volatile' 和 'final' 的组合非法
variable.cannot.be=变量不能具有修饰符 ''{0}''
remove.modifier=移除 ''{0}''
not.abstract.method.should.have.body=abstract 方法不应有主体
cannot.create.class.error.text=无法创建类 ''{0}''\: {1}
cannot.create.class.error.title=无法创建类
no.class.in.file.template=文件模板中未找到类
error.external=外部错误
Inner.methods.are.not.supported=不支持内部方法
final.class.cannot.be.extended=无法扩展 final 类

# Groovy 1.7 checks
unsupported.inner.class.0=Groovy {0} 中不支持内部类
unsupported.anonymous.class.0=Groovy {0} 中不支持匿名类

# Groovy 1.8 checks
unsupported.diamonds.0=Groovy {0} 中不支持 diamond
unsupported.command.syntax.0=Groovy {0} 中不支持命令表达式语法
unsupported.dollar.slashy.string.0=Groovy {0} 中不支持 $/ 字符串
unsupported.multiline.slashy.string.0=Groovy {0} 中不支持多行 / 字符串

#Groovy 2.3 checks
unsupported.traits.0=Groovy {0} 中不支持特征

#Groovy 2.5 checks
duplicating.named.parameter=参数中出现重复的命名参数 ''{0}''\: {1}
field.should.be.immutable=字段 ''{0}'' 应具有不可变的类型，或者应使用 @ImmutableOptions 声明
immutable.options.property.not.exist=属性 ''{0}'' 不存在

#Groovy 3.0 checks
illegal.default.modifier=修饰符 'default' 仅在接口的方法中有意义
illegal.default.modifier.fix=移除 'default' 修饰符
default.modifier.in.old.versions=修饰符 'default' 适用于 Groovy 3.0 或更高版本
unsupported.do.while.statement=当前版本中不支持 'do while'
unsupported.tuple.declaration.in.for=当前版本不支持 'for' 初始化中的元组声明
unsupported.multiple.variables.in.for=当前版本不支持 'for' 初始化中的多个变量
unsupported.expression.list.in.for.update=当前版本不支持 'for' 更新中的多个表达式
unsupported.resource.list=当前版本不支持 'try-with-resources'
unsupported.array.initializers=当前版本不支持数组初始器
operator.is.not.supported.in=当前版本不支持运算符 ''{0}''
unsupported.negated.in=当前版本不支持否定 'in'
unsupported.negated.instanceof=当前版本不支持否定 'instanceof'
unsupported.elvis.assignment=当前版本不支持 Elvis 赋值
unsupported.safe.index.access=当前版本不支持安全索引访问
unsupported.lambda=当前版本不支持 lambda
unsupported.type.annotations=当前版本不支持类型注解
illegal.single.argument.lambda=lambda 的单参数形式仅可用作赋值表达式的右侧部分或方法调用内的参数

#Override and implement
method.is.not.implemented=方法 ''{0}'' 未实现
change.implements.and.extends.classes=标准化 extends 和 implements 列表

fix.package.name=修复包名

#dynamic properties
add.dynamic.property=添加动态属性 ''{0}''
duplicate.element.in.the.map=映射中存在重复的元素 ''{0}''
dynamic.tool.window.id=动态成员

create.field.from.usage.family.name=从用法创建字段
create.field.from.usage=创建字段 ''{0}''
create.method.from.usage.family.name=从用法创建方法
create.method.from.usage=创建方法 ''{0}''
create.variable.from.usage.family.name=从用法创建变量
create.variable.from.usage=创建变量 ''{0}''
create.parameter.from.usage.family.name=从用法创建参数
create.parameter.from.usage=创建参数 ''{0}''
add.dynamic.element=添加动态元素
add.dynamic.method=添加动态方法
dynamic.type=类型
dynamic.name=名称
dynamic.properties.table.name=方法参数
dynamic.method.return.type=返回类型(&T)\:
dynamic.method.property.type=属性类型(&T)\:
are.you.sure.to.delete.dynamic.property=确定要删除 ''{0}'' 吗''?
dynamic.property.deletion=删除动态属性
are.you.sure.to.delete.elements=确定要删除 ''{0}'' 个元素吗''?
dynamic.element.deletion=动态元素删除
tuple.cant.be.placed.in.class=不允许对字段多次赋值
unknown.class=未知类\: ''{0}''
is.not.enclosing.class=''{0}'' 不是封闭类
package.definition.cannot.have.modifiers=包定义不能具有修饰符
import.statement.cannot.have.modifiers=导入语句不能具有修饰符
undefined.label=未定义标签 ''{0}''
continue.outside.loop=在循环之外继续
break.outside.loop.or.switch=仅允许在循环或 switch 内使用 break 语句
label.already.used=标签 ''{0}'' 已在使用中
break.outside.loop=仅允许在循环内使用具有命名标签的 break 语句

Constructor=构造函数
Getter=Getter
Setter=Setter
compile.groovy.files=编译 Groovy 文件(&C)
not.allowed.modifier.in.for.in=此处不允许使用修饰符 ''{0}''
property.name.expected=应为属性名称
add.method.body=添加方法体
wildcards.are.not.allowed.in.extends.list=super 类型可能未指定通配符类型
method.does.not.override.super=方法不覆盖其超类的方法
method.duplicate=具有签名 {0} 的方法已在类 ''{1}'' 中定义
ambiguous.code.block=不明确的代码块
cyclic.inheritance.involving.0=循环继承涉及 ''{0}''
there.is.no.default.constructor.available.in.class.0=类 ''{0}'' 中没有可用的默认构造函数
groovy.library.is.not.configured.for.module=没有为模块 ''{0}'' 配置 Groovy SDK
configure.groovy.library=配置 Groovy SDK…
create.instance.of.built-in.type=内置类型的实例化
incorrect.variable.name=变量名称不正确
no.interface.expected.here=此处不应为接口
no.class.expected.here=此处不应为类
move.to.extends.list=将引用移至 extends 列表
move.to.implements.list=将引用移至 implements 列表
script.file.is.not.groovy.file=脚本文件不是 Groovy 文件
class.does.not.exist=类不存在
class.cannot.be.executed=类无法执行
invoke.completion.second.time.to.show.skipped.methods=第二次调用补全以显示跳过的方法
groovy.file.extension.is.not.mapped.to.groovy.file.type=*.groovy 文件已映射到 ''{0}''。\n您可以在“设置 | 文件类型”中将它们映射到 Groovy
class.is.not.annotation=''{0}'' 不是一个注解
method.call.is.ambiguous=方法调用不明确
operator.call.is.ambiguous=运算符调用不明确
duplicated.named.parameter=已找到重复的命名参数 ''{0}''
no.super.classes.found=未找到 super 类
no.super.method.found=未找到 super 方法
wrong.package.name=包名称 ''{0}'' 与文件路径 ''{1}'' 不符
cannot.assign.string.to.enum.0=无法将字符串分配给枚举 ''{0}''
cannot.find.enum.constant.0.in.enum.1=无法在枚举 ''{1}'' 中找到枚举常量 ''{0}''
recursive.constructor.invocation=构造函数被递归调用
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=当前不支持使用映射项表达式来初始化枚举
class.definition.is.not.expected.here=不应在此处使用类定义
move.class.0.from.method=将 ''{0}'' 移至正确位置
move.class.from.method.family.name=移至正确位置快速修复
constructor.call.is.ambiguous=构造函数调用不明确
cannot.infer.argument.types=无法推断参数类型
Equals=等号
default.initializers.are.not.allowed.in.abstract.method=abstract 方法中不允许使用默认初始值设定项
groovy.does.not.support.constructor.type.arguments=Groovy 不支持构造函数类型参数
illegal.escape.character.in.string.literal=字符串文字中的非法转义字符
add.parentheses=添加括号
method.with.type.parameters.should.have.return.type=具有类型参数的方法应具有返回类型
primitive.type.parameters.are.not.allowed=类型参数列表中不允许使用基元类型参数
primitive.bound.types.are.not.allowed=不允许使用基元限定类型
ellipsis.type.is.not.allowed.here=此处不允许使用 ellipsis 类型
method.0.is.too.complex.too.analyze=方法 ''{0}'' 过于复杂而无法分析。\n无法推断局部变量的类型。
closure.is.too.complex.to.analyze=闭包分析起来很复杂。\n无法推断局部变量的类型。
0.is.deprecated=已弃用 ''{0}''
wrong.number.of.type.arguments=类型参数的数量错误：{0}；所需数量：{1}
type.argument.0.is.not.in.its.bound.should.extend.1=类型参数 ''{0}'' 不在其界限内；应扩展 ''{1}''
catch.statement.parameter.type.should.be.a.subclass.of.throwable=catch 语句参数类型应当是 Throwable 的子类
exception.0.has.already.been.caught=已捕捉到异常 ''{0}''
unnecessary.type=不必要的异常 ''{0}''。''{1}'' 已声明
create.enum=创建枚举 {0}
create.trait=创建特征 {0}
create.inner.class=创建内部类 {0}
annotation.field.can.only.be.used.within.a.script.body=注释 @Field 只能在脚本主体内使用
annotation.field.can.only.be.used.within.a.script=注释 @Field 只能在脚本内使用
return.type.is.incompatible={1} 中 {0} 的返回类型与 {3} 中的 {2} 不兼容
anonymous.class.derived.from.0=派生自{0}的匿名类
throws.clause.is.not.allowed.in.at.interface=@interface 成员中不允许使用 'throws' 子句
at.interface.0.does.not.contain.attribute=@interface ''{0}'' 不包含特性 ''{1}''
duplicate.attribute=重复属性
missed.attributes=缺少特性\: {0}
unexpected.attribute.type.0=意外的特性类型\: ''{0}''
annotation.attribute.should.have.return.type.declaration=注释特性应具有返回类型声明
annotation.field.should.have.type.declaration=注释中的字段应具有类型声明
interface.members.are.not.allowed.to.be=接口成员不允许为 {0}
abstract.method.cannot.be.final=abstract 方法不能为 final
abstract.methods.must.not.have.body=abstract 方法不得有主体
method.has.incorrect.modifier.volatile=方法具有不正确的修饰符 'volatile'
native.methods.cannot.have.body=原生方法不能有主体
top.level.class.may.not.have.private.modifier=顶层类不能具有 'private' 修饰符
top.level.class.may.not.have.protected.modifier=顶层类不能具有 'protected' 修饰符
property.missing=propertyMissing
attribute.name.expected=应为特性名称
java.style.for.each.statement.requires.a.type.declaration=Java 样式的 for-each 语句需要类型声明
super.cannot.be.used.in.static.context='super' 不能在 static 上下文中使用
qualified.0.is.allowed.only.in.nested.or.inner.classes=仅允许在嵌套/内部类中使用限定的 {0}
groovy.file.0=Groovy 文件 ''{0}''
type.argument.list.is.not.allowed.here=此处不允许使用类型参数列表
initializers.are.not.allowed.in.interface=接口中不允许使用初始值设定项
initializer.cannot.have.annotations=初始值设定项不能有注解
initializer.cannot.be.0=初始值设定项不能为 {0}
constructors.are.not.allowed.in.interface=接口中不允许使用构造函数
type.parameters.are.unexpected=存在意外的类型参数
constructors.cannot.have.return.type=构造函数中不允许使用返回类型元素
constructor.cannot.have.static.modifier=构造函数可能不为 static
annotation.types.may.not.have.extends.clause=注释类型不能具有 'extends' 子句
annotation.types.may.not.have.implements.clause=注释类型不能具有 'implements' 子句
no.implements.clause.allowed.for.interface=接口不能具有 'implements' 子句
enums.may.not.have.extends.clause=枚举不能具有 'extends' 子句
method.0.cannot.override.method.1.in.2.overridden.method.is.final=方法 ''{0}'' 无法重写 ''{2}'' 中的方法 ''{1}''；重写的方法为 final
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=方法 ''{0}'' 的访问权限(''{1}'')不能比 ''{3}'' (''{4}'')中的 ''{2}'' 弱
tuple.declaration.should.end.with.def.modifier=元组声明应以 'def' 修饰符结尾
injection.should.not.contain.line.feeds=GString 注入不得包含换行
collection.literal.contains.named.argument.and.expression.items=集合文字同时包含命名实参和表达式实参
annotation.collector.cannot.have.attributes=使用 @AnnotationCollector 注解的注解类型不能具有特性
annotation.type.cannot.be.inner=注解类型不能是内部类型
cannot.find.operator.overload.method=无法使用参数 {0} 解析索引访问
named.arguments.are.not.allowed.inside.index.operations=索引操作内不允许使用命名实参
expected.0.to.be.inline.constant=''{0}'' 应是一个内联常量
cannot.assign.a.value.to.final.field.0=无法将值赋给 final 字段 ''{0}''
cannot.assign.a.value.to.final.parameter.0=无法将值赋给 final 参数 ''{0}''
variable.0.might.not.have.been.initialized=变量 ''{0}'' 可能尚未初始化
doc.end.expected='*/' 预期
mixing.private.and.public.protected.methods.of.the.same.name=将具有相同名称的 private 和 public/protected 方法混合
explicit.constructors.are.not.allowed.in.immutable.class=@Immutable 类不允许使用显式构造函数
repetitive.method.name.0=重复的方法名称 ''{0}''
declared.type.0.have.to.extend.script=声明的类型 ''{0}'' 不扩展 ''groovy.lang.Script'' 类
base.script.annotation.is.allowed.only.inside.scripts=注解 @BaseScript 只能在脚本内使用
delegate.annotation.is.only.for.methods.without.arguments=注解 @Delegate 无法应用于带有参数的方法
builder.annotation.not.support.super.for.simple.strategy=groovy.transform.builder.SimpleStrategy 不支持注解特性 'includeSuperProperties'
0.expressions.on.trait.fields.properties.are.not.supported.in.traits=特征中不支持特征字段/属性上的 {0} 个表达式
only.traits.expected.here=此处应仅有特征
anonymous.classes.cannot.be.created.from.traits=无法从特征创建匿名类
trait.method.cannot.be.protected=不允许 protected 特征方法
non.static.classes.not.allowed=特征中不允许使用非 static 内部类
selfType.class.does.not.inherit=@SelfType\: 类 ''{0}'' 不继承 ''{1}''
illegal.type.void=非法类型\: 'void'
illegal.method.name=方法名称包含非法字符\: {0}

select.module.description=要使用哪个模块的类路径?
select.module.title=选择模块…
### Inspection groups ###
inspection.annotations=注释验证
inspection.assignments=赋值问题
inspection.bugs=可能的错误
inspection.confusing=可能引起混淆的代码结构
inspection.control.flow=控制流问题
inspection.data.flow=数据流问题
inspection.error.handling=错误处理
inspection.gpath=GPath
inspection.naming=命名约定
inspection.method.metrics=方法度量
inspection.redundancy=声明冗余
inspection.threading=线程问题
inspection.validity=有效性问题
inspection.style=样式
inspection.other=其他
### Inspections ###
inspection.display.name.result.of.assignment.used=使用的赋值的结果
inspection.display.name.assignment.can.be.operator.assignment=可用运算符赋值替换赋值
inspection.display.name.delegates.to=@DelegatesTo 检查
inspection.display.name.unresolved.access=访问未解析的表达式
inspection.display.name.untyped.access=访问无类型的表达式
inspection.display.name.list.set.can.be.keyed.access=List.set 调用可以是键控访问 
inspection.display.name.list.get.can.be.keyed.access=List.get 调用可以是键控访问 
inspection.display.name.map.put.can.be.keyed.access=Map.put 调用可以是键控访问 
inspection.display.name.map.get.can.be.keyed.access=Map.get 调用可以是键控访问 
inspection.display.name.parameter.naming.convention=方法参数命名惯例
inspection.display.name.constant.naming.convention=常量命名惯例
inspection.display.name.instance.variable.naming.convention=实例变量命名惯例
inspection.display.name.instance.method.naming.convention=实例方法命名惯例
inspection.display.name.static.variable.naming.convention=static 变量命名惯例
inspection.display.name.static.method.naming.convention=static 方法命名惯例
inspection.display.name.local.variable.naming.convention=局部变量命名惯例
inspection.display.name.class.naming.convention=类命名惯例
inspection.display.name.groovydoc.check=GroovyDoc 问题
inspection.display.name.constructor.named.arguments=构造函数调用的命名参数
inspection.display.name.result.of.object.allocation.ignored=对象分配的结果已忽略
inspection.display.name.divide.by.zero=除以零
inspection.display.name.infinite.recursion=无限递归
inspection.display.name.infinite.loop.statement=无限循环语句
inspection.display.name.non.short.circuit.boolean=非短路布尔
inspection.display.name.duplicate.switch.branch=switch case 重复
inspection.display.name.gstring.key=GString 映射键
inspection.display.name.octal.integer=八进制整数
inspection.display.name.overly.complex.boolean.expression=过度复杂的布尔表达式
inspection.display.name.clashing.trait.methods=trait 方法冲突
inspection.display.name.overly.complex.arithmetic.expression=过度复杂的算术表达式
inspection.display.name.double.negation=双重否定
inspection.display.name.pointless.arithmetic=无意义的算术表达式
inspection.display.name.empty.statement.body=带空正文的语句
inspection.display.name.reassigned.in.closure.local.var=在闭包类或匿名类中重新分配局部变量
inspection.display.name.result.of.increment.or.decrement.used=使用增量或减量的结果
inspection.display.name.negated.if=否定 if 条件表达式
inspection.display.name.in.argument.check='in' 参数类型不兼容
inspection.display.name.negated.conditional=否定条件表达式
inspection.display.name.nested.conditional=嵌套条件表达式
inspection.display.name.conditional=条件表达式
inspection.display.name.nested.switch=switch 语句嵌套
inspection.display.name.multiple.return.points.per.method=具有多个返回点的方法
inspection.display.name.method.with.more.than.three.negations=具有三个以上否定的方法
inspection.display.name.overly.nested.method=过度嵌套的方法
inspection.display.name.overly.long.method=过长的方法
inspection.display.name.overly.complex.method=过度复杂的方法
inspection.display.name.method.parameter.count=参数过多的方法
inspection.display.name.while.loop.spins.on.field=While 循环在字段上自旋
inspection.display.name.unsynchronized.method.overrides.synchronized.method=未同步方法重写 synchronized 方法
inspection.display.name.synchronization.on.variable.initialized.with.literal=对使用文字初始化的变量同步
inspection.display.name.synchronization.on.non.final.field=对非 final 字段同步
inspection.display.name.wait.while.not.synchronized=未同步时使用 'wait()'
inspection.display.name.wait.call.not.in.loop='wait()' 不在循环中
inspection.display.name.notify.while.not.synchronized=未同步时使用 'notify()' 或 'notifyAll()'
inspection.display.name.system.run.finalizers.on.exit=System.runFinalizersOnExit() 调用
inspection.display.name.thread.stop.suspend.resume=Thread.stop()、Thread.suspend() 或 Thread.resume() 调用
inspection.display.name.nested.synchronized.statement=嵌套 'synchronized' 语句
inspection.display.name.synchronized.method=synchronized 方法
inspection.display.name.synchronization.on.this=在 'this' 上同步
inspection.display.name.empty.sync.block='synchronized' 块为空
inspection.display.name.busy.wait=忙等待
inspection.display.name.public.field.accessed.in.synchronized.context=在同步上下文中访问非 private 字段
inspection.display.name.unconditional.wait=无条件的 'wait' 调用
inspection.display.name.double.checked.locking=双重检查锁定
inspection.display.name.access.to.static.field.locked.on.instance=访问实例数据上锁定的 static 字段
inspection.display.name.change.to.method=更改为方法
inspection.display.name.change.to.operator=更改为运算符
inspection.display.name.unnecessary.alias=不必要的 import 别名
inspection.display.name.unnecessary.semicolon=不必要的分号
inspection.display.name.unnecessary.public.modifier=不必要的 'public'
inspection.display.name.unnecessary.def.modifier=不必要的 'def'
inspection.display.name.java.style.properties.invocation=Java 风格的属性访问
inspection.display.name.trivial.if=冗余的 'if' 语句
inspection.display.name.constant.if.statement=常量 if 语句
inspection.display.name.constant.conditional=常量条件表达式
inspection.display.name.trivial.conditional=冗余条件表达式
inspection.display.name.return.from.closure.can.be.implicit='return' 语句可以是隐式语句
inspection.display.name.switch.statement.with.no.default=Switch 语句没有 default case
inspection.display.name.final.variable.access=final 变量访问
inspection.display.name.unnecessary.return=不必要的 'return' 语句
inspection.display.name.unnecessary.continue=不必要的 'continue' 语句
inspection.display.name.fallthrough=switch 语句中有 fallthrough
inspection.display.name.if.statement.with.too.many.branches=If 语句的分支过多
inspection.display.name.if.statement.with.identical.branches=If 语句的分支相同
inspection.display.name.conditional.can.be.conditional.call=条件表达式可以是条件调用
inspection.display.name.conditional.can.be.elvis=函数表达式可以是 elvis
inspection.display.name.conditional.with.identical.branches=具有相同分支的条件表达式
inspection.display.name.loop.statement.that.doesnt.loop=不循环的循环语句
inspection.display.name.unreachable.statement=无法访问的语句
inspection.display.name.continue=Continue 语句
inspection.display.name.break=Break 语句
inspection.display.name.unused.catch.parameter=未使用的 catch 参数
inspection.display.name.empty.try.block=空 'try' 块
inspection.display.name.empty.finally.block=空 'finally' 块
inspection.display.name.empty.catch.block=空 'catch' 块
inspection.display.name.throw.from.finally.block='throw' 位于 'finally' 块内
inspection.display.name.return.from.finally.block='return' 位于 'finally' 块内
inspection.display.name.method.may.be.static=方法可能为 static
inspection.display.name.continue.or.break.from.finally.block='continue' 或 'break' 位于 'finally' 块内
inspection.display.name.unchecked.assignment.of.member.of.raw.type=原始类型成员的赋值未经检查
inspection.display.name.silly.assignment=不实用的赋值
inspection.display.name.nested.assignment=嵌套赋值
inspection.display.name.assignment.to.method.parameter=赋值给方法参数
inspection.display.name.assignment.to.for.loop.parameter=赋值给 for-loop 参数
inspection.display.name.assignability.check=类型赋值不兼容
inspection.display.name.type.customizer=类型自定义工具检查
inspection.display.name.unused.declaration=未使用的声明
inspection.display.name.second.unsafe.call=第二次不安全的调用
inspection.display.name.unused.assignment=未使用的赋值
inspection.display.name.unused.inc.dec=未使用的递增或递减
inspection.display.name.unassigned.access=未分配变量
inspection.display.name.no.return=缺少返回语句
inspection.display.name.clashing.getters=Getter 冲突
inspection.display.name.package.mismatch=包不匹配
inspection.display.name.deprecated.api.usage=API 检查被弃用
inspection.display.name.unnecessary.qualified.reference=不必要的限定参考
inspection.display.name.pointless.boolean=无意义的布尔表达式
inspection.display.name.access.to.inaccessible.element=访问不可访问的元素
inspection.display.name.incorrect.range.argument=范围参数不正确
inspection.display.name.new.instance.of.singleton=使用 @groovy.lang.Singleton 注解的类的新实例
inspection.display.name.check.labeled.statement=标签化语句检查
inspection.display.name.variable.can.be.final=变量可以为 final
inspection.display.name.equals.between.inconvertible.types='equals()' 位于不可转换类型的对象之间
inspection.display.name.singleton.constructor=@Singleton 构造函数
### Intention groups ###
intention.category.groovy=Groovy
intention.category.conversions=Groovy/表达式转换
intention.category.closures=Groovy/闭包
intention.category.comments=Groovy/注释
intention.category.groovy.style=Groovy/Groovy 样式
intention.category.control.flow=Groovy/控制流
intention.category.groovy.declaration=Groovy/声明
intention.category.groovy.other=Groovy/其他
configurable.GroovyCompilerConfigurable.display.name=Groovy 编译器
configurable.GantConfigurable.display.name=Gant
settings.compiler.alternative=另外，您也可以在 <a href\=\"\#\">Java 编译器页面</a> 中指定 Groovy-Eclipse 编译器
settings.compiler.select.path.to.groovy.compiler.configscript=选择 Groovy 编译器配置脚本的路径
settings.compiler.path.to.configscript=配置脚本的路径(&C)\:
settings.compiler.invoke.dynamic.support=调用动态支持(&D)
settings.compiler.exclude.from.stub.generation=从存根生成中排除\:
settings.code.style.label.indent.style=标签缩进样式：
settings.code.style.label.indent.size=标签缩进大小
settings.code.style.indent.statements.after.label=缩进标签后的语句
settings.code.style.absolute=绝对
settings.code.style.indent.labels=缩进标签
settings.inlay.parameter.types=参数类型
settings.inlay.inferred.parameter.types=推断的参数类型
settings.inlay.type.parameter.list=类型参数列表
settings.inlay.show.type.hints.for=显示其类型提示\:
checkbox.delegate.via.overloading.method=通过重载方法委托
