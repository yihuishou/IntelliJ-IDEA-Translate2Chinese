add.import=添加导入
class.to.import.chooser.title=导入类
method.to.import.chooser.title=导入方法
field.to.import.chooser.title=导入字段
access.static.via.class.reference.family=通过类引用访问 static
access.static.via.class.reference.text=通过类 ''{2}'' 引用访问 static ''{1}.{0}''
add.default.constructor.family=添加默认构造函数
add.default.constructor.text=添加 {0} 无参构造函数到 {1}
add.catch.clause.family=添加异常到catch从句
add.catch.clause.text=添加 'catch' 从句
add.finally.block.family=添加 'finally' 块
add.exception.to.throws.inherited.method.warning.text=方法''{0}''被继承.\n\
你要在整个方法的层次结构中添加方法签名的异常吗?
method.is.inherited.warning.title=方法被继承
add.exception.to.throws.text=添加{0, choice, 0\#异常|2\#异常} 到方法签名
add.exception.to.throws.family=添加异常到方法签名
add.exception.to.existing.catch.family=将异常添加到现有 catch 子句
add.exception.to.existing.catch.generic=将异常添加到现有 catch 子句
add.exception.to.existing.catch.replacement=用更通用的 ''{1}'' 替换 ''{0}''
add.exception.to.existing.catch.no.replacement=将 ''{1}'' 添加到具有 ''{0}'' 的 catch
add.exception.to.existing.catch.chooser.title=选择 catch 块

add.method.body.text=添加方法体
add.method.family=添加方法
add.method.text=添加方法 ''{0}'' 到类 ''{1}''
add.new.array.family=添加缺少的新表达式
add.new.array.text=添加 ''new {0}[]''
add.return.statement.text=添加 'return' 语句
add.runtime.exception.to.throws.text=添加运行时异常到方法签名
add.runtime.exception.to.throws.family=添加运行时异常到方法签名
add.typecast.family=添加类型转换
add.typecast.text=转换到''{0}''
add.qualifier.typecast.text=将限定符转换为 ''{0}''
add.docTag.to.custom.tags=添加 {0} 到自定义标签
fix.javadoc.family=修正 Javadoc
adjust.package.family=调整包名称
adjust.package.text=设置包名称为 ''{0}''
bring.variable.to.scope.family=将变量引入范围
bring.variable.to.scope.text=将 ''{0}'' 引入范围

cast.parameter.text=将{0, choice, 1\#第 1 个|2\#第 2 个|3\#第 3 个|4\#第 {0,number} 个}参数转换为 ''{1}''
cast.single.parameter.text=转换参数为 ''{0}''

add.type.arguments.text=添加显式类型参数到第{0, choice, 1\#1|2\#2|3\#3|4\#{0,number}}个参数
add.type.arguments.single.argument.text=添加显式类型参数

change.class.signature.text=更改''{0}''的签名以匹配''{1}''
change.class.signature.family=更改类签名

uidesigner.change.bound.field.type=更改绑定字段类型
cannot.change.field.exception=无法更改字段''{0}''类型.\n\
原因\: {1}

# {0} - original keyword (extends or implements), {1} - proposed keyword (implements or extends), {2} - class name
exchange.extends.implements.keyword=改变''{0} {2}''到''{1} {2}''
uidesigner.change.gui.component.type=改变GUI组件类型
change.method.signature.from.usage.family=从用法改变方法签名

# {0} - original method signature including name, {1} - method name, {2} - proposed new parameters list
change.method.signature.from.usage.text=更改''{0}''的签名为''{1}({2})''
add.parameter.from.usage.text=将 ''{0}'' 作为第 {1,number,ordinal} 个{2}添加到{3} ''{4}'' 中
remove.parameter.from.usage.text=从{2} ''{3}'' 中移除第 {0,number,ordinal} 个{1}
change.parameter.from.usage.text=将{2} ''{3}'' 的第 {0,number,ordinal} 个{1}从 ''{4}'' 更改为 ''{5}''
searching.for.usages.progress.title=搜索用途...
create.class.from.new.family=创建新类
create.class.from.usage.family=从用法创建类
create.class.from.usage.text=创建 {0} ''{1}''
create.inner.class.from.usage.text=创建内部{0} ''{1}''
create.element.in.class=在 ''{2}'' 中创建{0} ''{1}''
create.constant.from.usage.family=从用法创建常亮
create.constructor.from.new.family=创建新构造函数
create.constructor.from.new.text=创建构造函数
create.constructor.from.super.call.family=从 super() 调用创建构造函数
create.constructor.from.this.call.family=从this()调用创建构造函数
create.constructor.family=创建构造函数
create.constructor.text=在''{0}''中创建构造函数
create.constructor.matching.super=创建匹配 super 的构造函数
super.class.constructors.chooser.title=选择超类构造函数
create.field.from.usage.family=从用法创建字段
target.class.chooser.title=选择目标类
new.method.body.template.error.text=请更正“新方法体”模板
new.method.body.template.error.title=文件模板错误
cannot.create.java.file.error.text=无法在{1}创建{0}.java\: {2}
cannot.create.java.file.error.title=文件创建失败
cannot.create.java.package.error.text=无法在{1}创建{0}\: {2}
cannot.create.java.package.error.title=包创建失败
create.accessor.for.unused.field.family=创建未使用字段的访问器
create.getter.for.field=为''{0}''创建getter
create.setter.for.field=为''{0}''创建setter
create.getter.and.setter.for.field=为''{0}''创建getter和setter
create.local.from.usage.family=从用法创建本地
create.local.from.instanceof.usage.family=从 instanceof 用法创建局部变量
create.local.from.instanceof.usage.text=插入''({0}){1}''声明
create.member.from.usage.family=从用法创建成员
create.method.from.usage.family=从用法创建方法
create.method.from.usage.text=创建方法 ''{0}''
create.type.parameter.from.usage.family=从用法创建类型参数
create.type.parameter.from.usage.text=创建类型参数 ''{0}''
create.type.parameter.from.usage.chooser.title=用于添加类型参数的位置
create.parameter.from.usage.family=从用法创建参数
create.property.from.usage.family=从用法创建属性
create.property.from.usage.text=创建属性 ''{0}''
create.property.from.usage.full.text=在 ''{1}'' 中创建属性 ''{0}''
create.read.only.property.from.usage.text=创建只读属性 ''{0}''
create.read.only.property.from.usage.full.text=在 ''{1}'' 中创建只读属性 ''{0}''
create.write.only.property.from.usage.text=创建只写属性 ''{0}''
create.write.only.property.from.usage.full.text=在 ''{1}'' 中创建只写属性 ''{0}''
create.getter=创建Getter
create.setter=创建Setter
create.annotation.family=将批注添加到声明
create.annotation.text=添加 @''{0}''
defer.final.assignment.with.temp.family=使用临时变量推迟最终赋值
defer.final.assignment.with.temp.text=使用临时变量推迟 ''{0}'' 赋值
delete.catch.family=删除 Catch
delete.catch.text=删除''{0}''的catch
delete.body.text=删除方法体
enable.optimize.imports.on.the.fly=启用 '设置|代码样式|导入|实时优化导入'
generify.family=生成文件
generify.text=尝试泛型化 ''{0}''
implement.methods.fix=导入方法
import.class.fix=导入类
insert.new.fix=插入新的
insert.super.constructor.call.family=基本控制调用
insert.super.constructor.call.text=插入 ''{0}''
make.class.an.interface.family=使类成为接口
make.class.an.interface.text=使 ''{0}'' 成为接口
make.interface.an.class.text=使 ''{0}'' 成为类
make.vararg.parameter.last.family=使最后参数为可变长参数
make.vararg.parameter.last.text=移动''{0}''到列表的末尾
fix.parameter.type.family=修正参数类型
fix.parameter.type.text=使 ''{0}'' 在此处获取类型为 ''{1}'' 的参数
fix.return.type.family=修正返回类型
fix.return.type.or.predecessor.text=使 ''{0}'' 返回 ''{1}'' 或前置符
fix.return.type.text=使''{0}''返回''{1}''
fix.throws.list.family=修正抛出列表
fix.throws.list.add.exception=添加''{0}''到''{1}''抛出列表
fix.throws.list.remove.exception=从''{1}''抛出列表移除''{0}''
fix.modifiers.family=修复修饰符

anonymous.class.presentation=派生自{0}的匿名类
# {0} owner class name
class.initializer.presentation={0} 类初始化器
add.modifier.fix=使 ''{0}'' 为 {1}
remove.modifier.fix=将 ''{0}'' 设为非 {1}

change.inheritors.visibility.warning.text=是否将继承者的可见性更改为基方法的可见性?
change.inheritors.visibility.warning.title=更改继承者
move.class.in.extend.list.family=在扩展列表中移动类
move.bound.class.to.front.fix.text=移动边界 ''{0}'' 到类型参数''{1}''的边界列表的开头
move.catch.up.family=上移 Catch
move.catch.up.text=将 ''{0}'' 的 catch 移动到 ''{1}'' 之前
move.class.to.separate.file.family=移动类到单独的文件
move.class.to.separate.file.text=移动类 ''{0}'' 到 ''{0}.java''
move.class.to.package.family=移动类到包
move.class.to.package.text=移动到包 ''{0}''

# change if (!a == b) ...  =>  if (!(a == b)) ...
negation.broader.scope.family=否定宽的范围
negation.broader.scope.text=更改为 ''\!({0})''

optimize.imports.fix=优化导入
remove.qualifier.fix=删除限定符
remove.unused.element.family=移除未使用的{0}
rename.wrong.reference.family=重用变量声明
rename.wrong.reference.text=重命名引用
reuse.variable.declaration.family=重用变量声明
reuse.variable.declaration.text=重用上一个变量 ''{0}'' 声明
navigate.variable.declaration.family=导航到变量声明
navigate.variable.declaration.text=导航到上一个变量声明''{0}''
safe.delete.family=安全删除
safe.delete.text=安全删除 ''{0}''
setup.jdk.location.family=设置JDK位置
setup.jdk.location.text=设置JDK
side.effects.warning.dialog.title=发现副作用
simplify.boolean.expression.family=简化布尔表达式
simplify.boolean.expression.text=简化 ''{0}'' 到 {1}
fix.super.method.return.type.family=修复 Super 方法返回类型
fix.super.method.return.type.text=使 ''{0}'' 返回 ''{1}''
surround.with.try.catch.fix=使用 try/catch 环绕
make.final.family=设为 final
make.final.text=将{0}设为 final
make.final.copy.to.temp=将 ''{0}'' 复制到 {1} 临时变量
make.final.transform.to.one.element.array=将 {0} 转换成 final 单元素数组
fix.variable.type.family=修改变量类型
fix.variable.type.text=将{0} ''{1}''类型更改为''{2}''

# Sample: Boolean b = "true"; -> Boolean b = Boolean.valueOf("true");
wrap.expression.using.static.accessor.family=包装表达式
wrap.expression.using.static.accessor.text=使用 ''{0}()'' 包装

# {0} - qualified class name suggested to be imported.
side.effect.action.remove=移除(&R)
side.effect.action.transform=转换(&T)
side.effect.action.cancel=取消(&C)
side.effect.message1=<html><body>分配给变量 ''{0}'' 的表达式中可能存在副作用<br>您可以\: <ul><li><b>移除</b>涉及的变量用法以及所有表达式</li></body></html>
# {0} - variable name, {1} - variable type, {2} - expression with side effect, {3} - same expression transformed to hold the effect

change.parameter.class.family=更改参数类

change.extends.list.family=扩展类来自
add.class.to.extends.list=使 ''{0}'' 继承 ''{1}''
remove.class.from.extends.list=使 ''{0}'' 不继承 ''{1}''
add.interface.to.implements.list=使 ''{0}'' 实现 ''{1}''
remove.interface.from.implements.list=使 ''{0}'' 不实现 ''{1}''
convert.method.to.constructor=使方法成为构造函数

create.field.text=创建字段 {0}
create.property.text=创建属性 {0}
add.constructor.parameter.name=添加构造函数的参数
remove.suppression.action.name=移除 ''{0}'' 抑制
remove.suppression.action.family=移除抑制
remove.qualifier.action.text=移除限定符
fix.argument.family=修正参数
change.new.operator.type.text=将 ''{0}'' 更改为 ''new {1}{2}''
change.new.operator.type.family=更改新的运算符类型

fix.unused.symbol.injection.family=添加到依赖注入注解
fix.unused.symbol.injection.text=禁止用''{1}''注解 {0}
fix.add.special.annotation.family=添加到特殊注解
fix.add.special.annotation.text=添加 ''{0}'' 到特殊注释列表

orderEntry.fix.add.dependency.on.module=添加对模块''{0}''的依赖
orderEntry.fix.add.dependency.on.module.choose=添加对模块的依赖...
orderEntry.fix.choose.module.to.add.dependency.on=选择模块添加到依赖关系
orderEntry.fix.family.add.module.dependency=添加模块依赖项
orderEntry.fix.add.library.to.classpath=添加库 ''{0}'' 到类路径
orderEntry.fix.family.add.library.to.classpath=添加库到类路径
orderEntry.fix.circular.dependency.warning=对模块''{0}''添加依赖将会引入模块 ''{1}'' and ''{2}'' 之间的循环依赖关系.\n\
添加依赖关系吗?
orderEntry.fix.title.circular.dependency.warning=循环依赖警告
static.import.method.text=导入 static 方法
static.import.method.choose.method.to.import=选择导入的方法
static.import.constant.text=导入 static 常量

add.library.title.dialog=添加 ''{0}'' 库到项目
add.library.title.choose.folder=选择目录
add.library.description.choose.folder=选择要复制的库所在目录
add.library.error.not.found=库文件''{0}''不存在
add.library.error.cannot.copy=无法拷贝 ''{0}'' 到 ''{1}''\n\
({2})
add.library.use.bundled.library.radio.button=使用{1}分发中的''{0}'' (&U)
add.library.copy.files.to.radio.button=将''{0}''库文件复制到 (&C)

permute.arguments=允许参数
fix.single.character.string.to.char.literal.text=将 {0} 更改为 {1} (到 {2} 字面值)
fix.single.character.string.to.char.literal.family=修正文字类型

change.to.append.family=修复StringBuilder拼接
change.to.append.text=更改为 ''{0}''

convert.to.string.family=修正字符文字
convert.to.string.text=转换为字符串字面值
convert.to.raw.string.text=转换为原始字符串文字

initialize.final.field.in.constructor.name=在构造函数中初始化
initialize.final.field.in.constructor.choose.dialog.title=选择构造函数来添加初始化

remove.redundant.arguments.text=删除冗余参数以调用 ''{0}''
remove.redundant.arguments.family=删除冗余参数

replace.with.list.access.text=替换为列表访问

add.qualifier=添加限定符
add.qualifier.original.class.chooser.title=原始类

annotations.fix=注解
add.missing.annotation.parameters.fix=添加缺少的注解参数 - {0}
add.missing.annotation.single.parameter.fix=添加缺少的注解参数 ''{0}''

add.method.qualifier.fix.text=添加限定符 {0} 到方法
add.method.qualifier.fix.family=添加方法限定符

collection.addall.can.be.replaced.with.constructor.fix.options.title=要检查的类
collection.addall.can.be.replaced.with.constructor.fix.description='\#ref()' 方法可以用参数化的构造函数替换
collection.addall.can.be.replaced.with.constructor.fix.family.name=用参数化的构造函数调用替换'addAll()/putAll()'调用
collection.addall.can.be.replaced.with.constructor.fix.name=用参数化的构造函数调用替换''{0}()''调用

add.exception.from.field.initializer.to.constructor.throws.text=添加类{0, choice, 0\#默认构造函数|1\#构造函数|2\#构造函数}签名的异常
add.exception.from.field.initializer.to.constructor.throws.family.text=对类构造函数添加异常签名
java.8.map.api.inspection.fix.text=用 ''{0}'' 方法调用替换
java.8.map.api.inspection.description=可以用单个 ''Map.{0}'' 方法调用替换
java.8.map.api.inspection.fix.family.name=替换为单个 Map 方法调用
java.8.collection.removeif.inspection.description=循环可以替换为 Collection.removeIf
java.8.collection.removeif.inspection.fix.name=用 Collection.removeIf 替换循环
java.8.list.sort.inspection.description=Collections.sort 可以替换为 List.sort
java.8.list.sort.inspection.fix.name=用 List.sort 替换

wrap.with.optional.parameter.text=使用 ''java.util.Optional'' 包装第{0, choice, 1\#1|2\#2|3\#3|4\#{0,number}}个参数
wrap.with.optional.single.parameter.text=使用'java.util.Optional'包装

move.file.to.source.root.text=移动文件到源根目录
delete.return.fix.family=删除 return
delete.return.fix.text=删除 return {0}
delete.return.fix.side.effects.text=删除 return {0} 并提取副作用

delete.reference.fix.text=删除引用
delete.unreachable.statement.fix.text=删除无用的语句

extract.side.effects.convert.to.if=转换为 'if' 语句
extract.side.effects=提取副{0, choice, 1\#作用|2\#作用}
extract.side.effects.family.name=删除提取副作用的语句

module.info.add.directive.family.name=将指令添加到 module-info.java
module.info.add.requires.name=添加 ''requires {0}'' 指示到 module-info.java
module.info.add.exports.name=将 ''exports {0}'' 指令添加到 module-info.java
module.info.add.uses.name=将 ''uses {0}'' 指令添加到 module-info.java

collection.to.array.text=应用转换到 ''.toArray({0})''
collection.to.array.family.name=应用转换到 '.toArray()'

insert.sam.method.call.fix.name=插入 ''.{0}'' 来调用功能界面方法
insert.sam.method.call.fix.family.name=插入单一 abstract 方法调用

wrap.with.adapter.call.family.name=使用适配器调用或对象包装
wrap.with.adapter.text=使用''{0}''包装
wrap.with.adapter.parameter.single.text=使用''{0}''包装参数
wrap.with.adapter.parameter.multiple.text=使用 ''{1}'' 包装第{0, choice, 1\#1|2\#2|3\#3|4\#{0,number}}个参数

java.9.merge.module.statements.fix.family.name=与其它 ''{0}'' 指令合并
java.9.merge.module.statements.fix.name=与其它''{0} {1}'' 指令合并

model.create.constructor.quickfix.message=创建构造函数 ''{0}''
model.create.constructor.quickfix.message.family.name=创建构造函数

adjust.method.accepting.functional.expression.fix.family.name=调整接收函数表达式的方法
adjust.method.accepting.functional.expression.fix.text=用''{1}()''替换''{0}()'' 

add.compiler.option.fix.name=将 ''{0}'' 添加到模块编译器选项

create.service.implementation.fix.family.name=创建服务实现类
create.service.implementation.fix.name=创建类 ''{0}''

create.service.interface.fix.family.name=创建服务
create.service.interface.fix.name=创建服务 ''{0}''

convert.variable.to.field.in.anonymous.class.fix.name=将 ''{0}'' 移动到匿名对象
change.method.parameters.text=将方法参数更改为 ''{0}''
change.method.parameters.family=更改方法参数

add.default.branch.to.variable.initializing.switch.fix.name=将 ''default'' 分支添加到初始化 ''{0}'' 的 ''switch'' 语句中

insert.empty.parenthesis=插入 '()'
remove.parameter.list=移除参数列表

convert.primitive.to.boxed.type=将基元类型转换为装箱类型

choose.class.to.move.popup.title=选择要移动的类
move.0.in.1=移动 ''{1}'' 中的 ''{0}''…
move.0.from.module.1.to.2=将 ''{0}'' 从模块 ''{1}'' 移动到 ''{2}''

add.0.to.classpath=将 ''{0}'' 添加到类路径中

pull.up=拉起

iterate.iterable=迭代
rename.reference=重命名引用

choose.fields.to.generate.constructor.parameters.for=选择要为其生成构造函数参数的字段
choose.constructors.to.add.parameter.to=选择要向其添加参数的构造函数
add.constructor.parameters=添加构造函数参数

add.annotation.attribute.name.family.name=添加注解特性名称
add.annotation.attribute.name=添加 ''{0}\=''

replace.with.getter.setter=替换为 getter/setter
replace.with.getter=替换为 getter
replace.with.setter=替换为 setter

wrap.with.block=使用块包装
create.block=创建块

replace.for.each.loop.with.iterator.for.loop=将 'for each' 循环替换为迭代器 'for' 循环

surround.annotation.parameter.value.with.quotes=使用引号环绕注解参数值
surround.with.array.initialization=通过数组初始化环绕

create.service.implementation=创建服务实现
create.service=创建服务

choose.default.value.parameters.popup.title=选择默认值参数
generate.overloaded.method.or.constructor.with.default.parameter.values=使用默认参数值生成过载{0}
generate.overloaded.method.with.default.parameter.values=使用默认参数值生成过载方法

remove.unreachable.branches=移除不可到达的分支
set.inspection.option.fix=设置检查选项
simplify.boolean.expression.extracting.side.effects=提取副作用