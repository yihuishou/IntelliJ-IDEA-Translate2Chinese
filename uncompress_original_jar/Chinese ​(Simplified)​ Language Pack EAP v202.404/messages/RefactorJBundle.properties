add.property=添加属性
add.property.dialog.title=将属性添加到{0}
property.name.field.label=属性名称\:
property.type.field.label=属性类型\:
create.property.getter.checkbox=创建属性 getter
create.property.setter.checkbox=创建属性 setter
add.property.to.constructors.checkbox=将属性添加到构造函数
make.property.final.checkbox=将属性设为 final
initialization.expression.checkbox=初始化表达式 (可选)\:
cannot.perform.the.refactoring=不能执行重构。
refactor.j.is.not.licensed=Refactor-J 未获得授权。
the.caret.should.be.positioned.in.the.class.to.add.to.property.to=脱字符号应置于要将属性添加到的类处。
class.to.be.add.property.to=要将属性添加到的类
constructor.calls.to.be.updated.view.descriptor=要更新的构造函数调用 {0}
unable.to.find.the.requested.class=无法找到请求的类
no.class.found=未找到类
search.for.class.text=搜索类
search.for.class.family.name=搜索类
add.global.library=添加库依赖项
global.library.source=全局库\: {0}
add.module.dependency=添加模块依赖项
module.source=模块\: {0}
project.library.source=项目库\: {0}
add.project.library=添加库依赖项
class.found.column.header=已找到类
source.column.header=源
action.column.header=操作
class.search.results.title=类搜索结果
extract.class.title=提取委托
extract.class.from.label=从{0}提取委托
name.for.new.class.label=新类的名称(&N)\:
choose.destination.package.label=选择目标包
package.for.new.class.label=包名称(&P)\:
name.for.wrapper.class.label=类名\:
package.for.wrapper.class.label=包名称\:
members.to.extract.label=要提取的成员(&B)
generate.array.access.methods.title=选择要为其生成数组访问方法的成员
generate.collection.access.methods.title=选择要为其生成集合访问方法的成员
generate.array.methods.undo.string=生成数组方法
generate.collection.methods.undo.string=生成集合方法

there.already.exists.a.class.with.the.chosen.name=已存在一个具有所选名称的类。
introduce.parameter.object=引入参数对象
introduce.type.parameter=引入类型参数
the.caret.should.be.positioned.at.on.a.type.to.be.parameterized=脱字符号应置于要参数化的类型处。
type.selected.is.not.in.class.context=选定类型不在类上下文中。
type.parameters.can.not.be.introduced.as.type.parameters=类型参数不能作为类型参数引入。
primitive.types.can.not.be.introduced.as.type.parameters=基元类型不能作为类型参数引入。
conflicts.found=已找到冲突
there.are.non.genericizable.instances.of.the.type.you.selected=存在选定类型的不可泛化实例。
do.you.wish.to.continue=要继续吗?
introduce.type.parameter.title=引入类型参数
name.for.new.type.parameter.label=新类型参数的名称\:
the.caret.should.be.positioned.within.a.class.to.be.refactored=脱字符号应置于要重构的类内。
push.javadoc.down=向下推送 Javadoc
the.selected.class.is.an.enumeration=选定类是枚举。
the.selected.class.has.no.overridden.methods.with.javadoc=选定类没有包含 javadoc 的重写方法。
push.javadoc.down.title=向下推送 Javadoc
replace.existing.comments.checkbox=替换现有注释
use.inheritdoc.comments=使用 @inheritdoc 注释
push.javadoc.down.from.label=从以下位置向下推送 Javadoc\:
methods.to.copy.javadoc.from=从中复制 javadoc 的方法
remove.property=移除属性
the.caret.should.be.positioned.at.on.a.property.to.be.removed=脱字符号应置于要移除的属性处。
remove.property.getter.checkbox=移除属性 getter
remove.property.setter.checkbox=移除属性 setter
remove.property.title=移除属性
remove.property.border=移除属性 {0}
replacement.expression.label=替换表达式 (可选)\:
remove.middleman=移除中间人
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=脱字符号应置于要重构的字段的名称处。
field.selected.is.not.used.as.a.delegate=选定字段不用作委托。
wrap.return.value=包装返回值
the.caret.should.be.positioned.at.the.name.of.the.method.to.be.refactored=脱字符号应置于要重构的方法的名称处、参数列表内或方法调用内。
method.selected.returns.void=选定方法返回 'void'。
constructor.returns.can.not.be.wrapped=无法包装构造函数返回值。
wrap.return.value.title=包装返回值
the.caret.should.be.positioned.at.an.annotation.to.be.refactored.to.be.refactored=脱字符号应置于要重构的注解处。
pull.annotation.up=向上拉取注解
pull.annotation.up.title=向上拉取注解
replace.existing.annotations.checkbox=替换现有注解
pull.up.annotation.from.label=从 {0} 将注解向上拉取至\:
pull.javadoc.up.title=向上拉取 Javadoc
pull.up.javadoc.from.label=从 {0} 将 javadoc 向上拉取至\:
methods.to.pull.up.javadoc.from.panel=从中向上拉取 javadoc 的方法
remove.type.parameter=移除类型参数
the.caret.should.be.positioned.at.the.name.of.the.type.parameter.to.be.refactored=脱字符号应置于要重构的类型参数的名称处。
type.parameter.selected.extends.multiple.types=选定类型参数可以扩展多个类型。
type.parameter.question.label=要移除类型参数 {0} 和它的所有用例吗?
method.to.wrap.returns.from.label=从中包装返回值的方法\:
method.whose.return.are.to.wrapped=要包装其返回值的方法
references.to.be.modified.usage.view=要修改的引用 {0}
reference=引用
type.parameter.to.be.remove=要移除的类型参数
references.to.be.changed.usage.view=引用是改变了{0}
references.to.be.made.removed.usage.view=要移除的引用 {0}
property.to.be.removed=要移除的属性
remove.middleman.field.header=移除中间人字段\:
references.to.expose.usage.view=要公开的引用 {0}
retain.all.delegating.methods.radio.button=保留所有委托方法
remove.middleman.title=移除中间人
delete.all.delegating.methods.radio.button=删除所有委托方法
field.label=字段{0}
delete.delegating.methods.border=删除委托方法
make.class.inner.title=使类成为内部类
make.class.an.inner.class.border=使类 {0} 成为内部类
outer.class.label=外部类\:
choose.destination.class.label=选择目标类
add.property.command=将属性 {0} 添加到 {1}
refactor=重构
preview=预览
wrapped.return.command.name=针对 {1}{2}{3}() 将返回值包装为 {0}
split.loop.text=拆分循环
split.loop.family.name=拆分循环
removed.type.parameter.from.class.command.name=已从类 {1} 移除类型参数 {0}
removed.type.parameter.from.method.command.name=已从方法 {1}() 移除类型参数 {0}
remove.property.command.name=移除属性 {0}
exposed.delegation.command.name=已将委托公开给 {0}{1}{2}
push.up.javadoc.command.name=向上推送 Javadoc
javadoced.class=使用 Javadoc 处理的类
superclass.methods.to.be.javadoced=要使用 javadoc 处理的超类方法
push.annotation.down=向下推送注解
0.refactor.j.is.not.licensed={0}Refactor-J 未获得授权。
0.the.caret.should.be.positioned.at.an.annotation.to.be.refactored.to.be.refactored={0}脱字符号应置于要重构的注解处。
push.down.annotation.command.name=向下推送注解
annotation=注释
subclass.elements.to.be.annotated=要注解的子类元素
push.annotation.down.title=向下推送注解
pull.up.annotation.command.name=向上拉取注解
superclass.elements.to.be.annotated=要注解的超类元素
pull.javadoc.up=向上拉取 Javadoc
pull.up.javadoc.command.name=向上拉取 Javadoc
merge.loops.text=合并循环
merge.loops.family.name=合并循环
make.class.inner=使类成为内部类
the.caret.should.be.positioned.at.on.a.class.to.be.made.into.an.inner.class=脱字符号应置于要成为内部类的类处。
only.outer.classes.and.static.inner.classes.may.be.made.inner=只有外部类和 static 内部类可以成为内部类。
a.class.can.not.be.made.an.inner.class.of.itself=类不能成为自己的内部类。
a.class.can.not.be.made.an.inner.class.of.one.of.it.s.decendents=类不能成为其后代的内部类。
make.class.inner.command.name=将类 {0} 移动到类 {1} 内部
invert.boolean=逆布尔
the.caret.should.be.positioned.at.the.name.of.the.variable.or.parameter.to.be.refactored=脱字符号应置于要重构的变量或参数的名称处。
variable.selected.is.not.boolean=选定变量不是布尔型。
invert.boolean.title=反转布尔
do.you.wish.to.invert.all.uses.of.variable=要反转变量 {0} 的所有用例吗?
parameter.selected.is.not.boolean=选定参数不是布尔型。
do.you.wish.to.invert.all.uses.of.parameter=要反转参数 {0} 的所有用例吗?
invert.parameter.command.name=已反转 {0}({1})
invert.variable.command.name=已反转
variable.to.be.inverted=要反转的变量
references.to.be.inverted.0=引用是倒{0}
parameterize.class.radio.button=参数化类 {0}
parameterize.method.radio.button=参数化方法 {0}()
genericize.uses.border=泛化 {0} 的用例
introduced.type.parameter.command.name=已将类型 {0} 作为参数引入到类 {1}
type.parameter.to.be.introduced=要引入的类型参数
class.references.to.be.made.inner=要成为内部引用的类引用
references.to.be.made.inner.usage.view=要成为内部{0}的引用
control.flow.category=控制流
other.category=其他
genericize.uses.in.border=泛化{1}中 {0} 的用例
extract.class=提取类
the.selected.class.is.an.interface=选定类是接口。
the.selected.class.is.an.annotation.type=选定类是注解类型。
the.refactoring.is.not.supported.on.non.static.inner.classes=非 static 内部类上不支持重构。
the.selected.class.has.no.members.to.extract=选定类没有要提取的成员。
references.to.extract=要提取的引用
extracting.from.class=正在从类提取\:
extracted.class.command.name=已提取类 {0}
method.to.extract.parameters.from.label=从方法中提取参数
name.for.new.parameter.label=新参数的名称\:
method.selected.has.no.parameters=选定方法没有参数。
parameters.to.extract.border=要提取的参数
parameter=参数
your.evaluation.license.for.refactor.j.will.expire.in.less.than.n.days=您的 Refactor-J 评估许可证将在 {0} 天内到期。
refactor.j.licensed.to=Refactor-J 已授权给\:
can.only.pull.annotations.up.on.methods.parameters.and.classes=只能在方法、参数和类上向上拉取注解
can.not.find.any.available.superclasses.for.the.selected.class=无法找到选定类的任何可用超类
can.not.find.any.available.super.methods.for.the.selected.method=无法找到选定方法的任何可用 super 方法
can.only.push.annotations.down.on.methods.parameters.and.classes=只能在方法、参数和类上向下推送注解
can.not.find.any.available.subclasses.for.the.selected.class=无法找到选定类的任何可用子类
can.not.find.any.available.overriding.methods.for.the.selected.method=无法找到选定方法的任何可用重写方法
delete.selected.annotation.checkbox=删除选定注解
push.annotation.down.from.label=从以下位置向下推送注解\:
there.already.exists.an.incompatible.class.with.the.chosen.name=已存在一个具有所选名称的不兼容类
weaken.type=缩小类型
weaken.type.label=将 ''{0}'' 的类型从 {1} 缩小为\:
weaken.type.command.name=削弱类型
weaken.type.refactoring.is.not.supported.for.primitive.types=基元类型不支持缩小类型重构
weaken.type.refactoring.is.not.supported.for.arrays=数组不支持缩小类型重构
weaken.type.refactoring.is.not.supported.for.type.parameters=类型参数不支持缩小类型重构
invalid.type.for.weaken.type.refactoring=缩小类型重构的类型无效
weaken.type.refactoring.is.not.supported.for.constructors=构造函数不支持缩小类型重构
the.selected.type.cannot.be.weakened=不能缩小选定类型
the.selected.type.cannot.be.weakened.because.the.method.is.declared.in.a.non.project.class=不能缩小选定类型，因为该方法在非项目类中声明
the.selected.method.cannot.be.wrapped.because.it.is.defined.in.a.non.project.class=不能包装选定方法，因为它在非项目类中定义
existing.wrapper.class.label=使用现有参数类
select.wrapper.class=选择参数类
could.not.find.selected.wrapping.class=无法找到选定包装类
there.already.exists.a.class.with.the.selected.name=已存在一个具有选定名称的类
pull.annotation.up.from.label=从以下位置向上拉取注解\:
convert.equality.disjunction.to.set.contains=将相等析取转换为 Set.contains()
convert.to.set.contains=转换为 Set.contains()
the.caret.should.be.positioned.at.the.name.of.the.variable.parameter.or.method.to.be.refactored=脱字符号应置于要重构的变量、参数或方法的名称处。
convert.to.String.format=转换为 String.format
convert.to.printf=转换为 printf
convert.to.MessageFormat.format=转换为 MessageFormat.format
split.string=拆分字符串
copy.javadoc.to.inheritors=将 Javadoc 复制到继承者
copy.javadoc.to.ancestors=将 Javadoc 复制到祖先
