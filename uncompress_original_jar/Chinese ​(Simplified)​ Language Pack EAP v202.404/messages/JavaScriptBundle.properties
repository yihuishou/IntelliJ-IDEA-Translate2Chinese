javascript.filetype.description=JavaScript
actionscript.filetype.description=ActionScript
typescript.filetype.description=TypeScript
typescript.jsx.filetype.description=TypeScript JSX
ecmascript6.filetype.description=ECMAScript 6
jsx.filetype.description=React JSX
flow.filetype.description=Flow JS
javascript.file=JavaScript 文件
typescript.file=TypeScript 文件

# Languages
javascript.language.simple.name=JavaScript
typescript.language.simple.name=TypeScript

# Language terms
javascript.language.term.function=函数
javascript.language.term.inner.function=内部函数
javascript.language.term.method=方法
javascript.language.term.constructor=构造函数
javascript.language.term.class=类
javascript.language.term.inner.class=内部类
javascript.language.term.interface=接口
javascript.language.term.inner.interface=内部接口
javascript.language.term.enum=枚举
javascript.language.term.type.alias=类型别名
javascript.language.term.definition=定义
javascript.language.term.namespace=命名空间
javascript.language.term.parameter=参数
javascript.language.term.property=属性
javascript.language.term.variable=变量
javascript.language.term.const=常量
javascript.language.term.const.field=常量字段
javascript.language.term.readonly.field=只读字段
javascript.language.term.local.variable=局部变量
javascript.language.term.local.const=局部常量
javascript.language.term.field=字段
javascript.language.term.value=值
javascript.language.term.tag=tag
javascript.language.term.label=标签
javascript.language.term.attribute=属性
javascript.language.term.decorator=装饰器
javascript.language.term.attribute.value=属性值
javascript.language.term.package=包
javascript.language.term.module=模块
javascript.language.term.external.module.reference=外部模块引用
javascript.language.term.import.specifier=导入说明符
javascript.language.term.export.specifier=导出说明符
javascript.language.term.entity.name=实体名称
javascript.language.term.jsdoc.tag=JSDoc 标签
javascript.language.term.imported.default.binding=已导入默认绑定
javascript.language.term.exported.default.binding=已导出默认绑定
javascript.language.term.namespace.import=命名空间导入
javascript.language.term.namespace.export=命名空间导出
javascript.language.term.import.statement=导入语句
javascript.language.term.type.parameter=类型参数
javascript.language.term.export.default.assignment=导出默认赋值
javascript.language.term.destructuring.property=解构属性
javascript.language.term.type.property=类型属性
javascript.language.term.default.export=默认导出
javascript.language.term.file=文件
javascript.language.term.global=全局
javascript.language.term.xml.tag=xml 标签

# Parser error messages
javascript.parser.message.expected.expression=表达式是预期的
javascript.parser.message.expected.xml.element=预期为 xml 元素
javascript.parser.property.expected=预期为属性
javascript.parser.message.expected.lbrace={ 是预期的
javascript.parser.message.expected.at=@ 预期
javascript.parser.message.expected.rbrace=} 预期
javascript.parser.message.expected.identifier.string.literal.or.numeric.literal=预期为标识符或字符串文字或数字
javascript.parser.message.expected.colon='\:'是预期的
javascript.parser.message.expected.colon.or.comma=预期为 \: 或 ,
javascript.parser.message.expected.semicolon=; 是预期的
javascript.parser.message.expected.lbrace.or.semicolon=预期为 { 或 ;
javascript.parser.message.expected.rbracket=] 是预期的
javascript.parser.message.expected.lparen=( 是预期的
javascript.parser.message.expected.rparen=) 预期
javascript.parser.message.expected.name=预期名字
javascript.parser.message.expected.comma.or.rparen=预期为 , 或 )
javascript.parser.message.expected.function.name=预期为函数名称
javascript.parser.message.expected.requires.or.function.name=预期为 'requires' 或函数名称
javascript.parser.message.expected.formal.parameter.name=预期为正式参数名称
javascript.parser.message.expected.statement=预期为语句
javascript.parser.message.unexpected.var=此处不允许变量声明
javascript.parser.message.unexpected.const=此处不允许常量声明
javascript.parser.message.expected.parameter.name=预期为参数名称
javascript.parser.message.expected.property.name=预期为属性名称
javascript.parser.message.expected.catch.or.default=预期为 catch 或默认
javascript.parser.message.expected.forloop.left.hand.side.expression.or.variable.declaration="in"前面预期为左侧表达式或变量声明
javascript.parser.message.expected.forloop.in.or.semicolon=预期为 'in' 或 ;
javascript.parser.message.expected.while.keyword=预期为 while
javascript.parser.message.expected.comma=, 预期
javascript.parser.message.expected.comma.or.rbrace=预期为 , 或 }
javascript.parser.message.expected.variable.name=预期为变量名称
javascript.parser.message.expected.mult.or.lbrace=预期为 * 或 {
javascript.parser.message.missing.rbrace=缺少 }
javascript.parser.message.missing.or_rbrace=缺少 |}
javascript.parser.message.missing.backquote=缺少 `
javascript.parser.message.missing.attribute.name=缺少属性名称
javascript.parser.message.unexpected.end.of.file=意外的文件结尾
javascript.parser.message.expected.type.name=预期为类型名称
javascript.parser.message.unclosed.string.literal=未闭合的字符串文字
javascript.parser.message.unclosed.comment=未闭合注释
javascript.parser.message.are.not.supported.by.dialect=当前 JavaScript 版本不支持 {0}
javascript.parser.message.expected.from=预期为 'from'
javascript.parser.message.expected.typename=预期为类型名称
javascript.parser.message.expected.typename.or.*=* 预期为 * 或类型名称
javascript.parser.message.expected.name.or.lbrace=预期为包名称或 {
javascript.parser.message.expected.module.reference=预期为模块引用
javascript.parser.message.expected.declaration=预期为声明
javascript.parser.message.expected.namespace=预期为"namespace”
javascript.parser.message.expected.string.literal=预期为字符串文字
javascript.parser.message.expected.xml=预期为 xml 上下文关键字
javascript.parser.message.expected.equal=是预期的 \=
javascript.parser.message.expected.identifier.lbrace.or.lbracket=预期为标识符、{ 或 [
javascript.parser.message.expected.eof=预期文件结束
javascript.parser.message.expected.eqgt=是预期的 \=>
javascript.parser.message.expected.identifier=标识符是预期的
javascript.parser.message.expected.instanceof=预期为 'instanceof'
javascript.parser.message.expected.in=预期 in
javascript.parser.message.expected.value=值是预期的
javascript.parser.message.expected.identifer.or.value=预期为标识符或值
javascript.parser.message.expected.identifier.or.string.literal=预期为标识符或字符串文字
javascript.parser.message.expected.as=预期为 'as'
javascript.parser.message.expected.identifier.string.literal.or.lbrace=预期为标识符、字符串文字或 {
javascript.parser.message.expected.import.value=预期为导入绑定或说明符
javascript.parser.message.expected.import.specifier=预期为导入说明符
javascript.parser.message.expected.heredoc.closing.identifier=预期为 heredoc 结束标识符
javascript.parser.message.expected.type.member=预期为类型成员
javascript.parser.message.expected.tuple.comma.or.rbracket=预期为 , 或 ]
javascript.parser.message.expected.target=只有"target"被接受为要新建的元属性
javascript.parser.message.expected.meta=只有"meta"被接受为要导入的元属性
javascript.parser.message.expected.declare=预期为 'declare'
javascript.parser.message.expected.exports=预期为 'exports'
javascript.parser.message.expected.checks=预期检查
javascript.parser.message.expected.type.keyword=预期为 'type'
javascript.parser.message.expected.type=预期类型
javascript.parser.message.expected.question=? 是预期的
javascript.parser.message.expected.class=预期类

# Validation messages
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=在命名空间 {1} 中发现冲突性的继承声明 {0}
javascript.validation.message.duplicate.declaration=重复声明
javascript.validation.message.duplicate.declaration.fix.remove=移除类型
javascript.validation.message.redundant.type=显式类型参数 {0} 可以替换为 {1}
javascript.validation.message.redundant.type.remove=可以移除显式类型参数 {0}
javascript.validation.message.duplicate.export.declaration=导出声明与已导出的声明 ''{0}'' 相冲突
javascript.validation.message.duplicate.default.export.declaration=一个模块不能有多个默认导出
javascript.validation.message.duplicate.default.export.in.module=默认导出只能在 ECMAScript-style 模块中使用
javascript.validation.message.duplicate.declaration.fix.family=导航到变量声明
javascript.validation.message.duplicate.declaration.fix.text=导航到上一个声明 ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=导航到上一个声明
javascript.validation.message.redeclaration.of.block.scope=无法重新声明块范围变量
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=块范围变量不能与同一块范围中的"var"变量或参数使用相同的名称
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope="var" 变量不能与其可见性范围内的块范围变量使用相同的名称
javascript.validation.message.assignment.to.const=尝试赋值给常量或只读变量
javascript.validation.message.assignment.to.const.fix.replace=替换为 let
javascript.validation.message.assignment.to.const.fix.remove.readonly=移除只读修饰符
javascript.validation.message.arguments.out.of.function=在函数外部使用函数参数对象
javascript.validation.message.must.be.lvalue={0} 中的左侧无效
javascript.validation.message.const.variable.without.initializer=不带初始值设定项的 const 变量。以后无法赋予有意义的值。
javascript.validation.message.constructor.field.not.allowed=类可能没有名为 'constructor' 的非 static 字段
es6.validation.message.const.variable.without.initializer=不允许使用无初始值设定项的 const 变量
javascript.validation.message.embed.annotation.used.with.var.of.wrong.type=嵌入注解应与类的变量或字符串类型一起使用
javascript.validation.message.continue.without.target=无法确定 'continue' 的目标
javascript.validation.message.break.without.target=无法确定 'break' 的目标
javascript.validation.message.continue.outside.loop='continue' 在循环语句外部
javascript.validation.message.return.outside.function.definition='return' 在函数定义外部
javascript.validation.message.duplicate.label=重复标签
javascript.validation.message.extend.multiple.classes=类不能继承多个类
javascript.validation.message.extend.final.class=无法扩展 final 类 ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode=在严格模式下不允许使用 {0} 作为标识符
javascript.validation.message.for.await.top.level=使用了顶层 'for await'
javascript.validation.message.for.await.no.async.context='for await' 只能在 'async' 函数中使用
typescript.validation.message.invalid.type.reference=类型引用不能引用 {0}
typescript.validation.message.invalid.modifier.cannot.be.here=修饰符 {0} 不能出现在此处
typescript.validation.message.duplicate.modifier=已看到修饰符 {0}
typescript.validation.message.duplicate.modifier2=已看到可访问性修饰符
typescript.validation.message.abstract.cannot.be.used=''{0}'' 修饰符不能与 ''abstract''修饰符结合使用
typescript.validation.message.abstract.class.be.created=无法创建 abstract 类 ''{0}'' 的实例
typescript.validation.message.abstract.member.access.super=无法通过 super 表达式访问 abstract 方法 ''{0}''。
typescript.validation.message.abstract.cannot.have.body=方法不能具有实现，因为它被标记为 'abstract'
typescript.validation.message.abstract.overload=重载签名必须全部为 abstract 或非 abstract。
typescript.validation.message.constructor.cannot.be.abstract=构造函数不能为 'abstract'
typescript.validation.message.function.implementation.missing=缺少函数实现或此声明之后未紧随函数实现
typescript.validation.message.abstract.class.should.be=abstract 方法只能出现在 abstract 类中
typescript.validation.module.reference.with.extension=外部模块引用不能以扩展结束
typescript.validation.class.extend.not.constructor.type=类型 ''{0}'' 不是构造函数类型
typescript.validation.class.extend.no.type.arguments.type=没有任何基类构造函数具有指定数量的类型参数
typescript.validation.class.extend.many.constructors=基类构造函数必须具有相同的返回类型
typescript.validation.class.extend.cycled.definition=循环类定义
typescript.validation.class.extend.constructor.return.not.class=基类构造函数返回类型 ''{0}'' 不是类或接口类型。
javascript.validation.generators.yield.not.iterable=表达式类型没有定义 [Symbol.iterator] 或 [Symbol.asyncIterator]
javascript.validation.generators.yield.not.assignable.to.return=类型 ''{1}'' 不可分配给类型 ''{0}''
typescript.validation.generators.incorrect.type.annotation=发生器不能有 ''{0}'' 类型注解
typescript.validation.async.incorrect.type.annotation=异步函数不能有 ''{0}'' 类型注解
typescript.validation.generators.incorrect.type.annotation.iterable=类型 ''{0}'' 不可分配给类型 ''{1}''。
typescript.validation.generators.overload=重载签名无法被声明为生成器
typescript.validation.generators.ambient=环境上下文中不允许使用生成器
typescript.validation.generators.no.yield=生成器隐式具有类型 'IterableIterator<any>'，因为它不产生任何值。请考虑提供返回类型。
typescript.validation.generators.async.no.yield=生成器隐式具有类型 'AsyncIterableIterator<any>'，因为它不产生任何值。请考虑提供返回类型。
typescript.validation.cannot.find.best.common.type=无法从用法推断类型参数


# Surround with names
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.if=if
javascript.surround.with.if.else=if / else
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.parenthesis=(表达式)
javascript.surround.with.not.parenthesis=\!(表达式)
javascript.surround.with.cast=Type(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.finally=try / finally
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.while=while
javascript.surround.with.with=with
javascript.surround.with.function=函数
javascript.surround.with.function.expression=函数表达式
javascript.surround.with.object.literal=对象文字

javascript.introduce.variable.title=提取变量
javascript.introduce.variable.title.local=引入局部变量
javascript.introduce.variable.error.no.expression.selected=无法引入变量。\n选定内容不构成表达式。
javascript.introduce.variable.error.expression.has.void.type=无法引入变量。\n选定的表达式类型无效。
javascript.introduce.variable.name.prompt=名称\:
javascript.introduce.variable.replace.all.occurrences=替换所有匹配项(找到 {0} 个匹配项) (&A)
javascript.introduce.variable.invalid.name=请输入有效名称。
javascript.introduce.element.already.exists=范围中已存在同名的 {0}。
javascript.introduce.variable.arrow.function.parameter.referenced=无法引入。\n选定内容包含对箭头函数参数的引用
javascript.introduce.variable.arrow.await.referenced=无法引入。\n选定内容包含 await 表达式
javascript.introduce.variable.xml.embedded=无法在嵌入式表达式中引入变量
javascript.introduce.incorrect.context=无法引入变量。\n选定内容包含对"this"的引用
javascript.introduce.field.title=引入字段
javascript.introduce.field.error.no.expression.selected=无法引入字段。\n选定内容不构成表达式。
javascript.introduce.field.error.expression.has.void.type=无法引入变量。\n选定的表达式类型无效。
javascript.introduce.field.error.no.enclosing.class=无法引入字段。\n没有封闭类。
javascript.introduce.field.make.readonly=令其只读 (&R)
javascript.introduce.field.initialize.in.scope=&初始化在\:
javascript.introduce.field.visibility=可见性(&V)\:
javascript.introduce.field.keyboard.hint=按 {0} 用于键盘快捷键
javascript.introduce.field.before.super.call=无法引入字段。\n在"super"调用前无法访问"this"。
javascript.introduce.constant.title=引入常量
javascript.introduce.constant.error.no.expression.selected=无法引入常量。\n选定内容不构成表达式。
javascript.introduce.constant.error.expression.has.void.type=无法引入常量。\n选定的表达式类型无效。
javascript.introduce.constant.error.not.constant.expression.selected=无法引入常量。\n选定内容不是常量表达式。

javascript.introduce.parameter.title=提取字段
javascript.introduce.parameter.error.no.expression.selected=无法引入参数。\n选定内容不构成表达式。
javascript.introduce.parameter.error.no.containing.function=无法引入参数。\n找不到要使用的包含函数。
javascript.introduce.parameter.error.expression.has.void.type=无法引入参数。\n选定的表达式类型无效。
javascript.introduce.parameter.error.not.async.context=无法为包含 'await' 的表达式引入参数。\n并非所有用法都包含在异步函数中
javascript.introduce.parameter.error.target.not.async=无法为包含 'await' 的表达式引入参数。\n目标函数不是异步函数
javascript.introduce.parameter.error.yield=无法为包含 'yield 的表达式引入参数。

javascript.introduce.throw.expressions.unsupported=无法调用重构。\n"Extract"重构中当前不支持 Throw 表达式。
javascript.introduce.breaks.operator.precedence=无法调用重构。\n通过引入将更改表达式中的运算符优先级。
javascript.introduce.constant.in.es5=无法调用重构。\n无法在 ECMAScript 3 或 ECMAScript 5 代码中引入常量。
javascript.introduce.in.embedded.expression=无法调用重构。\n无法在嵌入式表达式中引入

# Highlighting categories
javascript.keyword=关键字
javascript.string=字符串
javascript.number=数字
javascript.linecomment=行注释
javascript.doccomment=文档注释
javascript.blockcomment=块注释
javascript.regexp=正则表达式
javascript.operation=运算
javascript.parens=括号
javascript.brackets=方括号
javascript.braces=大括号
javascript.semicolon=分号
javascript.badcharacter=坏字符
javascript.docmarkup=文档标记
javascript.doctag=文档标签
javascript.valid.string.escape=有效字符串转义
javascript.invalid.string.escape=无效的字符串转义
javascript.comma=逗号
javascript.dot=点

# Errors with intentions
javascript.unresolved.function.name.message=未解析的函数或方法 {0}() \#loc
javascript.unresolved.variable.name.message=未解析的变量 {0} \#loc
javascript.unresolved.variable.null.qualifier.message=''{0}'' 的限定符可能为 null \#loc
javascript.unresolved.variable.undefined.qualifier.message=''{0}'' 的限定符可能未定义 \#loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=''{0}'' 的限定符可能为 null 或 undefined \#loc
javascript.unresolved.type.name.message=未解析的类型 {0} \#loc
javascript.unresolved.circle.definition=导入的圆定义
javascript.missing.read.property=未解析的读取属性 \#loc
javascript.missing.write.property=未解析的写入属性 \#loc
javascript.unresolved.variable.or.type.name.message=未解析的变量或类型 {0} \#loc
javascript.unresolved.variable.or.type.name.message2=未解析的变量或类型 {0}
javascript.unresolved.symbol.message=未解析的符号
javascript.unresolved.file=找不到文件 {0}
javascript.unknown.metadata.tag=未知元数据标签
javascript.unknown.metadata.attribute=未知元数据属性
javascript.undeclared.variable.name.message=隐式声明变量 {0} \#loc
javascript.create.function.intention.name=创建函数 ''{0}''
javascript.create.variable.intention.name=创建变量 ''{0}''
javascript.create.constant.intention.name=创建常量 ''{0}''
javascript.declare.variable.intention.name=插入 ''{0}'' 的 var 声明
javascript.declare.variable.intention.family.name=插入 var 声明
javascript.declare.variable.in.previous.var.statement.intention.name=向以前的 var 语句中插入 ''{0}'' 的 var 声明
javascript.declare.variable.in.previous.var.statement.intention.family=向以前的 var 语句中插入 var 声明
javascript.create.field.intention.name=创建字段 ''{0}''
javascript.create.constant.field.intention.name=创建字段常量''{0}''
javascript.create.method.intention.name=创建方法 ''{0}''
javascript.create.property.intention.name=创建属性 ''{0}''
javascript.create.function.property.intention.name=创建函数属性 ''{0}''
javascript.create.constructor.intention.name=在 ''{0}'' 类中创建构造函数
actionscript.create.constructor.intention.name=创建构造函数 ''{0}''
javascript.create.get.property.intention.name=创建 ''get'' 属性 ''{0}''
javascript.create.set.property.intention.name=创建 ''set'' 属性 ''{0}''
javascript.create.function.intention.family=创建 JavaScript 函数或方法
javascript.create.variable.intention.family=创建 JavaScript 变量或属性
javascript.intention.create.getter.setter=为''{0}''创建getter和setter
javascript.intention.create.getter.setter.desc=创建 getter 和 setter
javascript.intention.create.setter=为''{0}''创建setter
javascript.intention.create.setter.desc=创建 setter
javascript.intention.create.getter=为''{0}''创建getter
javascript.intention.create.getter.desc=创建 getter
create.mobile.view=创建视图 ''{0}''
invalid.package=无效的包：{0}
javascript.rename.reference.intention.name=重命名引用
typescript.rename.javascript.references=在 JavaScript 文件中搜索 (&J)
typescript.rename.dynamic.references=搜索动态引用 (&D)
js.usage.type.string=字符串文字中的用法
js.usage.type.call=函数调用中的用法
js.anonymous.to.named.function=匿名函数转换为命名函数
js.convert.to.named.function=转换为命名函数
js.convert.to.named.function.to.class.method=转换为类方法
js.convert.to.arrow.function.family.name=转换为箭头函数
js.convert.to.arrow.function=转换为箭头函数
js.add.braces.to.arrow.function=向箭头函数中添加大括号
js.inspection.function.expression.is.used.instead.of.arrow=使用了函数表达式而不是箭头函数
js.arrow.function.braces.can.be.removed.key=可移除箭头函数体周围的大括号
js.arrow.function.braces.can.be.removed.problem.description=可移除箭头函数体周围的大括号
js.arrow.function.braces.can.be.removed.fix.family.name=移除箭头函数体周围的大括号
js.convert.to.anonymous.function.family.name=箭头函数转换为匿名函数
js.convert.to.anonymous.function=转换为匿名函数
js.named.to.anonymous.family.name=转换为函数表达式
js.named.to.function.expression.text = 转换为包含变量的函数表达式
js.named.to.function.hoisting.conflict.text=函数在声明之前使用。转换为变量后，将中断使用
js.named.to.arrow.text = 转换为含有 {0} 的箭头函数
js.split.into.multiple.declarations=拆分为多个声明
js.remove.digit.separators=移除数字分隔符
js.copy.qualified.to.clipboard=将限定名称复制到剪贴板
js.iterate=使用 for..of 进行迭代
js.iterate.async=使用 await..of 进行迭代
js.separate.digits=分隔数字
js.separate.nibbles=分隔半字节
js.separate.bytes=分隔字节
js.separate.words=分隔 16 位单词
js.separate.thousands=分隔千位数
js.separate.thousands.in.integer.part=将千位数分隔成整数
js.split.declarations=拆分声明
js.swap.$0.and.$1=交换 ''{0}'' 和 ''{1}''
js.swap.arguments=交换方法调用参数
js.replace.string.with.es6.template=替换为模板字符串
js.replace.string.concatenation.with.es6.template.inspection.name=使用了字符串串联而不是字符串模板
js.replace.string.concatenation.with.es6.template.fix.text=替换为模板字符串
js.string.template.line.separators.visible=转换为可见行分隔符
js.string.template.line.separators.multispan=转换为多行字符串模板
js.string.template.line.separators.visible.family.name=转换模板字符串以使用可见行分隔符
js.string.template.line.separators.multispan.family.name=转换为多行字符串模板
js.convert.var.to.let=将 var 转换为 let
js.convert.var.to.const=将 var 转换为 const
js.convert.var.to.let.text=转换为 let
js.convert.var.to.const.text=转换为 const
js.convert.var.to.let.or.const=转换为 let/const
js.convert.var.to.let.or.const.family.name=将 var 转换为 let/const
js.convert.var.to.let.or.const.inspection.text=使用了 'var' 而不是 'let' 或 'const'
js.convert.let.to.const.inspection.text=在可能为 'const' 的场合使用 'let'
js.convert.var.to.let.or.const.inspection.conservative.option=使用“全部修复”操作保守地转换 var
js.convert.var.to.let.or.const.inspection.conservative.option.description=在第一次使用变量之前，声明可能会移至函数器顶部。\n要在使用“全部修复”操作时禁用此行为，请选中“保守转换 var”选项。
js.convert.require.into.es6.import.text=将 require() 转换为 import
js.convert.require.into.es6.import.family.name=将 require() 转换为 import
js.convert.require.into.es6.import.inspection.text=使用了 'require()' 而不是 'import'
js.convert.require.into.es6.import.inspection.withConditional.option=使用“全部修复”操作在内部范围内转换 require()
js.convert.require.into.es6.import.inspection.withConditional.option.description=在内部范围内转换 require()（例如 'if' 语句或内部函数）
js.convert.module.exports.into.es6.export.text=转换为 export
js.convert.module.exports.into.es6.export.family.name=转换为 export
js.convert.module.exports.into.es6.export.inspection.text=使用了 'module.exports' 而不是 'export'
js.convert.for.in.to.for.of.text='for..in' 转换为 'for..of'
js.convert.for.in.to.for.of.family.name='for..in' 转换为 'for..of'
js.convert.for.in.to.for.of.inspection.text=使用了 'for..in' 而不是 'for..of'
js.convert.indexed.for.to.for.of.text=将带索引的 'for' 转换为 'for..of'
js.convert.indexed.for.to.for.of.family.name=将带索引的 'for' 转换为 'for..of'
js.convert.indexed.for.to.for.of.inspection.text=带索引的 'for' 循环可替换为 'for..of'
js.convert.for.each.to.for.of.intention.text=转换为 'for..of'
js.convert.for.each.to.for.of.intention.family=将 'forEach' 替换为 'for..of' 循环
js.convert.for.each.to.indexed.intention.family=将 'forEach' 替换为索引的 'for' 循环
js.convert.for.of.to.indexed.intention.family=将 'for..of' 替换为索引的 'for' 循环
js.convert.map.to.for.of.intention.family=将 'map' 数组调用替换为 'for..of' 循环
js.convert.indexed.for.to.foreach.intention.family=将带索引的 'for' 转换为 'forEach' 数组调用
js.add.then.fix=添加 '.then()'
js.quote.unquote.intention.plural={0} 属性名称
js.quote.unquote.intention.singular={0} 属性名称
js.quote.unquote.intention.quote=引用
js.quote.unquote.intention.unquote=取消引用
js.property.to.indexer.intention=替换为索引器访问
js.indexer.to.property.intention=替换为属性访问
js.join.vars.intention=加入后续变量声明
js.infer.parameter.types.intention=从用法中推断参数类型
js.infer.parameter.types.intention.jsdoc=从用法中推断 JSDoc 参数类型
js.infer.parameter.types.intention.failure.title=无法推断类型
js.infer.parameter.types.intention.progress.text=推断类型
js.infer.parameter.types.intention.failure.text=无法从用法中推断类型
js.infer.parameter.types.intention.failure.readonly.text=无法从用法中推断类型：为只读文件
es6.move.module.members.refactoring.name=移动模块成员
es6.move.module.members.table.title=要移动的成员
es6.move.module.members.refactoring.create.file=创建文件
es6.move.module.members.refactoring.file.does.not.exist=文件{0}不存在
es6.move.module.members.refactoring.create.file.message=文件 {0} 不存在。\n你想创建它吗？
es6.move.module.members.refactoring.dialog.selected.title=移动所选成员：
es6.move.module.members.refactoring.dialog.error.no.script.tag=目标文件不包含脚本标签
es6.move.module.members.refactoring.dialog.error.invalid.file.name=目标文件名在此操作系统中无效
es6.move.module.members.refactoring.dialog.error.no.selected.items=没有要移动的选定成员
es6.move.module.members.refactoring.dialog.error.incorrect.module=目标模块不正确
es6.move.module.members.refactoring.dialog.error.modules.same=源模块和目标模块应不同
es6.move.module.members.refactoring.dialog.move.member.to=成员移动至
es6.move.module.members.refactoring.dialog.field.from=从\:
es6.move.module.members.refactoring.dialog.field.to=到\:
es6.move.module.members.references.unresolved.import.message=选择的 {0} 引用未解析导入 {1}
es6.move.module.members.references.local.message=选择的 {0} 引用非导出 {1}
es6.move.module.members.has.local.usage.message=文件 {1} 中使用未导出的 {0}
es6.move.module.members.non.es6.module.usage=在非 ES6 模块的文件 {1} 中使用 {0}
es6.move.module.members.destination.not.es6=目标文件 {0} 不是 ES6 模块
es6.move.module.members.cannot.detect.js.language=目标文件不是 JS 文件
es6.move.module.members.destination.contains.default.export=目标模块包含默认导出
es6.move.module.members.destination.does.not.support.jsx={0} 包含 JSX 标签，但目标语言不支持这些标签
es6.move.module.members.syntax.errors=移动 {0} 将引入语法错误，因为目标语言不同于源语言

js.pull.up.will.be.made.abstract=非 abstract {0} 将被设为 abstract
es6.extract.super.destination.label=目标文件 (&D)：
es6.extract.super.members.in.interface=新接口中的成员
es6.extract.super.members.in.superclass=新超类中的成员
es6.extract.super.overload.declaration.without.implementation.conflict=类中不允许没有实现的重载声明 {0}

# Unit testing
js.testing.inspection.group.name=单元测试
js.testing.highlight.line=在测试代码中高亮显示失败的行
rc.environmentVariables.label=环境变量 (&E)：
rc.testRunScope.all=所有测试(&A)
rc.testRunScope.testFile=测试文件 (&F)
rc.testRunScope.suite=套件(&S)
rc.testRunScope.test=&测试
rc.nodeOptions.label=节点选项 (&O)：
rc.workingDirectory.label=工作目录 (&W)\:
rc.workingDirectory.browseDialogTitle=选择工作目录
rc.testOrSuiteScope.suite.title=编辑套件名称
rc.testOrSuiteScope.suite.label=套件名称：
rc.testOrSuiteScope.test.title=编辑测试名称
rc.testOrSuiteScope.test.label=测试名称：
rc.testOrSuiteScope.emptyTest=空测试名称
rc.testRunScope.testFile.label=测试文件：
rc.testRunScope.testFile.browseTitle=选择测试文件

# Unit testing: Jest
jest.snapshot.update.rc.name=更新 {0} 的快照
jest.snapshot.update.single.test.text=<link>单击以更新 {0} 的快照</link>
jest.snapshot.update.test.file.text=<link>单击以更新 {0} 中失败的快照</link>
jest.snapshot.update.all.tests.text=<link>单击以更新所有失败的快照</link>
jest.rc.configurationFile.label=配置文件 (&C)：
jest.rc.configurationFile.title=选择 Jest 配置文件
jest.rc.jestPackageField.label=Jest 包 (&J)：
jest.rc.jestOptions.label=Jest 选项：
jest.rc.jestOptions.emptyText=CLI 选项，例如 --watch 或 --env\=jsdom

# Unit testing: Protractor
protractor.rc.configurationFile.label=配置文件 (&C)：
protractor.rc.configurationFile.title=选择 Protractor 配置文件
protractor.rc.protractorPackage.label=Protractor 包 (&P)：
protractor.rc.protractorOptions.label=Protractor 选项 (&O)：
protractor.rc.protractorOptions.emptyText=CLI 选项，例如 --browser 或 --rootElement

# Node.js
node.js.inspection.group.name=Node.js
node.js.missing.require=缺少 require() 语句
node.js.unresolved.api=未解析的 Node.js API
node.js.invalid.node=该项目使用了无效的 Node.js 路径。<br>它已更新为使用 {0} 中的 Node.js。
node.js.configure=配置 Node.js
node.js.downloading=正在下载 Node.js {0}
node.js.interpreters=Node.js 解释器
node.js.set.project.interpreter.action=设置为项目解释器
node.js.add.interpreter.action=添加 {0}...

# Inspections
js.inspection.group.name=选项
typescript.inspection.group.name=TypeScript
js.inspection.bitwise.group.name=按位运算的问题
js.code.style.issues.group.name=代码风格问题
js.probable.bugs.group.name=可能的错误
js.annotator.inspection.name=JavaScript 一般错误
js.inspection.convert.to.es6.group.name=ECMAScript 6 迁移辅助
js.inspection.switch.group.name=切换语句问题
js.inspection.async.group.name=Async 代码和 promise
js.function.metrics.group.name=函数指标
js.validity.issues.group.name=有效性问题
js.imports.dependencies.group.name=导入和依赖关系
js.unused.symbols.group.name=未使用的符号
js.unwanted.symbols.group.name=可能不合需要的代码结构
js.assignment.issues.group.name=赋值问题
js.potentially.invalid.usage.of.this.inspection.name=从闭包对 'this' 的引用可能无效
js.potentially.invalid.usage.of.class.this.inspection.name=从闭包对类中 'this' 的引用可能无效
js.potentially.invalid.target.of.indexed.property.access.inspection.name=索引的属性访问的目标可能不正确
javascript.potentially.invalid.usage.of.this=This 的用法可能无效
javascript.potentially.invalid.usage.of.class.this=通过嵌套函数的 'this.' 对类字段的引用访问可能无效
javascript.potentially.invalid.target.of.indexed.property.access=索引的属性访问的目标可能无效
js.unfiltered.for.in.loop.inspection.name=未过滤 for..in 循环
javascript.unfiltered.for.in.loop=可能迭代异常（自定义/继承）成员，可能缺少 hasOwnProperty 检查
js.unfiltered.for.in.loop.skip.primitives=使用数组或对象初始值设定项跳过引用迭代
js.unfiltered.for.in.loop.skip.primitives.tooltip=在未修改 Object.prototype 和 Array.prototype 时启用它
js.referencing.mutable.variable.from.closure.inspection.name=从闭包中引用可变变量
javascript.mutable.variable.accessible.from.closure=可从闭包访问可变变量
js.unresolved.variable.inspection.name=未解析的 JavaScript 变量
js.undeclared.variable.inspection.name=隐式声明的全局 JavaScript 变量
js.duplicate.declaration.inspection.name=重复 JavaScript 声明
# WI-11522 only the first word should start with uppercase letter
js.linters.inspection.group.name=代码质量工具
js.linters.detect.automatically.caption=从最近的 package.json 检测包和配置文件
js.unused.local.symbol.inspection.name=未使用的局部符号
js.unused.es6.import.inspection.name=未使用的 ES6 / TypeScript 导入
js.unused.assignment.inspection.name=未使用的赋值
js.join.declaration.assignment.inspection.name=变量声明可与变量的第一个赋值合并
js.join.declaration.assignment.inspection.fix=联接变量声明和赋值
js.unused.global.symbol.inspection.name=未使用的全局符号
js.missing.await.symbol.inspection.name=异步函数调用缺少 await
js.missing.await.symbol.inspection.for.returns=始终对异步函数调用使用 'await' 以避免错误，并帮助进行 V8 异步堆栈跟踪
js.missing.await.symbol.inspection.for.generator.name=异步生成器应使用 for-await 循环进行迭代
jsx.missing.namespace.inspection.name=缺少使用 JSX 的 React 导入
jsx.missing.namespace.inspection.text=在未导入 {0} 的情况下使用 JSX
tsx.missing.name.quick.fix.name="添加 {0} 导入语句
js.destructuring.merge.inspection=可以合并具有相同键的解构属性
js.destructuring.merge.inspection.text=可以合并具有多个相同键的解构属性
js.destructuring.merge.inspection.fix=合并解构属性
js.nested.template.literal.inspection=模板文字中的冗余嵌套
js.nested.template.literal.fix=内联嵌套文字
js.redundant.await.inspection=冗余 'await' 表达式
js.await.promise.resolve.inspection=冗余 'await Promise.resolve()'
js.await.promise.reject.inspection=冗余 'await Promise.reject()'
js.await.promise.double.await.inspection=冗余 'await await'
js.await.promise.return.await.inspection=冗余 'return await'
js.await.promise.trivial.await.inspection=非 promise 类型的冗余 'await'
js.await.promise.resolve.fix=替换为''{0}''
js.top.level.await.expression.inspection= 顶层 'await' 表达式
js.top.level.await.expression.inspection.description= 使用了顶层 'await' 表达式
js.possibly.async.function.inspection=可能的异步函数
js.await.in.synchronous.function='await' 运算符只能在 'async' 函数中使用
js.possibly.async.function.quick.fix=令函数 {0} 为异步函数
js.possibly.async.function.quick.fix.family.name=令其为异步函数
js.property.can.be.replaced.with.shorthand=属性可以替换为缩写
js.property.can.be.replaced.with.shorthand.method=属性可以替换为简式方法
js.replace.with.shorthand.property.quick.fix=替换为缩写属性
js.replace.with.shorthand.method.quick.fix=替换为简式方法
js.expand.shorthand.property.quick.fix=展开缩写属性
js.unresolved.function.inspection.name=未解析的 JavaScript 函数
js.deprecated.symbols.inspection.name=弃用的 JavaScript 符号
js.suspicious.eq.plus.inspection.name=可疑的 '\=+' 赋值
js.suspicious.eq.plus.inspection.desc=可疑的 '\=+' 赋值：'+\=' 可能拼写错误
js.suspicious.eq.plus.fix.name=替换为 '+\='
js.suspicious.name.combination.inspection.name=可疑名称组合
js.bitwise.operator.usage.name=按位运算符用法
js.bitwise.operator.usage.popup=使用了按位运算符
js.bitwise.operator.usage.quickfix=替换为 {0}
js.potentially.invalid.constructor.usages.inspection.name=可能无效的构造函数用法
js.mismatched.update.collection.inspection.name=集合的查询和更新不匹配
js.mismatched.update.collection.update.method.names=更新方法名称
js.closure.compiler.syntax.inspection.name=闭包编译器语法
js.closure.compiler.syntax.implements.not.interface={0} 未用 @interface 进行注解
js.closure.compiler.syntax.cyclic.inheritance=循环继承涉及 {0}
js.closure.compiler.syntax.empty.type=空类型不可用
js.closure.compiler.syntax.invalid.type=类型语法无效
collection.updated.but.not.queried=更新了集合 <code>\#ref</code> 的内容，但从未被查询
collection.queried.but.not.update=查询了集合 <code>\#ref</code> 的内容，但从未更新
javascript.constructor.with.lower.case.name.used.message=构造函数名称通常以大写字母开头。拼写错误？
interface.function.declaration.should.have.no.body=接口函数声明不应有本体
javascript.ambient.declaration.should.have.no.body=环境声明不应有本体
javascript.ambient.declaration.should.have.no.initializer=环境声明不应有初始值设定项
javascript.ambient.declaration.const.should.be.primitive=环境上下文中的 'const' 初始值设定项必须是基元文字或文字枚举引用
javascript.deprecated.symbol.used.name.message=使用了弃用的符号，请查阅文档，以获取更好的替代性 \#loc
javascript.deprecated.symbol.used.name.message2=自版本 {0} 符号被标记为弃用以来，使用 {1} 作为替换用 \#loc
js.classname.macro.description=jsClassName()
js.qualified.classname.macro.description=jsQualifiedClassName()
js.methodname.macro.description=jsMethodName()
js.unused.symbol=未使用的 {0} \#ref
js.unused.symbol.full=未使用的 {0}
js.unused.symbol.remove=移除未使用的 {0}
js.suspicious.name.assignment=''{0}'' 可能不应分配给 ''{1}''
js.suspicious.name.parameter=''{0}'' 可能不应作为参数 ''{1}'' 传递
js.suspicious.name.return=''{0}'' 可能不应从方法 ''{1}'' 返回
js.show.overriding.markers.inspection.name=在 JavaScript 中显示函数重写标记
js.constructor.cant.have.return.type=构造函数不能有返回类型
invalid.identifier.value=无效标识符值
class.0.does.not.have.default.constructor=类 {0} 没有默认构造函数
invalid.identifier.value.0=无效标识符：''{0}''
js.suspicious.bind.with.arrow.function=箭头函数 'bind' 用法可疑
javascript.change.signature.invalid.parameter.declaration=无效参数：''{0}''
javascript.change.signature.invalid.function.name.0=无效函数名称：''{0}''
javascript.validation.generators.yield.not.in.generator=只允许在生成器本体中使用 'yield' 表达式。
javascript.validation.new.target.not.in.function=仅允许函数声明、函数表达式或构造函数的本体中有元属性 'new.target'
javascript.validation.message.this.referenced.from.static.context=在 static 上下文中引用了 'this'
javascript.validation.message.super.referenced.without.class.instance.context=在没有类实例上下文的情况下引用了'super'
javascript.validation.message.super.referenced.from.static.context=在 static 上下文中引用了 'super'
javascript.validation.message.function.override.without.override.modifier=方法重写了没有 override 关键字的超类 {0} 中的方法
javascript.validation.message.class.should.be.in.file=应在文件 ''{1}'' 中定义类 ''{0}''
javascript.validation.message.function.should.be.in.file=应在文件 ''{1}'' 中定义函数 ''{0}''
javascript.validation.message.namespace.should.be.in.file=应在文件 ''{1}'' 中定义命名空间 ''{0}''
javascript.validation.message.variable.should.be.in.file=应在文件 ''{1}'' 中定义变量 ''{0}''
javascript.validation.message.incorrect.package.name=包名称 ''{0}'' 与文件路径 ''{1}'' 不符
javascript.validation.multiple.var.in.for.loop=''{0}'' 循环中只允许一个变量
javascript.validation.initialized.var.in.for.loop=''{0}'' 循环中不允许变量初始值设定项
javascript.fix.package.name=设置包名称为 ''{0}''
javascript.fix.add.override.modifier=添加重写修饰符
javascript.fix.property.spelling.family=修复属性名称中可能的拼写错误
javascript.fix.property.spelling.text=将拼写调整为 ''{0}''
js.code.style.tab.name=JavaScript
js.code.style.file.name.relaxed.style=重用当前文件的 case
js.code.style.file.name.camel.style=驼峰命名法 (appComponent)
js.code.style.file.name.pascal.style=帕斯卡命名法 (AppComponent)
js.code.style.file.name.snake.style=蛇形命名法 (app_component)
js.code.style.file.name.lisp.style=中线命名法 (app-component)
js.code.style.file.name.mixed.style=带后缀的中线命名法 (my-app.component)
es6.code.style.path.mapping.always=始终
es6.code.style.path.mapping.never=从不
es6.code.style.path.mapping.different.paths=仅在指定路径以外的文件中
typescript.code.style.tab.name=TypeScript
jsx.code.style.attribute.default.value=为 JSX 属性添加：
jsx.code.style.attribute.default.value.braces=大括号
jsx.code.style.attribute.default.value.quotes=引用
jsx.code.style.attribute.default.value.none=无
jsx.code.style.attribute.default.value.typebased=基于类型
to.indent.package.statement.children=缩进包语句子级 (&I)
javascript.formatting.options.panel.title=格式化选项
javascript.formatting.options.panel.coding.style=编码样式
javascript.formatting.options.panel.naming.conventions=命名约定
javascript.formatting.options.panel.comments=注释
js.convert.parameters.to.object.intention.name=将参数转换为对象
js.convert.parameters.to.object.with.interface.intention.name=将参数转换为对象并引入接口
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=不更新非调用用法
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=方法实现接口方法。不会更新基本方法
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=不会更新使用非终端传播参数进行的调用
js.undefined.property.assignment.inspection.name=未定义的属性赋值
js.undefined.property.assignment.inspection.message=类型 {1} 中未定义属性 {0}
js.jquery.efficiency.inspection.name=JQuery 使用效率
js.jquery.efficiency.inspection.message=Jquery 用法低效
js.jquery.efficiency.inspection.preface.with.id.selector=ID 选择器前置
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=允许属性和伪选择器
js.jquery.efficiency.inspection.attribute.used.message=jQuery 属性选择器可能低效
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 伪选择器可能低效
js.jquery.efficiency.inspection.duplicated.selector=重复的 jQuery 选择器
js.accessibility.check.inspection.name=@private 和 @protected 成员可访问性
ts.accessibility.check.inspection.name='private' 和 'protected' 成员可访问性
js.convert.to.foreach.intention.name=转换为对数组的 forEach 调用
js.consecutive.commas.in.array.literal.inspection.name=数组文字中的连续逗号
js.consecutive.commas.in.array.literal.inspection.message=数组文字中的连续逗号
js.consecutive.commas.in.array.literal.inspection.insert.undefined=插入 'undefined'
js.check.function.signature.guess.optionality=猜测参数的可选性
js.check.function.signature.guess.optionality.hint=如果禁用，则所有未键入的参数均视为可选参数
es6.redundant.await.report.for.promises=promise 报告
es6.redundant.await.report.for.promises.hint=总是报告 'return await' 为冗余，但这会破坏 V8 的异步堆栈跟踪功能
es6.missing.await.report.for.promises=返回声明中的 promise 报告
es6.missing.await.report.for.promises.hint=在异步函数调用前插入 'await' 有助于 V8 提供异步堆栈跟踪
es6.validation.inspection.name=实验性语言功能
es6.validation.elements.are.not.supported=ECMAScript 6 中不包含 {0} 功能
js.file.references.inspection.name=文件引用验证
js.file.references.inspection.ignore.complex.cases=忽略复杂 case
js.referencing.arguments.outside.of.function.inspection.name=在函数外部引用 'arguments'
js.inspection.es6.modules.dependencies.family.name=缺少导入语句
js.inspection.es6.modules.missing.import.or.require=缺少导入语句或 require() 调用
js.inspection.amd.modules.dependencies.family.name=缺少 AMD 模块依赖关系
js.inspection.promise.ignored.display.name=返回 promise 的方法调用结果被忽略
js.inspection.promise.ignored.problem.descriptor=从 {0} 返回的 Promise 被忽略
js.inspection.promise.value.expected.problem.descriptor=预期为值，但使用了从 {0} 返回的 Promise
js.flowjs.group.name=Flow 类型检查器
js.flowjs.config.inspection.name=缺少 .flowconfig
js.flowjs.config.inspection.message=无关联的 .flowconfig
js.flowjs.coverage.inspection.name=Flow 不涵盖代码
js.flowjs.coverage.inspection.error.text=Flow 不涵盖此元素
js.flowjs.config.inspection.to.project.path.name=向项目根中添加 .flowconfig
js.flowjs.config.inspection.to.module.path.name=向模块内容根中添加 .flowconfig
js.flowjs.config.inspection.to.current.path.name=向当前目录中添加 .flowconfig
js.flowjs.annotation.inspection.name=Flow 错误
js.flowjs.flag.comment.placement.inspection.name=Flow 标志放错位置
js.flowjs.flag.comment.placement.inspection.error=Flow 标志注释不在文件起始处
js.flowjs.flag.comment.placement.inspection.fix=将 Flow 标志注释移至文件起始处
js.flowjs.flag.without.language.version=无 Flow 语言版本的 Flow 标志
js.extjs.unresolved.ext.xtype.inspection.name=未解析的 Ext JS xtype
js.frameworks.sencha.xtype.not.found=找不到 xtype ''{0}'' 的 Ext JS 类
javascript.equality.comparison.with.coercion.family.name=替换但不进行类型强制
javascript.equality.comparison.with.coercion.display.name=相等运算符可能导致类型强制
javascript.equality.comparison.with.coercion.error.string=比较 \#ref 可能导致意外类型强制 \#loc
javascript.equality.comparison.with.coercion.fix=替换为''{0}''
javascript.equality.comparison.with.coercion.options.label=高亮显示 '\=\=' 和 '\!\=' 的用法：
javascript.equality.comparison.with.coercion.option.always=所有
javascript.equality.comparison.with.coercion.option.always.except.null=与 null 或 typeof 比较时除外
javascript.equality.comparison.with.coercion.option.only.suspicious=仅可疑表达式
js.strict.mode.inspection.name=使用了非严格模式
js.strict.mode.inspection.error={0} 不处于严格模式下
js.strict.mode.inspection.fix=添加“use strict”杂注
js.strict.mode.inspection.redundant.pragma="use strict"杂注冗余
js.strict.mode.remove.pragma=移除“use strict”杂注
js.class.member.initialization.inspection.name=在 static 初始值设定项中使用可能未分配的属性
js.class.member.initialization.inspection.text=字段 ''{1}'' 在 ''{0}'' 之后声明，并且可能尚未分配
js.class.member.initialization.inspection.text.id=字段 ''{0}'' 引用本身
js.assignment.used.as.condition.name=用作条件的赋值
js.assignment.used.as.condition.text=<code>\#ref</code> 作为条件使用
js.assignment.used.as.condition.fix=将 ''\='' 替换为 ''{0}''
js.missing.switch.branches.inspection.name='switch' 语句缺少分支
js.missing.switch.branches.inspection.desc=''switch'' 语句缺少 case：{0}
js.missing.switch.branches.ignore.with.default=忽略具有默认分支的 switch 语句
js.unreachable.switch.branches.inspection.name=不可到达 'switch' 语句的 'case' 分支
js.unreachable.switch.branches.inspection.desc=不可到达的 'case' 分支
js.unreachable.switch.branches.ignore.with.dynamic=不在动态类型的上下文中显示此警告
js.unreachable.switch.branches.remove=移除不可到达的 'case' 分支
js.redundant.switch.problems.inspection.name='switch' 语句冗余，可以替换
js.redundant.switch.problems.inspection.empty='switch' 语句为空
js.redundant.switch.problems.inspection.empty.remove=移除空的 'switch' 语句
js.redundant.switch.problems.inspection.default='switch' 语句仅包含一个 'default' 子句
js.redundant.switch.problems.inspection.default.unwrap=解开 'switch' 语句
js.redundant.switch.problems.inspection.side.effects=并提取副作用
js.redundant.switch.problems.inspection.single='switch' 语句仅包含一个非默认子句
js.redundant.switch.problems.inspection.single.replace=将 'switch' 替换为 'if'
js.switch.no.default='switch' 语句没有 'default' 分支
js.switch.no.default.add=创建缺少的默认分支
js.variable.problems.inspection.name=声明了变量并在不同的 'case' 子句中使用
js.variable.problems.inspection.desc=变量 ''{0}'' 在子句 ''{1}'' 中声明， 但在子句 ''{2}'' 中使用
js.variable.problems.inspection.desc.ref.error=访问时引用错误
js.variable.problems.ignore.desc=对可变变量忽略
js.inspection.package.json.dependencies=package.json 中的依赖关系不匹配
js.inspection.missing.amd.dependency=缺少 AMD 模块依赖关系
js.inspection.missing.import=缺少导入语句
js.inspection.missing.module.dependency=缺少模块依赖关系
typescript.narrowed.to=范围缩小至 ''{0}''

typescript.suspicious.constructor.parameter.assignment=构造函数中的参数赋值可疑。您忘了添加  'this.' 吗？
typescript.suspicious.constructor.parameter.assignment.desc=构造函数中的参数赋值可疑
typescript.abstract.class.constructor.can.be.made.protected=abstract 类构造函数可以设为 protected
typescript.make.constructor.protected=将构造函数设为 protected

typescript.private.field.modifiers.mix=使用私有名称的字段不能具有 'public'、'private' 或 'protected' 访问修饰符

javascript.validation.message.flowjs.path=Flow 路径不正确
javascript.validation.message.interface.members.cannot.have.access.modifiers=接口成员不能具有访问修饰符
javascript.validation.message.interface.members.cannot.have.namespace.attributes=接口成员不能具有命名空间属性
javascript.validation.message.interface.members.cannot.be.final.modifiers=接口成员不能为 final
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=仅允许类成员使用 static 修饰符
javascript.validation.message.interface.cannot.be.final.modifiers=接口不能为最终
javascript.template.context.type=JavaSc&ript 和 TypeScript
actionscript.template.context.type=ActionScript (&I)
interface.should.have.no.variable.declarations=接口不应有变量声明
javascript.validation.message.implements.for.interface.not.allowed=接口不允许有实现列表
javascript.validation.message.interface.name.expected.here=此处预期为接口名称
javascript.validation.message.class.name.expected.here=此处应为类名
javascript.validation.message.circular.dependency=循环依赖关系
javascript.validation.message.index.no.type=索引签名参数必须具有类型注解
javascript.validation.message.index.wrong.type=索引签名参数类型必须可以分配给 'string | number | symbol'
javascript.fix.remove.circular.dependency=移除循环依赖关系
javascript.validation.message.more.than.one.externally.visible.symbol=文件中定义了多个外部可见符号

# these items are used implicitly - see JSClosureCompilerSyntaxInspection.getNotImplementedTextId
javascript.validation.message.interface.method.not.implemented=未实现来自于接口 {1} 的方法 {0}
javascript.validation.message.abstract.method.not.implemented=未实现类 {1} 中的 abstract 方法 {0}
javascript.validation.message.abstract.get.accessor.not.implemented=未实现类 {1} 的 abstract get 访问器 {0}
javascript.validation.message.abstract.set.accessor.not.implemented=未实现类 {1} 的 abstract set 访问器 {0}
javascript.validation.message.interface.property.not.implemented=未实现接口 {1} 的属性 {0}
javascript.validation.message.interface.get.accessor.not.implemented=未实现接口 {1} 的属性 get 访问器 {0}
javascript.validation.message.interface.set.accessor.not.implemented=未实现接口 {1} 的属性 set 访问器 {0}

javascript.validation.message.class.method.incompatible= ''{1}'' 类中的方法 ''{0}'' 不可分配给基类 ''{2}'' 中的同一方法
javascript.validation.message.class.property.incompatible= ''{1}'' 类中的属性 ''{0}'' 不可分配给基类 ''{2}'' 中的同一属性
javascript.validation.message.class.method.not.implemented=未实现类 {1} 的方法 {0}
javascript.validation.message.class.property.not.implemented=未实现类 {1} 的属性 {0}
javascript.validation.message.interface.call.signature.not.implemented=未实现接口 {0} 的调用签名
javascript.validation.message.interface.index.signature.not.implemented=未实现接口 {0} 的索引签名
javascript.validation.message.class.setter.cannot.have.return.type='set' 访问器不能有返回类型
javascript.fix.remove.externally.visible.symbol=移除外部可见符号
javascript.fix.remove.abstract.keyword=移除 'abstract' 修饰符
javascript.fix.remove.static.keyword=移除 'static' 修饰符
javascript.fix.remove.modifier=移除修饰符
javascript.fix.implement.members=实现成员
javascript.fix.implement.methods=执行方法
javascript.fix.implement.fields=实现字段
javascript.implement.all.interfaces=实现所有成员
javascript.implement.required.interfaces=实现所需的所有成员
javascript.implement.members.abstract=实现 abstract 成员

# Symbols
javascript.parameter=参数
javascript.local.variable=局部变量
javascript.global.variable=全局变量
javascript.global.function=全局函数
javascript.local.function=局部函数
javascript.global.decorator=装饰器
javascript.static.member.function=static 成员函数
javascript.static.member.variable=static 成员变量
javascript.instance.member.variable=实例成员变量
javascript.instance.member.function=实例成员函数
javascript.create.class.intention.name=创建类 ''{0}''
javascript.create.interface.intention.name=创建接口 ‘’{0}''
choose.class.to.import.title=导入类
javascript.fix.remove.override.modifier=移除重写修饰符
javascript.fix.remove.virtual.modifier=移除虚拟修饰符
javascript.validation.message.attribute.was.specified.multiple.times=多次指定修饰符 {0}
javascript.fix.remove.dynamic.modifier=移除动态修饰符
javascript.validation.message.function.override.for.object.method=从 Object 继承的方法无需重写
javascript.validation.message.function.override.without.parent.method=方法不重写超类的方法
javascript.parser.message.expected.gt=预期 >
javascript.parser.message.expected.lbracket=预期 [
javascript.parser.message.expected.readonly=预期为 'readonly'
javascript.module.name=模块名称
javascript.exported.variable=导出的变量
javascript.exported.function=导出的函数
javascript.exported.class=导出的类
typescript.module.name=模块名称
typescript.type.alias.name=类型别名
typescript.type.guard.name=变量类型缩小为类型防护
typescript.type.guard.name.disable=禁用缩小类型为“类型防护”的颜色
typescript.primitive.types.name=基元类型
typescript.type.parameter=类型参数
typescript.remove.type.declaration=移除类型声明

generate.constructor.overloads.and.fields.chooser.title=选择要使用的重载和要初始化的字段
generate.getter.setter.chooser.title=选择字段生成Getter和Setter
generate.to.string.chooser.title=选择要在 toString 函数中使用的字段
generate.getter.fields.chooser.title=选择字段生成Getter
generate.setter.fields.chooser.title=选择字段生成Setter
methods.to.implement.chooser.title=选择实现的方法
members.to.implement.chooser.title=选择要实现的方法
methods.to.override.chooser.title=选择要重写的方法
members.to.override.chooser.title=选择要重写的成员
fields.to.implement.chooser.title=选择要重写的字段
no.candidates=无候选项
no.methods.to.implement=找不到要实现的方法
no.members.to.implement=找不到要实现的成员
no.fields.to.implement=找不到要实现的字段
no.methods.to.override=找不到要重写的方法
no.members.to.override=找不到要重写的成员
no.variables.for.getter=找不到没有 getter 的字段
no.variables.for.setter=找不到没有 setter 的字段
no.variables.for.getter.setter=找不到没有 getter 和 setter 的字段
javascript.validation.unused.import=未使用的导入
javascript.validation.fqn.to.replace.with.import=限定名称可替换为导入语句
javascript.fix.optimize.imports=优化导入
javascript.parser.message.expected.doc.tag.value=预期为标签值
javascript.parser.message.expected.doc.tag.name=预期为文档标签名称
javascript.invalid.number.of.parameters=参数个数无效，预期为 {0}
javascript.invalid.e4x.filter.query.receiver=e4x 过滤器查询参数无效，应为 XML 或 XMLList 类型
javascript.expression.type.implicitly.coerced.to.unrelated.type=表达式类型 {1} 隐式强制为不相关类型 {0}
javascript.argument.type.mismatch=参数类型 {1} 不可分配给参数类型 {0}
javascript.initializer.type.mismatch=初始器类型 {1} 不可分配给变量类型 {0}
actionscript.binary.operand.type.mismatch=二元运算参数类型 {0} 与类型 {1} 不兼容
javascript.incorrect.variable.type.mismatch=变量类型 {1} 不可分配给类型 {0}
javascript.term.does.not.evaluate.to.function=方法表达式不是函数类型
javascript.term.does.not.evaluate.to.function.nullable=方法表达式可以为 null 或 undefined
javascript.term.does.not.evaluate.to.function2=属性不能作为函数调用
javascript.term.does.not.evaluate.to.function.line.break=表达式不可调用。如果这不应是调用，请检查是否缺少分号
javascript.term.does.not.evaluate.to.function2.fix=移除参数列表
javascript.term.nullable.indexer.qualifier=索引的表达式可以为 null 或 undefined
javascript.unused.import.remove=移除未使用的 'import'
javascript.unused.import.remove.specifier=移除未使用的元素
javascript.assigned.expression.type.mismatch=分配的表达式类型 {1} 不可分配给类型 {0}
javascript.vector.literal.element.type.mismatch=矢量文字元素类型 {1} 不可分配给类型 {0}
javascript.type.is.not.assignable.to.type=类型 {1} 不可分配给类型 {0}
javascript.no.call.signatures=分配的类型不包含调用签名
javascript.known.props.only=对象文字只能指定已知属性，但以下为额外属性：{0}
javascript.returned.expression.type.mismatch=返回的表达式类型 {1} 不可分配给类型 {0}
javascript.insert.cast.fix=插入转换
javascript.insert.primitive.wrapper.fix.family.name=使用基元类型包装
javascript.insert.generic.wrapper.fix.family.name=使用泛型类型包装
javascript.insert.wrapper.fix.text=使用 ''{0}'' 包装
typescript.insert.cast.fix=插入类型断言
es6.insert.await.fix=插入 await
es6.change.to.default.fix=对 ''{0}'' 使用默认导入
es6.change.to.named.import.fix=对 ''{0}'' 使用命名导入
typescript.insert.type.guard.fix.family=插入类型防护
typescript.insert.type.guard.surround=封闭在 ''{0}''中
typescript.insert.type.guard.prefix=前缀为 ''{0}''
typescript.insert.type.guard.postfix=使用 ''{0}'' 进行可选查询
typescript.insert.type.guard.nc=将限定符替换为 ''{0}''
typescript.insert.type.guard.nc.self=替换为''{0}''
error.not.available.in.javascript.code={0} 在 JavaScript 代码中不可用
cannot.modify.library.code=无法修改库或 SDK 代码
javascript.extract.method.title=提取函数
javascript.validation.message.function.override.incompatible.signature.generic=不兼容重写
javascript.validation.message.function.override.incompatible.access.modifier=不兼容重写，应有 ''{0}'' 访问修饰符
javascript.validation.message.function.override.incompatible.signature=不兼容重写，应有签名 ''{0}''
javascript.validation.message.function.override.incompatible.signature2=不兼容重写，应有返回类型 ''{0}''
javascript.validation.message.function.override.incompatible.signature3=不兼容重写，应有种类 ''{0}''
javascript.validation.message.function.method.invalid.overridden.parameter.type=不兼容重写，应有类型 ''{0}''
javascript.validation.message.interface.method.invalid.access.modifier=不兼容实现，应有 'public' 访问修饰符
javascript.validation.message.interface.method.invalid.signature=不兼容实现，应有签名 ''{0}''
javascript.validation.message.interface.method.invalid.signature2=不兼容实现，应有返回类型 ''{0}''
javascript.validation.message.interface.method.invalid.signature3=不兼容实现，应有 get / set ''{0}''
javascript.validation.message.duplicate.catch.block=重复 catch 块 \#loc
javascript.validation.message.duplicate.catch.block.fix=移除重复的 catch 块
javascript.validation.message.missing.catch.or.finally=缺少 catch 或 finally 子句
javascript.validation.message.return.value.of.type.is.required=必需具备类型 {0} 的返回值
javascript.validation.message.return.statement.required=非无效返回类型必需具备返回语句
typescript.validation.message.invalid.module.member.modifier=''{0}'' 不是模块成员的有效修饰符
javascript.validation.message.unresolved.component=未解析的组件
javascript.validation.message.constructor.in.mxml.is.not.allowed=MXML 类不允许构造函数
javascript.validation.message.super.constructor.call.should.be.in.constructor=超类构造函数调用应位于构造函数本体中
javascript.fix.remove.constructor=移除构造函数
javascript.validation.message.package.shouldbe.first.statement=包应为文件中的第一个语句
javascript.metadata=元数据
javascript.class=类
javascript.interface=接口
javascript.label=标签
javascript.function.arrow=箭头函数
javascript.validation.message.file.should.be.under.source.root=对象位于源根目录外的文件中，某些功能将不可用
javascript.validation.message.more.than.one.named.object.in.package=包中的非唯一对象
javascript.validation.message.unneeded.comma=不需要的逗号
javascript.validation.message.remove.unneeded.comma.fix=移除不需要的逗号
javascript.validation.message.constructor.cannot.be.static=构造函数不能为 static
javascript.create.event.handler.intention.name=创建事件处理程序 ''{0}''
javascript.validation.message.missed.super.constructor.call=缺少超类构造函数调用
javascript.validation.message.this.before.super.call=超类构造函数调用前不允许有 'this'
javascript.validation.message.baseMethod.before.super.call=超类构造函数调用前不允许有 'super'
javascript.validation.message.base.constructor.in.not.derived=仅允许在派生构造函数中调用基类构造函数
typescript.validation.message.base.constructor.must.be.first.statement=如果类包含初始化属性或具有参数属性，则基类构造函数调用必须为构造函数中的第一条语句
javascript.fix.create.constructor.invoke.super=创建构造函数匹配super
javascript.fix.create.invoke.super=插入超类构造函数调用
javascript.interface.can.not.be.instantiated.message=无法实例化接口
javascript.abstract.class.can.not.be.instantiated.message=无法实例化 abstract 类
javascript.validation.message.set.method.should.be.void.or.without.type=setter 定义的返回类型必须为未指定或无效
javascript.validation.message.set.method.should.have.one.parameter=setter 定义必须正好有一个参数
javascript.validation.message.get.method.should.have.no.parameter=getter 定义不得有参数
javascript.validation.message.get.method.should.be.valid.type=getter 定义的返回类型不应为 {0}
javascript.validation.message.access.modifier.allowed.only.for.class.members=仅允许类成员使用访问修饰符
javascript.validation.message.namespace.allowed.only.for.class.members=仅允许类成员使用命名空间
javascript.validation.message.access.modifier.allowed.only.for.package.members=包成员仅允许使用 public/internal 修饰符
javascript.validation.message.use.namespace.reference.or.access.modifier=使用命名空间或访问修饰符
javascript.validation.message.one.visibility.modifier.allowed=只允许一个可见性修饰符(public、protected、internal、private)
javascript.validation.destructuring.without.initializer=解构声明必须有初始值设定项
javascript.fix.remove.access.modifier=移除访问修饰符
javascript.fix.remove.final.modifier=移除 final 修饰符
javascript.validation.message.final.modifier.allowed.only.for.methods=final 修饰符只能应用于类和类方法
javascript.fix.remove.namespace.reference=移除命名空间引用
javascript.fix.remove.visibility.modifier=移除可见性修饰符
javascript.incorrect.array.type.in.for-in=数组键类型应为字符串
javascript.validation.message.unexpected.type.for.rest.parameter=Rest 参数不应有类型
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 参数必须为数组类型或具有数组约束的泛型
typescript.validation.message.unexpected.type.for.rest.parameter.fix=替换为数组类型
typescript.validation.message.class.invalid.context={0} 必须在文件或模块上下文中
javascript.fix.remove.type.reference=移除类型引用
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=rest 参数后不允许有任何参数
javascript.validation.message.comma.is.not.allowed.after.rest.element=rest 元素后不允许有逗号
javascript.validation.message.comma.is.not.allowed.after.last.parameter=最后一个参数后不允许有逗号
javascript.fix.remove.comma=移除逗号
javascript.fix.remove.parameter=删除参数
javascript.fix.remove.parameters=移除参数
javascript.fix.remove.initializer=移除初始值设定项
javascript.validation.message.parameter.should.be.initialized=应初始化参数
javascript.validation.message.parameter.non.optional.after.optional=必选参数不能位于可选参数后
javascript.validation.message.parameter.rest.optional=rest 参数不能是可选参数
javascript.fix.initialize.parameter=初始化参数
javascript.validation.message.rest.parameter.should.not.be.initialized=不应初始化 Rest 参数
javascript.validation.message.nested.classes.are.not.allowed=不允许嵌套类
javascript.validation.message.nested.packages.are.not.allowed=不允许嵌套包
javascript.validation.message.implements.is.not.allowed=标准 ECMAScript 中不允许有实现子句
generate.getter.fields.bindable.properties=可绑定属性 (&B)
javascript.validation.message.arguments.with.rest.parameter=使用 rest 参数时，'arguments' 对象不可用
js.validate.types.inspection.name=类型不匹配
typescript.validate.optional.parameter.inspection.error=参数不能有问号和初始值设定项
typescript.validate.optional.parameter.inspection.fix.question=移除问号
typescript.validate.generic.types.inspection.name=泛型类型不匹配
typescript.redundant.typescript.type.argument.inspection.name=泛型类型的类型参数冗余
typescript.duplicate.typescript.union.inspection.name=联合或相交类型组件重复
typescript.validate.generic.types.fix.delete=移除泛型参数
typescript.validate.generic.types.fix.add=添加泛型参数
typescript.validate.generic.types.inspection.error.argument.number=泛型类型 ''{0}'' 需要 ''{1}'' 类型参数
typescript.validate.generic.types.inspection.error.argument.number.between=泛型类型 ''{0}'' 需要介于 {1} 和 {2} 之间的类型参数
typescript.validate.generic.types.inspection.error.not.empty.argument=类型参数列表不能为空
typescript.validate.generic.types.inspection.error.not.empty.parameter=类型参数列表不能为空
typescript.validate.types.any.inspection.name='any' 类型上下文中的类型不匹配
js.incompatible.types.comparison.inspection.name=类型不兼容的表达式的比较
js.incompatible.types.comparison.message=条件始终为 {0, choice,0\#false|1\#true}，因为类型 ''{1}'' 和 ''{2}'' 没有重叠
javascript.validate.imports.name=导入验证
es6.validate.import.error=不能解决符号 ''{0}''
es6.prefer.short.import.name=可以缩短导入
typescript.reference.to.umd.global=引用 UMD 全局
typescript.field.can.be.made.readonly=仅在构造函数中分配字段，并且可以置于只读
javascript.suspicious.type.guard.desc=类型防护检查不健全
javascript.object.null.or.undefined.desc=对象为 'null' 或 'undefined'
javascript.suspicious.typeof.guard=''typeof'' 检查无效：''{0}'' 不能具有类型 ''{1}''
javascript.redundant.typeof.guard=''typeof'' 检查冗余：''{0}'' 始终具有类型 ''{1}''
javascript.falsy.typeof.guard=''typeof'' 检查始终为 false：{0}'' 始终具有类型 ''{1}''
javascript.false.null.or.undefined.guard=条件始终为 false
javascript.true.null.or.undefined.guard=条件始终为 true
typescript.suspicious.instanceof.guard=''instanceof'' 检查无效：''{0}'' 的类型与 ''{1}'' 无关
typescript.redundant.instanceof.guard=''instanceof'' 检查冗余：''{0}'' 具有类型 ''{1}'' 或 ''{1}'' 的子类型
typescript.redundant.instanceof.inheritor.guard=''instanceof'' 检查冗余：''{0}'' 具有类型 ''{1}'' 或 ''{1}'' 的继承者
javascript.object.is.null={0} 为 null
javascript.object.is.possibly.null={0} 可能为 null
javascript.object.is.undefined={0} 为 undefined
javascript.object.is.possibly.undefined={0} 可能为 undefined
javascript.object.is.null.or.undefined={0} 为 null 或 undefined
javascript.object.is.possibly.null.or.undefined={0} 可能为 null 或 undefined
typescript.smart.cast=使用类型防护缩小了变量类型的范围
typescript.smart.cast.hyperlink=设置字体和背景
typescript.missing.augmentation.import=缺少增强导入
typescript.explicit.member.type.inspection.name=显式成员类型
typescript.config.inspection=tsconfig.json 验证
typescript.config.inspection.libs=tsconfig.json 中不包含所需的 TypeScript 库
typescript.config.inspection.missing.option=tsconfig.json 中缺少选项
typescript.config.inspection.libs.fix=在 tsconfig.json 中启用库 ''{0}''
typescript.config.inspection.config.options.fix=向 tsconfig.json 中添加 ''{0}''
typescript.config.inspection.fix.pattern=添加 ''{0}'' 属性
typescript.config.inspection.path.mapping.info=路径映射需要 baseUrl 属性
typescript.config.inspection.checkjs.info=属性 checkJs 需要 allowJs 属性
typescript.redundant.declaration=类型声明与推断的类型相匹配，因此可以移除
unnecessary.parentheses.display.name=不必要的括号
unnecessary.parentheses.problem.descriptor=<code>\#ref</code> 周围的括号不必要 \#loc
remove.unnecessary.parentheses.fix.text=移除不必要的括号
typescript.specify.type.explicitly=显式指定类型
typescript.specify.type.explicitly.from.hint=添加显式类型注解
typescript.specify.all.param.types.explicitly=显式指定所有参数类型
typescript.specify.all.param.types.explicitly.from.hint=向所有参数中添加显式类型注解
typescript.make.field.readonly=令其为只读字段
typescript.unwrap.if=解开 'if' 分支并移除 'else' 分支
typescript.unwrap.else=移除 'if' 分支并解开 'else' 分支
es6.replace.import.action.name=替换为 {0}
es6.replace.import.family.name=替换为较短的路径
js.validate.signature.inspection.name=签名不匹配
find.usages.of.base.interface={1} 的方法 {0}\n{2} 的实现方法。\n您想要基本方法 {3} 吗？
find.usages.of.base.class={1} 的方法 {0}\n重写 {2} 的方法。\n您想要基本方法 {3} 吗？
javascript.validation.empty.component.type=组件标签不应为空
javascript.fix.visibility.family=修复可见性问题
javascript.fix.set.element.visibility=将{0}设为 {1}
javascript.fix.add.sharp=向引用访问添加 \#
javascript.fix.remove.sharp=从引用访问中移除 \#
javascript.fix.set.method.return.type=使''{0}''返回''{1}''
javascript.fix.generate.argument.stubs=生成参数存根
javascript.deprecated.symbol.replace.fix=将弃用的代码替换为 {0}
javascript.deprecated.symbol.replace.fix.family=将弃用的代码替换为建议的替换
javascript.label.visibility.public=public(&B)
javascript.label.visibility.package_local=internal(&I)
javascript.label.visibility.private=private(&V)
javascript.label.visibility.protected=protected(&O)
move.members.refactoring.name=移动成员
move.members.dialog.title=移动成员
class.0.cannot.be.created=无法创建目标类 {0}，因为存在同名的限定元素
javascript.visibility.public=public
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
entity.in.parent.description={0}在{1}
package.description=包{0}
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=目标类中可见性为 {1} 的{0}无法从 {2} 访问
0.with.1.visibility.is.not.accessible.from.2=可见性为 {1} 的{0}将无法从{2}访问

# Refactoring
javascript.refactoring.variable.used.as.lvalue=要内联的变量在赋值的左侧使用
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=从闭包访问时变量值被更改
javascript.refactoring.inline.variable.title=内联变量
javascript.refactoring.inline.function.title=内联函数
javascript.refactoring.cannot.find.usages.of.definition.to.inline=无法找到要内联的定义的用法.
javascript.refactoring.searching.usages=查找用法
javascript.refactoring.cannot.inline.not.initialized.variable=无法内联未初始化的变量
javascript.refactoring.cannot.inline.destructuring.variable.with.default=无法内联使用默认值的解构变量
javascript.refactoring.cannot.inline.destructuring.rest.variable=无法内联解构 rest 变量
javascript.inline.element.is.not.used=从未使用 {0}
javascript.refactoring.inline.dialog.title=内联{0}
javascript.refactoring.inline.all.message=内联所有引用并移除 {0} ({1}) (&A)
javascript.refactoring.inline.this.only=仅内联此引用并保留 {0}(&K)
javascript.refactoring.cannot.inline.function.defined.in.library=无法内联外部库中定义的函数
javascript.refactoring.cannot.inline.function.referencing.arguments=无法内联函数引用参数
javascript.refactoring.cannot.inline.interface.method=无法内联接口方法
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=无法内联函数引用的 rest 参数
javascript.refactoring.cannot.inline.overrided.or.overridden.method=无法内联参与层次结构的方法
javascript.refactoring.cannot.inline.recursive.function=无法内联递归函数
javascript.refactoring.cannot.inline.function.with.multiple.returns=无法内联有多个退出点的函数
javascript.refactoring.cannot.inline.complex.expression.evaluation=无法内联复杂表达式评估
javascript.refactoring.cannot.inline.constructor=无法内联构造函数
javascript.refactoring.cannot.inline.jsx.usage=无法内联 JSX 标签用法
javascript.refactoring.cannot.inline.ambient.function=无法内联没有实现的声明
javascript.refactoring.function.to.es6.class.command=将函数 {0} 转换为类
js.convert.to.es6.class=转换为类
js.convert.to.es6.class.family.name=将函数及其成员声明转换为类
js.move.type.to.file.family=移至名称匹配的文件
js.create.derived.type.family=创建派生类/实现接口
js.create.derived.type.class=创建派生类
js.create.switch.cases=创建缺少的 'switch' 分支
js.create.switch.cases.fix=创建缺少的分支：{0}
js.edit.object.literal=编辑对象文字属性的值
js.create.derived.type.interface=实现接口
js.create.derived.type.abstract.class=实现 abstract 类
js.rename.file.to.match.type.name.family=重命名文件以匹配类型名称
js.rename.file.to.match.type.name=将文件重命名为 {0} 以匹配 {1} 名称
js.move.type.to.file.text=将 {0} 移至文件 {1}
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=警告：将使用“Object.defineProperty”、“Object.defineProperties”或“Object.create”创建的属性转换为 ES6 语法可能会影响其可枚举性和可配置性
rename.destructuring.property.title=重命名解构属性
rename.destructuring.property.description=解构属性引用多个成员。应重命名相关属性，否则可能导致代码不一致。
rename.type.members.title=重命名类型成员
rename.type.members.union.intersection.mapped.description=检测到联合、相交或映射类型用法。应重命名相关属性，否则可能导致代码不一致。
rename.type.members.destructuring.description=检测到解构属性中的用法。应重命名相关属性，否则可能导致代码不一致。
rename.containing.file.message=重命名包含的文件
make.private=设为 private
choose.destination.scope=选择目标范围

# Destructuring
javascript.find.usages.destructuring.target.dialog=缩写的解构变量使用 {0} 初始化。\n您想查找哪些用法？
javascript.destructuring.initializer=初始值设定项 {0}
javascript.destructuring.variable.only=仅解构变量
javascript.rename.destructuring.target.dialog.title=缩写的解构变量使用 {0} 初始化
javascript.rename.choose.target.message=您要重命名哪一个？
javascript.rename.shorthand.target.dialog.title=缩写的属性使用 {0} 初始化
javascript.rename.shorthand.property.description=特性
javascript.rename.file.with.related.title=重命名文件
javascript.rename.containing.file.message=是否也想将文件及其用法重命名为 {0}?
javascript.rename.related.declaration.message=是否想将 {0} 及其用法重命名为 {1}?

javascript.uml.visibility.public=public
javascript.uml.visibility.protected=protected
javascript.uml.visibility.package_local=protected \\&\\& internal
javascript.uml.visibility.private=所有
javascript.uml.show.supers.header={0} 的超类
javascript.uml.show.implementations.header={0}的实现
javascript.refactoring.asdoc.for.abstracts=摘要的 ASDoc
0.is.not.allowed.in.interface=接口中不允许使用 {0} 
javascript.validation.message.static.method.in.interface=接口中不允许使用 static 方法
javascript.fix.remove.static.modifier=移除 static 修饰符
javascript.validation.message.override.can.be.applied.to.method=重写只能应用于函数声明
javascript.validation.message.dynamic.can.be.applied.to.class=动态属性只能应用于类声明
0.is.static.it.cannot.be.moved.to.the.interface={0} 为 static。不能将它移至接口
javascript.illegal.variable.type.void=非法变量类型：'void'
javascript.cannot.return.expression.from.function.with.void.result.type=无法从结果类型为 void 的函数返回值
javascript.cannot.return.expression.from.function.with.void.result.type.fix=移除返回值
javascript.validation.message.function.override.for.interface=对 {0} 中的方法进行了不兼容的重写
javascript.validation.message.incompatible.override=对 {0} 中的成员进行了不兼容的重写
class.does.not.have.inheritors.in.current.project={0} 在当前项目中没有继承者
javascript.kind.unknown=未知元素
js.unnecessary.semicolon.inspection.name=不必要的分号
js.unnecessary.semicolon.problem=不必要的分号 \#loc
js.unnecessary.semicolon.fix.name=移除不必要的分号
javascript.refactoring.extract.function.title=提取函数
javascript.refactoring.extract.function.bad.selection=所选块应代表一组语句或表达式
javascript.refactoring.extract.function.multiple.exit.points=所选代码片段有多个退出点
javascript.refactoring.extract.function.yield.and.return=所选片段同时包含 yield 表达式和返回语句
javascript.refactoring.extract.function.no.loop.for.continue=代码片段内没有用于 continue 语句的相应循环
javascript.refactoring.extract.function.no.loop.for.break=代码片段内没有用于 break 语句的相应循环
javascript.refactoring.extract.function.no.switch.for.break=代码片段内没有用于 break 语句的相应 'switch'
javascript.refactoring.extract.function.function.used.before.declaring=选定内容包含在声明之前使用的函数
javascript.validation.message.constructor.cannot.have.custom.visibility=构造函数应为 public 或未指定可见性
javascript.validation.message.can.not.override.final.method=无法从{0}重写最终方法
top.level.package=顶层包
top.level=顶层
javascript.parser.message.expected.dot=预期
js.comparison.with.nan.inspection.name=与 NaN 比较
js.comparison.with.nan.inspection.problem=与 NaN 的相等比较始终评估为 false
js.comparison.with.nan.inspection.problem2=与 NaN 的不等比较始终评估为 true
js.comparison.with.nan.inspection.quickfix=替换为 {0}isNaN(...)
js.add.double.quotes.quickfix=使用双引号包装
js.constructor.returns.primitive.inspection.name=构造函数返回基元值
js.constructor.returns.primitive.inspection.problem=使用 'new' 调用时从构造函数返回的基元值将丢失
js.constructor.returns.primitive.inspection.quickfix=返回类型显式设置为 {0}
js.comment.matches.signature.inspection.name=JSDoc 注释匹配函数签名
js.comment.matches.signature.inspection.problem1=JSDoc 中未描述参数 {0}
js.comment.matches.signature.inspection.problem2=JSDoc 中描述的参数 {0} 未出现在函数签名中
js.comment.matches.signature.inspection.quickfix=更新 JSDoc 注释

livetemplate.description.fori=创建迭代循环
livetemplate.description.iter=迭代 (for..of)
livetemplate.description.itera=迭代 (for await..of)
livetemplate.description.itin=迭代 (for..in)
livetemplate.description.itar=遍历数组元素
livetemplate.description.ritar=反序遍历数组元素
livetemplate.description.us=插入 'use strict' 语句
livetemplate.description.ref=插入引用路径注释
livetemplate.description.defi=插入 define() 表达式
livetemplate.description.flow=插入 @flow 注解
livetemplate.description.importfrom=导入语句 - 从 ''a'' 导入 {b}
livetemplate.description.importns=导入语句 - 从 'a' 导入 * as b
livetemplate.description.importdefault=导入语句 - 从 'a' 导入 b
livetemplate.description.exportall=导出语句 - 从 'a' 导出 *
livetemplate.description.exportfrom=导出语句 - 从 ''a'' 导出 {b} 
livetemplate.description.exportitems=导出语句 - export {b}

livetemplate.description.console.log=console.log()
livetemplate.description.console.warn=console.warn()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.assert=console.assert()

macro.js.suggest.variable.name=jsSuggestVariableName()
macro.js.suggest.imported.entity.name=jsSuggestImportedEntityName()
macro.js.suggest.index.name=jsSuggestIndexName()
macro.js.array.variable=jsSuggestIndexName()
macro.js.component.type.of=jsComponentTypeOf(Array)
macro.define.parameter=jsDefineParameter()
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)

javascript.validation.tag.must.be.last.child.of.root.tag=<{0}> 标签必须是根文档标签的最后一个子标签
javascript.validation.tag.must.be.first.child.of.root.tag=<{0}> 标签必须是根文档标签的第一个子标签
javascript.validation.tag.must.be.direct.child.of.fx.library.tag=<{0}> 标签必须是 <{1}> 标签的直接子标签
javascript.validation.tag.must.have.exactly.one.child.tag=<{0}> 标签必须只有一个子标签
javascript.validation.tag.must.have.attribute.includein.or.excludefrom=<{0}> 标签必须有属性 ''includeIn'' 或 ''excludeFrom''
javascript.validation.only.this.tag.is.allowed.here=此处仅允许使用 <{0}> 标签

# Line markers
linemarker.implements.invalid=<无效>
linemarker.implements.text=实现 {1} 中的 {0}
linemarker.overrides.text=重写 {1} 中的 {0}
linemarker.implements.several=实现多种接口方法
linemarker.overridden=重写
linemarker.implemented=已实现
linemarker.overriding=重写
linemarker.implementing=实现
linemarker.javascript.typescript=JavaScript/TypeScript 行标记

js.validate.json.inspection.name=验证 JSON
json.warn.about.comments.name=有关 JSON 中注释的警告
js.validate.jsdoc.inspection.name=JSDoc 中的语法错误和未解析的引用
json.comment.problem.description=JSON 标准不允许注释。在解析前，请使用 JSMin 或类似工具移除注释。
incompatible.json.element=JSON 标准不允许此元素类型
javascript.expected.class.or.descendant=预期为类 {0} 或后代
javascript.qualified.class.name.expected=应为限定的类名
javascript.validation.message.unknown.metadata.annotation.used=使用了未知的元数据属性
javascript.validation.message.static.method.with.override=static 函数不能有重写修饰符
javascript.validation.message.set.method.type.is.different.from.getter=Set 访问器方法的类型与 get 访问器类型不兼容，预期为 ''{0}''
javascript.validation.message.get.method.type.is.different.from.setter=Get 访问器方法的类型与 set 访问器类型不兼容，预期为 ''{0}''
typescript.validation.message.getter.and.setter.must.have.same.access.type=Getter 和 setter 必须具有相同的访问类型
actionscript.validation.message.set.method.access.type.is.different.from.getter=Flash 编译器错误 174646：Set 访问器方法访问类型不同于 get 访问器访问类型，预期为 ''{0}''
actionscript.validation.message.get.method.access.type.is.different.from.setter=Flash 编译器错误 174646：Get 访问器方法访问类型不同于 set 访问器访问类型，预期为 ''{0}''
javascript.validation.message.static.method.cannot.be.final=静态方法不能为最终
javascript.validation.message.vector.without.parameters=无类型的矢量
javascript.validation.message.vector.without.parameters2=无类型的矢量无法实例化
javascript.assign.parameter.to.field.intention.name=分配参数 ''{0}'' 给字段
javascript.fix.create.parameter=创建参数 ''{0}''
javascript.introduce.parameter.introduced.variable.value=&值\:
action.JSExtractInterface.text=提取接口...(_I)
action.JSExtractInterface.description=从选中类提取接口
0.is.not.a.legal.name=''{0}'' 不是合法的类名
asdoc=ASDoc
item.already.exists={0} {1} 已存在
directory.already.contains.file=目录 ''{0}'' 已包含文件 ''{1}''
turn.refs.to.super=将 refs 转换为 super
extract.subclass.command.name=从 {1} 提取子类 {0}
extract.interface.command.name=提取接口
extract.type.alias.command.name=提取类型别名
new.actionscript.class.action.title=创建 ActionScript 类
new.actionscript.class.command.name=新建 ActionScript 类
new.actionscript.class.dialog.title=新建 ActionScript 类
new.actionscript.interface.dialog.title=新建 ActionScript 接口
new.actionscript.class.action.description=创建新的 ActionScript 类
class.template.title=类
class.with.supers.template.title=包含 Super 的类
interface.template.title=接口
extract.0.turn.refs=提取 {0} 并尽量使用 (&T)
superclass.cannot.be.extracted.from.mxml.component=无法从 MXML 组件中提取超类。
superclass.cannot.be.extracted.from.type.alias=无法从类型别名中提取超类
superclass.cannot.be.extracted.from.enum=不能从一个枚举中提取超类.
interface.cannot.be.extracted.from.type.alias=无法从类型别名中提取接口
interface.cannot.be.extracted.from.enum=无法从枚举中提取接口
javascript.fix.message.change.parameters.to.expected=将这些参数更改为预期参数
javascript.fix.message.change.return.type.to.expected=将返回类型更改为预期类型
js.last.comma.in.array.literal.inspection.name=数组文字中的最后一个逗号多余
js.last.comma.in.object.literal.inspection.name=对象文字中的最后一个逗号多余
error.wrong.caret.position.method.name=脱字符号应置于要重构的方法的名称处。
changeSignature.vararg.not.last=Rest 参数应在方法签名的最后
parameter.type.is.not.specified=参数 ''{0}'' 的类型未指定 。\n是否继续？
return.type.is.not.resolved=返回类型 ''{0}'' 未解析。\n是否继续？
change.signature.column.name.initializer=初始值设定项
change.signature.column.name.default.parameter=默认参数
change.signature.column.name.call.value=调用中的值
change.signature.parameter.table.empty.message=使用  '+' 按钮添加新参数
required.parameters.are.not.permitted.after.optional.parameters=必选参数不能位于可选参数后
javascript.fix.remove.setter.parameter.initializer=移除参数默认值
javascript.validation.message.setter.parameter.cannot.have.initializer=Setter 定义不能具有可选参数
javascript.changeSignature.no.call.value=新的必选参数 ''{0}'' 已添加。\n指定要用于此方法的所有现有调用的默认值。
es6.changeSignature.no.call.value=新参数 ''{0}'' 已添加。\n指定要用于此方法的所有现有调用的默认值或值。
javascript.changeSignature.call.value.not.allowed=参数 ''{0}'' 不允许使用默认值 。因为没有为前面的参数指定它。
es6.changeSignature.call.value.not.allowed=参数 ''{0}'' 不允许使用调用中的值 。因为没有为前面的参数指定它。
change.signature.usage.view.declarations.header=要重构的方法
0.should.be.1=''{0}'' 应为 {1}
{0}.visibility.will.break.methods.hierarchy=可见性为 {1} 的{0}无法参与层次结构
generate.delegate.method.chooser.title=选择的方法来生成代表名额
generate.delegate.method.conflict.message=无法通过不同的属性为同名成员生成委托
generate.delegate.method.conflict.message.title=无法生成委托
new.actionscript.class.uml.action.text=ActionScript 类
invalid.return.type.expression=返回类型 ''{0}'' 无效
invalid.parameter.type.expression=参数类型 ''{0}'' 无效
type.is.not.resolved=类型 ''{0}'' 未解析。\n是否继续？
invalid.field.type.expression=无效字段类型：''{0}''
choose.field.type=选择字段类型
new.field.action.text=字段
new.field.action.description=在类中创建新字段
create.field.dialog.title=创建字段
create.field.command.name=创建字段 ''{0}''
field.initializer.is.not.specified=未指定字段初始值设定项
new.method.action.text=方法
new.method.action.description=在类中创建新方法
create.method.dialog.title=创建方法
create.button.text=创建(&C)
create.method.command.name=创建方法 ''{0}()''
class.already.contains.method.warning=类 ''{0}''''已经 {1, choice, 1\# 包含|2\#继承] 方法 ''{2}()''。\n是否继续？
class.already.contains.field.warning=类 ''{0}'' 已包含字段 ''{1}''。\n是否继续？
declare.static=声明 static(&S)
new.constructor.action.text=构造函数
new.constructor.action.description=创建构造函数
create.constructor.dialog.title=创建构造函数
change.method.signature.fix.text=更改 {0} 签名
change.method.signature.and.update.delegating.call.fix.text=更改 {0} 签名以匹配 {1} 调用和更新调用
change.method.signature.and.update.delegating.call.noname.fix.text=更改签名以匹配 {0} 调用和更新调用
change.method.signature.delegating.default.text=委托
change.method.signature.fix.family.name=更改方法签名
change.method.signature.and.update.delegating.call.fix.family.name=更改方法签名并更新委托调用
javascript.callback.signature.mismatch=回调应只有一个事件类型的参数
javascript.callback.signature.mismatch.event.class=回调应只有一个 {0} 类型的参数
json.filetype.description=JSON 文件
js.uml.presentable.name=ActionScript/Flex

# Settings
settings.javascript.root.configurable.name=JavaScript
settings.javascript.linters.configurable.name=代码质量工具
Settings.JavaScript.Linters.settings.description=代码质量工具
settings.javascript.linters.autodetect.disabled=禁用 {0}(&D)
settings.javascript.linters.autodetect.configure.automatically=自动 {0} 配置 (&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 将使用 node_modules 目录中的 {1} 包，还会使用与当前文件或其任何父文件夹位于同一文件夹中的 {2} 配置文件。
settings.javascript.linters.autodetect.configure.manually=手动 {0} 配置 (&M)
settings.javascript.linters.flowjs.configurable.name=Flow JS
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.prefer.strict=首选严格模式 (&S)
settings.javascript.only.type.based.completion=仅基于类型补全 (&C)
settings.javascript.opt.chain.completion=为可空类型建议包含可选链的项目 (&O)
settings.javascript.overrides.completion=在重写补全中展开方法体
settings.javascript.var.names.completion=建议变量和参数名称 (&V)
settings.javascript.field.names.completion=为类字段建议名称 (&F)
settings.javascript.var.names.completion.desc=补全名称
settings.javascript.var.names.completion.types=为建议的参数名称添加类型注解 (&T)
settings.javascript.var.names.completion.names.only=无类型
settings.javascript.var.names.completion.types.for.params=具有函数参数的类型
settings.javascript.var.names.completion.types.for.params.fields=具有参数和字段的类型
settings.javascript.var.names.completion.types.except.fields=随处都是类型，字段除外
settings.javascript.var.names.completion.types.everywhere=随处都是类型
settings.javascript.only.type.based.completion.tooltip=根据类型信息显示较少的补全建议。可能会显著提高性能。
settings.javascript.lang.templates.configurable.name=模板
es6.auto.import.options.completion.add.imports=在代码补全时添加 ES6 导入
es6.auto.import.options.title=TypeScript / JavaScript
typescript.auto.import.options.add.imports=自动添加 TypeScript 导入
typescript.auto.import.options.add.imports.on.the.fly=即时明确导入
typescript.auto.import.options.add.on.code.completion=代码补全
typescript.auto.import.options.show.popup=导入弹出
js.import.options.merge.import=合并同一模块中成员的导入
js.import.options.use.node.resolution=在 index.js 可用时使用目录导入（节点样式模块解析）
js.import.options.use.explicit.js.extension=在模块名称中使用文件扩展名
ts.import.options.use.explicit.js.extension=在模块名称中使用 .js 文件扩展
js.add.members.to.type.desc=将成员添加到类或接口
js.add.members.to.type=将成员 {0} 添加到 ''{1}''
js.import.options.sort.members=对导入的成员排序
js.import.options.sort.module.name=按模块对导入排序
es6.import.options.paths=使用路径别名：
es6.import.options.paths.help=此选项配置导入语句中使用的路径样式。<br><br>选择“始终”时，IDE 在添加导入时始终使用来自 webpack、system.js 或 jsconfig.json 配置的别名。<br><br>选择“仅在指定路径之外的文件中”时，IDE 针对为之定义了别名的文件之间的导入使用相对路径。在所有其他文件中使用路径映射。<br><br>选择“从不”时，则不使用别名。
typescipt.import.options.paths.help=此选项配置导入语句中使用的路径样式。<br><br>选择“始终”时，IDE 在添加导入时始终使用从 tsconfig.json 映射的路径。<br><br>选择“仅在指定路径之外的文件中”时，IDE 针对为之定义了映射的文件之间的导入使用相对路径。在所有其他文件中使用路径映射。<br><br>选择“从不”时，则不使用路径映射。
typescript.import.options.paths=使用 tsconfig.json 的路径映射：
typescript.import.options.use.config=使用相对于 tsconfig.json 的路径
javascript.import.options.use.resource.root=使用相对于项目、资源或源根目录的路径
typescript.import.options.blacklist.title=不要完全从此导入：
typescript.import.options.blacklist.change.button=更改模块
typescript.import.options.blacklist.change.dialog.text=模块名称
typescript.import.options.blacklist.change.dialog.title=添加模块
js.flow.settings.executable.label=Flow 包或可执行文件 (&F)：
js.flow.settings.executable.dialog.title=选择 Flow 包或可执行文件
js.flow.services.label=为之使用 Flow 服务器：
js.flow.enable.type.checking=类型检查
js.flow.enable.other.services=导航、代码补全和类型提示
js.flow.enable.flow.service.error=\ 不正确的 Flow 路径
js.flow.enable.flow.service.error.empty=Flow 可执行文件的路径为空
js.flow.enable.flow.service.error.on.checking=检查 Flow 路径时出错：{0}
js.flow.enable.flow.service.error.message={0。禁用所有 Flow 服务或为可执行文件提供有效路径。
js.flow.settings.auto.save=自动保存所有修改的文件
js.flow.settings.auto.save.warning=只有保存其他所有修改过的文件时，Flow 才会检查当前文件。
js.flow.settings.auto.save.warning.lsp=这样 Flow 将始终显示最新的错误状态。
js.dialect.settings.dialog.title=JavaScript 语言版本
js.dialect.settings.caption=
js.dialect.settings.tableTitle=模板语言
js.dialect.settings.override.question=重写子目录和文件的语言版本？
js.dialect.settings.override.title=重写语言版本设置
js.dialect.settings.empty.text=使用 + 按钮添加目录，并选择 JavaScript 版本
js.dialects.customized.label=根据目录自定义
configure.code.completion.settings=配置代码补全设置

# Bower
settings.javascript.bower.configurable.name=Bower
bower.packages.view.dependencies=依赖\:
bower.package=Bower 包 (&B)\:
bower.json=bower.json (&O)：
bower.correct.path=请更正 {0} 的路径
bower.node.interpreter=节点解释器
bower.package.name=Bower 包

node.interpreter.mnenonic=节点解释器 (&N)：

# JS language version management
js.language.version.combo.es5=ECMAScript 5.1
js.language.version.combo.es5.description=
js.language.version.combo.js185=JavaScript 1.8.5
js.language.version.combo.js185.description=已弃用特定于 Firefox 的 ECMAScript 实现。请考虑切换。
js.language.version.combo.es6=ECMAScript 6+
js.language.version.combo.es6.description=ECMAScript 2015–2019 和一些提议
js.language.version.combo.jsx=React JSX
js.language.version.combo.jsx.description=ECMAScript 6 中的 JSX
js.language.version.combo.nashorn=Nashorn JS
js.language.version.combo.nashorn.description=Java 中的 JavaScript 实现
js.language.version.combo.flow=Flow
js.language.version.combo.flow.description=ECMAScript 6 中的 Flow 和 JSX
js.language.version.label=JavaScript 语言版本
js.language.version.not.supported.by.browsers=特别用于此版本的 JavaScript 编译器
js.switch.to.jsx.inspection.dismiss=消除
ts.switch.to.jsx.inspection.name=更改文件扩展名为 .tsx
javascript.change.language.level.message=更改 JavaScript 语言版本为 {0}
javascript.change.language.level.family=更改 JavaScript 语言版本

# JS library management
js.library.attach.debug=附加和调试版本 (&D)...
js.library.attach.release=附加和发布版本 (&R)...
js.library.select.debug=选择具有调试版本的文件或目录
js.library.select.release=选择具有发布版本的文件或目录
js.library.unresolved.url.inspection.name=HTTP 链路没有本地存储的库。
js.library.download.fix=下载库
js.library.downloading.library=正在下载库
js.library.documentation=文档
js.library.configurable.name=库
js.library.download.stubs.label=TypeScript 社区存根

choose.super.method=<html><body>选择 <b>{0}</b> 的 Super 方法（找到 {1}）</body></html>
choose.super.function=<html><body>选择 <b>{0}</b> 的 Super 函数（找到 {1}）</body></html>
choose.super.field=<html><body>选择 <b>{0}</b> 的 Super 字段（找到 {1}）</body></html>
choose.super.classifier=<html><body>选择 <b>{0}</b> 的超类或接口（找到 {1}）</body></html>
choose.subclass=<html><body>选择 <b>{0}</b> 的子类（找到 {1}）</body></html>
choose.implementing.class=<html><body>选择 <b>{0}</b> 的实现（找到 {1}）</body></html>
choose.overridden.method=<html><body>选择 <b>{0}</b> 的重写方法（找到 {1}）</body></html>
choose.overridden.function=<html><body>选择 <b>{0}</b> 的重写函数（找到 {1}）</body></html>
choose.implementing.method=<html><body>选择 <b>{0}</b> 的实现（找到 {1}）</body></html>
javascript.parser.message.expected.newline.or.semicolon=预期为换行符或分号
javascript.invalid.delete.target.message=删除运算符目标无效，预期为字段引用
javascript.with.statement.is.not.allowed.in.strict.mode.message=严格模式下不允许使用 With 语句
javascript.validation.message.redefining.is.not.allowed=不允许重新定义 {0}
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=不允许从参数中引用 'caller' 和 'callee'
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=不允许引用 'arguments' 函数属性
javascript.validation.message.arguments.is.readonly='arguments' 只读
javascript.validation.message.eval.cannot.be.assigned=不能在严格模式下分配 'eval'
javascript.octal.literals.are.not.allowed.es6.message=不允许使用前缀为 '0' 的八进制文字。改用 '0o' 前缀
javascript.octal.literals.are.not.allowed.es5.message=前缀为 '0' 的八进制文字已过时，不建议使用
javascript.octal.sequences.are.not.allowed.message=不允许八进制转义序列
javascript.invalid.extended.unicode.escape=扩展的 Unicode 转义仅允许介于 0x0 和 0x10FFFF 之间的值
javascript.octal.literals.are.not.allowed.in.strict.mode=在严格模式下不允许八进制文字
javascript.octal.literals.warn.always=关于 ES5-代码中过时八进制文字的警告
javascript.validation.message.only.one.default.is.allowed=\ switch 中只允许一个默认子句
javascript.fix.remove.default=移除默认子句
javascript.namespace.initializer.should.be.string.or.another.namespace.reference=命名空间初始值设定项应为字符串文字或其他命名空间引用
javascript.validation.message.accessor.could.not.be.nested.under.other.function=访问器方法不能嵌套在其他函数中
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=禁止在程序或函数的顶层使用函数语句
class.chooser.not.available.in.dumb.mode=正在进行索引更新，选择器不可用。
choose.super.class.title=选择超类
choose.base.component.title=选择超类
choose.super.interface.title=选择 Super 接口
0.is.not.accessible.from.1=无法从 {1} 访问 {0}
javascript.constructor.call.without.new.message=没有 new 的构造函数调用
javascript.qualified.name.is.not.imported.message=未导入限定名称 \#loc
javascript.element.is.not.accessible.message=元素不可访问 \#loc
javascript.protected.member.is.not.accessible.message=protected 成员不可访问 \#loc
javascript.protected.constructor.is.not.accessible.message=protected 构造函数不可访问 \#loc
javascript.private.member.is.not.accessible.message=private 成员不可访问 \#loc
javascript.export.only.member=元素仅导出
javascript.private.constructor.is.not.accessible.message=private 构造函数不可访问 \#loc
javascript.public.member.is.not.accessible.via.sharp.message=无法通过 \#-语法引用 public 成员 \#loc
javascript.private.member.is.not.accessible.via.sharp.message=无法通过 \# 语法引用 private 非 \# 成员 \#loc
javascript.private.member.is.not.accessible.without.sharp.message=没有 \# 语法无法引用 private 成员 \#loc
javascript.private.member.obsolete.syntax.name=*-无显式 'this.' 的 private 字段访问
javascript.private.member.obsolete.syntax=没有显式限定符 'this.' 无法访问 \#-private 字段
javascript.jsdoc.protected.member.is.not.accessible.message=protected 成员不可访问 \#loc
javascript.jsdoc.private.member.is.not.accessible.message=private 成员不可访问 \#loc
javascript.static.member.is.not.accessible.message=static 成员不可访问 \#loc
javascript.instance.member.is.not.accessible.message=实例成员不可访问 \#loc
javascript.element.need.to.be.exported=未导出元素
javascript.element.need.to.be.imported=未导入元素
javascript.element.default.instead.named=使用了默认导入而不是命名导入
javascript.element.need.to.be.included.to.config=tsconfig.json 中不包含相应文件
javascript.element.is.export.only=元素仅导出
javascript.argument.types.mismatch=参数类型与参数不匹配
javascript.member.from.unopened.namespace.message=未打开命名空间的成员 \#loc
javascript.property.is.read.only.message=只读属性 \#loc
javascript.property.is.write.only.message=只写属性 \#loc
javascript.assume.uppercase.functions.to.be.constructors=假设只有大写的函数是构造函数
javascript.not.a.constructor.call.message=不是构造函数调用
cannot.refactor.anonymous.function=现有非调用用法阻止调用站点分析。
change.signature.method.references.arguments=函数引用参数，更改签名后代码可能会中断
change.signature.call.expression.contains.spreads=函数调用包含传播参数。用法将保持不变。
change.signature.tagged.template.issue=无法更新标记的模板调用。用法将保持不变。
change.signature.conflict.incompatible.override=重写 {0} 的参数个数与重构 {1} 的参数个数不同。重构期间将忽略 {2}。
change.signature.conflict.incompatible.implementation=实现 {0} 的参数个数与重构 {1} 的参数个数不同。重构期间将忽略 {2}。
change.signature.conflict.eliminating.parameter.property.breaks.usages=将参数-属性转换为简单的参数将中断 {0} 的字段用法
change.signature.conflict.readonly.parameter.property.write.usage=将 {0} 变为只读将中断非读取用法
javascript.missed.argument.for.parameter=参数 {0} 缺少参数

# Code folding settings
checkbox.collapse.object.literals=对象文字
checkbox.collapse.one.line.function.literals=JavaScript 和 TypeScript 中的单行函数
checkbox.collapse.array.literals=数组文字
checkbox.collapse.xml.literals=XML 文字
checkbox.collapse.ts.imports=TypeScript 导入
checkbox.collapse.js.imports=JavaScript 导入
change.signature.value.column.title=值
change.signature.column.name.optional.flag=可选
change.signature.column.name.modifier=修饰符

# Flow general
javascript.flow.error.panel.all.errors=显示所有错误
js.flow.all.servers.action.restart=重启所有 Flow 服务器
js.flow.has.unsaved.files=由于修改了某些文件，因此没有执行高亮显示
js.flow.tool.window.name=Flow
flow.js.get.type=Flow JS\:Get 类型
flow.show.error.details=显示错误详情

# Code style settings
space.before.name.value.separator=在属性名称-值分隔符 '\:' 前面
space.after.name.value.separator=在属性名称-值分隔符 '\:' 后面
space.before.function.left.parenth=在函数表达式中
actionscript.space.after.dots.in.rest.parameter=在 rest 参数中的 '...' 后面
space.after.dots.in.rest.spread=在 rest/spread 中的 '...' 后面
space.before.generator.mult=在生成器中的 '*' 前面 
space.after.generator.mult=在生成器中的 '*' 后面 
spaces.within.object.type.braces=对象文字类型大括号
space.before.type.colon=在类型引用冒号 '\:' 前面
space.after.type.colon=在类型引用冒号 '\:' 后面
space.before.class.lbrace=类的左大括号
space.before.class.interface.module.lbrace=类/接口/模块左大括号
spaces.within.object.literal.braces=对象文字大括号
spaces.within.import.braces=ES6 导入/导出大括号
spaces.within.indexer.brackets=索引访问中括号
spaces.within.array.initializer=数组中括号
spaces.within.union.and.intersection=联合和相交类型
spaces.within.type.assertion=类型断言
spaces.arrow.function=箭头函数 (\=>)
spaces.async.arrow.function=在异步箭头函数中
spaces.within.interpolation.expressions=插值表达式
spaces.within.unary.additive=一元加法运算符 (+,-,++,--)
spaces.after.unary.not=在 'not' (\!) 和 '\!\!' 后面
spaces.before.unary.not=在 'not' (\!) 和 '\!\!' 前面
js.blank.lines.around.method=环绕方法\:
js.blank.lines.around.function=Around 函数：
js.spaces.in.flow.category=在 Flow 中
js.wrap.settings.import=ES6 导入/导出
js.align.properties=对齐对象属性：
js.align.properties.none=不对齐
js.align.properties.on.colon=冒号上
js.align.properties.on.value=值上
js.function.call.parentheses=函数调用括号
js.function.declaration.parentheses=函数声明括号
js.function.brace.style=在函数声明中
js.function.expression.brace.style=在函数表达式中
js.function.parameters.wrap=函数声明参数
js.function.call.wrap=函数调用参数
js.space.before.function.left.brace=函数左大括号
js.format.cstyle.comments=对齐多行
js.chained.call.dot.on.next.line='.' 在新行中
js.quote.marks=引号
js.generated.use.public.modifier=使用 'public' 修饰符
js.generated.use.as.cast=首选 'as' 类型转换
js.generated.types=类型
js.generated.types.settings.link=显式类型的代码样式设置
js.generated.explicit.types=此项的首选显式类型：
js.generated.explicit.var.types=变量和字段
js.generated.explicit.return.types=函数声明返回
js.generated.explicit.return.expression.types=函数表达式返回
js.trailing.comma=尾随逗号\:
js.trailing.comma.keep=保持
js.trailing.comma.remove=移除
js.trailing.comma.whenMultiline=多行时添加
js.extends.list.wrap=扩展列表
js.align.multiline.extends.list=多行时对齐
js.extends.keyword.wrap=扩展关键字
js.wrap.settings.union.and.intersection.types=联合和相交类型
js.code.style.object.literals.category.name=对象
js.code.style.align.caption=对齐
js.code.style.align.from.clause.caption=对齐 'from' 子句
js.wrap.settings.var.group.name=变量声明
js.code.style.do.not.align.var.statement=不对齐
js.code.style.align.var.statements=当多行时
js.code.style.align.var.statements.and.assignments=分组时
js.code.style.array.group.name=数组
js.array.new.line.after.left.bracket=新行后 '['
js.array.new.line.before.right.bracket=将 ']' 置于新行

js.method.can.be.static=方法可以为 static
js.method.can.be.static.option=仅检查 'private' 方法
make.method.static=设为 'static'
typescript.fix.change.member.access=使 ''{0}''
js.fix.change.member.access.to.sharp=使用 '\#' 设为 private
declare.event.0=声明事件 ''{0}''
js.variable.might.not.been.initialized=变量可能尚未初始化 \#loc
js.variable.initializer.is.redundant=变量初始值设定项冗余 \#loc
js.value.assigned.is.never.used=从未使用过所赋之值 \#loc
javascript.fix.change.type=''{0}'' 类型更改为 ''{1}''
javascript.fix.change.parameter.type=参数 ''{0}'' 类型更改为 ''{1}''
javascript.change.jsdoc.type.family.name=更改 JSDoc 中元素的类型
change.signature.dialog.title=更改 {0} 的签名
javascript.fix.add.enum.values=添加显式枚举值
javascript.fix.add.string.enum.values=添加匹配字段名称的字符串枚举值
javascript.fix.create.implements=使 ''{0}'' 实现 ''{1}''
javascript.fix.create.inheritor.family=从 super 类型继承
javascript.fix.implement.family=在派生类中实现
javascript.fix.implement.chooser.title=从中实现成员
javascript.fix.implement.chooser.all=所有类
javascript.fix.implement=实现 {0}
javascript.fix.create.extends=使 ''{0}'' 继承 ''{1}''
javascript.report.unused.properties=报告未使用的属性
javascript.report.unused.definitions=报告未使用的定义
javascript.check.global.definitions=检查全局范围内的赋值
javascript.strictly.check.global.vars=将未声明的全局变量报告为错误
javascript.strictly.check.object.properties=将未声明的属性报告为错误
javascript.strictly.check.global.functions=将未声明的全局函数报告为错误
inspection.edit.options.inspection.text=编辑验证选项
change.signature.column.type=按类型分组
change.signature.column.name=名称
javascript.invalid.invoker.target=无效调用目标
js.declarations.at.scope.start.inspection=变量声明不在范围起始处
js.make.single.var.statement=进行单变量声明
js.declaration.is.not.at.scope.start=变量声明不在范围起始处
js.move.to.scope.start=将变量声明移至范围起始处
js.primitive.type.wrapper.usage.inspection=使用了基元类型对象包装器
js.replace.with.type.cast.to.primitive=替换为 {0} 的类型转换
js.assigning.to.primitive.type.property=赋给基元的值将丢失
js.primitive.type.improper.instantiation.inspection={0} 实例化可以简化
js.replace.with.literal=替换为 {0} 文字
non.ascii.identifiers.inspection.name=包含非 ASCII 符号的标识符
non.ascii.identifiers.only.ascii=仅允许 ASCII 名称
non.ascii.identifiers.non.ascii.found=<html>名称包含非 ASCII 符号：{0}</html>
non.ascii.identifiers.mixed.set=<html>名称同时包含 ASCII 和非 ASCII 符号：{0}</html>

class.name.invalid=<无效>
element.name.anonymous=<anonymous>
element.name.default=<默认>
duplicate.parameter.name=重复的参数名称：{0}
rename.accessors.dialog.title=重命名字段
rename.accessors.dialog.text=是否将属性访问器也重命名为 ''{0}''？
insert.new.keyword.fix.name=插入新关键字
insert.this.keyword.fix.name=添加 this 限定符
insert.class.fix.name=添加类名限定符
replace.implements.keyword.fix.name=将 'implements' 更改为 'extends'
superclass.label.text=&超类\:
varible.name.column.title=名称
varible.value.column.title=值
custom.variables.step.title.label.text=模板 ''{0}'' 中的自定义变量 (&C)：
create.class.ok.button.text=创建
create.class.name.label=名称\:
create.class.package.label=包\:
create.class.template.label=模板(&T)\:
create.class.superclass.label=&超类\:
create.class.interfaces.label=接口(&I)\:
action.structureview.show.object.inherited=从对象继承
predefined.libraries.converter.description=捆绑的 JavaScript 库已更改，因此需要更新项目中的库映射
libraries.roots.converter.description=将更新 JavaScript 库存储格式

# JSHint
jshint.option.edit.dialog.title=设置 ''{0}'' 选项
jshint.clear.field.to.disable=清除要禁用的字段
jshint.illegal.integer=非法整数
jshint.use.config.files=使用配置文件
jshint.version.label=版本(&V)\:
jshint.bundled.suffix.text=(已捆绑)
jshint.config.option.default.name=默认(通用)
jshint.config.default.description=<div style\="padding-bottom\:10px"><div><b>.jshintrc</b></div><div style\="padding-left\:10px; padding-top\:4px;">对 JavaScript 文件进行 Linting 检查时，IDE 会从文件所在的文件夹开始查找 .jshintrc，然后上行到文件系统根目录。</div></div><div><div><b>package.json</b></div><div style\="padding-left\:10px; padding-top\:4px;">将您的配置添加到项目的 package.json 文件中的 <code>jshintConfig</code> 属性下。</div></div>
jshint.config.option.custom.name=自定义配置文件
jshint.config.option.custom.browser.title=选择 JSHint 配置文件 （*.jshintrc）
jshint.config.failed.to.read=无法读取 JSHint 配置
jshint.config.extends.cyclically=JSHint 配置循环扩展
jshint.esversion.text=在与指定的 ECMAScript 版本不兼容时发出警告
jshint.latedef.text=当变量在未定义的情况下使用时发出警告
jshint.unused.text=存在未使用的变量时发出警告
jshint.indent.text=缩进
jshint.quotmark.text=引号
jshint.latedef.false.text=不警告
jshint.latedef.true.text=禁止变量在未定义的情况下使用
jshint.latedef.nofunc.text=<html><body>禁止变量在未定义的情况下使用，<br>但允许函数声明。</body></html>
jshint.unused.false.text=不检查任何内容
jshint.unused.true.text=<html><body>检查所有变量和参数，但允许<br>使用的参数后存在未使用参数</body></html>
jshint.unused.vars.text=检查变量，而不是函数参数
jshint.unused.strict.text=检查所有变量和参数
jshint.quotmark.false.text=允许两种引号
jshint.quotmark.true.text=仅允许单引号或双引号
jshint.quotmark.single.text=仅允许单引号
jshint.quotmark.double.text=仅允许双引号

action.structureview.show.locals=显示本地

#common linters
linter.configurable.selectPackage.browseDialogTitle=选择 {0} 包目录
javascript.linter.import.notification={0}：项目代码样式和编辑器设置基于 ''{1}'' 更新。
javascript.linter.import.notification.rules.applied=应用了以下 {0}：{1}。
javascript.linter.import.notification.reset=重置
javascript.linter.import.notification.restored=默认代码样式和编辑器设置已恢复
javascript.linter.import.translate.config.title=应用 ESLint 代码样式规则
javascript.linter.import.translate.config.progress.title=应用 {0} 代码样式规则
javascript.linter.import.translate.config.file.error=无法应用代码样式规则
javascript.linter.import.nothing.to.import={0}：已应用所有已知规则
javascript.linter.use.severity.from.config.label=使用配置文件中的规则严重性
javascript.linter.configure.additional.inspection.label=其他选项：
javascript.linter.configuration.file.title=配置文件
javascript.linter.radio.button.configuration.file=配置文件(&C)\:
javascript.linter.error.empty.path=路径为空
javascript.linter.error.no.such.file=没有此类文件

javascript.linter.action.fix.prompt=使用 {0} 重新格式化选定的文件?
javascript.linter.action.fix.problems.file.text={0}：修复当前文件
javascript.linter.action.fix.problems.name=修复 {0} 问题
javascript.linter.action.fix.problems.name.start=已开始修复 {0} 问题
javascript.linter.action.fix.problems.name.finish=已结束修复 {0} 问题
javascript.linter.configurable.config.autoSearch.title=自动搜索 (&S)
javascript.linter.suppress.rules.for.line.family.name=对当前行禁止
javascript.linter.suppress.rules.for.line.description=禁止当前行的{0}
javascript.linter.suppress.rules.for.file.family.name=对当前文件禁止
javascript.linter.suppress.rules.for.file.description=禁止当前文件的{0}

# eslint
settings.javascript.linters.eslint.configurable.name=ESLint
eslint.configurable.eslintPackage.label=ESLint 包 (&E)：
eslint.configurable.eslintPackage.browseDialogTitle=选择 ESLint 包目录
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint 将在要 lint 的文件的目录中以及连续的父目录中查找 .eslintrc.* 和 package.json 文件，直至查找到文件系统的根目录。<div style\="padding-top\:8px">要使用 package.json，请将您的配置添加到 <code>eslintConfig</code> 属性下。</div>
eslint.configurable.config.select.config.text=选择 ESLint 配置文件（*.eslintrc.*）
eslint.configurable.additionalRulesDir.label=其他规则目录 (&R)：
eslint.configurable.additionalRulesDir.browseDialogTitle=选择 ESLint 其他规则目录
eslint.configurable.extraOptions.label=额外 eslint 选项 (&O)：
eslint.run.on.save=保存时运行 eslint --fix(&U)
eslint.action.fix.problems.description=通过调用 'eslint --fix' 修复 ESLint 问题
eslint.fix.problems.text={0}：修复 {1}
eslint.error.package.directory.expected=应为包目录
eslint.code.style.apply.message=应用 ESLint 的代码样式？
eslint.code.style.dismiss.text=否
eslint.code.style.apply.text=是
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint 版本 {0} 不受支持。请升级 ESLint。
eslint.additional.rules.directory.field.name=其他规则目录
eslint.configuration.file.field.name=ESLint 配置文件
reformatting.with.0=正在使用 {0} 重新格式化…

#standardJS
standardjs.name=标准代码样式
standardjs.eslint.label=指定标准包的路径以使用标准代码样式
standardjs.editor.notification.can.be.enabled.text=为此项目使用 JavaScript 标准代码样式？
standardjs.editor.notification.action=是
standardjs.editor.notification.do.not.show.text=否
standardjs.enable.code.style.dialog.text=是否要将 set JavaScript 标准样式设置为此项目的代码样式？
standardjs.edit.settings.caption=ESlint/标准代码样式
standardjs.action.fix.problems.description=修复标准代码样式问题

# Actions
js.show.type.info.action.error=找不到表达式
javascript.ignore.unused.function.parameters=忽略未使用的参数：
javascript.ignore.unused.catch.parameters=忽略未使用的 catch 参数
complete.import.binding=完整的导入绑定
complete.import.name=完整的导入名称
remove.type.prefix=移除类型前缀
add.import.binding.to.import=将导入绑定添加到导入
add.import.specifier.to.import=将导入说明符添加到导入
create.js.file.description=从指定的模板创建 JavaScript 文件
create.ts.file.description=创建新的 TypeScript 文件

# todo remove, has external usages
javascript.completion.several.definitions=（多个定义）

# File watchers
js.file.watcher.traceur.name=Traceur 编译器
js.file.watcher.traceur.description=将 ECMAScript 6 和 AtScript 代码转成 ECMAScript 5
js.format.align.multiline.var=对齐多行变量声明
js.file.watcher.6to5.name=Babel
js.file.watcher.6to5.description=使用 Babel 将 ECMAScript 6 代码转成 ECMAScript 5
js.flowjs.watcher.config.file.name=Flow JS
js.flowjs.watcher.config.file.description=添加 .flowconfig 文件

# Annotator
typescript.export.assignment.cannot.be.used.in.internal.modules=导出不能在内部模块中使用的赋值
typescript.type.predicate.not.return=仅函数和方法的返回类型位置允许类型谓词
typescript.type.this.predicate.not.return=仅类或接口成员、get 访问器或函数和方法的返回类型位置允许基于 'this' 类型的谓词。
typescript.type.predicate.not.match.name=找不到参数 {0}
typescript.type.predicate.rest=类型谓词不能引用 rest 参数
typescript.type.predicate.destructuring=类型谓词不能引用绑定模式中的元素。
typescript.type.predicate.incompatible.types=类型谓词不可分配给 {0}
typescript.generics.should.not.be=类型 ''{0}'' 非泛型
es6.default.export.not.declared=未在导入的模块中声明默认导出
js.annotator.assignment.pattern.rhs=赋值模式必须位于赋值的左侧
es6.generate.index.action=生成 index.js/index.ts
es6.generate.index.action.description=生成 index.js/index.ts
line.comment.at.first.column=行注释在第一列
code.commenting.panel.title=代码注释
js.settings.generated.code.title=生成的代码
js.annotator.thin.arrow.used=使用了细箭头
js.annotator.newline.before.arrow=箭头前不允许换行符
js.annotator.replace.with.fat.arrow=替换为粗箭头
js.annotator.unary.operator.within.exponential=一元运算符 ''{0}'' 不允许直接位于指数表达式之前。建议添加括号以解决歧义问题。

# Live templates
jsx.html.context.type=JSX HTML
js.expression.context.type=表达式
js.statement.context.type=声明
js.top.level.statement.context.type=顶级语句
js.class.context.type=类/接口
ecmascript.6.or.higher=ECMAScript 6 或更高版本

# Gulp
gulp.rc.gulpfile.label=Gulpfile (&F)：
gulp.rc.gulpfile.browseDialogTitle=选择 gulpfile.js
gulp.rc.tasks.label=&任务\:
gulp.rc.arguments.label=参数(&A)\:
gulp.rc.nodeInterpreter.label=节点解释器(&I)\:
gulp.rc.nodeOptions.label=节点选项 (&O)：
gulp.rc.gulpPackage.label=Gulp 包 (&G)：
gulp.rc.environmentVariables.label=环境 (&E)：
gulp.task.title=Gulp 任务
gulp.before.run.task=运行 gulp 任务
gulp.before.run.task.descr=运行 gulp {0, choice,0\#任务|1\#任务 |2\#任务 }{1} [{2}]

# Grunt
grunt.rc.gruntfile.label=Gruntfile (&F)：
grunt.rc.gruntfile.browseDialogTitle=选择 Gruntfile
grunt.rc.tasks.label=&任务\:
grunt.rc.arguments.label=参数(&A)\:
grunt.rc.nodeInterpreter.label=节点解释器(&I)\:
grunt.rc.nodeOptions.label=节点选项 (&O)：
grunt.rc.gruntCliPackage.label=包 grunt-cli (&P)：
grunt.rc.environmentVariables.label=环境 (&E)：
grunt.task.title=Grunt 任务
grunt.before.run.task=运行 Grunt 任务
grunt.before.run.task.descr=运行 Grunt {0, choice,0\#任务|1\#任务 |2\#任务 }{1} [{2}]

#node
settings.nodejs.name=Node.js 和 NPM
settings.nodejs.coding.assistance.label=Node.js 编码协助 (&A)：
settings.nodejs.coding.assistance.manage.scopes.label=管理范围…

node.interpreter.label=节点解释器(&I)\:
node.interpreter.unspecified.error.text=请指定 Node.js 解释器
node.package.manager.label=包管理器 (&M)：
node.package.empty.hint={0} 包目录路径
node.package.empty.hint.pkg1.or.pkg2={0} 或 {1}
node.package.selector.single.package.title=选择 {0} 包目录
node.package.selector.multiple.packages.title=选择包目录
node.package.selector.multiple.packages.description=选择 {0}
node.package.none=无包
node.package.dropDownList.select=选择...

node.js.modules.dependencies.missing.family.name=缺少 require() 调用

#npm
npm.rc.packageJson.label=package.json (&P)：
npm.rc.packageJson.browseDialogTitle=选择 package.json 文件
npm.rc.command.label=命令(&C)\:
npm.rc.scripts.label=脚本 (&T)：
npm.rc.scriptsArguments.label=参数 (&R)：
npm.rc.nodeInterpreter.label=节点解释器(&I)\:
npm.rc.nodeOptions.label=节点选项 (&O)：
npm.rc.environmentVariables.label=环境：
npm.task.title=NPM 脚本
npm.before.run.task=运行 npm 脚本
npm.before.run.task.descr=运行 npm {0, choice,0\#脚本|1\#脚本|2\#脚本}{1} [{2}]

#build tools
buildTools.JsbtRunTaskAction.text=运行 Gulp/Grunt/npm 任务
buildTools.JsbtAddBuildfileAction.text=添加 {0}
buildTools.choose_buildfile.text=选择 {0}
buildTools.JsbtRemoveBuildfileAction.text=移除 {0}
buildTools.JsbtReloadTasksAction.text=重新加载任务
buildTools.JsbtReloadTasksAction.npm.text=重新加载脚本
buildTools.JsbtShowTasksAction.text=显示 {0} 任务
buildTools.JsbtShowTasksAction.npm.text=显示 npm 脚本
buildTools.searchEverywhere.text=运行 ''{0}'' 任务
buildTools.searchEverywhere.npm.text=运行 ''{0}'' npm 脚本
buildTools.ShowSettingsAction.text={0} 设置...
buildTools.ShowSettingsAction.npm.text=编辑 npm 配置 (&E)...
buildTools.EditRunSettingsAction.text=编辑 ''{0}'' 设置 (&E)...
buildTools.tree.sortBy.text=排序方式
buildTools.tree.sortBy.definitionOrder.text=定义顺序
buildTools.tree.sortBy.name.text=名称

#npm modules
npm.modules.inspection.content.of.require.not.in.dependencies.warning=package.json 依赖关系中未列出模块
npm.modules.inspection.content.of.require.module.not.installed.warning=未安装模块
npm.modules.install.global.types.fix.name=安装 TypeScript 定义以提供更好的类型信息
package.json.install.types.fix.family.name=为包安装 @types
node.js.quickfix.install.node.module.with.dev.dependencies.text=安装 ''{0}'' 作为开发依赖关系
node.js.quickfix.install.node.module.text=安装 ‘’{0}''
node.js.quickfix.install.node.module.family.name=安装模块
node.js.quickfix.install.node.module.devDependencies.family.name=安装模块作为开发依赖关系
node.js.quickfix.install.node.module.update.modules.family.name=运行 'npm install'
node.js.quickfix.run.command=运行''{0}''
node.js.quickfix.install.node.module.error.prefix.text=无法安装 Node.js 模块：{0}
node.js.quickfix.install.node.module.error.no.interpreter.text=无法安装 Node.js 模块：请指定默认 Node.js 解释器。
node.js.quickfix.install.node.module.error.no.interpreter.title=安装 Node.js 模块
node.js.select.file=选择 {0} 文件

typescript.types.module.not.installed.warning=无法解析模块 ''{0}'' 的定义
npm.modules.install.global.types.directory.error=无法创建所需的目录
npm.modules.install.global.types.dialog.title=安装 TypeScript 定义

typescript.types.union=联合
typescript.types.intersection=相交
typescript.types.mapped=映射
typescript.types.key=键引用
typescript.types.merged=已合并
typescript.types.merged.accessor=合并访问器
typescript.types.type.member={0} 类型属性
typescript.types.merged.parts=引用的属性：

# Intentions
ts.generate.reference.path.name=生成引用路径注释
ts.add.import.statement.family.name=添加导入语句
ts.add.import.all.family.name=添加所有明确的导入
ts.add.import.hint.text=使用 {1} 添加 {0}
ts.add.import.hint.multiple.text=使用  {1} 为 {0} 添加导入
ts.add.import.hint.all.part=或全部使用 {0} 导入
ts.change.import.action.one.title=更改为 {0}
ts.change.import.action.many.title=更改导入...
ts.change.import.action.command=更改导入
ts.change.import.action.family.name=更改 ES6 导入 
ts.change.import.action.dialog.title=从...导入
ts.convert.alias.to.interface.action.title=将别名转换为接口
ts.convert.alias.to.interface.action.family.name=将类型别名转换为接口
ts.convert.alias.to.enum.action.title=将别名转换为枚举
ts.convert.alias.to.enum.action.family.name=将类型别名转换为枚举
ts.convert.parameter.property.to.field=将参数属性转换为类字段
ts.convert.field.to.parameter.property=将字段转换为参数属性
anonymous.to.named.intention.function.name=函数名称：
initialize.fields.intention.visibility=可见性\:

# Language Service
javascript.language.service.default.empty.text=无错误
javascript.language.service.tracking.disabled=错误跟踪已禁用
javascript.language.service.tracking.is.not.started=服务未启动
javascript.language.service.default.project.errors=显示项目错误
javascript.service.node.error=节点解释器路径不正确。请检查解释器设置
javascript.starting.service=启动 {0} 服务
javascript.language.service.cannot.get.results=无法从语言服务获得结果
javascript.language.service.start.timeout=启动语言服务进程超时
javascript.language.service.cannot.start=无法启动语言服务进程

# TypeScript Compiler

typescript.compiler.notification.editor.dismiss=否
typescript.compiler.notification.editor.no=否
typescript.compiler.notification.editor.configure=配置
typescript.compiler.notification.editor.configure.compiler=配置编译器
typescript.compiler.notification.editor.enable=是
typescript.compiler.notification.editor.fw.replace=将 File Watcher 替换为编译器
typescript.compiler.notification.editor.fw.message=已弃用 TypeScript 的 File Watcher。IDE 内置有 TypeScript 编译器
typescript.compiler.name=TypeScript 编译器
typescript.compiler.name.enable.message=将 TypeScript 编译为 JavaScript？
typescript.compiler.configurable.name=TypeScript

typescript.config.configurable.options.enable= 使用 tsconfig.json 解析对象
typescript.use.service.configurable.options.enable=TypeScript 语言服务
typescript.compiler.configurable.options.service.directory=自定义目录
typescript.compiler.configurable.options.service.directory.configure=配置 TypeScript 编译器
typescript.compiler.configurable.version.choose.service.directory=选择服务目录
typescript.compiler.configurable.options.service.directory.info=包含这些文件的 TypeScript lib 目录：typescriptServices.js, lib.d.ts
typescript.compiler.configurable.options.macro.list=FileDir, FileRelativeDir, FileDirRelativeToProjectRoot, ModuleFileDir, Sourcepath, FileDirRelativeToSourcepath
typescript.compiler.configurable.options.macro.text=可用的宏：
typescript.compiler.configurable.options.service.directory.error.empty=自定义目录不能为空
typescript.compiler.configurable.options.service.directory.error.cannot.find.file=" 在目录 {1} 中找不到文件 {0}
typescript.compiler.configurable.options.output.path=使用输出路径：
typescript.compiler.configurable.options.compile.main=仅编译主文件：
typescript.compiler.configurable.options.compile.main.error=主文件的路径不正确
typescript.compiler.configurable.options.version=TypeScript\:
typescript.compiler.configurable.options.generate.source.map=生成源映射
typescript.compiler.configurable.options.enable.no.config=也针对没有 tsconfig.json 的项目
typescript.compiler.configurable.options.track.file.system=在更改时重新编译
typescript.compiler.configurable.options.scope=编译范围：
typescript.compiler.configurable.options.command.line=选项\:

typescript.service.no.config=文件未包括在任何 tsconfig.json 中
typescript.service.no.main.reference=文件未处理，因为没有从主文件引用

typescript.compiler.configurable.service.title=服务选项
typescript.compiler.configurable.service.use.completion=代码补全
typescript.compiler.configurable.service.use.annotation=注释

js.tool.window.limit=First {0} errors are shown.
js.tool.window.limit.all=See all {0} errors
typescript.compiler.action.compile.all=全部编译
typescript.compiler.action.compile.toolbar=编译
typescript.compiler.action.compile.all.description=编译所有项目文件
typescript.service.action.restart=重启 TypeScript 服务
typescript.compiler.action.compile.all.stop=停止编译
typescript.compiler.action.compile.all.compile=编译文件 {0}
typescript.compiler.action.compile.all.compile.config=配置 {0} 的编译文件
typescript.compiler.action.compile.all.clean=重置缓存
typescript.compiler.action.compile.current=编译当前文件
typescript.compiler.action.compile.simple=编译 TypeScript
typescript.compiler.action.compile.description=编译当前项目
typescript.compiler.action.compile.current.description=编译当前文件或文件夹
typescript.compiler.action.no.compile.message=文件未编译，因为没有从主文件引用
typescript.compiler.before.run=编译 TypeScript

typescript.language.service.clean=重置缓存
typescript.language.service.compile.file=正在编译文件... {0}
typescript.language.service.compile.project=正在编译项目... {0}
typescript.language.service.compile.file.errors=正在计算错误... {0}
typescript.language.service.compile.project.errors=正在计算项目错误... {0}
typescript.language.service.compile.project.open.file=正在打开文件... {0}

typescript.before.task.check.errors=检查错误
typescript.before.task.config.path=配置文件：
typescript.before.task.title=TypeScript 编译设置
typescript.before.task.config.dialog.title=选择 tsconfig.json

# Documentation
js.documentation.fires=触发：
js.documentation.more.overload=其他 {0} 个重载
js.documentation.more.overloads=其他 {0} 个重载
exportable.JSCodeFoldingSettings.presentable.name=JavaScript 代码折叠

node.js.remote.interpreters.plugin.missing=缺少 Node.js 远程解释器插件。请启用 {0} 中的插件

javascript.module.dependencies.got.it.title=模块依赖关系图
javascript.module.dependencies.got.it.text=<div align\='left'>此图显示所选文件或目录具有的模块依赖关系。<br/>要查看多个文件或目录的依赖关系，请在<i>项目视图</i><br/>中将其选定，然后从所选项目上下文菜单中选择<i>图 – 显示图</i>。</div>
javascript.module.dependencies.empty.got.it.text=<div align\='left'>当前文件或文件夹没有任何依赖关系。<br/>请尝试使用其他文件或文件夹。</div>
js.remove.redundant.initializer.fix=移除冗余的初始化器
js.remove.unused.assignment=移除未使用的赋值
js.inject.with.comment.intention.family.name=使用注释对注射做出注解
js.inject.dont.format.intention.text=不格式化注入的内容

js.webpack.config.highlighting.name=Webpack 配置验证

js.linter.guesser.linter.enabled.because.of.dependency=已启用 {0}：''{1}'' 列出在 package.json 中。
js.linter.guesser.linter.enabled.because.of.package.json.section=已启用 {0}：''{1}'' 位于 package.json 中。
js.linter.guesser.linter.enabled.because.of.config.file=已启用 {0}：配置文件位于项目中。
js.linter.guesser.linter.disabled={0} 已禁用。

# Breadcrumbs
js.breadcrumbs.callback.for=\ {0}() 回调

typescript.extract.type.alias.name=类型别名...
typescript.include.js.sources.element=搜索 JavaScript 声明
typescript.include.js.sources.dialog.title=包括包 {0}
typescript.include.js.sources.dialog.message=是否在项目中包括 ''{0}'' 中的 JavaScript 文件？
start.template.string.interpolation.on.typing=键入 '$' 时启动模板字符串插值
typescript.include.js.sources.action=包括 JavaScript 文件
escape.pasted.text=在粘贴字符串文字时转义文本
rename.prompt.do.you.want.to.rename.base.method=是否要重命名基本方法？
jsx.convert.html.attributes.to.jsx=将 HTML 粘贴到 JSX 文件时转换属性

# Generate dialog
generate.filter.indexers=索引器
generate.filter.methods=方法
generate.filter.fields=字段和属性
generate.filter.button.tooltip=显示 {0}
generate.filter.button.description=在列表中显示 {0} 
codestyle.ui.field.prefix=字段前缀 (&F)：
codestyle.ui.property.prefix=属性前缀 (&P)：
codestyle.ui.file.name.style=文件命名惯例 (&N)：
codestyle.ui.generated.jsdoc.use.types.checkbox=在 JSDoc 中包括类型 (&T)
codestyle.ui.generated.jsdoc.section.title=JSDoc
inline.type.used.in.reference.list=无法在''{0}'' 列表中内联用法
inline.cannot.inline.references.this.type=无法内联引用 'this' 类型的接口
inline.cannot.inline.has.supers=无法内联扩展其他类型的 {0} 

refactoring.extract.react.component.component.for.refactor.this=提取组件…
refactoring.extract.react.component.title=提取组件
refactoring.extract.react.component.no.expression=所选内容不构成 JSX 表达式
refactoring.extract.react.component.no.scope=找不到用于放置所创建组件的范围
refactoring.react.function.to.class.refactoring.title=转换为类组件
refactoring.react.function.to.class.intention.title=转换为类组件
refactoring.react.function.to.class.used.in.new.conflict=\ ''new'' 表达式中使用了 {0}
refactoring.react.function.to.class.used.in.call.conflict=调用表达式中使用了 {0}
refactoring.react.class.to.functional.conflict.used.with.ref={0} 与 ''ref'' 属性结合使用。无法为无状态函数组件提供 ref
refactoring.react.class.to.functional.refactoring.title=转换为函数组件
refactoring.react.class.to.functional.intention.title=转换为函数组件
refactoring.react.could.not.find.in.template=无法重构。找不到名称为 {0} 的元素。可能的代码模板 {1} 无效吗？
react.function.to.class.caret.at.function=脱字符号应置于要转换的函数处
react.class.to.function.caret.at.class=脱字符号应置于要转换的类处
js.arrangement.group.arrow.fields.with.methods=使用包含方法的箭头函数初始化组字段
intellilang.tagged.literal.injection.name.label=模式\:
intellilang.tagged.literal.expression.border.title=模板标签

refactoring.destructuring.vars.for.refactor.this=对象或数组解构...
refactoring.destructuring.vars.intention.name=引入对象或数组解构
refactoring.destructuring.vars.intention.name.object=引入对象解构
refactoring.destructuring.vars.intention.name.array=引入数组解构
refactoring.destructuring.vars.intention.replace.object=替换为对象解构
refactoring.destructuring.vars.intention.replace.array=替换为数组解构
refactoring.destructuring.vars.intention.replace.promise=替换为 'await Promise.all'
refactoring.destructuring.vars.intention.propagate=传播到解构声明
refactoring.destructuring.vars.intention.depropagate=将解构替换为属性和索引访问
refactoring.destructuring.vars.intention.deconstruct=生成解构模式
refactoring.destructuring.vars.intention.replace.shorthand=替换为解构和缩写属性
refactoring.destructuring.vars.intention.const.to.var.warning=在转换期间，高亮显示的 const 变量将转换为 let 变量。\n要继续吗？
refactoring.destructuring.vars.intention.const.to.var.warning.title=变量关键字更改
refactoring.destructuring.vars.intention.guard.conflict=通过类型防护将表达式类型缩小为 ''{0}''，该类型防护在重构后将不起作用
javascript.intention.add.export.family.name=添加导出
javascript.intention.add.export.fix.text=将 {0} 导出在文件 {1} 中
javascript.intention.add.default.export.family.name=Add default export（添加默认导出）
javascript.intention.remove.export.family.name=移除导出
javascript.intention.remove.export.inaccessible.conflict.text={0} 在 {1} 中进行了使用
javascript.intention.promise.to.async.name=转换为异步功能
javascript.intention.code.optimizations.text=正在优化生成的代码
javascript.intention.add.template.argument=插入模板字符串参数
javascript.intention.call.chain.to.pipe=将嵌套调用替换为管道表达式
javascript.intention.pipe.to.call.chain=将管道表达式替换为嵌套调用
javascript.intention.opt.chain.family=使用可选的链或空值合并
javascript.intention.opt.chain.chain.only=使用可选链
javascript.intention.opt.chain.coalesce.only=使用空值合并
javascript.intention.opt.chain.conditional.only=使用 '||'
javascript.intention.opt.chain.chain.and.coalesce=使用可选的链和空值合并
javascript.intention.expand.opt.chain.family=将可选的链接或空值合并扩展到显式检查
javascript.intention.expand.opt.chain=展开可选链
javascript.intention.expand.nullish.coalescing=展开空值合并
javascript.intention.expand.or.coalescing=使用 ?\: 运算符
javascript.intention.expand.opt.chain.and.nullish.coalescing=展开可选的链和空值合并
javascript.intention.expand.opt.chain.and.or.coalescing=展开可选的链和使用 ?\: 运算符
javascript.intention.explicit.fields=声明显式类字段
javascript.intention.explicit.fields.single=声明显式类字段
javascript.intention.explicit.fields.dialog.title=选择要显式声明的字段
javascript.intention.init.fields=从参数初始化新字段
javascript.intention.init.fields.dialog.title=选择参数以初始化字段

js.param.hints.show.names.for.all.args=对于非文字参数
js.param.hints.show.names.for.tagged=对于标记的模板参数
js.param.hints.show.names.for.pipes=对于管道运算符
js.param.hints.blacklist.pattern.explanation=<html>要禁用方法或函数的提示，请使用下面的一种模式：<p style\="margin-left\: 5px"><code><b>(*info)</b></code> - 所有参数名称以 <em>info</em><br><code><b>(key, value)</b></code> 结尾的单参数方法 - 所有带有参数<em>键</em>和<em>值</em><br><code><b>*.put(key, value)</b></code> 的方法- 所有<em>put</em>带有<em>键</em>和<em>value</em>参数<br><code><b>Console.log(*, *)</b></code> 的方法- <em>log</em>正好有两个参数的<em>控制台</em>类型的方法</p><br><p>必须为所有参数（包括可选参数）提供名称或占位符。<br>限定方法名称必须包含类或接口名称或其占位符。<br>在编辑代码时，请使用“不为当前方法显示提示” {0} 操作来添加模式。</p></html>

js.checkbox.make.readonly=令其只读 (&R)

action.JavaScriptGenerateDictionaries.text=生成 JavaScript 拼写检查器字典
action.JavaScriptIntroduceDestructuringVariables.description=提取解构变量
action.ReactClassToFunctionalComponentAction.description=转换为函数组件
action.ReactFunctionalToClassComponentAction.description=转换为类组件
action.ReactExtractComponentAction.description=提取组件
action.EslintImportCodeStyle.description=应用 ESLint 代码样式
action.TypeScriptExtractTypeAlias.description=提取类型别名
action.JS.TypeScript.Include.Generated.Declarations.text=包括 '.d.ts' 子文件
action.JS.TypeScript.Include.Generated.Declarations.description=在项目中包含 .d.ts 子文件
action.Generate.GetSetAccessor.JavaScript.text=Getter 和 Setter
action.Generate.SetAccessor.JavaScript.text=Setter
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.Constructor.JavaScript.text=构造函数
action.Generate.Missing.Members.ES6.text=实现方法…
action.Generate.Missing.Members.TypeScript.text=实现成员...
group.Editor.JSLibrariesMenu.LibraryList.text=使用库
group.Editor.JSLibrariesMenu.LibraryList.description=设置使用的 JS 库
group.Editor.JSLibrariesMenu.text=使用 JavaScript 库
group.Editor.JSLibrariesMenu.description=选择要与当前文件一起使用的 JavaScript 库
configurable.JSTemplateLangConfigurable.display.name=模板
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.MyConfigurable.display.name=JSX
import.options.find.more.configuration.options=从中查找更多配置选项 
import.options.find.more.configuration.options.code.style=代码风格
settings.code.style.indent.chained.methods=缩进链式方法
settings.code.style.indent.all.chained.calls.in.a.group=缩进组中的所有链式调用
settings.code.style.semicolon.to.terminate.statements=用分号终止语句 (&S)
settings.code.style.use=使用
settings.code.style.quotes=引号 (&Q)
settings.code.style.Trailing.comma=尾随逗号 (&T)：
settings.code.style.single=单一
settings.code.style.double=按两次
settings.code.style.in.new.code=在新代码中
settings.code.style.always=始终
settings.code.style.option.use=使用
settings.code.style.dont.use=不使用
checkbox.enable=开启
webpack.configuration.title=Webpack
webpack.configuration.field=webpack 配置文件：
webpack.configuration.field.description=webpack 配置文件路径
create.react.app.name=React 应用
create.react.app.description=<a href\="https\://github.com/facebookincubator/create-react-app">创建 React 应用</a>是官方支持的一种创建单页 React 应用程序的新方法。它提供了没有配置的现代构建设置。
create.react.app.scripts.version=脚本版本 (&V)
create.react.app.typescript.checkbox=创建 TypeScript 项目 (&T)
dialog.title.new.javascript.file=新建 JavaScript 文件
list.item.javascript.file=JavaScript 文件
dialog.title.new.typescript.file=新建 TypeScript 文件
list.item.typescript.file=TypeScript 文件
list.item.typescript.jsx.file=TypeScript JSX 文件
dialog.kind.0.file=提交文件
action.creates.new.file.description=创建新的 {0} 文件
build.event.title.failed.to.list.tasks=无法列出 {0} 任务
action.show.error.details.text=显示错误详情
dialog.title.grunt.settings=Grunt 设置
dialog.title.gulp.settings=Gulp 设置
dialog.title.error.details=错误详情
dialog.message.failed.to.download.0.1=下载 {0} 失败。{1}
dialog.title.download.error=下载错误
label.import.popup=导入弹出窗口\:
label.namespace=命名空间\:
dialog.message.cannot.infer.type.new.parameter=无法推断新参数的类型
dialog.title.cannot.introduce.new.interface=无法引入新接口
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=按类型防护缩小范围的类型着色被禁用
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href\='settings'>显示检查设置</a>或<a href\='undo'>撤消</a></html>
dialog.message.cannot.propagate.variable=无法传播变量\: {0}
dialog.title.cannot.propagate=无法传播
dialog.message.usages.search.was.interrupted=用法搜索被中断
dialog.title.cannot.convert=无法转换
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=嵌入式表达式中有非读取用法时，无法继续
dialog.message.variables.from.destructuring.pattern.have.no.usages=来自于解构模式的变量没有用法
button.continue=继续
button.abort=中止
action.don.t.use.library.description=不使用库
action.already.set.for.containing.folder.or.project.description=已针对包含的文件夹或项目进行设置。
action.use.library.description=使用库
text.cannot.download=无法下载 {0}。{1}
notification.content.show.details=显示详情
action.name.disable.category=禁用 {0}
progress.text.processing=正在处理 {0}{1}
label.css.stylelint.view.node.path=节点解释器 (&N)：
label.path=&路径\:
border.title.inspection.export.results.capitalized.location=位置
border.title.inspection.description.title=描述
progress.title.updating.jshint.to=更新 JSHint 到 {0}
progress.download.0.title=下载中{0}
progress.title.jshint=JSHint {0}
progress.title.install.npm.module=安装 npm 模块 ''{0}''
dialog.message.cannot.find.module.types=找不到模块 @types/{0}
action.jump.to.text=跳转到...
dialog.title.select.navigation.target=选择导航目标
dialog.title.select.targets.to.convert.to.class=选择要转换为类的目标
dialog.message.component.name=组件名称\:
label.name=名称\: 
label.type=按类型分组\: 
label.minimum.language.level=最低语言级别\:
dialog.message.cannot.create.argument.stubs.invoked.method.function=无法创建参数存根\: 调用的方法不是函数
action.show.structure.text=显示结构
status.text.no.errors.in.current.file=当前文件中没有错误。
status.text.javascript.language.service.default.project.errors=显示项目错误
progress.title.compiling.typescript.files=编译 TypeScript 文件
dialog.message.cannot.find.file=找不到文件 {0}
radio.set.options.manually=手动设置选项
radio.use.tsconfig.json=使用 tsconfig.json
separator.deprecated.settings=已弃用的设置
dialog.title.main.file=主文件
label.choose.main.file=选择主文件
dialog.title.output.directory=输出目录
label.choose.output.directory=选择输出目录
dialog.message.incorrect.path.to.typescript.package=Typescript 包的路径不正确
status.text.project.structure.isn.t.available=项目结构不可用
status.text.service.doesn.t.contain.open.projects=服务不包含开放项目
status.text.refresh.required=需要刷新
dialog.message.cannot.find.module.for.import=找不到要导入的模块
action.js.tagged.literal.injection.text=JS 标记文字注入
dialog.title.wsl.node.interpreter={0} WSL 节点解释器
dialog.title.wsl.node.interpreter.edit=编辑
dialog.title.wsl.node.interpreter.edit.add=添加
label.linux.distribution=Linux 分发版(&D)\:
label.wsl.node.interpreter=WSL 节点解释器 (&N)\:
dialog.message.please.select.distribution=请选择分发版
dialog.message.please.specify.wsl.path.to.node.js.interpreter=请指定 Node.js 解释器的 WSL 路径
status.text.running.which.node=正在运行 `which node`...
progress.title.configuring.node.js.coding.assistance=正在配置 Node.js 编码辅助...
action.package.json.file.text=package.json 文件
action.creates.package.json.file.description=创建 package.json 文件
progress.title.install=安装 {0}
progress.subtitle.install=正在安装包含 {1} 的 {0}...
inspection.message.package.installed=未安装 {0} 包
inspection.message.package.version.specified=未指定包版本
inspection.message.installed.version.doesn.t.match.version.range=安装的版本 {0} 与版本范围 {1} 不匹配
dialog.title.missing.dependencies=缺少依赖项
button.install.update=安装/更新
action.view.install.text=查看并安装...
action.don.t.ask.again.text=不再询问
dialog.title.configure.coding.assistance.for.node.js.api=配置 Node.js API 编码辅助
action.Anonymous.text.configure=配置
inspection.message.sm.test.runner.magnitude.assertion.failed.title=断言失败
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>前端模板<a href\='http\://html5boilerplate.com'>http\://html5boilerplate.com</a></html>
dialog.message.node.interpreter.unspecified.error.text=请指定 Node.js 解释器
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>美观、直观、强大的前端框架，更快、更轻松地进行 Web 开发 <a href\='http\://getbootstrap.com'>http\://getbootstrap.com</a></html>
popup.title.target.function=目标函数
popup.title.select.destructuring.assignment.target=选择解构赋值目标
visibility.level.overview=概览
visibility.level.details=详细信息
js.module.uml.presentable.name=JavaScript 模块依赖项
intention.family.name.run.npm.install=运行 'npm install'
intention.name.run.npm=运行''{0}''
intention.family.name.navigate.to.package.json=导航到 package.json
intention.name.navigate.to.0.package.json=导航到 {0}/package.json
popup.advertisement.start.typing.package.name=开始输入包名，以从 npm 官方公共注册表中获取更具体的结果
popup.advertisement.latest.available.versions.for.all.distribution.tags=所有发行版标签的最新可用版本
intention.family.name.select.in.test.tree=在测试树中选择
intention.family.name.introduce.parameter.properties.for.unused.parameters=为未使用的参数引入参数-属性
dialog.title.select.parameters.to.convert.to.parameter.properties=选择要转换为参数-属性的参数
inspection.message.object.or.array.expected=应为对象或数组
intention.family.name.add.required.property=添加所需的属性
intention.name.create.library.with.files.outside.project=使用项目外部的文件创建库
dialog.message.unspecified.suite.name=未指定的套件名称
dialog.message.unspecified.test.name=未指定的测试名称
dialog.message.unspecified=未指定的 {0}
dialog.message.no.such=没有这样的 {0}
dialog.message.please.specify.package.json=请指定 package.json
dialog.message.please.specify.package.json.correctly=请正确指定 package.json
dialog.message.please.specify.npm.scripts.to.run=请指定要运行的 npm 脚本
dialog.message.command.supported.by={1} 不支持命令 ''{0}''
dialog.message.no.npm.script=无 ''{0}'' npm 脚本
titled.separator.predefined=预定义
label.compiles.js.files=编译 .js 文件
label.compress.js.files=压缩 .js 文件
dialog.title.edit.run.debug.configuration=编辑运行/调试配置\: ''{0}''
js.commandline.configure.language.version=为项目配置 JavaScript 语言版本
js.commandline.configure.nodejs=配置 NodeJS 解释器并为 package.json 文件安装包
