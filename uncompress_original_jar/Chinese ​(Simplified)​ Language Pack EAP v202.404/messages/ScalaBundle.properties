### org/jetbrains/plugins/scala/DesktopUtils.scala
title.problem.opening.web.page=打开网页时出现问题
html.unable.to.launch.web.browser=<html><body>无法启动 Web 浏览器，请手动打开\: <br />{0} (<a href\="{0}">复制到剪贴板</a>)</body></html>

### org/jetbrains/plugins/scala/actions/MakeExplicitAction.scala
make.implicit.conversion.explicit.action.text=令隐式转换变为显式转换
make.implicit.conversion.explicit.action.description=令隐式转换变为显式转换
title.choose.implicit.conversion.method=选择隐式转换方法\:
press.alt.enter=按 Alt+Enter

### org/jetbrains/plugins/scala/actions/NewPackageObjectAction.scala
new.packageobject.menu.action.text=包对象
new.packageobject.menu.action.description=创建新的 Scala 包对象

### org/jetbrains/plugins/scala/actions/NewScalaTypeDefinitionAction.scala
newclass.menu.action.text=Scala 类
newclass.menu.action.description=创建新的 Scala 类
create.new.scala.class=创建新 Scala 类
this.is.not.a.valid.scala.qualified.name=这不是有效的 Scala 限定名称

### org/jetbrains/plugins/scala/actions/ScalaExpressionTypeProvider.scala
no.expression.found=未找到表达式

### org/jetbrains/plugins/scala/actions/ShowTypeInfoAction.scala
type.info.text=类型信息
type.info.description=显示类型信息

### org/jetbrains/plugins/scala/actions/ToggleTypeAwareHighlightingAction.scala
toggle.type.aware.highlighting.menu.action.text=切换类型感知高亮显示
toggle.type.aware.highlighting.menu.action.description=切换类型感知高亮显示

### org/jetbrains/plugins/scala/actions/implicitArguments/ImplicitArgumentNodes.scala
implicit.argument.is.applicable=隐式参数适用
implicit.is.diverged=隐式分叉
can.t.infer.proper.types.for.type.parameters=无法推断类型参数的正确类型
can.t.find.implicit.argument.for.this.definition=无法为此定义找到隐式参数
no.implicits.applicable.by.type=没有按类型适用的隐式参数

### org/jetbrains/plugins/scala/actions/implicitArguments/ShowImplicitArgumentsAction.scala
show.implicit.arguments.action.text=显示隐式参数
show.implicit.arguments.action.description=显示隐式参数
no.implicit.arguments=无隐式参数
title.expressions=表达式
navigate=导航
implicit.arguments.for.implicit.conversion=适用于隐式转换的隐式参数\:
implicit.arguments=隐式参数\:

### org/jetbrains/plugins/scala/actions/implicitConvertions/ShowImplicitConversionsAction.scala
implicit.conversions.action.text=显示隐式转换
implicit.conversions.action.description=显示隐式转换

### org/jetbrains/plugins/scala/actions/internal/ScalaCollectShortTroubleshootingInfoAction.scala
scala.collect.troubleshooting.information.short.action.text=(Scala) 收集故障排除信息(短)
scala.collect.troubleshooting.information.short.action.description=收集 Scala 插件和 IntelliJ IDEA 版本，以将其快速粘贴到 YouTrack
short.troubleshooting.summary.copied.to.your.clipboard.with.summary=简短的故障排除摘要已复制到剪贴板\n\
{0}

### org/jetbrains/plugins/scala/annotator/AnnotatorUtils.scala
# TODO unify type mismatch messages
type.mismatch.found.required=类型不匹配，找到的是\: {0}，需要的是\: {1}
# TODO unify type mismatch messages
type.mismatch.expected.actual=类型不匹配，应为\: {0}，实际为\: {1}
abstract.member.not.have.private.modifier=abstract 成员可能没有 private 修饰符
illegal.inheritance.from.sealed.kind=从 sealed {0} ''{1}'' 非法继承

### org/jetbrains/plugins/scala/annotator/ByNameParameter.scala
passed.as.by.name.parameter=作为传名参数传递

### org/jetbrains/plugins/scala/annotator/FunctionAnnotator.scala
function.must.define.type.explicitly=方法 {0} 有 return 语句; 需要提供结果类型
function.recursive.need.result.type=递归方法 {0} 需要结果类型
return.expression.is.redundant=从具有单元结果类型的方法返回 {0}
family.name.remove.tailrec.annotation=移除 @tailrec 注解
method.annotated.with.tailrec.is.neither.private.nor.final=使用 @tailrec 注解的方法既不为 private 也不为 final (因此可以重写)
method.annotated.with.tailrec.contains.no.recursive.calls=使用 @tailrec 注解的方法不包含任何递归调用
recursive.call.not.in.tail.position=递归调用不在尾部位置(在 @tailrec 注解的方法中)

### org/jetbrains/plugins/scala/annotator/OverridingAnnotator.scala
member.needs.override.modifier={0} ''{1}'' 需要覆盖修饰符
member.overrides.nothing={0} ''{1}'' 不覆盖任何对象
can.not.override.final={0} ''{1}'' 无法重写 final 成员
member.cannot.override.var=方法 {0} 无法覆盖可变变量
member.cannot.override.val= 方法 {0} 必须为稳定不变的值
var.cannot.override.val= 变量 {0} 无法覆盖不可变值
override.types.not.conforming=覆盖类型 {0} 与基本类型 {1} 不符

### org/jetbrains/plugins/scala/annotator/ScalaAnnotator.scala
covariant.type.contravariant.position.of.method=协变类型 {0} 出现在方法 {2} 的类型 {1} 中的逆变位置 
covariant.type.contravariant.position.of.value=协变类型 {0} 出现在值 {2} 的类型 {1} 中的逆变位置
covariant.type.invariant.position.of.method=协变类型 {0} 出现在方法 {2} 的类型 {1} 中的不变位置 
covariant.type.invariant.position.of.value=协变类型 {0} 出现在值 {2} 的类型 {1} 中的不变位置
contravariant.type.covariant.position.of.method=逆变类型 {0} 出现在方法 {2} 的类型 {1} 中的协变位置 
contravariant.type.covariant.position.of.value=逆变类型 {0} 出现在值 {2} 的类型 {1} 中的协变位置
contravariant.type.invariant.position.of.method=逆变类型 {0} 出现在方法 {2} 的类型 {1} 中的不变位置 
contravariant.type.invariant.position.of.value=逆变类型 {0} 出现在值 {2} 的类型 {1} 中的不变位置

### org/jetbrains/plugins/scala/annotator/ScopeAnnotator.scala
id.is.already.defined=范围中已定义 {0}

### org/jetbrains/plugins/scala/annotator/TypeMismatchError.scala
# TODO unify type mismatch messages
type.mismatch.message=类型不匹配。需要为\: {0}，发现为\: {1}

### org/jetbrains/plugins/scala/annotator/TypeMismatchHints.scala
type.mismatch.tooltip=<html><body>类型不匹配。<table><tr><td>需要为\: </td>{0}</tr><tr><td>发现为\: </td>{1}</tr></table></body></html>

### org/jetbrains/plugins/scala/annotator/TypeMismatchToggleAction.scala
type.mismatch.hints.action.text=类型不匹配提示
type.mismatch.hints.action.description=切换类型不匹配提示

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateApplyQuickFix.scala
family.name.create.apply.method=创建 ''{0}'' 方法
create.apply.method.in=在 {0} 中创建 ''apply'' 方法

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateEntityQuickFix.scala
error.message.title.create.entity.quickfix=创建实体 quickfix

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateExtractorObjectQuickFix.scala
family.name.create.extractor.object=创建提取器对象
create.extractor.object.named=创建提取器对象 ''{0}''

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateParameterlessMethodQuickFix.scala
family.name.create.parameterless.method=创建无参数方法
create.parameterless.method.named=创建无参数方法 ''{0}''
family.name.create.variable=创建变量
create.variable.named=创建变量 ''{0}''
family.name.create.value=创建值
create.value.named=创建值 ''{0}''
family.name.create.method=创建方法
create.method.named=创建方法 ''{0}''

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateTypeDefinitionQuickFix.scala
family.name.create.object=创建对象
family.name.create.trait=创建特征
family.name.create.class=创建类
family.name.create.case.class=创建 case 类
create.object.named=创建对象 ''{0}''
create.trait.named=创建特征 ''{0}''
create.class.named=创建类 ''{0}''
create.case.class.named=创建 case 类 ''{0}''
choose.level.popup.title=选择级别

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateUnapplyQuickFix.scala
family.name.create.unapply.method=创建 'unapply' 方法
create.unapply.method.in=在 {0} 中创建 ''unapply'' 方法

### org/jetbrains/plugins/scala/annotator/element/ScAnnotationAnnotator.scala
scala.meta.recompile=元程序已过期。单机此处进行编译
scala.meta.expandfailed=宏扩展失败\: {0}

### org/jetbrains/plugins/scala/annotator/element/ScAssignmentAnnotator.scala
annotator.error.wrong.right.assignment.side=右侧赋值错误
annotator.error.reassignment.to.val=重新赋值给 val
illegal.assignment.target=Illegal assignment target

### org/jetbrains/plugins/scala/annotator/element/ScCatchBlockAnnotator.scala
# TODO unify type mismatch messages
expr.type.does.not.conform.expected.type=类型 {0} 的表达式不符合预期的类型 {1}
method.is.not.member=方法 {0} 不是类型 {1} 的成员
expected.type.boolean=预期的布尔类型作为方法 {0} 的返回类型

### org/jetbrains/plugins/scala/annotator/element/ScClassAnnotator.scala
illegal.secondary.constructors.value.class=值类中不允许使用次级构造函数
value.class.can.have.only.one.parameter=值类只能有一个参数
value.class.can.have.only.val.parameter=值类只能有一个非 private val 参数
type.parameter.value.class.may.not.be.specialized=值类的类型参数可能没有专门化
value.classes.cannot.have.nested.objects=值类不能有嵌套的类、对象或特征
value.classes.cannot.redefine.equals.hashcode=值类无法重新定义 equals 和 hashCode
value.classes.can.have.only.defs=值类中不允许字段定义
value.classes.may.not.be.member.of.another.class=值类别不得为另一个类的成员

### org/jetbrains/plugins/scala/annotator/element/ScConstrBlockAnnotator.scala
constructor.invocation.expected=应为 'this'
called.constructor.definition.must.precede=已调用的构造函数的定义必须先于正在调用的构造函数的定义

### org/jetbrains/plugins/scala/annotator/element/ScConstructorInvocationAnnotator.scala
# TODO unify type mismatch messages
type.mismatch.default.args.expected.actual=类型不匹配涉及默认参数，应为\: {0}，实际为\: {1}
annotator.error.class.type.required.but.found=需要类的类型，但找到的是 ({0})
annotator.error.constructor.has.malformed.definition=构造函数的定义格式错误
annotator.error.no.constructor.accessible=从这里无法访问构造函数
annotator.error.cannot.resolve.overloaded.constructor=无法解析重载的构造函数 ''{0}`
annotator.error.unspecified.value.parameters=未指定的值参数\: {0}
annotator.error.trait.has.no.constructor={0} 是特征; 不接受构造函数参数
annotator.error.too.many.arguments.for.constructor=构造函数 {0} 的参数太多
annotator.error.missing.argument.list.for.constructor=构造函数 {0} 缺少参数列表
annotator.error.expansion.for.non.repeated.parameter=非重复参数扩展
annotator.error.positional.after.named.argument=命名参数后的位置
annotator.error.parameter.specified.multiple.times=多次指定了参数
annotator.error.cannot.apply.constructor=无法应用构造函数 {0}

### org/jetbrains/plugins/scala/annotator/element/ScEnumeratorsAnnotator.scala
semicolon.not.allowed.here=此处不允许使用分号
remove.all.erroneous.semicolons.from.forexpression=从表达式中移除所有错误的分号

### org/jetbrains/plugins/scala/annotator/element/ScForBindingAnnotator.scala
enumerators.binding.val.keyword.deprecated=枚举器中的 'val' 关键字已弃用
enumerators.binding.case.keyword.found=应为模式，但找到的是 'case'
remove.case=移除 'case'
family.name.remove.case.from.enumerator=从枚举器中移除 'case'

### org/jetbrains/plugins/scala/annotator/element/ScFunctionExprAnnotator.scala
annotator.error.too.many.parameters=太多参数
annotator.error.missing.parameter.type=缺少参数类型
type.mismatch.expected=类型不匹配，应为\: {0}，实际为\: {1}

### org/jetbrains/plugins/scala/annotator/element/ScFunctionalTypeElementAnnotator.scala
repeated.param.non.method=仅方法签名中允许重复的参数。改用 `Seq`

### org/jetbrains/plugins/scala/annotator/element/ScGeneratorAnnotator.scala
for.pattern.bindings.require.scala3='for' 模式绑定中的 'case' 语法需要的版本为 Scala 3.0
enumerators.generator.val.keyword.found=应为模式，但找到的是 'val'

### org/jetbrains/plugins/scala/annotator/element/ScImportExprAnnotator.scala
import.expr.should.be.qualified=必须限定 import 表达式

### org/jetbrains/plugins/scala/annotator/element/ScInterpolatedStringLiteralAnnotator.scala
cannot.resolve.in.StringContext=值 ''{0}'' 不是 StringContext 的成员

### org/jetbrains/plugins/scala/annotator/element/ScLiteralTypeElementAnnotator.scala
wrong.type.no.literal.types=错误的类型 `{0}`，对于文字类型，支持使用 Scala 2.13 或带有 `-Yliteral-types` 编译器标志的 Typelevel Scala

### org/jetbrains/plugins/scala/annotator/element/ScMacroDefAnnotator.scala
macro.defs.must.have.explicit.return.type=宏定义必须有显式指定的返回类型

### org/jetbrains/plugins/scala/annotator/element/ScMethodInvocationAnnotator.scala
annotator.error.unspecified.value.parameters.mkstring=未指定的值参数\: {0}
annotator.error.cannot.resolve.overloaded.method=无法解析重载方法
annotator.error.too.many.arguments=参数太多
annotator.error.target.does.not.take.parameters={0} 不接受参数
missing.argument.list.for.method.with.explicit.list=方法 {1} 缺少参数列表 {0}
missing.argument.list.for.method=方法 {0} 缺少参数列表

### org/jetbrains/plugins/scala/annotator/element/ScNewTemplateDefinitionAnnotator.scala
illegal.instantiation={0} ''{1}'' 为 abstract；无法实例化

### org/jetbrains/plugins/scala/annotator/element/ScNumericLiteralAnnotator.scala
octal.literals.removed=自 Scala 2.11 起已禁用八进制文字语法
octal.literals.deprecated=Scala 2.10 中已弃用八进制文字语法
trailing.underscore.separator=不允许使用尾随的下划线分隔符
illegal.underscore.separator=下划线分隔符需要的版本为 Scala 2.13
long.literal.is.out.of.range=即使对于 Long 类型，整数也超出范围
integer.literal.is.out.of.range=整数文字超出 Int 类型的范围
lowercase.long.marker=小写的长文字标记

### org/jetbrains/plugins/scala/annotator/element/ScParameterAnnotator.scala
annotator.error.parameter.without.an.owner.name=没有所有者的参数\: {0}
annotator.error.missing.type.annotation.for.parameter=参数缺少类型注解\: {0}
missing.parameter.type.name=缺少参数类型\: {0}
topic.parameters.may.not.be.call.by.name={0} 参数可能不是传名调用

### org/jetbrains/plugins/scala/annotator/element/ScParametersAnnotator.scala
annotator.error.repeated.parameter.must.be.last=*-parameter 必须位于最后
annotator.error.repeated.or.default=带 *-parameter 的参数部分不允许有默认参数

### org/jetbrains/plugins/scala/annotator/element/ScPatternAnnotator.scala
pattern.on.refinement.unchecked=细化类型中的模式匹配未选中
type.cannot.be.used.in.type.pattern=类型 {0} 不能在类型模式或 isInstanceOf 测试中使用
scrutinee.incompatible.pattern.type=Scrutinee 与模式类型不兼容，找到的是\: {0}，需要的是\: {1}
pattern.type.incompatible.with.expected=模式类型与预期类型不兼容，找到的是\: {0}，需要的是\: {1}
constructor.cannot.be.instantiated.to.expected.type=构造函数无法实例化为预期类型，找到的是\: {0}，需要的是\: {1}
fruitless.type.test=无结果的类型测试\: 类型 {0} 的值也不能为 {1}
erasure.warning= (但仍可能与其擦除相符)
wrong.number.arguments.extractor=提取器的参数数量错误，找到 {0} 个，预期为 {1} 个
wrong.number.arguments.extractor.unapplySeq=提取器的参数数量错误，找到 {0} 个，预期为 {1} 个或更多
stable.identifier.required=需要稳定的标识符，但找到的是 {0}
better.monadic.for.invalid.pattern=参数必须有显式类型注解

### org/jetbrains/plugins/scala/annotator/element/ScPatternArgumentListAnnotator.scala
vararg.pattern.must.be.last.pattern=_* 仅可用于最后一个参数

### org/jetbrains/plugins/scala/annotator/element/ScPatternTypeUnawareAnnotator.scala
vararg.pattern.with.colon.requires.scala3=vararg 模式中的 '\:' 语法需要的版本为 Scala 3.0
vararg.pattern.with.at.deprecated.since.scala3=自 Scala 3.0 起已弃用 vararg 模式中的 '@' 语法
vararg.short.pattern.with.at.deprecated.since.scala3=Scala 3.0 中已弃用简短的 _* 模式语法
family.name.replace.type.with.type.in.vararg.pattern=将 vararg 模式中的 ''{0}'' 替换为 ''{1}''
replace.with.type=替换为''{0}''
replace.with.scala3.wildcard.varargs=替换为 '_\: _*'
family.name.replace.old.varags.with.scala3.varargs.pattern=将 vararg 模式中的 '_*' 替换为 '_\: _*'

### org/jetbrains/plugins/scala/annotator/element/ScReferenceAnnotator.scala
cannot.resolve=无法解析符号{0}
cannot.resolve.overloaded=无法解析重载方法 ''{0}''
forward.reference.detected=错误的前向引用
cannot.resolve.apply.method=无法解析方法 {0}.apply
cannot.resolve.unapply.method=无法解析方法 {0}.unapply
annotator.error.unspecified.type.parameters=未指定的类型参数\: {0}
annotator.error.does.not.take.type.parameters={0} 不接受类型参数
annotator.error.too.many.type.arguments={0} 的类型参数太多
annotator.error.too.many.arguments.method=方法 {0} 的参数太多
annotator.error.sunspecified.value.parameters=未指定的值参数\: {0}
annotator.error.name.has.malformed.definition=''{0}'' 的定义格式错误
annotator.error.missing.arguments.for.method=方法 {0} 缺少参数

### org/jetbrains/plugins/scala/annotator/element/ScReturnAnnotator.scala
return.outside.method.definition=return 语句在方法定义外部

### org/jetbrains/plugins/scala/annotator/element/ScSelfInvocationAnnotator.scala
annotator.error.cannot.find.constructor.for.this.call=找不到此调用的构造函数

### org/jetbrains/plugins/scala/annotator/element/ScSimpleTypeElementAnnotator.scala
type.takes.type.parameters=类型 {0} 接受类型参数

### org/jetbrains/plugins/scala/annotator/element/ScStringLiteralAnnotator.scala
string.literal.is.too.long=字符串文字大小超出编译器限制

### org/jetbrains/plugins/scala/annotator/element/ScSymbolLiteralAnnotator.scala
symbolliterals.are.deprecated=Scala 2.13 中已弃用符号文字。请改用 Symbol("{0}")。

### org/jetbrains/plugins/scala/annotator/element/ScTemplateDefinitionAnnotator.scala
illegal.inheritance.from.final.kind=从 final {0} ''{1}'' 非法继承
illegal.inheritance.from.value.class=从值类 {0} 非法继承
illegal.inheritance.multiple={0} ''{1}'' 继承了多次
illegal.inheritance.self.type=非法继承，自类型 {0} 不符合 {1}
illegal.mixin={0} ''{1}'' 必须是特征方可混入
member.implementation.required={0} ''{1}'' 必须声明为 abstract，或者必须在 ''{3}'' 中实现 abstract 成员 ''{2}''
mixin.required={0} ''{1}'' 需要混合，因为 ''{3}'' 中的成员 ''{2}'' 被标记为 ''abstract'' 和 ''override''，但在基类中找不到具体的实现
illegal.undefined.member=仅类可以具有已声明但未定义的成员

### org/jetbrains/plugins/scala/annotator/element/ScTraitAnnotator.scala
trait.parameter.require.scala3=特征参数需要的版本为 Scala 3.0

### org/jetbrains/plugins/scala/annotator/element/ScTypeBoundsOwnerAnnotator.scala
lower.bound.conform.to.upper=下边界与上边界不符

### org/jetbrains/plugins/scala/annotator/element/ScTypedExpressionAnnotator.scala
cannot.upcast.type.to.other.type=无法将 {0} 向上转换为 {1}

### org/jetbrains/plugins/scala/annotator/element/ScUnderscoreSectionAnnotator.scala
unbound.placeholder.parameter=无界的占位符参数
local.variables.must.be.initialized=局部变量必须初始化
default.init.prohibited.literal.types=文字型 var 禁止默认初始化

### org/jetbrains/plugins/scala/annotator/element/ScValueOrVariableAnnotator.scala
annotation.ascriptions.in.pattern.definitions.require.scala3=模式定义中的注解归属需要的版本为 Scala 3.0

### org/jetbrains/plugins/scala/annotator/gutter/RecursiveCallLineMarkerProvider.scala
method.is.recursive=方法 ''{0}'' 为递归方法
method.is.tail.recursive=方法''{0}'' 为尾递归

### org/jetbrains/plugins/scala/annotator/gutter/ScalaGoToSuperActionHandler.scala
goto.super.member.chooser.title=选择超类成员
goto.super.class.chooser.title=选择超类
goto.super.class.or.member.chooser.title=选择超类/超类成员

### org/jetbrains/plugins/scala/annotator/gutter/ScalaLineMarkerProvider.scala
companion.class=类
companion.object=对象
companion.trait=特征
go.to.companion=转到伴生 {0}
go.to.implementation=转到实现
go.to.super.method=Go to super member
gutter.companion=伴生
gutter.implemented=Implemented member
gutter.implementing=Implementing member
gutter.overridden=Overridden member
gutter.overriding=Overriding member
gutter.recursion=递归类型
gutter.sam=实现 SAM
has.companion=具有伴生 {0}
multiple.overriding.tooltip=多次覆盖成员
multiple.overriden.tooltip=多次覆盖成员
scala.line.markers=Scala 行标记

### org/jetbrains/plugins/scala/annotator/gutter/ScalaMarkerType.scala
implements.member.prefix=Implements member
implements.member.from.prefix=Implements member from
implements.member.from.several.classes=Implements members from {0} classes
overrides.member.from.prefix=Overrides member from
overrides.member.from.several.classes=Overrides members from {0} classes
overrides.type.prefix=重写类型
overrides.type.from.super.several.classes=重写 {0} 类中的类型
navigation.title.super.members=选择 {0} 的超类成员
navigation.findUsages.title.super.members={0} 的超类成员
navigation.title.super.types=选择 {0} 的超类型成员
navigation.findUsages.title.super.types={0} 的超类型成员
trait.has.implementations=Is mixed into
trait.has.several.implementations=混合到 {0} 类
class.has.subclasses=由以下对象扩展
class.has.several.subclasses=由 {0} 子类扩展
has.implementations=成员有多次实现
is.overridden.by=成员有多次覆盖
navigation.title.inheritors.trait=<html>选择 <b>{0}</b> 的实现(找到 {1} 个类)</html>
navigation.findUsages.title.inheritors.trait={0}的实现
navigation.title.inheritors.class=<html>选择 <b>{0}</b> 的子类(找到 {1} 个类)</html>
navigation.findUsages.title.inheritors.class={0} 的子类
navigation.title.implementing.member=<html>选择 <b>{0}</b> 的实现成员(找到 {1} 个成员)</html>
navigation.findUsages.title.implementing.member={0} 的实现成员
navigation.title.overriding.member=<html>选择 <b>{0}</b> 的覆盖成员(找到 {1} 个成员)</html>
navigation.findUsages.title.overriding.member={0} 的覆盖成员

### org/jetbrains/plugins/scala/annotator/hints/HintUI.scala
type.mismatch.dot=类型不匹配.

### org/jetbrains/plugins/scala/annotator/modifiers/ModifierChecker.scala
lazy.modifier.is.not.allowed.here='lazy' 修饰符仅允许用于值的定义
lazy.modifier.is.not.allowed.with.param=此处不允许使用 'lazy' 修饰符，请改用 call-by-name 参数
lazy.values.may.not.be.abstract=lazy 值可能不为 abstract
final.modifier.not.with.declarations='final' 修饰符不能用于不完整的成员
final.modifier.not.with.trait=不允许对特征使用 'final' 修饰符
final.modifier.is.redundant.with.final.parents='final' 修饰语对于对象或 final 类成员是冗余的
final.modifier.is.not.allowed.here=此处不允许使用 'final' 修饰符
access.modifier.is.not.allowed.here=此处不允许使用 ''{0}'' 修饰符
abstract.modifier.redundant.fot.traits='abstract' 修饰符对于特征是冗余的
abstract.modifier.is.not.allowed='abstract' 修饰符仅允许用于类或包含 'override' 修饰符的定义
abstract.override.modifier.is.not.allowed='abstract override' 修饰符仅允许用于特征的成员
override.modifier.is.not.allowed.for.classes='override' 修饰符仅允许用于类型定义成员
override.modifier.is.not.allowed=此处不允许使用 'override' 修饰符
sealed.modifier.is.not.allowed.here=此处不允许使用 'sealed' 修饰符
illegal.modifiers.combination=非法的修饰符组合\: {0} 和 {1}
implicit.modifier.cannot.be.used.for.top.level.objects='implicit' 修饰符无法用于顶层对象
implicit.class.must.have.a.primary.constructor.with.one.argument=隐式类必须具有主构造函数，其恰好包含第一个参数列表中的一个参数
implicit.modifier.can.be.used.only.for='implicit' 修饰符只能用于值、变量、方法和类

### org/jetbrains/plugins/scala/annotator/quickfix/AddBreakoutQuickFix.scala
add.collection.breakout.argument=添加 `collection.breakOut` 参数
family.name.add.collection.breakout=添加 `collection.breakOut`

### org/jetbrains/plugins/scala/annotator/quickfix/AddElementToMethodCallFix.scala
add.element=添加 {0}

### org/jetbrains/plugins/scala/annotator/quickfix/AddReturnTypeFix.scala
add.return.type=添加返回类型

### org/jetbrains/plugins/scala/annotator/quickfix/ChangeTypeFix.scala
family.name.change.type=更改类型
change.type.to=将 ''{0}'' 类型更改为 ''{1}''

### org/jetbrains/plugins/scala/annotator/quickfix/ConvertToExplicitSymbolQuickFix.scala
convert.to.explicit.symbol=转换为 Symbol("{0}")
convert.to.explicit.symbol.family=转换为显式符号

### org/jetbrains/plugins/scala/annotator/quickfix/EnableTypeMismatchHints.scala
family.name.enable.type.mismatch.hints=启用类型不匹配提示

### org/jetbrains/plugins/scala/annotator/quickfix/ImplementMethodsQuickFix.scala
implement.methods.fix=执行方法

### org/jetbrains/plugins/scala/annotator/quickfix/ModifierQuickFix.scala
make.non.private.title=将属性设为非 private
add.modifier.fix.without.name=添加 ''{0}'' 修饰符
remove.named.modifier.fix=移除 ''{0}'' 修饰符
make.protected.fix=将属性设为 protected
make.public.fix=将属性设为 public

### org/jetbrains/plugins/scala/annotator/quickfix/NumberLiteralQuickFix.scala
numeric.literal.family=数字文字
convert.to.hex.fix=将八进制文字转换为十六进制
convert.to.long.fix=转换为长文字
lowercase.long.marker.fix=将长文字标记转换为大写

### org/jetbrains/plugins/scala/annotator/quickfix/PullUpQuickFix.scala
pull.method.to=将方法 ''{0}'' 拉取到...
pull.value.to=将值 ''{0}'' 拉取到...
pull.variable.to=将变量 ''{0}'' 拉取到...

### org/jetbrains/plugins/scala/annotator/quickfix/ReportHighlightingErrorQuickFix.scala
report.highlighting.error.fix=报告高亮显示错误...

### org/jetbrains/plugins/scala/annotator/quickfix/WrapInOptionQuickFix.scala
wrap.in.option.name=在选项中包装
wrap.in.option.hint=在 Option(...) 中包装表达式?

### org/jetbrains/plugins/scala/annotator/template/CaseClassWithoutParamList.scala
family.name.add.empty.parentheses=添加空括号
family.name.convert.to.object=转换为对象
case.classes.without.parameter.list.not.allowed=不允许使用没有参数列表的 case 类
case.classes.without.parameter.list.deprecated=已弃用没有参数列表的 case 类

### org/jetbrains/plugins/scala/annotator/template/PrivateBeanProperty.scala
annotator.error.bean.property.should.not.be.private=Bean 属性不应为 private

### org/jetbrains/plugins/scala/annotator/template/TraitHasImplicitBound.scala
traits.cannot.have.type.parameters.with.context.bounds=特征不能有包含上下文边界的类型参数
traits.cannot.have.type.parameters.with.view.bounds=特征不能有包含视图边界的类型参数

### org/jetbrains/plugins/scala/autoImport/quickFix/ImportImplicitConversionFix.scala
import.with=导入 ''{0}''
import.implicit.conversion=导入转换…

### org/jetbrains/plugins/scala/autoImport/quickFix/ImportImplicitInstanceFix.scala
import.implicit=导入隐式…

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaAddImportAction.scala
import.class.chooser.title=导入类
import.package.chooser.title=要导入的包
import.something.chooser.title=要导入的名称
import.conversion.chooser.title=转换为导入
import.implicit.chooser.title=要导入的隐式
add.import.action=添加导入操作
exclude.value.from.auto.import=从自动导入中排除 ''{0}''

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportElementFix.scala
import.hint.text={0}? {1} Alt+Enter
import.multiple.choices=(多重选择.…)

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportGlobalMemberFix.scala
import.global.member=导入全局成员
import.as=作为 ''{0}'' 导入
import.with.prefix.ellipsis=带前缀的导入…
import.with.prefix=带前缀的导入
import.something=导入 ...

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportTypeFix.scala
import.class=导入类
import.package=导入包

### org/jetbrains/plugins/scala/build/BuildToolWindowReporter.scala
report.build.toolwindow.cancel=取消构建
report.build.toolwindow.running=运行中 ...
report.build.toolwindow.failed=已失败
report.build.toolwindow.canceled=已取消
report.build.toolwindow.items=列表

### org/jetbrains/plugins/scala/build/ExternalSystemNotificationReporter.scala
report.build.task.canceled=task canceled

### org/jetbrains/plugins/scala/build/IndicatorReporter.scala
report.build.running=构建正在运行...
report.build.completed=构建已完成
report.build.failed=构建失败
report.failed.with.message=失败\: {0}
report.canceled=已取消
report.warning.with.message=警告\: {0}
report.error.with.message=错误\: {0}
report.building=正在构建...

### org/jetbrains/plugins/scala/codeInsight/intention/AddBracesIntention.scala
family.name.add.braces=添加大括号
add.braces.around.single.line.expression=在单行表达式周围添加大括号

### org/jetbrains/plugins/scala/codeInsight/intention/CreateCompanionObjectIntention.scala
create.companion.object.for.class=为类创建伴生对象
family.name.create.companion.object=创建伴生对象

### org/jetbrains/plugins/scala/codeInsight/intention/RemoveBracesIntention.scala
family.name.remove.braces=移除大括号

### org/jetbrains/plugins/scala/codeInsight/intention/collections/ComparingLengthIntention.scala
family.name.comparing.length=比较长度

### org/jetbrains/plugins/scala/codeInsight/intention/collections/FilterSetContainsIntention.scala
family.name.filter.set.contains=筛选器 Set Contains 

### org/jetbrains/plugins/scala/codeInsight/intention/collections/SomeToOptionIntention.scala
family.name.some.to.option=Some 转换为 Option

### org/jetbrains/plugins/scala/codeInsight/intention/comprehension/ConvertToCurlyBracesIntention.scala
family.name.convert.to.curly.braces=转换为花括号

### org/jetbrains/plugins/scala/codeInsight/intention/comprehension/ConvertToParenthesesIntention.scala
intention.for.comprehension.convert.to.parentheses=转换为括号

### org/jetbrains/plugins/scala/codeInsight/intention/comprehension/DesugarForIntention.scala
desugar.for.comprehension=for 推导脱糖
family.name.convert.to.desugared.expression=转换为脱糖表达式

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertFromInfixExpressionIntention.scala
family.name.convert.from.infix.expression=从中缀表达式转换

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertParameterToUnderscoreIntention.scala
family.name.convert.parameter.to.underscore.section=将参数转换为下划线部分

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertToInfixExpressionIntention.scala
family.name.convert.to.infix.expression=转换为中缀表达式

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertUnderscoreToParameterIntention.scala
family.name.convert.underscore.section.to.parameter=将下划线部分转换为参数

### org/jetbrains/plugins/scala/codeInsight/intention/expression/MakeImplicitConversionExplicit.scala
family.name.make.implicit.conversion.explicit=令隐式转换变为显式转换

### org/jetbrains/plugins/scala/codeInsight/intention/expression/RemoveApplyIntention.scala
family.name.remove.unnecessary.apply=移除不必要的应用

### org/jetbrains/plugins/scala/codeInsight/intention/expression/RemoveUnnecessaryParenthesesIntention.scala
remove.unnecessary.parentheses=移除不必要的括号

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ReplaceTypeCheckWithMatchIntention.scala
family.name.replace.type.check.with.pattern.matching=将类型检查替换为模式匹配

### org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportAdditionalIdentifiersIntention.scala
family.name.import.additional.identifiers=导入附加标识符
import.additional.identifiers.from.qualifier=从限定符导入其他标识符

### org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportAllMembersIntention.scala
family.name.import.all.members=导入所有成员
import.all.members.of.reference=导入 {0} 的所有成员

### org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportStableMemberIntention.scala
family.name.import.member.with.stable.path=导入有稳定路径的成员
import.stable.member=导入 {0}

### org/jetbrains/plugins/scala/codeInsight/intention/matcher/ConvertToTypedPatternIntention.scala
convert.to.typed.pattern=转换为类型化模式

### org/jetbrains/plugins/scala/codeInsight/intention/matcher/ExpandPatternIntention.scala
family.name.expand.to.constructor.pattern=扩展到构造函数模式
expand.to.new.pattern=扩展到\: {0}

### org/jetbrains/plugins/scala/codeInsight/intention/types/AddUnitTypeAnnotationIntention.scala
intention.add.explicit.unit.type.annotation=添加显式 Unit 类型注释
intention.type.annotation.function.add.text=将类型注解添加到函数定义

### org/jetbrains/plugins/scala/codeInsight/intention/types/AdjustTypesIntention.scala
family.name.adjust.types=调整类型

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertFromInfixIntention.scala
family.name.use.prefix.type.syntax=使用前缀类型语法

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertImplicitBoundsToImplicitParameter.scala
family.name.convert.implicit.bounds=转换隐式边界
convert.view.and.context.bounds.to.implicit.parameters=将视图和上下文边界转换为隐式参数

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertJavaToScalaCollectionIntention.scala
convert.java.to.scala.collection.hint=使用 asScala 转换为 Scala 集合?
convert.java.to.scala.collection.name=转换为 Scala 集合

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertScalaToJavaCollectionIntention.scala
convert.scala.to.java.collection.hint=使用 asJava 转换为 Java 集合?
convert.scala.to.java.collection.name=转换为 Java 集合

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertToInfixIntention.scala
family.name.use.infix.type.syntax=使用中缀类型语法

### org/jetbrains/plugins/scala/codeInsight/intention/types/MakeTypeMoreSpecificIntention.scala
make.type.more.specific.fun=使之为更特定的返回类型
make.type.more.specific=使之为更特定的声明类型

### org/jetbrains/plugins/scala/codeInsight/intention/types/RegenerateTypeAnnotation.scala
intention.type.annotation.regen.family=重新生成类型注解
intention.type.annotation.function.regenerate.text=重新生成函数定义的类型注解
intention.type.annotation.value.regenerate.text=重新生成值定义的类型注解
intention.type.annotation.variable.regenerate.text=重新生成变量定义的类型注解

### org/jetbrains/plugins/scala/codeInsight/intention/types/ToggleTypeAnnotation.scala
intention.type.annotation.toggle.family=切换类型注解
intention.type.annotation.function.remove.text=从函数定义中移除类型注解
intention.type.annotation.value.add.text=将类型注解添加到值定义
intention.type.annotation.value.remove.text=从值定义中移除类型注解
intention.type.annotation.variable.add.text=将类型注解添加到变量定义
intention.type.annotation.variable.remove.text=从变量定义中移除类型注解
intention.type.annotation.pattern.add.text=将类型注解添加到模式定义
intention.type.annotation.pattern.remove.text=从模式定义中移除类型注解
intention.type.annotation.parameter.add.text=将类型注解添加到参数中
intention.type.annotation.parameter.remove.text=从参数中移除类型注解
intention.type.annotation.underscore.add.text=将类型注解添加到下划线参数
intention.type.annotation.underscore.remove.text=从下划线参数中移除类型注解

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaCaseClauseRemover.scala
remove.case.clause=移除 case 子句

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaCatchOrFinallyRemover.scala
remove.finally=移除 finally 块
remove.catch=移除 catch 块

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaInterpolatedStringUnwrapper.scala
unwrap.interpolated.string.injection=解开内插字符串注入

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaMatchUnwrapper.scala
unwrap.case.clause=解开 case 子句

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaTryOrFinallyUnwrapper.scala
unwrap.finally=解开 finally

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaTryWithFinallyUnwrapper.scala
unwrap.try.with.finally=解开 try / finally

### org/jetbrains/plugins/scala/codeInspection/caseClassParamInspection/CaseClassParamInspection.scala
val.on.case.class.param.redundant=对于 case 类主构造函数的参数而言，'val' 修饰符冗余

### org/jetbrains/plugins/scala/codeInspection/caseClassParamInspection/RemoveValQuickFix.scala
remove.val=移除 'val'

### org/jetbrains/plugins/scala/codeInspection/catchAll/ReplaceDangerousCatchAllQuickFix.scala
specify.type.of.exception=指定异常类型

### org/jetbrains/plugins/scala/codeInspection/forwardReferenceInspection/ForwardReferenceInspection.scala
suspicicious.forward.reference.template.body=类中的前向引用可疑

### org/jetbrains/plugins/scala/codeInspection/imports/RemoveBracesForSingleImportQuickFix.scala
remove.braces.from.import=移除 import 语句中的大括号

### org/jetbrains/plugins/scala/codeInspection/relativeImports/RelativeImportInspection.scala
make.import.fully.qualified=使之为完全限定的 import

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocInlinedTagInspection.scala
delete.inlined.tag=删除内联标签
replace.with.wiki.syntax=将内联标签替换为等宽的 wiki 语法

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnbalancedHeaderInspection.scala
move.text.after.header.to.new.line=将文本移动到靠近新行的标头后面
balance.header=平衡标头

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnclosedTagWithoutParserInspection.scala
replace.tag.with.esc.seq=将标签替换为转义序列

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnknownParameterInspection.scala
delete.duplicating.param=删除重复参数
delete.tag=删除标签

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnknownTagInspection.scala
delete.unknown.tag=删除未知标签

### org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/FunctionTupleSyntacticSugarInspection.scala
replace.tuple.type=将 TupleN[A1, A1, ...,  AN] 替换为 (A1, A1, ...,  AN)
replace.fun.type=将 FunctionN[A1, A1, ...,  AN, R] 替换为 (A1, A1, ...,  AN) \=> R

### org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/RedundantNewCaseClassInspection.scala
new.on.case.class.instantiation.redundant=移除 'new' 修饰符

### org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/RemoveRedundantReturnInspection.scala
remove.return.keyword=移除 return 关键字

### org/jetbrains/plugins/scala/codeInspection/xml/ScalaXmlUnmatchedTagInspection.scala
xml.no.opening.tag=无开始标签
xml.no.closing.tag=无结束标签
xml.delete.unmatched.tag=删除不匹配的标签
xml.rename.opening.tag=重命名开始标签
xml.rename.closing.tag=重命名结束标签

### org/jetbrains/plugins/scala/compiler/CompileServerLauncher.scala
cannot.start.scala.compile.server=无法启动 Scala 编译服务器

### org/jetbrains/plugins/scala/compiler/CompileServerManager.scala
scala.compile.server.title=Scala 编译服务器
action.run=&运行
start.compile.server=启动编译服务器
action.stop=&停止
shutdown.compile.server=关闭编译服务器
action.configure=配置(&C)...
configure.compile.server=配置编译服务器

### org/jetbrains/plugins/scala/compiler/EnsureModulesHaveDifferentProdAndTestOutputsTask.scala
shared.compile.output.paths.in.scala.modules=Scala 模块中的共享编译输出路径
production.and.test.output.paths.are.shared.in=生产和测试输出路径在以下位置共享\: {0}
split.output.paths.automatically=自动拆分输出路径
cancel.compilation=取消编译

### org/jetbrains/plugins/scala/compiler/ScalaCompileServerForm.form
#ScalaCompileServer UI
jvm.options=JVM 选项(&O)\:
jvm.maximum.heap.size.mb=JVM 最大堆大小(MB)(&H)\:
jdk=&JDK\:
advanced.settings=高级设置
minutes=分钟的更改项
compile.server.new.project.restart=每次编译新项目时重启编译服务器。
compile.server.use.project.home=使用项目主目录作为编译服务器工作目录(&W)
compile.server.jvm.command.line.parameters=编译服务器 JVM 命令行参数
compile.server.shutdown.if.idle.for=经历此时长的空闲状态后关闭服务器
compile.server.description=编译服务器为应用程序级(所有项目使用同一个实例)。\n\
使用 JDK 实例化编译服务器并调用\n\
进程内的 Java 编译器(当 JDK 和模块 SDK 匹配时)。
compile.server.use.for.scala=为 Scala 使用编译服务器(&S)

### org/jetbrains/plugins/scala/components/PluginVersionVerifier.scala
incompatible.plugin.detected=检测到不兼容的插件

### org/jetbrains/plugins/scala/components/Scala3Disclaimer.scala
scala.3.disclaimer=Scala 3 免责声明
scala.3.support.is.experimental=正在开发 Scala 3 支持。<br>请考虑使用每日构建版。<a href\=''{0}''>了解详情</a>
configure.updates=配置更新…
scala.3.support.is.incompatible=Dotty 版本\: {0}，支持的版本\: {1}
adjust.dotty.version=使用 Dotty {0}

### org/jetbrains/plugins/scala/components/TypeAwareWidgetProvider.scala
type.aware.highlighting.title=Scala 类型感知高亮显示
click.or.press.shortcut.to.change=(单击或按 {0} 进行更改)
click.to.change=(单击以进行更改)
enabled.word=已启用
disabled.word=已禁用

### org/jetbrains/plugins/scala/components/libextensions/ExtensionDownloader.scala
downloading.url=下载中{0}

### org/jetbrains/plugins/scala/components/libextensions/LibraryExtensionsManager.scala
title.searching.for.library.extensions=搜索库表达式

### org/jetbrains/plugins/scala/components/libextensions/ui/LibExtensionsSettingsPanelWrapper.scala
select.library.from.the.list.above=从以上列表中选择库
idea.will.try.to.search.for.extra.support.for.particular.libraries=IDEA 将尝试搜索对您项目中特定库的额外支持
title.failed.to.load.extension.jar=加载扩展 JAR 失败
no.known.extension.libraries=无已知的扩展库
known.extension.libraries=已知扩展库
extensions.in.selected.library=所选库中的扩展
enable.loading.external.extensions=启用加载外部扩展
how.to.add.custom.macro.support.help.link.title=如何添加自定义 scala 宏支持

### org/jetbrains/plugins/scala/components/libextensions/ui/PopupHelper.scala
title.extensions.available=可用的扩展
additional.support.has.been.found.popup=<p>已为您的某些库找到了其他支持。</p><p>是否要启用该支持? <a href\="Yes">是</a> / <a href\="No">否</a></p>

### org/jetbrains/plugins/scala/console/actions/RunConsoleAction.scala
scala.console.actions.scala.repl=Scala REPL
scalarepl.menu.action.text=Scala REPL...
scalarepl.menu.action.description=运行 Scala REPL

### org/jetbrains/plugins/scala/console/actions/ScalaConsoleCleanAction.scala
clean.scala.repl.content.menu.action.text=清除 Scala REPL 内容
clean.scala.repl.content.menu.action.description=清除 Scala REPL 内容

### org/jetbrains/plugins/scala/console/actions/ScalaConsoleExecuteAction.scala
execute.scala.repl.statement.menu.action.text=执行 Scala REPL 语句
execute.scala.repl.statement.menu.action.description=执行 Scala REPL 语句

### org/jetbrains/plugins/scala/console/actions/SendSelectionToConsoleAction.scala
send.selection.to.scala.repl.menu.action.text=将所选内容发送到 Scala REPL
send.selection.to.scala.repl.menu.action.description=将所选内容发送到 Scala REPL

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleConfigurationType.scala
scala.console.config.display.name=Scala REPL
scala.console.config.scala.repl.run.configurations=Scala REPL 运行配置

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfiguration.scala
scala.console.configure.scala.sdk.classpath=配置 Scala SDK 类路径(&C)
scala.console.config.module.is.not.specified=未指定模块
scala.console.config.unknown.sdk=<unknown sdk>
scala.console.config.scala.console.requires.jline={0} 需要具备 {1} 才能运行\n\
请将其添加到 `{2}` 编译器类路径

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfigurationForm.form
scala.console.config.working.directory=工作目录\:
scala.console.config.use.classpath.and.sdk.of.module=使用模块的类路径和 SDK\:

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfigurationForm.java
scala.console.config.vm.options=虚拟机选项
scala.console.config.console.arguments=控制台参数
scala.console.config.test.run.config.choose.working.directory=选择工作目录

### org/jetbrains/plugins/scala/debugger/breakpoints/ScalaLineBreakpointType.scala
line.breakpoints.tab.title=Scala 行断点

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilder.scala
non-scala.code.fragment=Scala 评估程序构建器中的非 scala 代码片段

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilderUtil.scala
cannot.evaluate.imported.reference=无法评估导入的引用
cannot.evaluate.local.method=无法评估局部方法
cannot.evaluate.parameter=无法评估参数 {0}
cannot.evaluate.method=无法评估方法 {0}
cannot.evaluate.local.object=无法评估局部对象 {0}
cannot.evaluate.local.variable=无法评估局部变量 {0}
wrong.number.of.arguments=方法 {0} 的参数数量错误
array.instance.is.not.found=无法评估方法 {0}\: 找不到数组实例
array.method.not.supported=不支持数组方法
cannot.find.implicit.parameters=找不到要传递的隐式参数
implicit.parameters.from.dependent.objects=不支持依赖对象的隐式参数
implicit.conversions.from.dependent.objects=不支持依赖对象中的隐式转换
method.with.by-name.parameters=无评估法包含传名参数的方法
wrong.number.of.expressions=无法评估参数\: 匹配表达式的数量错误
tupling.not.supported=不支持元组化。请使用元组表达式。
not.used.from.for.statement=无法评估 for 语句中的变量 {0}，因为它没有在主体中使用
cannot.find.pattern=找不到 case 子句的模式
cannot.find.expression.of.match=找不到匹配语句的表达式
invalid.case.clause=无效的 case 子句
assignent.without.expression=无法评估没有表达式的赋值语句
unapply.without.arguments=无法从没有参数的 unapply 提取值
pattern.doesnot.resolves.to.unapply=模式引用 {0} 不会解析为 unapply 或 unapplySeq
pattern.alternatives.cannot.bind.vars=模式替代项不能绑定变量
xml.patterns.not.supported=不支持 Xml 模式
kind.of.patterns.not.supported=不支持此类模式\: {0}
anon.classes.not.supported=不支持匿名类
new.expression.without.class.reference=无法评估没有类引用的新表达式
new.expression.without.constructor.call=无法评估没有构造函数调用的表达式
new.expression.without.template.parents=无法评估没有模板父项的表达式
could.not.resolve.constructor=无法解析构造函数
if.statement.without.condition=无法评估没有条件的 if 语句
if.statement.without.if.branch=无法评估没有 if 分支的 if 语句
while.statement.without.condition=无法评估没有条件的 while 语句
while.statement.without.body=无法评估没有主体的 while 语句
do.statement.without.condition=无法评估没有条件的 do 语句
do.statement.without.body=无法评估没有主体的 do 语句
method.call.implicitly.converted.qualifier=无法评估包含隐式转换限定符的方法调用\: {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaThisEvaluator.scala
outer.this.not.available=外部 'this' 不可用

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.form
friendly.collection.debug.start.index=集合起始索引
friendly.collection.debug.end.index=集合结束索引
friendly.collection.display.enabled=在调试器中直观显示 Scala 集合
friendly.collection.do.not.display.streams=不扩展 流和视图
dont.show.runtime.refs=无法在调试器中显示运行时引用
force.class.prepare.request.for.nested.types=在虚拟机加载嵌套类时强制处理这些类
force.position.lookup.in.nested.types=强制创建嵌套类型的断点
show.variables.from.outer.scopes.in.variables.view=在变量视图中显示外部范围的变量

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.java
scala.debug.caption=Scala

### org/jetbrains/plugins/scala/debugger/filters/ScalaSteppingConfigurable.form
scala.debug.disable.specific.methods=不单步执行特定的 Scala 类(&I)

### org/jetbrains/plugins/scala/editor/autoimport/ScalaAutoImportOptionsProviderForm.scala
auto.import.insert.imports.on.paste=粘贴时插入导入\:
auto.import.show.import.popup.for=为下列对象显示导入弹出窗口\:
auto.import.add.unambiguous.imports.on.the.fly.for=快速添加清晰的导入\:
auto.import.optimize.imports.on.the.fly=即时优化 import
auto.import.show.popup.classes=类
auto.import.show.popup.methods=static 成员
auto.import.show.popup.conversions=隐式转换
auto.import.show.popup.implicits=隐式定义
options.scala.display.name=Scala
auto.import.find.more.options.in=从中查找更多选项 
auto.import.code.style.link=代码风格

### org/jetbrains/plugins/scala/externalHighlighters/CompilerEventGeneratingClient.scala
highlighting.compilation.progress=高亮显示\: {0}

### org/jetbrains/plugins/scala/externalHighlighters/JpsCompiler.scala
highlighting.compilation=错误/警告高亮显示

### org/jetbrains/plugins/scala/findUsages/compilerReferences/ScalaCompilerReferenceService.scala
open.compiler.index.reader=打开编译器索引读取器
index.invalidation.callback=索引作废回调

### org/jetbrains/plugins/scala/findUsages/compilerReferences/SearchTargetExtractors.scala
bytecode.indices.target.sam.type=SAM 类型
bytecode.indices.target.unapply.method=apply/unapply 方法
bytecode.indices.target.for.comprehension.method=for-comprehension 方法
bytecode.indices.target.implicit.definition=隐式定义

### org/jetbrains/plugins/scala/findUsages/compilerReferences/compilation/JpsCompilationWatcher.scala
malformed.message.from.builder=构建器中的 messageText 格式错误\: {0}

### org/jetbrains/plugins/scala/findUsages/compilerReferences/compilation/SbtCompilationWatcher.scala
failed.to.parse.offline.compilation.analysis.files=解析脱机编译分析文件失败。
sbt.module.added=sbt 模块已添加。
sbt.connection.failure=sbt 编译管理工具\: 连接失败。
failed.to.parse.compilation.info.file=无法解析编译信息文件 {0}
error.while.reading.sbt.compilation.info=尝试读取 sbt 编译信息文件时出错。

### org/jetbrains/plugins/scala/findUsages/compilerReferences/indices/CompilerReferenceIndexer.scala
bytecode.indices.indexing=正在索引类文件...
title.initializing.compiler.indices.writer=初始化编译器索引写入器
title.closing.compiler.indices.writer=关闭编译器索引写入器
title.invalidating.compiler.indices=作废编译器索引

### org/jetbrains/plugins/scala/findUsages/compilerReferences/indices/CompilerReferenceIndexerScheduler.scala
bytecode.indices.progress.title=正在索引重新编译的类文件...

### org/jetbrains/plugins/scala/findUsages/compilerReferences/search/CompilerIndicesReferencesSearcher.scala
bytecode.indices.unavailable=在编译期间不可通过字节码索引查找用法。
bytecode.indices.in.progress=正在索引

### org/jetbrains/plugins/scala/findUsages/compilerReferences/search/CompilerIndicesSearcher.scala
bytecode.indices.find.usages=发现用法
bytecode.indices.invalidated.title=用法已作废
bytecode.indices.invalidated.message=由于进行了外部更改，以下文件中的某些用法可能已失效\: {0}。

### org/jetbrains/plugins/scala/findUsages/compilerReferences/search/ImplicitUsagesSearchDialogs.scala
bytecode.indices.find.usages.with.title=查找用法 ({0})
bytecode.indices.settings.navigate=导航到字节码索引设置
bytecode.indices.enable.indexing=启用字节码索引
bytecode.indices.enable=开启
bytecode.indices.enable.and.restart=启用并重启
bytecode.indices.precompile=在搜索前预编译使用范围内的模块
bytecode.indices.bytecode=字节码
bytecode.indices.settings=设置 | 字节码索引
bytecode.indices.required=此搜索依赖于
bytecode.indices.outdated=，但它未处于最新状态。
bytecode.indices.incomplete=如果不进行编译，结果可能不完整。
bytecode.indices.must.be.enabled.1=搜索 {0} 用法需要启用字节码索引。
bytecode.indices.must.be.enabled.2=是否要启用字节码索引(在 IDEA 重启后生效)?

### org/jetbrains/plugins/scala/findUsages/compilerReferences/settings/CompilerIndicesConfigurable.scala
bytecode.indices=字节码索引
bytecode.indices.restart.title=字节码索引设置更新
bytecode.indices.restart.message=重启 IDEA 以激活字节码索引设置中的更改?
bytecode.indices.shutdown.message=关闭 IDEA 以激活字节码索引设置中的更改?

### org/jetbrains/plugins/scala/findUsages/compilerReferences/settings/CompilerIndicesSettingsForm.form
scala.compiler.indices.settings.enable.cb=索引 .class 文件(&I)
scala.compiler.indices.settings.invalidate.button=删除索引(&D)
scala.compiler.indices.sbt.automatic=自动(需要 sbt shell)(&A)
scala.compiler.indices.sbt.manual=&手动
#Bytecode indices settings
apply.unapply.methods=apply / unapply 方法
for.comprehension.methods=For-comprehension 方法 (map, withFilter, flatMap, foreach)
add.line.to.build.sbt=向 build.sbt 中添加以下行\:
add.line.to.plugins.sbt=向 project/plugins.sbt 中添加以下行\:
implicit.definitions=隐式定义
port.number=端口号\:
sam.types=SAM 类型
sbt.compilation.listener=sbt 编译侦听器配置(应用程序级)
use.indices.to.search=使用索引搜索此对象的用法\:

### org/jetbrains/plugins/scala/findUsages/factory/ScalaFindUsagesHandlerFactory.scala
find.usages.member.has.supers= 成员 {0} 覆盖/实现一些基本成员。\n\
要查找基本成员的用法吗?
title.warning=警告

### org/jetbrains/plugins/scala/findUsages/factory/ScalaTypeDefinitionUsagesDialog.scala
find.what.members.usages.checkbox=成员的用法(&M)
find.what.implementing.type.definitions.checkbox=实现类型定义(&D)
find.what.companion.module.checkbox=伴生模块的用法(&C)
find.what.new.instances.usages=仅创建实例(&I)

### org/jetbrains/plugins/scala/highlighter/ScalaColorSchemeAnnotator.scala
scala.mutable.collection=可变集合
scala.immutable.collection=不可变集合
java.collection=Java 集合

### org/jetbrains/plugins/scala/lang/completion/ScalaCompletionUtil.scala
wrong.top.statment.declaration=错误的 top 语句声明

### org/jetbrains/plugins/scala/lang/completion/ScalaGlobalMembersCompletionContributor.scala
to.import.method.statically.press.hotkey=要静态导入方法，请按 {0}

### org/jetbrains/plugins/scala/lang/completion/lookups/ScalaImportStaticLookupActionProvider.scala
action.import.member=导入成员

### org/jetbrains/plugins/scala/lang/findUsages/ScalaUsageTypeProvider.scala
usage.extractor=提取器
usage.typed.pattern=类型化模式
usage.typed.statement=类型化语句
usage.method.apply=`apply` 方法
usage.this.reference=This 引用
usage.access.modifier=访问修饰符
usage.package.clause=包子句
usage.function.expression=函数表达式
usage.named.parameter=命名参数
usage.interpolated.string.prefix=内插字符串前缀
usage.parameter.in.pattern=模式中的参数
usage.self.type=自类型
usage.type.bound=类型边界
usage.type.alias=类型别名
usage.secondary.constructor=次级构造函数
usage.implicit.conversion.parameter=隐式转换/参数
usage.unresolved.implicit.conversion.parameter=未解析的隐式转换/参数
usage.sam.interface.implementation=SAM 接口实现

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalaFmtSuggesterService.scala
scalafmt.suggester.detected.in.project=在此项目中检测到 Scalafmt 配置
scalafmt.suggester.use.scalafmt.formatter=使用 scalafmt 格式化程序
scalafmt.suggester.continue.using.intellij.formatter=继续使用 IntelliJ 格式化程序

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalafmtDynamicConfigServiceImpl.scala
#Scalafmt
scalafmt.picked.new.config=Scalafmt 选择了新样式配置 (v{0})
scalafmt.can.not.find.config.file=无法找到配置文件\: {0}
scalafmt.can.not.find.config.file.go.to.settings=设置...
scalafmt.can.not.find.config.file.create.new=创建新文件
scalafmt.can.not.create.config.file=无法创建配置文件
scalafmt.config.load.errors.failed.to.load.config=加载 scalafmt 配置失败
scalafmt.config.load.errors.file.not.found=找不到文件 
scalafmt.config.load.errors.parse.error=解析错误\: {0}
scalafmt.config.load.errors.unknown.error=未知错误\: {0}
scalafmt.config.load.errors.cyclic.includes.detected=检测到循环包含
scalafmt.config.load.actions.open.config.file=打开配置文件

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalafmtDynamicServiceImpl.scala
scalafmt.download=下载
scalafmt.resolve.again=再次解析
scalafmt.progress.resolving.scalafmt.version=正在解析 scalafmt 版本 {0}
scalafmt.progress.downloading.scalafmt.version=正在下载 scalafmt 版本 {0}
scalafmt.progress.resolving.scalafmt.version.cancel=停止解析
scalafmt.progress.downloading.scalafmt.version.cancel=停止下载
scalafmt.progress.version.was.downloaded=已下载 Scalafmt 版本 {0}
scalafmt.resolve.errors.cant.resolve.scalafmt.version=无法解析 scalafmt 版本 {0}
scalafmt.resolve.errors.version.is.not.downloaded.yet=尚未下载 Scalafmt 版本 `{0}`。<br>是否下载?
scalafmt.resolve.errors.download.is.in.progress=正在下载
scalafmt.resolve.errors.downloading.error.occurred=下载出错
scalafmt.resolve.errors.classpath.is.corrupted=类路径损坏
scalafmt.resolve.errors.unknown.error=未知错误

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/dynamic/ScalafmtDynamic.scala
file.does.not.exist=文件不存在
failed.to.resolve.scalafmt.version=无法解析 Scalafmt 版本 ''{0}''

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/processors/ScalaFmtPreFormatProcessor.scala
#0:file link;1:error message
scalafmt.format.errors.scala.file.parse.error=Scalafmt 解析错误 ({0})\:<br>{1}
#0:file link;1:error message
scalafmt.format.errors.failed.to.find.correct.surrounding.code=Scalafmt 错误 ({0})\: <br>未能找到要传递给 scalafmt 的正确的包围代码，不会执行格式化

### org/jetbrains/plugins/scala/lang/formatting/settings/ImportPanelConverterProvider.scala
scala.imports.settings.will.be.moved.to.code.style.settings=Scala 导入设置将移动到代码样式设置。

### org/jetbrains/plugins/scala/lang/formatting/settings/ImportsPanel.form
imports.panel.class.count.to.use.import.with=要对 '_' 使用 import 的类计数\:
imports.panel.add.import.statement.in.closest.block=添加最接近的块中的 import 语句
imports.panel.add.fully.qualified.imports=添加完全限定的 import
imports.panel.do.not.change.path.during.optimize.imports.for.local.imports=在针对局部导入优化导入期间不更改路径
imports.panel.sort.imports.for.optimize.imports=排序 import(用于优化 import)\:
imports.panel.lexicographically=字典顺序
imports.panel.scalastyle.consistent=scalastyle 一致
#TODO
imports.panel.merge.imports.with.the.same.prefix.into.one.statement=将具有相同前缀的 import 合并到一条语句中
imports.panel.use.the.shortest.path.when.trying.to.import.reference.with.already.imported.name=在尝试导入具有已导入名称的引用时，请使用最短路径
imports.panel.classes.to.use.only.with.prefix=仅对前缀使用的类
imports.panel.import.layout=导入布局
imports.panel.imports.always.marked.as.used=import 始终标记为已使用

### org/jetbrains/plugins/scala/lang/formatting/settings/ImportsPanel.java
# Imports panel
imports.panel.title=导入
imports.panel.add.pattern.to.use.appropriate.classes.only.with.prefix=添加模式以使用仅带有前缀的适当的类
imports.panel.use.references.with.prefix=使用带前缀的引用\:
imports.panel.no.imports.with.prefix=没有带前缀的 import
imports.panel.add.package.name=添加包名
imports.panel.import.layout.manager=导入布局管理器
imports.panel.add.import.to.always.mark.it.as.used=添加 import 以始终将其标记为已使用
imports.panel.always.mark.as.used=始终标记为已使用
imports.panel.honestly.mark.imports.as.unused=如实将 import 标记为未使用

### org/jetbrains/plugins/scala/lang/formatting/settings/MultiLineStringCodeStylePanel.form
multi.line.string.panel.opening.quotes.on.new.line=在新行中放置左引号(&O)
multi.line.string.panel.place.closing.quotes.on.new.line.on.enter.press=在新行中按 enter 键时放置右引号(&C)
multi.line.string.panel.align.dangling.closing.quotes=对齐悬空的右引号(&A)
multi.line.string.panel.insert.margin.char.on.enter=在新行中按 enter 键时插入边距字符(&I)
multi.line.string.panel.process.margin.on.copy.paste=在复制/粘贴时去除/插入边距(&S)
multi.line.string.panel.margin.char.value=边距字符\:
multi.line.string.panel.margin.char.indent=边距字符缩进\:

### org/jetbrains/plugins/scala/lang/formatting/settings/MultiLineStringCodeStylePanel.java
#Multi-line strings panel
multi.line.string.panel.title=多行字符串

### org/jetbrains/plugins/scala/lang/formatting/settings/OtherCodeStylePanel.form
other.panel.enforce.functional.syntax.for.methods.with.unit.return.type=对具有 Unit 返回类型的方法强制执行函数语法
other.panel.reformat.on.compile=编译时重新格式化
other.panel.replace.with.unicode.symbol=将 '\=>' 替换为 unicode 符号
other.panel.replace.with.unicode.symbol1=将 '->' 替换为 unicode 符号
other.panel.replace.in.for.generator.with.unicode.symbol=将 \"for\" 生成器中的 '<-' 替换为 unicode 符号
other.panel.kind.projector.replace.lambda.with.unicode.symbol=Kind Projector\: 将 'Lambda' 替换为 unicode 符号
other.panel.alternate.indentation.for.constructor.args.and.parameter.declarations=构造函数参数和参数声明的备选缩进\:
other.panel.spaces=空格
other.panel.implicit.value.class.prefix.suffix=Implicit value class prefix / suffix

### org/jetbrains/plugins/scala/lang/formatting/settings/OtherCodeStylePanel.java
#Other panel
other.panel.title=Java EE

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaCodeStyleSettings.java
#align options
wrapping.and.braces.panel.extends.do.not.align=不对齐
wrapping.and.braces.panel.extends.on.first.token=在第一个令牌上
wrapping.and.braces.panel.extends.align.to.extends=对齐 'extends'

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaDocFormattingPanel.scala
#Scaladoc panel
scaladoc.panel.title=ScalaDoc
scaladoc.panel.enable.scaladoc.formatting=启用 scaladoc 格式化
scaladoc.panel.add.additional.space.for.leading.asterisk=为前导星号添加额外空格
scaladoc.panel.groups.blank.lines=空行
scaladoc.panel.groups.alignment=对齐
scaladoc.panel.groups.other=Java EE

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaFmtSettingsPanel.scala
scalafmt.default=默认(通用)
scalafmt.default.path=默认\: {0}
#Code style panel
scalafmt.settings.panel.show.warnings.when.formatting.invalid.code=尝试格式化无效代码时显示警告
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting=使用 IntelliJ 格式化程序进行代码范围格式化
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting.warning.tooltip=使用 Scalafmt 格式化代码范围可能导致代码不一致。<br>Scalafmt 设计为仅格式化包含 scala 代码的整个文件。
scalafmt.settings.panel.reformat.on.file.save=保存文件时重新格式化
scalafmt.settings.panel.fallback.to.default.settings=回退到默认 intellij 设置
scalafmt.settings.panel.configuration.label=配置
scalafmt.settings.panel.scalafmt.version.label=Scalafmt 版本
scalafmt.settings.panel.select.custom.scalafmt.configuration.file=选择自定义 scalafmt 配置文件
scalafmt.settings.panel.no.config.found.under.path.using.default=未在指定路径下找到配置文件
scalafmt.settings.panel.errors.cant.resolve.version=无法解析 scalafmt 版本 {0}
scalafmt.settings.panel.errors.failed.to.parse.config=解析配置失败\:<br> {0}
scalafmt.settings.panel.errors.cant.find.config.file=无法找到具有以下路径的 scalafmt 配置文件\:<br> {0}

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaLanguageCodeStyleSettingsProvider.scala
#Spaces
spaces.panel.simple.one.line.block.braces=简单的单行块大括号
spaces.panel.import.braces=导入大括号
spaces.panel.self.type.braces=自类型大括号
spaces.panel.before.context.bound.colon.rest=上下文边界冒号前面 (rest)
spaces.panel.before.context.bound.colon.leading.higher.kinded=上下文边界冒号前面(前导的较高类型)
spaces.panel.before.context.bound.colon.leading=上下文边界冒号前面(前导)
spaces.panel.before.opening.square.bracket=左方括号前面
spaces.panel.keep.one.line.comments.on.same.line=在同一行上保留一行注释
spaces.panel.newline.after.annotations=注解后面换行
spaces.panel.around.at.in.pattern.bindings=围绕模式绑定中的 '@'
spaces.panel.inside.closure.braces=右大括号里面
spaces.panel.before.colon.after.declarations.name=冒号前面，声明的名称后面
spaces.panel.after.colon.before.declarations.type=冒号后面，声明的类型前面
spaces.panel.method.call.left.brace=方法调用左大括号
spaces.panel.preserve.space.before.method.parentheses=保留方法括号前面的空格
spaces.panel.infix.method.parentheses=中缀方法括号
spaces.panel.infix.operator.like.method.call.parentheses=类似于中缀运算符的方法调用括号
spaces.panel.infix.method.call.parentheses=中缀方法调用括号
spaces.panel.constructor.parameters.with.modifiers=带修饰符的构造函数参数
#Wrapping and Braces
#custom groups
wrapping.and.braces.panel.groups.method.definition=方法定义
wrapping.and.braces.panel.groups.anonymous.method.definition=匿名方法定义
wrapping.and.braces.panel.groups.class.definition=类定义
wrapping.and.braces.panel.groups.xml.formatting=XML 格式化
wrapping.and.braces.panel.groups.tuple=元组
wrapping.and.braces.panel.groups.type.arguments=参数类型
wrapping.and.braces.panel.groups.type.parameters=参数类型
wrapping.and.braces.panel.force.braces=强制加大括号
wrapping.and.braces.panel.force.try.braces=强制 'try' 使用大括号
wrapping.and.braces.panel.force.case.branch.braces=强制 'case' 分支使用大括号
wrapping.and.braces.panel.force.finally.braces=强制 'finally' 大括号
wrapping.and.braces.panel.align.tuple.elements=对齐元组元素
wrapping.and.braces.panel.do.not.indent.tuples.closing.parenthesis=不缩进元组右括号
wrapping.and.braces.panel.do.not.align.block.expression.parameters=不对齐块表达式参数
wrapping.and.braces.panel.indent.braced.arguments=缩进大括号内的参数
wrapping.and.braces.panel.simple.one.line.lambdas.in.arg.list=参数列表中简单的单行 lambdas
wrapping.and.braces.panel.keep.xml.formatting=保持 xml 格式化
wrapping.and.braces.panel.place.self.type.on.new.line=将自类型置于新行
wrapping.and.braces.panel.align.multiline.pattern.alternatives=对齐多行模式替代项
wrapping.and.braces.panel.align.in.columns.case.branches=对齐列 'case' 分支
wrapping.and.braces.panel.do.not.indent.case.clause.body=不缩进 case 子句主体
wrapping.and.braces.panel.match.statement='match' 语句
wrapping.and.braces.panel.indent.first.parameter.clause.if.on.new.line=遇到新行时缩进第一个参数子句
wrapping.and.braces.panel.indent.first.parameter.if.on.new.line=遇到新行时缩进第一个参数
wrapping.and.braces.panel.align.parameter.types.in.multiline.declarations=对齐多行声明中的参数类型
wrapping.and.braces.panel.use.normal.indent.for.parameters=对参数使用标准缩进
wrapping.and.braces.panel.parameters.on.new.line=新行中的参数
wrapping.and.braces.panel.wrap.before.with.keyword=在 'with' 关键字前面包装 
wrapping.and.braces.panel.align.if.else.statements=对齐 if-else 语句
wrapping.and.braces.panel.indent=缩进
wrapping.and.braces.panel.new.line.options.no.new.line=无新行
wrapping.and.braces.panel.new.line.options.new.line.always=始终换行
wrapping.and.braces.panel.new.line.options.new.line.for.multiple.arguments=对多行参数换行
wrapping.and.braces.panel.renamed.infix.expressions=中缀表达式
wrapping.and.braces.panel.renamed.extends.with.list=Extends/with 列表
wrapping.and.braces.panel.renamed.extends.keyword=扩展关键字
wrapping.and.braces.panel.renamed.force.yield.braces=强制使用 yield 大括号
#Blank Lines
blank.lines.panel.around.method.in.inner.scopes=围绕内部范围中的方法
blank.lines.panel.around.field.in.inner.scopes=围绕内部范围中的字段
scaladoc.panel.align.parameter.descriptions=对齐参数说明
scaladoc.panel.align.throws.exception.descriptions=对齐抛出异常描述
scaladoc.panel.align.return.value.description=对齐返回值描述
scaladoc.panel.align.other.tags.descriptions=对齐其他标签描述
scaladoc.panel.blank.lines.keep=保持(不移除标签之间的空白行)
scaladoc.panel.between.parameter.descriptions=在参数描述之间
scaladoc.panel.before.parameter.descriptions=在参数描述前面
scaladoc.panel.preserve.spaces.in.tags=保留标签中的空格

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaTabbedCodeStylePanel.scala
scala.root.code.style.panel.formatter=格式化程序\:

### org/jetbrains/plugins/scala/lang/formatting/settings/TrailingCommaPanel.scala
#Trailing comma
trailing.comma.panel.title=尾随逗号
trailing.comma.panel.keep=保持
trailing.comma.panel.remove.when.multiline=多行时移除
trailing.comma.panel.add.when.multiline=多行时添加
trailing.comma.panel.scope.arguments.list=参数列表
trailing.comma.panel.scope.parameters.list=参数列表
trailing.comma.panel.scope.tuple=元组
trailing.comma.panel.scope.tuple.type=元组类型
trailing.comma.panel.scope.pattern.arguments.list=模式参数列表
trailing.comma.panel.scope.type.parameters.list=类型参数列表
trailing.comma.panel.scope.import.selector=导入选择器

### org/jetbrains/plugins/scala/lang/formatting/settings/TypeAnnotationsPanelBase.form
#Use for
type.annotations.panel.use.for=用于
type.annotations.panel.public.member=public 成员
type.annotations.panel.protected.member=protected 成员
type.annotations.panel.private.member=private 成员
type.annotations.panel.local.definition=本地定义
type.annotations.panel.function.literal.parameter=函数文字参数
type.annotations.panel.underscore.parameter=下划线参数
#Enforce for
type.annotations.panel.enforce.for=对此对象实施
type.annotations.panel.implicit.definition=隐式定义
type.annotations.panel.unit.type=Unit 类型
type.annotations.panel.accidental.structural.type=意外结构类型*
type.annotations.panel.accidental.structural.type.tooltip=<html>强制对值执行类型注解，这些注解具有推断的结构类型，例如<br>\n\
<pre><code>\n\
val foo \= Runnable {\n\
  override def run()\: Unit \= ()\n\
  def helper()\: Unit \= ()\n\
} // foo has inferred type Runnable { def helper()\: Unit } \n\
</code></pre></html>
#Except when
type.annotations.panel.except.when=以下情况除外
type.annotations.panel.member.of.anonymous.class=匿名类的成员
type.annotations.panel.member.of.private.class=private 类的成员
type.annotations.panel.member.of=成员所属的对象\:
type.annotations.panel.annotated.with=注解方式\:
type.annotations.panel.constant.final.val=常量(final val)
type.annotations.panel.type.is.stable=类型稳定*
type.annotations.panel.type.is.stable.tooltip=<html><body>当右侧为\:<br> 文字\: <code>123</code>、<code>\"string\"</code> 等( <code>null</code> 除外)<br> 单元表达式\: <code>()</code><br> 对象创建\: <code>new Foo(...)</code> (包含细化的除外\: <code>new Foo() {}</code>)<br> 工厂方法调用\: <code>Foo(...)</code> (遇到伴生对象时调用 <code>apply(...)</code>)<br> 空集合\: <code>Seq.empty[Int]</code>、<code>Map.empty[Int, String]</code> 等。<br> Java 枚举常量\: <code>Enum.VALUE</code><br> 异常\: <code>throw Exception()</code> </body></html>
type.annotations.panel.type.matches=类型匹配\:
type.annotations.panel.in.test.sources=在测试源中
type.annotations.panel.in.scala.dialect.sources=在 Scala 方言源中*
type.annotations.panel.in.scala.dialect.sources.tooltip=*.sbt、*.sc 等

### org/jetbrains/plugins/scala/lang/formatting/settings/TypeAnnotationsPanelBase.java
#Type Annotations panel
type.annotations.panel.title=类型注解
type.annotations.panel.classes=类
type.annotations.panel.annotations=注解
type.annotations.panel.type.patterns=类型模式

### org/jetbrains/plugins/scala/lang/macros/expansion/MacroExpansionLineMarkerProvider.scala
scala.meta.expand=扩展宏

### org/jetbrains/plugins/scala/lang/parser/parsing/CommonUtils.scala
wrong.pattern=错误模式
right.brace.expected=应为 '}'
bad.interpolated.string.injection=内插字符串注入错误
wrong.string.literal=字符串文字错误

### org/jetbrains/plugins/scala/lang/parser/parsing/CompilationUnit.scala
package.qualID.expected=应为包限定标识符
semi.expected=应为 ';' 或换行符
out.of.compilation.unit=超出编译单元

### org/jetbrains/plugins/scala/lang/parser/parsing/Packaging.scala
lbrace.expected='{' 预期
unreachable.error=发现意外错误

### org/jetbrains/plugins/scala/lang/parser/parsing/base/AccessQualifier.scala
rsqbracket.expected=']' 是预期的
identifier.expected=标识符是预期的

### org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportExpr.scala
identifier.or.opening.brace.expected=预期为标识符或左大括号

### org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportSelector.scala
identifier.or.wild.sign.expected=应为标识符或 '_'

### org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportSelectors.scala
rbrace.expected='}' 是预期的
import.selector.expected=应为 Import 选择器

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Annotation.scala
wrong.annotation.expression=错误的注解表达式

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ArgumentExprs.scala
rparenthesis.expected=')' 预期
wrong.expression=错误的表达式

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Ascription.scala
annotation.or.type.expected=应为注解或类型

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Binding.scala
wrong.type=错误类型

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Bindings.scala
wrong.binding=错误参数

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/BlockStat.scala
wrong.declaration.in.block=块不能包含声明

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Enumerator.scala
choose.expected=生成器语句中应有 '<-' 

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Expr1.scala
case.clauses.expected=应为 case 子句
while.expected='do' 语句中应有 while 关键字
enumerators.expected='for' 语句中应有枚举器
condition.expected=应为布尔条件
expected.then=预期为 'then'
expected.do=预期为 'do'
expected.do.or.yield=预期为 'do' 或 'yield'

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/InfixExpr.scala
wrong.type.associativity=错误的关联性。所有运算符应有相同的关联性

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/NameValuePair.scala
assign.expected='\=' 是预期的

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Quoted.scala
type.expected=预期为类型

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ResultExpr.scala
fun.sign.expected='\=>' 预期

### org/jetbrains/plugins/scala/lang/parser/parsing/params/FunTypeParamClause.scala
wrong.parameter=错误参数

### org/jetbrains/plugins/scala/lang/parser/parsing/params/ImplicitParamClause.scala
implicit.params.excepted=隐式参数子句必须至少有一个参数

### org/jetbrains/plugins/scala/lang/parser/parsing/params/ParamClauses.scala
param.clause.expected=应为参数子句

### org/jetbrains/plugins/scala/lang/parser/parsing/params/TypeParam.scala
variance.annotation.not.allowed=此处不允许变量注解
context.bounds.not.allowed=此处不允许上下文边界
view.bounds.not.allowed=此处不允许视图边界

### org/jetbrains/plugins/scala/lang/parser/parsing/params/TypesAsParamsOrParams.scala
expected.more.types=预期更多类型

### org/jetbrains/plugins/scala/lang/parser/parsing/patterns/CaseClause.scala
pattern.expected=应为模式

### org/jetbrains/plugins/scala/lang/parser/parsing/patterns/Guard.scala
wrong.postfix.expression=错误的后缀表达式

### org/jetbrains/plugins/scala/lang/parser/parsing/patterns/Pattern3.scala
simple.pattern.expected=简单模式的起始处非法

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/FunDef.scala
constr.block.expected=应为构造函数块
wrong.constr.expression=错误的构造函数表达式
expected.parameter.clause.for.extension.method=预期扩展方法的参数子句

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/PatDef.scala
expression.expected=表达式预期

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/TypeDef.scala
match.type.expected=应为匹配类型

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/ValDcl.scala
wrong.val.declaration=错误的值声明

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/VarDcl.scala
wrong.var.declaration=错误的变量声明

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/VarDef.scala
type.declaration.expected=应为类型声明

### org/jetbrains/plugins/scala/lang/parser/parsing/top/Parents.scala
wrong.simple.type=错误的简单类型

### org/jetbrains/plugins/scala/lang/parser/parsing/top/Qual_Id.scala
wrong.qual.identifier=错误的限定标识符

### org/jetbrains/plugins/scala/lang/parser/parsing/top/TmplDef.scala
wrong.case.modifier=错误的 case 修饰符。将它用于类或对象

### org/jetbrains/plugins/scala/lang/parser/parsing/top/params/ClassParam.scala
colon.expected='\:' 是预期的
parameter.type.expected=应为参数类型
val.var.expected=应为 val 或 var 关键字

### org/jetbrains/plugins/scala/lang/parser/parsing/top/template/TemplateBody.scala
def.dcl.expected=应为定义或声明
expected.indented.template.body=预期缩进模板主体

### org/jetbrains/plugins/scala/lang/parser/parsing/types/ExistentialClause.scala
existential.block.expected=应为存在子句

### org/jetbrains/plugins/scala/lang/parser/parsing/types/ExistentialDclSeq.scala
wrong.existential.declaration=存在声明错误。它必须是类型声明或值声明

### org/jetbrains/plugins/scala/lang/parser/parsing/types/InfixType.scala
compound.type.expected=应为复合类型

### org/jetbrains/plugins/scala/lang/parser/parsing/types/MatchTypeSuffix.scala
match.type.cases.expected=应为匹配类型 case 子句

### org/jetbrains/plugins/scala/lang/parser/parsing/types/PolyFunOrTypeLambda.scala
type.lambda.expected='\=>>' 预期

### org/jetbrains/plugins/scala/lang/parser/parsing/types/SimpleType.scala
identifier.expected.comma.found=应为标识符，但找到的是 ','

### org/jetbrains/plugins/scala/lang/parser/parsing/types/StableId.scala
dot.expected='.' 预期
dot.or.cq.expected=应为 '.' 或类限定符

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/AttrValue.scala
xml.attribute.end.expected=应为 xml 特性值结束分隔符

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/Attribute.scala
xml.eq.expected='\=' 是预期的
xml.attribute.value.expected=应为属性值

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/CDSect.scala
xml.cdata.end.expected=应为 Xml CData 结束

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/Comment.scala
xml.comment.end.expected=应为 xml 注释结束 ('-->')
xml.wrong.character=xml 注释中的字符错误

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/ETag.scala
xml.tag.end.expected=应为 xml 标签结束
xml.name.expected=应为 xml 标签名称

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/Element.scala
xml.end.tag.expected=应为 xml 结束标签 ('</' name '>')

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/PI.scala
xml.PI.end.expected=应为 xml 处理指令结束

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/ScalaExpr.scala
xml.scala.injection.end.expected=应为 xml 中的 Scala 注入结束 ('}')
xml.scala.expression.exected=xml 注入中应有 Scala 表达式

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/pattern/ScalaPatterns.scala
xml.scala.patterns.exected=xml 注入中应有 Scala 模式

### org/jetbrains/plugins/scala/lang/psi/api/base/types/ScTypeElement.scala
recursive.type.of.type.element=类型元素的递归类型
cannot.desugarize.typename=无法对 {0} 脱糖

### org/jetbrains/plugins/scala/lang/psi/api/expr/ScBlock.scala
cannot.find.partialfunction.class=找不到 PartialFunction 类
cannot.find.throwable.class=找不到 Throwable 类
cannot.infer.type.without.expected.type=没有预期的类型就无法推断类型
cannot.infer.type.without.function.expected.type=如果没有预期的 scala.FunctionN 或 scala.PartialFunction 类型就无法推断类型

### org/jetbrains/plugins/scala/lang/psi/api/expr/ScExpression.scala
no.type.inferred=没有为表达式 ''{0}'' 推断出类型

### org/jetbrains/plugins/scala/lang/psi/api/statements/ScTypeAliasDefinition.scala
no.alias.type=无类型别名

### org/jetbrains/plugins/scala/lang/psi/compiled/SigFileViewProviderFactory.scala
file.type.scala.outlines=Scala 概述
could.not.decompile.file.comment=//无法反编译 {0}

### org/jetbrains/plugins/scala/lang/psi/impl/base/ScConstructorInvocationImpl.scala
can.t.resolve.type=无法解析类型
java.constructors.only.have.one.parameter.section=Java 构造函数 只有一个参数部分
has.no.reference=无引用

### org/jetbrains/plugins/scala/lang/psi/impl/base/literals/ScLiteralImplBase.scala
wrong.psi.for.literal.type="用于获取文字类型的元素错误"

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScConstructorPatternImpl.scala
cannot.resolve.unknown.symbol=不能解决符号

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScNamingPatternImpl.scala
no.expected.type.for.wildcard.naming=通配符命名没有预期的类型

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScPatternImpl.scala
cannot.type.pattern=无法键入模式

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScReferencePatternImpl.scala
cannot.define.expected.type=无法定义预期类型

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScTypedPatternImpl.scala
no.type.element.for.type.pattern=类型模式没有类型元素
no.type.pattern=无类型模式

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScWildcardPatternImpl.scala
cannot.determine.expected.type=无法确定预期类型

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScSimpleTypeElementImpl.scala
cannot.find.template.for.this.reference=找不到 this 引用的模板
cannot.find.enclosing.container=找不到封闭的容器
cannot.resolve.ref=无法解析引用
unknown.macro.in.type.position=类型位置中的宏未知
recursive.non.value.type.of.type.element=类型元素的递归非值类型

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScTypeProjectionImpl.scala
cannot.resolve.reference=无法解析引用

### org/jetbrains/plugins/scala/lang/psi/impl/expr/MethodInvocationImpl.scala
suitable.method.not.found=找不到适合的方法

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScForImpl.scala
cannot.create.expression=无法创建表达式

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScGenericCallImpl.scala
not.a.polymorphic.lambda=非多态 lambda。

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScIfImpl.scala
nothing.to.type=没有要输入的内容

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScParenthesisedExprImpl.scala
no.expression.in.parentheseses=括号中无表达式

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScReferenceExpressionImpl.scala
no.declared.type.found=找不到声明的类型
case.class.has.no.primary.constructor=case 类没有主构造函数
cannot.resolve.expression=无法解析表达式

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScSuperReferenceImpl.scala
cannot.infer.type.of.super.expression=无法推断 `super' 表达式的类型

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScThisReferenceImpl.scala
cannot.infer.type=无法推断类型
no.clazz.type.found=找不到类类型

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScUnderscoreSectionImpl.scala
typed.statement.is.not.complete.for.underscore.section=下划线部分的带类型语句不完整
failed.to.found.corresponging.underscore.section=找不到对应的下划线部分
could.not.infer.type.of.underscore.section=无法推断下划线部分的类型
no.type.inferred.for.unknown.expression=没有为表达式推断出类型

### org/jetbrains/plugins/scala/lang/psi/impl/statements/ScFunctionImpl.scala
both.stub.and.name.identifier.node.are.null={0} 的存根和名称标识符节点均为空\n\
{1}
no.defined.return.type=未定义返回类型

### org/jetbrains/plugins/scala/lang/psi/impl/statements/ScValueDeclarationImpl.scala
no.type.element.found=''{0}'' 中找不到类型元素

### org/jetbrains/plugins/scala/lang/psi/impl/statements/ScVariableDefinitionImpl.scala
cannot.infer.type.without.an.expression=没有表达式无法推断类型

### org/jetbrains/plugins/scala/lang/psi/impl/statements/params/ScParameterImpl.scala
wrong.stub.problem=存根错误
wrong.type.element=类型元素错误

### org/jetbrains/plugins/scala/lang/psi/impl/toplevel/typedef/ScTypeDefinitionImpl.scala
cannot.resolve.parent.class=无法解析父类

### org/jetbrains/plugins/scala/lang/psi/light/DummyLightTypeParam.scala
no.containing.file=未包含文件

### org/jetbrains/plugins/scala/lang/psi/types/Compatibility.scala
found.chekced.named.parameter=找到了不应检查的命名参数
assignment.missing.right.side=右侧缺少赋值
cannot.handle.compatibility.for=无法处理 {0} 的兼容性

### org/jetbrains/plugins/scala/lang/psi/types/api/Variance.scala
variance.contravariant=逆变
variance.covariant=协变
variance.invariant=不变
variance.bivariant=双变

### org/jetbrains/plugins/scala/lang/psi/types/recursiveUpdate/RecursiveUpdateException.scala
type.mismatch.after.update.method=更新方法后面的类型不匹配

### org/jetbrains/plugins/scala/lang/psi/types/result/package.scala
no.element.found=找不到元素

### org/jetbrains/plugins/scala/lang/rearranger/RearrangerUtils.scala
#Rearranger panel
rearranger.panel.keep.scala.style.getters.and.setters.together=保持 scala-style getter 和 setter 在一起
rearranger.panel.keep.java.style.getters.and.setters.together=保持 java-style getter 和 setter 在一起
rearranger.panel.split.into.unarrangeable.blocks.by.expressions=通过表达式拆分为不可排列的块
rearranger.panel.split.into.unarrangeable.blocks.by.implicits=通过隐式拆分为不可排列的块

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ConflictsUtil.scala
by.name.parameters.cannot.be.used=此方法有 Java 重写器，无法使用值类的传名参数。
method.is.overridden.in.composite.kind.in.class=方法在 {1} 的复合 {0} 中被覆盖。不支持将其转换为函数定义。
method.is.overridden.by.class.parameter.of.class=方法被 {0} 的传类参数覆盖。不支持将其转换为函数定义。
updating.of.usages.of.generated.unapply=不支持更新生成的 `unapply` 方法的用法

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/DefaultValuesUsagePanel.scala
default.values=默认值\:
add.to.definition=添加到定义
modify.method.calls=修改方法调用

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaChangeSignatureDialog.scala
change.signature.vararg.should.be.last.in.clause=Vararg 参数应当是参数子句中的最后一个参数
change.signature.parameters.same.name.{0}=参数有相同的名称\: {0}
change.signature.add.parameter.clause=添加参数子句
change.signature.remove.parameter.clause=移除参数子句
default.value.is.missing.default.arguments=缺少默认值。默认参数将包含空值，而不是新的参数值。
default.value.is.missing.method.calls=缺少默认值。方法调用将包含空值，而不是新的参数值。

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaChangeSignatureHandler.scala
error.wrong.caret.position.method.name=脱字符号应置于要重构的方法的名称处。
change.signature.not.supported.implicit.functions=隐式函数不支持更改签名
change.signature.not.supported.implicit.parameters=具有隐式参数的函数不支持更改签名
change.signature.not.supported.extractors=提取器不支持更改签名

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaParameterTableModelItem.scala
change.signature.specify.type.for.parameter=指定参数 ''{0}'' 的类型 
parameter.could.not.be.repeated.and.by.name=参数不能同时为重复参数和传名参数
could.not.understand.type=无法理解类型 {0}

### org/jetbrains/plugins/scala/lang/refactoring/extractMethod/ScalaExtractMethodDialog.java
extract.method.title=提取方法

### org/jetbrains/plugins/scala/lang/refactoring/extractMethod/ScalaExtractMethodHandler.scala
cannot.extract.used.function.definition=不支持重构\: 选定范围内的函数定义在所选片段之外使用
extract.method.cannot.find.possible.scope=找不到所提取方法的可能范围
extract.local.method=提取 {0} 中的局部方法
extract.method.to.object.name=提取方法到对象 {0}
extract.method.to.class.name=提取方法到类 {0}
extract.method.to.trait.name=提取方法到特征 {0}
extract.method.to.anonymous.class=提取方法到匿名类
try.block=try 块
constructor=构造函数
case.clause=case 子句
if.block=if 块
def.name=def {0}
extract.local.method.in.else.block=提取 else 块中的局部方法
val.name=val {0}
var.name=var {0}
for.statement=for语句
while.statement=while 语句
do.statement=do语句
function.expression=函数表达式
code.block=代码块
extract.file.method=提取文件方法
unknown.extraction=未知提取
choose.level.for.extract.method=选择提取方法的级别

### org/jetbrains/plugins/scala/lang/refactoring/extractMethod/duplicates/DuplicatesUtil.scala
process.duplicates=处理重复项

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ExtractSuperUtil.scala
choose.class=选择类
cannot.find.package.with.name=找不到具有此名称的包\: {0}
cannot.find.directory.for.package=找不到包的目录\: {0}
class.already.exists.in.package=包 {1} 中已存在名称为 {0} 的类

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitAction.scala
extract.trait.action.text=提取特征...
extract.trait.action.description=从选定的类提取特征

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitDialog.java
extract.trait.title=提取特征
extract.trait.top.label.text=从中提取特征\:
extract.trait.name=特征名称\:
extract.trait.package.label=新特征的包\:
members.to.extract=要提取的成员
extract.abstracts=提取 abstract 项

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitHandler.scala
private.member.cannot.be.used.in.extracted.member=private 成员 {0} 无法在提取的成员 {1} 中使用
member.of.anonymous.class.cannot.be.used.in.extracted.member=匿名类的成员 {0} 无法在提取的成员 {1} 中使用
super.reference.used.in.extracted.member=提取的成员 {0} 引用了 super，但提取的特征没有基类
type.parameters.for.self.type.not.supported=提取的特征将以 {0} 作为自类型，但不支持识别其类型参数

### org/jetbrains/plugins/scala/lang/refactoring/inline/ScalaInlineHandler.scala
cannot.inline.different.files=成员在另一个文件中声明。不支持内联。
cannot.inline.used.outside.class=成员在包含类之外使用。不支持内联。
cannot.inline.stable.reference=该值用于稳定的引用，不能内联
cannot.inline.never.used=从未使用变量。
cannot.inline.not.simple.pattern=仅简单的模式定义支持内联
cannot.inline.recursive.function=递归函数不支持内联
cannot.inline.function.implicit.parameters=具有隐式参数的函数不支持内联
cannot.inline.function.multiple.clauses=具有多个参数子句的函数不支持内联
cannot.inline.function.varargs=具有 varargs 参数的函数不支持内联
cannot.inline.implicit.element=隐式元素不支持内联
cannot.inline.special.function=特殊函数不支持内联
cannot.inline.generic.function=泛型函数不支持内联
cannot.inline.notsimple.typealias=仅简单的类型别名支持内联
cannot.inline.value.functional.type=不支持值与函数类型内联
cannot.inline.function.functional.parameters=不支持函数与函数参数内联
cannot.inline.parameter=参数不支持内联
cannot.inline.not.method.call=仅常规方法调用支持内联

### org/jetbrains/plugins/scala/lang/refactoring/introduceField/ScalaIntroduceFieldDialog.java
introduce.field.title=提取常量

### org/jetbrains/plugins/scala/lang/refactoring/introduceField/ScalaIntroduceFieldFromExpressionHandler.scala
cannot.refactor.not.expression=所选字符串无法提取为表达式
cannot.create.field.from.this.expression=无法根据此表达式创建字段
cannot.find.place.for.the.new.field=找不到新字段的位置
choose.class.for.introduce.field=选择用于引入字段的类

### org/jetbrains/plugins/scala/lang/refactoring/introduceParameter/ScalaIntroduceParameterDialog.scala
parameter.label.name=名称\:
parameter.label.type=按类型分组\:
parameter.label.default.value=默认值\:
replace.all.occurrences=替换所有匹配项

### org/jetbrains/plugins/scala/lang/refactoring/introduceParameter/ScalaIntroduceParameterHandler.scala
cannot.refactor.no.function=找不到用于引入参数的函数
introduce.parameter.title=引入参数
refactoring.is.not.supported.contains.return=不支持重构\: 所选部分包含 return 语句
choose.function.for.refactoring=选择 {0} 的函数

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/IntroduceExpressions.scala
introduce.variable.title=引入值/变量

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/IntroduceTypeAlias.scala
cannot.refactor.not.valid.type=应选择类型元素
cannot.refactor.scope.not.found=找不到适合的类或包
choose.scope.for=选择 {0} 的范围
introduce.type.alias.title=引入类型别名

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaInplaceTypeAliasIntroducer.scala
command.introduce.type.alias=引入类型别名
press.hotkey.to.show.more.options=按 ctrl + alt + v 显示带有更多选项的对话框

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaInplaceVariableIntroducer.scala
introduce.variable.declare.as.var=&变量
introduce.variable.specify.type.explicitly=指定类型
introduce.variable.identifier.is.not.valid=标识符无效

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaIntroduceVariableHandler.scala
cannot.refactor.not.expression.nor.type=应选择表达式或类型元素
press.escape.to.remove.the.highlighting=按 Esc 移除高亮显示

### org/jetbrains/plugins/scala/lang/refactoring/memberPullUp/ScalaPullUpProcessor.scala
pull.up.members.from=向上拉取其中的成员
class.to.pull.up.members.to.class=用于将成员向上拉取到 {0} 的类

### org/jetbrains/plugins/scala/lang/refactoring/move/ScalaMoveClassesOrPackagesHandler.scala
move.to.inner.is.not.supported.title=不支持重构
move.to.inner.is.not.supported=Scala 不支持将类移动到内部
move.with.companion=与伴生对象一起移动

### org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMemberHandler.scala
target.0.already.contains.definition.of.1=<b>{0}</b> 已包含成员 <b>{1}</b> 的定义

### org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMembersDialog.scala
move.members.object.name.or.qualified.name.expected=应为 Scala 对象的名称或限定名称
move.members.cannot.find.object=找不到具有此名称的对象
move.members.source.title=移动此对象中的成员\:
move.members.target.title=移至此对象\:

### org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMembersHandler.scala
move.members.supported.only.stable.objects=仅稳定的对象成员支持移动重构
move.members.not.supported.implicits=隐式定义不支持移动重构
move.members.not.supported.overridden=重写的定义不支持移动重构
move.members=移动成员

### org/jetbrains/plugins/scala/lang/refactoring/rename/RenameScalaClassProcessor.scala
rename.companion.module=重命名伴生 {0}

### org/jetbrains/plugins/scala/lang/refactoring/rename/RenameScalaMethodProcessor.scala
rename.getters.and.setters.title=函数有同名的 getter 或 setter。是否也对它们进行重命名?

### org/jetbrains/plugins/scala/lang/refactoring/rename/RenameSuperMembersUtil.scala
rename.all.base.members=重命名所有基本成员
rename.base.member=重命名基本成员
rename.only.current.member=仅重命名当前成员
rename.has.multiple.base.members={0} 有多个基本成员
rename.only.in=仅在 {0} {1} 中重命名
name.implements.member.of.qualname={0} 实现 {1} 的成员
name.overrides.member.of.qualname={0} 重写 {1} 的成员

### org/jetbrains/plugins/scala/lang/refactoring/rename/inplace/ScalaInplaceRenameHandler.scala
rename.special.method.title=此方法无法重命名
rename.special.method.rename.class=重命名包含的 {0}
rename.cancel=取消
rename.aliased.title=不支持重命名导入别名
rename.aliased.rename.actual=重命名实际元素

### org/jetbrains/plugins/scala/lang/refactoring/rename/inplace/ScalaMemberInplaceRenamer.scala
rename=重命名
could.not.perform.inplace.rename=无法执行就地重命名\:\n\
要重命名的元素\: {0} {1}\n\
替代\: {2}\n\
围绕脱字符号\: {3}

### org/jetbrains/plugins/scala/lang/refactoring/util/ScalaRefactoringUtil.scala
only.for.scala=这仅适用于 scala 文件
cannot.refactor.constr.expression=选定的块不应显示为构造函数表达式
cannot.refactor.under.generic.call=泛型调用中不支持重构
cannot.refactor.arg.in.self.invocation.of.constructor=构造函数主体中的自调用参数不支持重构
cannot.refactor.named.arg=命名参数不支持重构
cannot.refactor.literal.pattern=文字模式不支持重构
cannot.refactor.class.parameter.top.level=顶层类的参数不支持重构
cannot.refactor.interpolated.string.prefix=内插字符串前缀不支持重构
cannot.refactor.self.invocation=辅助构造函数中的构造函数调用不支持重构
refactoring.is.not.supported.in.guard=守卫中不支持重构，它很可能破坏代码结构
file.is.not.writable=文件不具备写入权限
cannot.extract.empty.message=重构选择错误。应为完整表达式或语句的数量。
cannot.extract.self.invocation=无法提取自我调用。
cannot.extract.used.type.definition=不支持重构\: 选定范围内的类型定义在所选片段之外使用
choose.expression.for=选择 {0} 的表达式
choose.type.element.for=选择 {0} 的类型元素

### org/jetbrains/plugins/scala/lang/refactoring/util/ScalaTypeValidator.scala
introduced.typeAlias.will.conflict.with.type.name=引入的类型别名与类型名称冲突\: {0}
introduced.typeAlias.will.conflict.with.class.name=引入的类型别名与类名称冲突\: {0}

### org/jetbrains/plugins/scala/lang/refactoring/util/ScalaVariableValidator.scala
introduced.variable.will.conflict.with.local=引入的变量与局部变量冲突(或可能被其隐藏)\: {0}
introduced.variable.will.conflict.with.parameter=引入的变量与参数冲突(或可能被其隐藏)\: {0}
introduced.variable.will.conflict.with.field=引入的变量将与没有参数的字段或方法冲突(或可能被其隐藏)\: {0}
introduced.variable.will.conflict.with.class.parameter=引入的变量与类参数冲突(或可能被其隐藏)\: {0}

### org/jetbrains/plugins/scala/lang/resolve/processor/MethodResolveProcessor.scala
not.all.type.parameters.are.defined=未定义所有类型参数。typeargs\=[{0}] 和 classTypeParams\=[{1}]

### org/jetbrains/plugins/scala/lang/scaladoc/generate/ScaladocAction.scala
generate.scaladoc=生成 Scaladoc
generate.scaladoc.action.text=生成 Scaladoc
generate.scaladoc.action.description=生成 scaladoc

### org/jetbrains/plugins/scala/lang/scaladoc/parser/parsing/MyScaladocParsing.scala
scaladoc.parsing.open.syntax.element=打开语法元素
scaladoc.parsing.closing.link.tag.before.opening=结束链接标签在起始链接标签前面
scaladoc.parsing.closing.code.tag.before.opening=结束代码标签在起始代码标签前面
scaladoc.parsing.error.bad.token=错误\: 不良令牌\: {0}
scaladoc.parsing.header.closed.by.opening.new.one=标头由起始新标头结束
scaladoc.parsing.wiki.syntax.element.closed.by.message=Wiki 语法元素由 {0} 结束
scaladoc.parsing.wiki.syntax.closed.by.new.paragraph=新段落
scaladoc.parsing.wiki.syntax.closed.by.tag=标签
scaladoc.parsing.wiki.syntax.closed.by.inner.code.tag=内部代码标签
scaladoc.parsing.closing.link.element.before.opening.one=结束链接元素在起始链接元素前面
scaladoc.parsing.cross.tags=交叉标签
scaladoc.parsing.no.closing.element=无结束元素
scaladoc.parsing.unclosed.code.tag=未结束的代码标签
scaladoc.parsing.unexpected.end.of.tag.body=标签主体异常结束
scaladoc.parsing.inline.tag=内联标签
scaladoc.parsing.missing.tag.param=缺少标签参数
scaladoc.parsing.unknown.tag=未知标记\: {0}

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithBoldSurrounder.scala
bold.surrounder.template.description=粗体\: '''' ''''

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithItalicSurrounder.scala
italic.surrounder.template.description=斜体\: ' '

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithMonospaceSurrounder.scala
monospace.surrounder.template.description=等宽\: ` `

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithSubscriptSurrounder.scala
subscript.surrounder.template.description=下标\: ,, ,,

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithSuperscriptSurrounder.scala
superscript.surrounder.template.description=上标\: ^ ^

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithUnderlinedSurrounder.scala
underline.surrounder.template.description=下划线\: __ __

### org/jetbrains/plugins/scala/lang/transformation/DesugarCodeAction.scala
desugar.scala.code.in.scope=Scala 代码 ({0}) 脱糖
scope.selection=选择区域
scope.file=文件
desugar.scala.code.action.text=Scala 代码脱糖...
desugar.scala.code.action.description=Scala 代码脱糖(选定部分/整个文件)

### org/jetbrains/plugins/scala/lang/transformation/SelectionDialog.scala
column.enabled=启用
column.transformation=转换

### org/jetbrains/plugins/scala/overrideImplement/ScalaMemberChooser.scala
specify.return.type.explicitly=指定类型(&T)
add.override.modifier=插入 "override"(&O)
copy.scaladoc=复制 ScalaDoc(&S)

### org/jetbrains/plugins/scala/overrideImplement/ScalaOIUtil.scala
select.method.override=选择要重写的成员
select.method.implement=选择要实现的方法
action.implement.method=实现方法
action.override.method=重写方法

### org/jetbrains/plugins/scala/project/CompileOrderDescriptions.scala
compile.order.mixed=混合
compile.order.java.then.scala=先 Java，后 Scala
compile.order.scala.then.java=先 Scala，后 Java

### org/jetbrains/plugins/scala/project/DebuggingInfoLevelDescription.scala
debug.info.level.none=无
debug.info.level.source=源文件特性
debug.info.level.source.and.line.number=源和行号信息
debug.info.level.source.line.number.and.local.variable=源、行号和局部变量信息
debug.info.level.complete.no.tail.call.optimization=完整，无尾调用优化

### org/jetbrains/plugins/scala/project/Versions.scala
title.fetching.available.this.versions=获取可用的 {0} 版本

### org/jetbrains/plugins/scala/project/converter/ScalaProjectConverterProvider.scala
scala.facets.will.be.converted.to.scala.sdks=Scala facet 将转换为 Scala SDK

### org/jetbrains/plugins/scala/project/notification/AbstractNotificationProvider.scala
setup.kittitle=设置 {0}

### org/jetbrains/plugins/scala/project/notification/SetupJdkNotificationProvider.scala
project.jdk.is.not.defined=未定义项目 JDK

### org/jetbrains/plugins/scala/project/notification/SetupScalaSdkNotificationProvider.scala
sdk.title=Scala SDK

### org/jetbrains/plugins/scala/project/notification/source/AttachSourcesUtil.java
module.libraries.attach.sources.immediately.button=附加源...
multiple.libraries.contain.file="多个库包含文件。<br>选择要附加源的库。"

### org/jetbrains/plugins/scala/project/notification/source/ScalaAttachSourcesNotificationProvider.scala
library.sources.not.found=找不到源
library.sources.not.attached=未附加源
cannot.find.library.for=找不到 {0} 的库
cannot.find.library.error.title=错误

### org/jetbrains/plugins/scala/project/sdkdetect/ScalaSdkProvider.scala
sdk.scan.title=定位 Scala SDK\: {0}

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerConfigurable.scala
scala.compiler=Scala 编译器

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerConfigurationPanel.form
#Scala compiler settings UI
incrementality.type=递增类型(&I)\:

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerProfilesPanel.scala
scala.compiler.profiles.panel.profile.name=配置文件名称
scala.compiler.profiles.panel.move.to=移动到
scala.compiler.profiles.panel.create.new.profile=创建新的配置文件
scala.compiler.profiles.panel.profile.should.not.be.empty=配置文件名称不应为空
scala.compiler.profiles.panel.profile.already.exists=配置文件 {0} 已存在

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerSettingsPanel.form
unchecked.warnings=未检查的警告(&U)
unchecked.warnings.tooltip=生成的代码取决于假设时，则启用其他警告。
deprecation.warnings=弃用警告(&D)
deprecation.warnings.tooltip=发出弃用 API 用法的警告和位置。
feature.dynamics=动态(&D)
feature.existential.types=存在类型(&E)
explain.type.errors=解释类型错误(&E)
explain.type.errors.tooltip=更详细地解释类型错误
feature.warnings=功能警告(&F)
feature.warnings.tooltip=发出语言功能警告。
feature.higher.kinded.types=较高种类的类型(&H)
feature.implicit.conversions=隐式转换(&I)
feature.macros=&宏
optimise.bytecode=优化字节码(谨慎使用*)(&O)
optimise.bytecode.tooltip=通过对程序进行优化来生成更快的字节码。可能会触发各种编译问题。慎用。
feature.postfix.notation=后缀运算符表示法(&P)
feature.reflective.calls=反射调用(&R)
additional.compiler.options=其他编译器选项(&O)\:
compile.order=编译顺序(&O)\:
compiler.plugins=编译器插件
debugging.info.level=调试信息级别(&L)\:
feature.experimental.features=实验性功能(&X)
enable.continuations=启用继续(&C)
enable.specialization=启用专门化(&S)
enable.specialization.tooltip=遵循 @specialize 注解
enable.warnings=启用警告(&W)
enable.warnings.tooltip=生成警告
features=功能
options=选项

### org/jetbrains/plugins/scala/project/template/ScalaFilesChooserDescriptor.scala
title.scala.sdk.files=Scala SDK 文件
choose.either.a.scala.sdk.directory.or.scala.jar.files=选择 Scala SDK 目录或 Scala jar 文件(允许\: 二进制、源、文档)

### org/jetbrains/plugins/scala/project/template/ScalaProjectTemplate.scala
idea.based.scala.project=基于 IDEA 的 Scala 项目
module.with.a.scala.sdk=包含 Scala SDK 的模块

### org/jetbrains/plugins/scala/project/template/SdkSelectionDialog.java
sdk.create.select.files=选择适合新 Scala SDK 的 JAR
sdk.create.missing.version=Ivy 存储库中没有 Scala 版本 {0}

### org/jetbrains/plugins/scala/project/template/SdkTableModel.scala
sdk.table.model.location=位置
sdk.table.model.version=版本
sdk.table.model.sources=源
sdk.table.model.docs=文档

### org/jetbrains/plugins/scala/project/template/VersionDialog.scala
title.download=下载
title.error.downloading.scala.libraries=下载 Scala 库出错
no.versions.available.for.download=没有可供下载的版本
downloading.scala.version=正在下载 Scala {0}
error.downloading.scala.version=下载 Scala {0} 出错

### org/jetbrains/plugins/scala/settings/ScalaEditorSmartKeysConfigurable.scala
insert.pair.multiline.quotes=为多行字符串插入双引号
wrap.single.expression.body=键入 '{' 后，用右大括号包装单个表达式主体
upgrade.to.interpolated=Upgrade simple string into interpolated after typing '${'
insert.block.braces.automatically.based.on.indentation=Add braces automatically
remove.block.braces.automatically.based.on.indentation=Remove braces automatically
control.curly.braces.based.on.line.indents=Control curly braces based on line indentation\:

### org/jetbrains/plugins/scala/settings/ScalaProjectSettingsPanel.form
scala.project.settings.form.tabs.editor=编辑器
scala.project.settings.form.tabs.project.view=项目视图
scala.project.settings.form.tabs.performance=性能问题
scala.project.settings.form.tabs.worksheet=工作表
scala.project.settings.form.tabs.base.packages=基本包
scala.project.settings.form.tabs.misc=杂项
scala.project.settings.form.tabs.updates=更新
scala.project.settings.form.tabs.extensions=扩展
scala.project.settings.form.collection.type.highlighting.option=集合类型高亮显示\:
scala.project.settings.form.sbt.index.ivy2.mode=本地 Ivy2 缓存索引模式
scala.project.settings.form.sbt.index.ivy2.mode.hint=禁用 - 完全无索引\n\
元数据 - 仅索引库名称和版本，用于 SBT 文件依赖项补全\n\
类 - 也索引缓存中的类名称，由“添加 sbt 依赖项”快速修复程序使用
scala.project.settings.form.scala.meta.settings.annot212=执行 scala.meta 程序
scala.project.settings.form.scala.meta.settings.annot212.tooltip=由于二进制不兼容，2.12 模块中的注解必须使用 \\ 进行基于字符串的缓慢序列化和重新解析。这可能会严重影响整体性能。
scala.project.settings.form.scala.meta.settings.modeOptions.tooltip=启用 - 在类型推断期间执行所有元程序\n\
禁用 - 在类型推断期间跳过 \\ 元程序\n\
手动 - 仅在手动扩展时运行元程序
scala.project.settings.form.scala.meta.settings.trimBodies.caption=修剪方法主体由 scala.meta 扩展
scala.project.settings.form.scala.meta.settings.trimBodies.tooltip=依赖生成的方法的显式返回类型(主体替换为 ???)。通过跳过方法主体类型检查可加快类型推断。
scala.project.settings.form.show.type.info.on.mouse.hover=经过此时间后在鼠标悬停时显示类型信息 (ms)
scala.project.settings.form.highlighting=高亮显示
scala.project.settings.form.highlight.implicit.conversions=高亮显示隐式转换
scala.project.settings.form.show.hints.if.no.implicit.arguments.found=找不到隐式参数时显示提示
scala.project.settings.form.show.hints.if.ambiguous.implicit.arguments.found=找到模糊的隐式参数时显示提示
scala.project.settings.form.highlight.arguments.to.by.name.parameters=高亮显示传名形参的实参
scala.project.settings.form.include.block.expressions=包含块表达式
scala.project.settings.form.include.literals=包含文字
scala.project.settings.form.custom.scalatest.keywords.highlighting=自定义 scalaTest 关键字高亮显示
scala.project.settings.form.autocomplete=自动补全
scala.project.settings.form.ahead.of.time.completion=提前补全(参数和变量名称)
scala.project.settings.form.use.scala.classes.priority.over.java=使用 Scala 类的优先级高于 Java 类
scala.project.settings.form.code.conversion=代码转换
scala.project.settings.form.convert.java.code.to.scala.on.copy.paste=复制粘贴时将 Java 代码转换为 Scala
scala.project.settings.form.automatically.convert.to.scala.code.without.dialog=粘贴时不显示对话框，并自动转换为 Scala 代码
scala.project.settings.form.add.override.keyword.to.method.implementation=向方法实现中添加 override 关键字
scala.project.settings.form.group.package.object.with.package=使用包对包对象分组(&G)
scala.project.settings.form.highlight.nodes.with.errors=高亮显示有错误的节点(&H)
scala.project.settings.form.implicit.parameters.search.depth=隐式参数搜索深度(若为无，则搜索深度为 -1)\:
scala.project.settings.form.search.all.symbols=搜索所有符号(包括局部符号)
scala.project.settings.form.resolve.to.all.classes.even.in.wrong.directories=解析所有类，包括错误目录中的类(这可能导致性能问题)
scala.project.settings.form.disable.parsing.of.documentation.comments=禁用文档注释解析。对于极大的文件，这可以提高编辑器性能。 (SCL-2900)
scala.project.settings.form.disable.language.injection.in.scala.files=禁用 Scala 文件中的语言注入(注入的语言可能会对自动弹出窗口补全冻结键入）
scala.project.settings.form.dont.cache.compound.types=不缓存复合类型(在 GC 中出现大停顿的情况下使用)
scala.project.settings.form.treat.sc.files.as=将 .sc 文件作为此种文件处理\:
scala.project.settings.form.output.cutoff.limit=输出截止限制，行\:
scala.project.settings.form.run.worksheet.in.the.compiler.process=在编译器过程中运行工作表(仅限纯模式)
scala.project.settings.form.use.eclipse.compatibility.mode=使用“Eclipse 兼容”模式
scala.project.settings.form.treat.scala.scratch.files.as.worksheet.files=将 Scala 临时文件视为工作表文件
scala.project.settings.form.collapse.long.output.by.default=默认折叠长输出
scala.project.settings.form.delay.before.auto.run=自动运行前延迟
scala.project.settings.form.scalatest.default.super.class=ScalaTest 默认超类\:
scala.project.settings.form.trailing.commas=尾随逗号\:
scala.project.settings.form.plugin.update.channel=更新通道\:
scala.project.settings.form.check.for.updates=立即检查
scala.project.settings.form.info=您可以始终选择“文档版本”或“抢先体验计划”以转换为更稳定的内部版本。

### org/jetbrains/plugins/scala/settings/ScalaProjectSettingsPanel.java
scala.collection.highlighting.type.none=无
scala.collection.highlighting.type.only.non.qualified=仅非限定
scala.collection.highlighting.type.all=所有
scala.plugin.chanel.nightly=每日构建版
scala.plugin.chanel.eap=抢先体验计划
scala.plugin.chanel.release=稳定版本
scala.meta.mode.enabled=开启
scala.meta.mode.disabled=已禁用
scala.meta.mode.manual=手动
ivy2.indexing.mode.disabled=已禁用
ivy2.indexing.mode.metadata=元数据
ivy2.indexing.mode.classes=类
trailing.commas.mode.enabled=开启
trailing.commas.mode.disabled=已禁用
trailing.commas.mode.auto=自动
script.file.mode.always.worksheet=始终选择工作表
script.file.mode.ammonite.in.test.sources.otherwise.worksheet=测试源中的 Ammonite，否则为工作表
script.file.mode.always.ammonite=始终选择 Ammonite

### org/jetbrains/plugins/scala/testDiscovery/actions/ScalaShowAffectedTestsAction.java
show.affected.tests.action.text=显示受影响的测试 (Scala)
show.affected.tests.action.description=显示受影响的测试 (Scala)

### org/jetbrains/plugins/scala/testingSupport/test/AbstractTestRunConfiguration.scala
test.run.config.module.is.not.specified=未指定模块
test.run.config.multiple.suite.traits.detected=检测到多个套件特征\: {0}
test.framework.is.not.specified=未指定 {0}

### org/jetbrains/plugins/scala/testingSupport/test/MyInheritorChooser.scala
test.config.choose.executable.classes.to.run.test=选择用于运行 {0} 的可执行类

### org/jetbrains/plugins/scala/testingSupport/test/scalatest/ScalaTestConfigurationProducer.scala
test.in.scope.scalatest.presentable.text=''{0}'' 中的 ScalaTest

### org/jetbrains/plugins/scala/testingSupport/test/scalatest/ScalaTestConfigurationType.scala
scalatest.config.display.name=ScalaTest
scalatest.config.description=ScalaTest 测试框架运行配置

### org/jetbrains/plugins/scala/testingSupport/test/specs2/Specs2ConfigurationProducer.scala
test.in.scope.specs2.presentable.text=''{0}'' 中的 Specs2

### org/jetbrains/plugins/scala/testingSupport/test/specs2/Specs2ConfigurationType.scala
specs2.config.display.name=Specs2
specs2.config.description=Specs2 测试框架运行配置

### org/jetbrains/plugins/scala/testingSupport/test/structureView/TestNodeProvider.scala
test.node.provider.show.scala.tests=显示 scala 测试

### org/jetbrains/plugins/scala/testingSupport/test/testdata/AllInPackageTestData.scala
test.run.config.test.package.not.found=无法找到测试包\: {0}
test.config.package.does.not.exist=包不存在
test.config.can.nott.run.while.indexing.no.class.names.memorized.from.previous.iterations=索引时无法运行\: 以前的迭代中没有记住类名。
test.config.did.not.find.suite.classes.in.package=在包 {0} 中找不到套件类

### org/jetbrains/plugins/scala/testingSupport/test/testdata/ClassTestData.scala
test.run.config.test.class.not.found=找不到测试类\: {0}
test.config.test.class.is.not.specified=未指定测试类
test.config.test.class.not.found.in.module=在模块 ''{1}'' 中找不到测试类 ''{0}''
test.config.no.suite.class.is.found.for.class.in.module=在模块 ''{1}'' 中找不到类 ''{0}'' 的套件类
test.config.class.is.not.inheritor.of.suite.trait=类 ''{0}'' 不是套件特征的继承者
test.config.clazz.is.not.a.valid.test.suite={0} 不是有效的测试套件

### org/jetbrains/plugins/scala/testingSupport/test/testdata/RegexpTestData.scala
test.config.failed.to.compile.pattern=编译模式 {0} 失败
test.config.no.patterns.detected=未检测到模式
test.config.cant.run.while.indexing.no.class.names.memorized.from.previous.iterations=索引时无法运行\: 以前的迭代中没有记住类名。

### org/jetbrains/plugins/scala/testingSupport/test/testdata/SingleTestData.scala
test.config.test.name.is.not.specified=未指定测试名称
test.config.multiple.classes.specified.for.single.test.run=为单个测试运行指定了多个类

### org/jetbrains/plugins/scala/testingSupport/test/ui/RegexpPanel.scala
test.run.config.for.class.pattern=类模式
test.run.config.test.pattern=测试模式

### org/jetbrains/plugins/scala/testingSupport/test/ui/ScalaTestRunLineMarkerProvider.scala
scalatest.gutter.run.test=运行测试

### org/jetbrains/plugins/scala/testingSupport/test/ui/TestRunConfigurationForm.scala
test.run.config.test.kind=测试类型\:
test.run.config.test.class=测试类(&C)\:
test.run.config.test.name=测试名称(&N)\:
test.run.config.regular.expressions=正则表达式(&X)\:
test.run.config.test.package=测试包(&G)\:
test.run.config.search.for.tests=搜索测试\:
test.run.config.use.sbt=使用 sbt(&T)
test.run.config.use.ui.with.sbt=对 sbt 使用 UI
test.run.config.print.information.messages.to.console=将消息打印到控制台(&P)
test.run.config.choose.test.class=选择测试类
test.run.config.test.kind.all.in.package=包中所有内容
test.run.config.test.kind.class=类
test.run.config.test.kind.test.name=测试名称
test.run.config.test.kind.regular.expression=正则表达式
test.run.config.search.scope.in.whole.project=在整个项目中
test.run.config.search.scope.in.single.module=在单个模块中
test.run.config.search.scope.across.module.dependencies=整个模块依赖项

### org/jetbrains/plugins/scala/testingSupport/test/utest/UTestConfigurationProducer.scala
test.in.scope.utest.presentable.text=''{0}'' 中的 UTest

### org/jetbrains/plugins/scala/testingSupport/test/utest/UTestConfigurationType.scala
utest.config.display.name=utest
utest.config.description=utest 测试框架运行配置

### org/jetbrains/plugins/scala/util/NotificationUtil.scala
default.notification.title=警告

### org/jetbrains/plugins/scala/worksheet/actions/CreateLightWorksheetAction.scala
create.light.scala.worksheet.menu.action.text=创建 Light Scala 工作表
create.light.scala.worksheet.menu.action.description=创建 Light Scala 工作表

### org/jetbrains/plugins/scala/worksheet/actions/NewScalaWorksheetAction.scala
new.scalaworksheet.menu.action.text=Scala 工作表
new.scalaworksheet.menu.action.description=创建新的 Scala 工作表

### org/jetbrains/plugins/scala/worksheet/actions/topmenu/CleanWorksheetAction.scala
worksheet.clear.button=清除结果
clean.scala.worksheet.action.text=清理 Scala 工作表
clean.scala.worksheet.action.description=清理 Scala 工作表

### org/jetbrains/plugins/scala/worksheet/actions/topmenu/CopyWorksheetAction.scala
worksheet.copy.button=复制工作表
copy.scala.worksheet.action.text=复制 Scala 工作表
copy.scala.worksheet.action.description=复制 Scala 工作表

### org/jetbrains/plugins/scala/worksheet/actions/topmenu/RunWorksheetAction.scala
worksheet.execute.button=评估工作表
run.scala.worksheet.action.text=运行 Scala 工作表
run.scala.worksheet.action.description=运行 Scala 工作表

### org/jetbrains/plugins/scala/worksheet/actions/topmenu/ShowWorksheetSettingsAction.scala
worksheet.settings.button=显示工作表设置

### org/jetbrains/plugins/scala/worksheet/actions/topmenu/StopWorksheetAction.scala
worksheet.stop.button=停止执行工作表

### org/jetbrains/plugins/scala/worksheet/ammonite/AmmoniteGotoHandler.scala
ammonite.goto=转到

### org/jetbrains/plugins/scala/worksheet/ammonite/AmmoniteScriptWrappersHolder.scala
notification.title.ammonite.imports.found=找到 Ammonite 导入
ammonite.import.ivy.dependencies.message=<html><body><a href\="ftp\://run">导入</a> {0} 中声明的全部 $ivy 依赖项(出现在本地缓存中)? <a href\="ftp\://disable">忽略</a></body></html>

### org/jetbrains/plugins/scala/worksheet/ammonite/AmmoniteUnresolvedLibraryInspection.scala
ammonite.cannot.resolve.import=无法解析导入
display.name.unresolved.ivy.import=未解析的 Ivy 导入

### org/jetbrains/plugins/scala/worksheet/ammonite/CreateImportedLibraryQuickFix.scala
ammonite.create.library.from.jar=从 jar 创建库...

### org/jetbrains/plugins/scala/worksheet/ammonite/ImportAmmoniteDependenciesFix.scala
ammonite.loading.list.of.versions=Ammonite\: 正在加载版本列表...
ammonite.extracting.info.from.sbt=Ammonite\: 正在从 SBT 提取信息...
ammonite.adding.dependencies.title=添加依赖项
ammonite.adding.dependencies.progress=Ammonite\: 正在加载依赖项...
add.a.all.ammonite.deps.to.project=将全部 Ammonite 标准依赖项<html><body><p><a href\="ftp\://run">添加</a>到项目? <a href\="ftp\://disable">忽略</a></p></body></html>

### org/jetbrains/plugins/scala/worksheet/ammonite/runconfiguration/AmmoniteRunConfiguration.scala
ammonite.config.select=选择...
ammonite.script=脚本\:
ammonite.executable=Amm 可执行文件\:
ammonite.script.parameters=脚本参数\:

### org/jetbrains/plugins/scala/worksheet/ammonite/runconfiguration/AmmoniteRunConfigurationType.scala
ammonite.config.display.name=Ammonite
ammonite.config.run.ammonite.script=运行 Ammonite 脚本

### org/jetbrains/plugins/scala/worksheet/ammonite/runconfiguration/AmmoniteRunScriptAction.scala
ammonite.run.script=运行脚本...

### org/jetbrains/plugins/scala/worksheet/processor/WorksheetCompiler.scala
worksheet.compilation=工作表 {0} 编译

### org/jetbrains/plugins/scala/worksheet/processor/WorksheetCompilerErrorReporter.scala
worksheet.configuration.errors.base=工作表配置错误
worksheet.configuration.errors.repl.is.available.only.in.compile.server.process=REPL 模式下的工作表只能在编译服务器进程中执行
worksheet.configuration.errors.project.indexing.not.finished=项目索引编制未完成
worksheet.configuration.errors.enable.compile.server=启用编译服务器
worksheet.configuration.errors.configure.compile.server=配置编译服务器
compile.server.is.not.running=编译服务器未运行

### org/jetbrains/plugins/scala/worksheet/ui/dialog/ShowCompilerProfileSettingsButton.scala
worksheet.show.compiler.profiles.settings=显示编译器配置文件设置

### org/jetbrains/plugins/scala/worksheet/ui/dialog/WorksheetAllSettingsPanel.scala
worksheet.settings.panel.settings.for.module={0} 的设置
worksheet.settings.panel.default.settings=默认设置

### org/jetbrains/plugins/scala/worksheet/ui/dialog/WorksheetFileSettingsDialog.scala
worksheet.settings.panel.title=工作表设置

### org/jetbrains/plugins/scala/worksheet/ui/dialog/WorksheetSettingsSetForm.form
worksheet.settings.panel.change.make.button=运行前创建项目
worksheet.settings.panel.interactive.mode=交互模式
worksheet.settings.panel.run.type=运行类型\:
worksheet.settings.panel.use.class.path.of.module=使用模块的类路径\:
worksheet.settings.panel.compiler.profile=编译器配置文件\:

### org/jetbrains/plugins/scala/worksheet/ui/dialog/WorksheetSettingsSetForm.java
worksheet.settings.panel.using.class.path.of.the.module=使用模块的类路径...

### org/jetbrains/plugins/scala/worksheet/ui/printers/WorksheetEditorPrinterBase.scala
worksheet.internal.error=由于意外异常，无法评估工作表

### org/jetbrains/plugins/scala/worksheet/ui/printers/WorksheetEditorPrinterFactory.scala
worksheet.printers.output.exceeds.cutoff.limit=输出超过截止限制。

### <unused>
conversion.is.not.available.in.it.s.own.definition=转换定义中无法进行转换
element.has.incompatible.type.parameter.bounds.for.type={0} 的 {1} 类型参数边界不兼容
type.does.not.conform.to.type={0} 不符合 {1}
import.implicitInstance.chooser.title=选择要导入的隐式实例
family.name.search.implicit.instances=选择隐式实例
search.implicit.instances.for=搜索 {0} 的隐式实例
choose.type.to.search=选择要搜索的类型
applicable.implicits.not.found=Applicable implicits not found
test.run.config.choose.working.directory=选择工作目录
sdk.build.title=构建 SDK
statement.expected=应为块语句
star.expected='*' 预期
case.clauses.or.qualified.reference.expected=应为子句或限定引用
annotation.expected=应为注解
simple.type.expected.requires=在 requires 块中应为简单类型
type.dcl.expected=应为类型声明
block.expected=应为块
type.tale.expected=Type keyword expected in simple type tale
refined.type.expected=应为细化的类型
this.expected=应为 'this' 关键字
arg.expr.expected=应为参数表达式
# TODO unify type mismatch messages
expr.type.does.not.conform=表达式中的 {0} 类型不符合值声明的类型
# TODO unify type mismatch messages
patt.type.does.not.conform.expr.type=模式 {0} 的预期类型与表达式类型 {1} 不符
title.cache.updating=更新缓存
title.cache.creating=创建缓存
title.cache.files.scanning=扫描文件...
title.cache.files.parsing=正在解析新文件...
title.please.wait=请稍候
title.cache.saving=保存缓存
title.cache.datafile.loading=加载缓存
title.cache.files.removing=移除旧缓存
title.cache.loading=加载缓存
error.report.to.jetbrains.action=报告给 JetBrains
error.report.submit.label=<html>>此错误报告将把 <b><a href\="{1}{2}">{1}{2}</a></b> 处的新的 <b>JIRA</b> 问题 <br><b>''{0}''</b><br><br>作为组件 <b>''{3}''</b> 进行创建。<br><br>请简要描述该问题以及再现该问题的方式\:</html>
error.report.submit.register.in.jira=<html><a href\="{0}">注册帐户</a></html>
error.report.submit.new.issue.url=<html>您的问题已成功添加，请参见 <br><a href\="{0}">{0}</a></html>
error.report.submit.new.issue.title=问题已添加
error.report.wrong.login=用户名或密码无效。
error.report.canceled=已取消发送报告
error.report.error.creating.issue=创建新的 JIRA 问题时出错
error.report.jira.issue=JetScala 问题 \#{0}
error.report.dialog.title=提交错误
error.report.dialog.wrong.password.title=发送失败
error.report.button.sendreport.caption=发送报告(&S)
error.report.button.cancel.caption=取消
error.report.form.not.jira=我没有 JIRA 帐户，以“JetScala 错误报告者”的名义创建问题(&I)
error.report.form.jira=我是 JIRA 用户(&J)
error.report.form.jira.login=&登录名
error.report.form.jira.password=&密码
error.report.form.jira.password.save=保存密码
repetitive.method.name.signature=重复的方法名称/签名
repetitive.method.name.signature.and.return.type=重复的方法名称、签名和返回类型
illegal.combination.of.modifiers=修饰符的组合非法
modifier.is.not.allowed.here.0=此处不允许使用修饰符 ''{0}''
illegal.combination.of.modifiers.abstract.and.final=修饰符 'abstract' 和 'final' 的组合非法
modifier.volatile.not.allowed.here=此处不允许使用修饰符 'volatile'
modifier.transient.not.allowed.here=此处不允许使用修饰符 'transient'
intarface.cannot.have.modifier.final=接口不能具有修饰符 'final'
script.cannot.have.modifier.abstract=脚本不能有 'abstract' 修饰符
script.cannot.have.modifier.native=脚本不能具有修饰符 'native'
interface.must.have.no.static.method=接口不得有 static 方法
not.abstract.class.cannot.have.abstract.method=非 abstract 类不能有 abstract 方法
illegal.combination.of.modifiers.volatile.and.final=修饰符 'volatile' 和 'final' 的组合非法
variable.cannot.be.native=变量不能有 'native' 修饰符
variable.cannot.be.abstract=变量不能有 'abstract' 修饰符
not.abstract.class.cannot.have.method.without.body=非 abstract 类不能有无主体的方法
not.abstract.method.should.have.body=非 abstract 方法应有主体
cannot.create.class.error.text=无法创建类 ''{0}''\: {1}
cannot.create.class.error.title=无法创建类
no.class.in.file.template=文件模板中未找到类
interface.must.have.no.private.method=接口不得有 private 方法
error.external=外部错误
Inner.methods.are.not.supported=不支持内部方法
final.class.cannot.be.extended=无法扩展 final 类
element.is.not.accessible=元素 {0} 对此位置具有 private 访问权限
class.must.declared.abstract=类 ''{0}'' 必须声明为 abstract 或实现继承的 abstract 成员
object.must.implement=对象 ''{0}'' 必须实现未实现的方法
cannot.refactor.constructor.parameter.top.level=顶层类中的构造函数参数不支持重构
wrong.refactoring.context=当前上下文中不支持重构
operation.not.supported.in.current.block=当前块不支持运算
class.import.title=为类添加 import\:
0.is.not.a.legal.scala.identifier=''{0}'' 不是合法的 scala 标识符
cannot.have.implicit.parameters.and.implicit.bounds=类型参数不能同时包含隐式参数和上下文边界 `\: ...' 或视图边界 `<% ...'
block.must.end.result.expression=块必须以结果表达式结尾
illegal.cyclic.reference=非法循环引用 ''{0}''
anonymous.class.must.declared.abstract=匿名类必须实现继承的 abstract 成员
cyclic.reference.type=涉及类型 {0} 的循环引用非法
implicit.usage.tooltip=检测到<html><body>隐式转换 {0}(<b>{1}</b>)\: <b>{2}</b>
implicit.usage.message=检测到隐式转换 ''{0}({1})\: {2}''。
suspicicious.inference=推断的 {0} 类型可疑。如果确实需要此类型，请对其进行显式注解。
suspicicious.newline=参数列表前面的换行符不推断为分号。不妨考虑在方法名称前使用 '.'。
# TODO Remove? (or even better, do show a clarification, just as the scalac does)
missing.arguments.for.method=方法 {0} 缺少参数，它不是部分应用函数。添加更多参数或插入一个占位符。
element.of.trait=特征的
element.of.class=类的
element.method=方法
label.method=方法{0}
method.has.supers= 方法 {0} 覆盖/实现某些基本方法，是否也对其重命名?
remove.explicit.val=移除显式 'val'
maven.repository.presentable.name=项目储存库
config.display.name=配置
scala.facet.title=Scala(&L)
config.scala.libraries=配置 Scala 库
scala.config.label=Scala 安装目录
scala.config.dscr=请指定 Scala 安装目录的路径
scala.config.noscala.title=Scala 配置错误
scala.config.download.link=https\://www.scala-lang.org/downloads/
scala.config.download.link.label=从这里可以下载 Scala\:
scala.config.compiler.library=Scala 编译器库(&I)\:
scala.config.sdk.library=Scala SDK 库(&S)\:
scala.config.sdk.space.hint=必须使用文件分隔符 - ';' 分隔多个路径
scala.config.take.compiler.from.settings=使用指定 jar 中的 Scala 编译器库(&L)
scala.config.take.relative.path=使用指向项目根的相对路径
error.scala.path.not.valid=Scala 路径无效
scala.config.project.template.name=非 sbt
scala.config.project.template.description=用于开发 Scala 应用程序的模块
scala.config.project.settings.title=Scala 设置
scala.config.module.name=Scala 模块
scala.config.module.description=创建 Scala 模块
no.java.sdk=未配置 java SDK
cannot.compile.scala.files.no.facet=请附加 Scala facet 到模块。
cannot.compile.scala.files.no.compiler=请指定 Scala facet 中的编译器库。
cannot.compile.scala.files.compiler.problem=请调整 Scala facet 中的编译器库\: {0}。
cannot.compile.scala.files.no.sdk=请设置模块 ''{0}'' 的 Java SDK。
cannot.compile.scala.files.no.sdk.mult=请设置模块 ''{0}'' 的 Java SDK。
cannot.compile=无法编译 Scala 文件
debug.option=开启调试堆栈跟踪
scalac.compiler.name=Scalac
javac.error.tools.jar.missing=无法获取 JDK {0} 的路径 javac 类。
javac.error.unknown.jdk.version=无法确定JDK的版本 {0}.\n\
更新JDK配置.
different.scala.sdk.in.modules=依赖模块必须具有相同的 Scala SDK 版本
scala.compiler.description=Scala 编译器
jtype.is.not.found=\n\
无法编译 Scala 文件。\n\
找不到 ch.epfl.lamp.fjbg.JType 类。\n\
请将适当的 jar 附加到模块 ''{0}''。
scala.sdk.configuration=Scala SDK 配置
new.button.label=新建
scala.sdk.configuration.label=<html><b>Scala SDK\:</b><br> 选择特定于此模块的 Scala SDK</html>
add.new.scala.lib=新 Scala SDK
invalid.scala.sdk.path.text=指定了错误路径
duplicate.scala.lib.version=重复的 Scala SDK 版本
duplicate.scala.lib.version.add=要再添加版本 {0} 的一个 Scala SDK?
scala.sdk.combo.box.project.item=<No Scala SDK>
no.scala.facet=应为 Scala Facet
new.scala.facet.detected=检测到 Scala Facet
invalid.scala.sdk.path.message=Scala SDK 路径无效
facet.create.lib.title=创建 Scala 库
facet.create.project.lib=创建项目级 Scala 库 ''{0}''(&P)
facet.create.application.lib=创建应用程序级 Scala 库 ''{0}''(&A)
facet.setting.exclude.compiler.from.cp=从模块范围中排除 Scala 编译器库(&P)
facet.setting.exclude.library.from.cp=从模块范围中排除 Scala SDK 库(&L)
file.template.group.title.scala=Scala
# class
newclass.dlg.prompt=输入新 Scala 类的名称
newclass.dlg.title=新建 Scala 类
newclass.command.name=创建 Scala 类
newclass.progress.text=创建 Scala 类 ''{0}''
# worksheet
newworksheet.dlg.prompt=输入新 Scala 工作表的名称
newworksheet.dlg.title=新建 Scala 工作表
newworksheet.menu.action.text=Scala 工作表
newworksheet.menu.action.description=创建新的 Scala 工作表
newworksheet.command.name=创建 Scala 工作表
newworksheet.progress.text=创建 Scala 工作表 ''{0}''
#object
newobject.dlg.prompt=输入新 Scala 对象的名称
newobject.dlg.title=新建 Scala 对象
newobject.menu.action.text=Scala 对象
newobject.menu.action.description=创建新的 Scala 对象
newobject.command.name=创建 Scala 对象
newobject.progress.text=创建 Scala 对象 ''{0}''
#trait
newtrait.dlg.prompt=输入新 Scala 特征的名称
newtrait.dlg.title=新建 Scala 特征
newtrait.menu.action.text=Scala 特征
newtrait.menu.action.description=创建新的 Scala 特征
newtrait.command.name=创建 Scala 特征
newtrait.progress.text=创建 Scala 特征 ''{0}''
scala.compiler.option.additional.command.line.parameters=Scala 编译器的其他命令行参数
psi.decompiled.text.header=// 用于 Scala 语言的 IntelliJ API 反编译器\n\
// 从类文件生成的存根源\n\
// 功能实现不可用
scala.compiler.heap.size=最大堆大小 (MB)\:
scala.compiler.cmd.line.params=命令行参数
scala.compiler.use.deprecation=编译 @&deprecated 注解
scala.compiler.scalac.first=先编译 Scala 文件(&S)
scala.compiler.show.unchecked=编译 @unchecked 注解(&U)
scala.compiler.generate.no.warnings=不生成警告(&W)
scala.compiler.optimize=优化字节码(&O)
scala.compiler.no.generics=对 Scala 泛型签名禁止(&G)
no.right.operand.found=找不到右侧的操作数
cannot.resolve.infix.operator=无法解析中缀运算符
circular.dependency.detected=检测到类型别名 ''{0}'' 的循环依赖
no.result.expression.found=找不到结果表达式
unreachable.expression=无法访问的语句
choose.inferred.or.super.type.popup.title=选择类型
test.in.scope.specs.presentable.text=''{0}'' 中的 Specs
equals.between.inconvertible.types.display.name=不可转换类型对象之间的相等测试
equals.between.inconvertible.types.description=检测因操作数的 static 类型不可转换而始终返回 false 的相等测试。
equals.between.inconvertible.types.problem.descriptor=在不可转换类型 ''{0}'' 和 ''{1}'' 的对象之间进行相等测试 \#loc
find.usages.implementing.type.definition=实现类型定义
find.usages.companin.module=伴生模块用法
find.usages.instances.title=创建实例
introduce.typealias.search.companion=从伴生替换
introduce.typealias.search.inheritors=在继承者中替换
introduce.field.choose.class=选择用于引入字段的类
extract.trait.name.not.specified=未指定特征名称
change.signature.not.supported.multiple.parameter.clauses=有多个参数子句的函数不支持更改签名
change.signature.not.supported.constructors=构造函数不支持 Scala 中的更改签名
default.ta.settings = 设置
default.ta.tooltip = 配置类型注解设置
parameter.not.from.function=根据参数而不是函数定义或函数表达式来求值
local.variable.from.anonymous.class=无法加载匿名类中的局部变量 {0}
invalid.expression.in.parentheses=括号中的表达式无效\: {0}
formatted.interpolator.not.supported=Scala 2.11 不支持格式化字符串内插器 f"..."
gradle.dataService.scalaVersionCantBeDetected=无法确定模块 {0} 的 Scala 编译器版本
gradle.dataService.scalaLibraryIsNotFound=找不到模块 {1} 的项目 Scala 库 {0}
configure.type.aware.highlighting=配置项目的类型感知高亮显示
vm.options=VM 选项：
console.arguments=控制台参数\:
working.directory=工作目录\:
use.classpath.and.sdk.of.module=使用模块的类路径和 SDK\:
test.run.config.sbt.runner.form.environment.variables=环境变量 (&E)
