conflicting.annotations.display.name=Guice 注释冲突
conflicting.annotations.problem.descriptor=注释 \#ref 与声明的其他注释冲突 \#loc
multiple.binding.annotations.display.name=变量有多个绑定注释
multiple.binding.annotations.problem.descriptor=变量 \#ref 有多个绑定注释 \#loc
binding.annotation.without.inject.display.name=没有 @Inject 的绑定注释
binding.annotation.without.inject.problem.descriptor=没有声明 @Inject 的绑定注释 \#ref \#loc
interception.annotation.without.runtime.retention.display.name=没有运行时保留的截取注释
interception.annotation.without.runtime.retention.problem.descriptor=注释 \#ref 没有运行时保留 \#loc
invalid.request.parameters.display.name=@RequestParameters 参数的类型不正确
invalid.request.parameters.problem.descriptor=标记为 \#ref 的变量或参数的类型必须为 Map<String, String[]> \#loc
invalid.implemented.by.display.name=@ImplementedBy 注释无效
invalid.implemented.by.problem.descriptor=\#ref 类未实现注释类 \#loc
singleton.injects.scoped.display.name=@Singleton 组件注入作用域组件
singleton.injects.scoped.problem.descriptor=作用域类 \#ref 的 @Inject 来自于 @Singleton 类 \#loc
group.guice.inspections.name=Guice
session.scoped.injects.request.scoped.display.name=@SessionScoped 组件注入 @RequestScoped 组件
session.scoped.injects.request.scoped.problem.descriptor=@RequestScoped 类 \#ref 的 @Inject 来自于 @SessionScoped 类 \#loc
invalid.provided.by.display.name=无效的 @ProvidedBy 注释
invalid.provided.by.problem.descriptor=\#ref 类未提供注释类 \#loc
uninstantiable.implemented.by.class.display.name=无法实例化的 @ImplementedBy 类
uninstantiable.implemented.by.class.problem.descriptor=类 \#ref 不可实例化，因此不能为 @ImplementedBy \#loc
uninstantiable.provided.by.class.display.name=无法实例化的 @ProvidedBy 类
uninstantiable.provided.by.class.problem.descriptor=类 \#ref 不可实例化，因此不能为 @ProvidedBy \#loc
uninstantiable.binding.display.name=无法实例化的绑定
uninstantiable.binding.problem.descriptor=类 \#ref 不可实例化，因此不可绑定 \#loc
redundant.to.binding.display.name=冗余绑定
redundant.to.binding.problem.descriptor=对类 \#ref 的绑定冗余 \#loc
redundant.to.provider.binding.display.name=冗余提供程序绑定
redundant.to.provider.binding.problem.descriptor=对类 \#ref 的绑定冗余 \#loc
redundant.scope.binding.display.name=冗余范围绑定
redundant.scope.binding.problem.descriptor=对范围 \#ref 的绑定冗余 \#loc
pointless.binding.display.name=无意义的绑定
pointless.binding.problem.descriptor=非必要绑定，可以移除 \#loc
unnecessary.static.injection.display.name=不必要的静态注入
unnecessary.static.injection.problem.descriptor=类 \#ref 没有 static @Inject 成员 \#loc
multiple.injected.constructors.for.class.display.name=类有多个 @Inject 构造函数
multiple.injected.constructors.for.class.problem.descriptor=类 \#ref 有多个 @Inject 构造函数 \#loc
move.binding.scope.to.class.text=将绑定范围移到类
move.binding.scope.to.class.family.name=将绑定范围移到类
move.binding.to.class.text=将绑定类移到类
move.binding.to.class.family.name=将绑定移到类
move.provider.binding.to.class.text=将提供程序绑定移到类
move.provider.binding.to.class.family.name=将提供程序绑定移到类
guice.intentions=Guice
new.guice.module.error=无法创建 Guice 模块
new.guice.module.action.name=创建 Guice 模块
new.guice.module.name=创建 Guice 模块\: {0}。{1}
new.guice.scope.annotation.error=无法创建 Guice 范围注释
new.guice.scope.annotation.action.name=创建 Guice 范围注解
new.guice.binding.annotation.error=无法创建 Guice 绑定注释
new.guice.binding.annotation.action.name=创建 Guice 绑定注解
new.guice.binding.annotation.name=创建 Guice 绑定注释\: {0}。{1}
new.guice.method.interceptor.error=无法创建 Guice 方法拦截器
new.guice.method.interceptor.action.name=创建 Guice 方法拦截器
new.guice.method.interceptor.name=创建 Guice 方法拦截器\: {0}。{1}
new.guice.provider.error=无法创建 Guice 提供程序
new.guice.provider.action.name=创建 Guice 提供程序
new.guice.provider.name=创建 Guice 提供程序\: {0}。{1}
toggle.injection.required.family.name=切换所需的注入
make.injection.optional=设定为选用注入
make.injection.mandatory=设定为必用注入
toggle.required=切换 'optional'
action.group.guice.title=Google Guice
action.group.guice.description=创建 Google Guice 组件
delete.binding=删除绑定
select.provided.class=选择要提供的类
GuiceClassAnnotator.popup.title=选择要导航到的表达式
GuiceClassAnnotator.popup.tooltip.text=导航到 Guice 绑定表达式
gutter.choose.injected.point=选择注入点
gutter.navigate.to.injection.point=导航到注入点
provider.class.name=提供程序类名\:
class.provided=提供的类\: 
new.guice.provider=新的 Guice 提供程序