add.explicit.type.arguments=添加显式类型参数

# suppress inspection "UnusedProperty"
annotation.target.ANNOTATION_TYPE=注解类型
# suppress inspection "UnusedProperty"
annotation.target.CONSTRUCTOR=构造函数
# suppress inspection "UnusedProperty"
annotation.target.FIELD=字段
# suppress inspection "UnusedProperty"
annotation.target.LOCAL_VARIABLE=局部变量
# suppress inspection "UnusedProperty"
annotation.target.METHOD=方法
# suppress inspection "UnusedProperty"
annotation.target.MODULE=模块
# suppress inspection "UnusedProperty"
annotation.target.PACKAGE=包
# suppress inspection "UnusedProperty"
annotation.target.PARAMETER=参数
# suppress inspection "UnusedProperty"
annotation.target.RECORD_COMPONENT=记录组件
# suppress inspection "UnusedProperty"
annotation.target.TYPE=按类型分组
# suppress inspection "UnusedProperty"
annotation.target.TYPE_PARAMETER=类型参数
# suppress inspection "UnusedProperty"
annotation.target.TYPE_USE=类型使用

change.type.arguments=更改类型参数
change.type.arguments.to.0=将类型参数更改为 <{0}>
convert.0.to.float=将 ''{0}'' 转换为 float

dataflow.message.array.index.out.of.bounds=Array索引超出范围
dataflow.message.arraystore=将 <code>{0}</code> 类型的元素存储为 <code>{1}</code> 元素数组可能会生成 <code>ArrayStoreException</code>
dataflow.message.assigning.null.notannotated=正在将 <code>null</code> 值指定给非注解字段
dataflow.message.assigning.null=<code>null</code> 被分配到一个是注解变量 @NotNull
dataflow.message.assigning.nullable.notannotated=表达式 <code>\#ref</code> \#loc 可能为 null，但被指定给非注解字段
dataflow.message.assigning.nullable=表达式 <code>\#ref</code> 可能为 null ,但是它被分配了注解 @NotNull
dataflow.message.cce.always=将 <code>{0}</code> 转换为 <code>\#ref</code> \#loc 会为任意非 null 值生成 <code>ClassCastException</code>
dataflow.message.cce=从<code>{0}</code> 到 <code>\#ref</code> \#loc 可能产生 <code>java.lang.ClassCastException</code>
dataflow.message.constant.condition.when.reached=到达时，条件 <code>\#ref</code> \#loc 始终为 <code>{0, choice, 0\#false|1\#true}</code>
dataflow.message.constant.condition=条件 <code>\#ref</code> \#loc 始终为 <code>{0, choice, 0\#false|1\#true}</code>
dataflow.message.constant.method.reference=方法引用结果始终为''{0}''
dataflow.message.constant.no.ref=条件始终为 {0, choice, 0\#false|1\#true}
dataflow.message.contract.fail.index=由于索引超出范围,对'\#ref'的调用总是失败
dataflow.message.contract.fail=依据其方法约定，对 '\#ref' 的调用始终失败
dataflow.message.immutable.modified=不可变对象已被修改
dataflow.message.immutable.passed=不可变对象在预期可变位置传递
dataflow.message.npe.array.access.sure=数组访问 <code>\#ref</code> \#loc 可能生成 <code>NullPointerException</code>
dataflow.message.npe.array.access=数组访问 <code>\#ref</code> \#loc 可能产生 <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access.sure=引用 <code>\#ref</code> \#loc 会产生 <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access=废弃的<code>\#ref</code> \#loc 可能产生 <code>java.lang.NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure=内部类构造将生成 <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction=内联类建立可能会产生<code>java.lang.NullPointerException</code>
dataflow.message.npe.method.invocation.sure=方法调用 <code>\#ref</code> \#loc 可能生成 <code>NullPointerException</code>
dataflow.message.npe.method.invocation=方法调用 <code>\#ref</code> \#loc 可能产生 <code>java.lang.NullPointerException</code>
dataflow.message.npe.methodref.invocation=方法引用调用 <code>\#ref</code> \#loc 可能会产生 <code>java.lang.NullPointerException</code>
dataflow.message.only.switch.label=Switch 标签 <code>\#ref</code> \#loc 是整个 switch 中唯一可访问的对象
dataflow.message.passing.null.argument.nonannotated=将 <code>null</code> 参数传递到非注解参数
dataflow.message.passing.null.argument=通过 <code>null</code> 参数注解为 @NotNull
dataflow.message.passing.nullable.argument.methodref.nonannotated=方法引用实参可能为 null，但被传递给非注解参数
dataflow.message.passing.nullable.argument.methodref=方法引用参数可能为空
dataflow.message.passing.nullable.argument.nonannotated=实参 <code>\#ref</code> \#loc 可能为 null，但被传递给非注解参数
dataflow.message.passing.nullable.argument=参数 <code>\#ref</code> \#loc 可能为null
dataflow.message.pointless.assignment.expression=条件 <code>\#ref</code> \#loc 在赋值表达式的左侧是永远 <code>{0}</code>. 可以简化
dataflow.message.pointless.same.arguments='\#ref' 的参数相同。调用包含相同参数的此方法毫无意义
dataflow.message.pointless.same.argument.and.result='\#ref' 的结果与{0,choice,1\#第 1 个|2\#第 2 个}参数相同使调用毫无意义
dataflow.message.redundant.assignment=变量已被指定给此值
dataflow.message.redundant.instanceof=条件 <code>\#ref</code> \#loc是多余的，可以用 <code>\!\= null</code>
dataflow.message.redundant.update=变量更新不执行任何操作
dataflow.message.return.notnull.from.nullable=@{0} 方法 ''{1}'' 总是返回非 null 值
dataflow.message.return.null.from.notnull=<code>null</code> 由声明为 @{0} 的方法返回
dataflow.message.return.null.from.notnullable=<code>null</code> 由未被声明为 @{0} 的方法返回
dataflow.message.return.nullable.from.notnull.function=函数可能返回null,但这里不允许
dataflow.message.return.nullable.from.notnull=表达式 <code>\#ref</code> 可能会评估为 null，但由声明为 @{0} 的方法返回
dataflow.message.return.nullable.from.notnullable=表达式 <code>\#ref</code> 可能会评估为 null，但由未被声明为 @{0} 的方法返回
dataflow.message.storing.array.null=<code>null</code> 已存储到 @NotNull 元素的数组中
dataflow.message.storing.array.nullable=表达式 <code>\#ref</code> 可能会评估为 null，但已存储到 @NotNull 元素的数组
dataflow.message.unboxing.method.reference=使用 <code>\#ref</code> \#loc 需要取消装箱，这可能会产生 <code>java.lang.NullPointerException</code>
dataflow.message.unboxing=拆箱的 <code>\#ref</code> \#loc 可能产生 <code>java.lang.NullPointerException</code>
dataflow.message.unreachable.switch.label=Switch 标签 <code>\#ref</code> \#loc 不可到达
dataflow.method.fails.with.null.argument=当参数为null时，方法将引发异常
dataflow.not.precise={0} 复杂\: 数据流结果可能不准确
dataflow.too.complex=方法 <code>\#ref</code> 太复杂，无法通过数据流算法进行分析

delete.repeated.0=删除重复的 ''{0}''
delete.repeated.interface=删除重复的接口
exception.removal.will.break.source.code.proceed.anyway=异常移除会破坏源代码。仍然继续?

feature.generics=泛型
feature.annotations=<html>注释</html>
feature.static.imports=静态导入
feature.for.each=For-each 循环
feature.varargs=可变 arity 方法
feature.hex.fp.literals=十六进制浮点文字
feature.diamond.types=Diamond 类型
feature.multi.catch=多 catch
feature.try.with.resources=Try-with-resources
feature.binary.literals=二进制文字
feature.underscores.in.literals=在文字中加下划线
feature.extension.methods=扩展方法
feature.method.references=方法引用
feature.lambda.expressions=Lambda 表达式
feature.type.annotations=类型注解
feature.type.receivers=接收器参数
feature.intersections.in.casts=转换中的交叉类型
feature.static.interface.calls=static 接口方法调用
feature.try.with.resources.refs=资源引用
feature.modules=模块
feature.lvti=局部变量类型推理
feature.var.lambda.parameter=lambda 参数中的 'var'
feature.text.blocks=文本块文字
feature.text.block.escape.sequences='\\s' 和 '\' 转义序列
feature.enhanced.switch=增强的 'switch' 块
feature.switch.expressions='switch' 表达式
feature.records=记录
feature.patterns.instanceof='instanceof' 中的模式
feature.sealed.classes=密封类
feature.local.interfaces=本地接口
feature.local.enums=本地枚举

find.searching.for.references.to.class.progress=查找引用类{0}...
find.usages.panel.title.derived.classes=派生类
find.usages.panel.title.derived.interfaces=派生接口
find.usages.panel.title.implementing.classes=实现类
find.usages.panel.title.implementing.methods=实现方法
find.usages.panel.title.overloaded.methods.usages=重载方法使用
find.usages.panel.title.overriding.methods=重写方法
message.class.inaccessible.from.module=类 ''{0}'' 无法从模块 ''{1}'' 访问
message.class.inaccessible=类 ''{0}'' 无法在此处访问

inspection.i18n.quickfix.annotate=注释...
inspection.i18n.quickfix.annotate.as=注释为 @{0}
inspection.i18n.quickfix.annotate.element=注释 {0} ''{1}''…
inspection.i18n.quickfix.annotate.element.as=注释{0} ''{1}'' 为 @{2}
inspection.reference.default.package=<默认>
error.message.invalid.java.type=无效的 Java 类型
move.0.to.the.beginning=将 ''{0}'' 移动到开头
move.to.front=移到前面
processing.method.usages=正在处理方法用例…
qualify.0=限定 {0}
qualify.with.0.this=使用 {0}.this 限定
remove.annotation=移除注释
remove.left.side.of.assignment=移除赋值的左侧
replace.get.class.with.class.literal=使用 .class 文字替换 getClass()
service.provides=提供服务 <a href\="\#javaClass/{0}">{0}</a><br><div style\=''margin-top\: 5px''><font size\=''2''>点击以导航</font></div>
service.uses=使用服务 <a href\="\#javaClass/{0}">{0}</a><br><div style\=''margin-top\: 5px''><font size\=''2''>点击以导航</font></div>
suppress.for.parameter=对参数禁止
suppress.for.statement.with.comment=对包含注释的语句禁止
intention.add.annotation.family=添加注解
intention.text.remove.annotation=移除

scope.package=包 {0}

0.field.is.always.initialized.not.null=@{0} 字段始终为初始化的非 null
access.can.be.0=访问可以是 {0}
access.to.field.code.ref.code.outside.of.declared.guards.loc=访问声明的临界外部的字段 <code>\#ref</code> \#loc
call.to.method.code.ref.code.outside.of.declared.guards.loc=在声明的 guard 之外调用方法  <code>\#ref()</code> \#loc
annotate.as.safevarargs=注解为 @SafeVarargs
annotate.overridden.methods.parameters.family.name=注释重写方法参数
annotate.overridden.methods.parameters=重写方法参数注释''@{0}''
anonymous.ref.loc.can.be.replaced.with.0=匿名 \#ref \#loc 可以替换为 {0}
anonymous.ref.loc.can.be.replaced.with.lambda=匿名 \#ref \#loc 可以替换为 lambda
assigning.a.collection.of.nullable.elements=正在将可空元素集合指定给非空元素集合
nullable.stuff.error.overriding.nullable.with.notnull=用非 null 元素集合覆盖可 null 元素的集合
nullable.stuff.error.overriding.notnull.with.nullable=用可 null 元素集合覆盖非 null 元素的集合
comparision.between.object.and.primitive=对象与基元之间的比较非法，仅在 java 7 中接受
custom.exception.class.should.have.a.constructor=自定义异常类应具有一个包含字符串类型的单个消息参数的构造函数
delimiters.argument.contains.duplicated.characters=分隔符参数包含重复的字符
deprecated.class.usage.group.xml=XML文件
deprecated.member.0.is.still.used=弃用的成员 ''{0}'' 仍在使用
detach.library.quickfix.name=分离库
detach.library.roots.quickfix.name=分离未使用的库根
don.t.report.unused.jars.inside.used.library=不要在使用的库内报告未使用的 jar
explicit.type.argument.ref.loc.can.be.replaced.with=显式类型参数 \#ref \#loc 可以替换为 <>
exports.to.itself.delete.module.ref.fix=删除模块''{0}''的引用
exports.to.itself.delete.statement.fix=删除声明
html.classes.exposed.with.code.module.info.code.html=<html>类通过 <code>module-info</code> 公开</html>
html.ignore.overrides.of.deprecated.abstract.methods=<html>在未弃用的 super 中忽略弃用的 abstract 方法的重写</html>
ignore.casts.in.suspicious.collections.method.calls=忽略可疑集合方法调用中的转换
ignore.exceptions.thrown.by.entry.points.methods=忽略由入口点方法引发的异常
ignore.in.the.same.outermost.class=在相同的最外侧类中忽略
ignore.inside.deprecated.members=在弃用的成员内忽略
ignore.inside.non.static.imports=在非静态导入内忽略
ignore.members.of.deprecated.classes=忽略弃用类的成员
ignore.operation.which.results.in.negative.value=忽略 '<<' 操作，后者会导致负值
inspection.annotate.method.quickfix.family.name=标注方法
inspection.annotate.overridden.method.and.self.quickfix.family.name=注解重写的方法和本身
inspection.annotate.overridden.method.quickfix.family.name=注释覆盖方法
inspection.c.style.array.declarations.option=忽略变量中的 C 样式声明
inspection.can.be.final.accept.quickfix=设为 final
inspection.can.be.final.option1=报告方法
inspection.can.be.final.option2=报告字段
inspection.can.be.final.option=报告类
inspection.can.be.local.parameter.problem.descriptor=参数 <code>\#ref</code> 可以具有 <code>final</code> 修饰符
inspection.can.be.local.variable.problem.descriptor=变量 <code>\#ref</code> 可以具有 <code>final</code> 修饰符
inspection.can.be.replaced.with.message=可以替换为 ''{0}''
inspection.class.getclass.display.name=Class.getClass() 调用
inspection.class.getclass.fix.remove.name=移除 'getClass()' 调用
inspection.class.getclass.fix.replace.name=替换为 'Class.class'
inspection.class.getclass.message=在类实例上调用了 'getClass()'
inspection.class.has.no.to.string.method.description=类 ''{0}'' 不会重写 ''toString()'' 方法
inspection.class.has.no.to.string.method.exclude.classes.reg.exp.option=排除类 (reg exp)\:
inspection.class.has.no.to.string.method.ignore.abstract.classes.option=忽略 abstract 类
inspection.class.has.no.to.string.method.ignore.deprecated.classes.option=忽略弃用的类
inspection.class.has.no.to.string.method.ignore.enum.classes.option=忽略枚举类
inspection.class.has.no.to.string.method.ignore.exception.classes.option=忽略异常类
inspection.class.has.no.to.string.method.ignore.inner.classes.option=忽略内部类
inspection.class.has.no.to.string.method.ignore.test.classes.option=忽略测试类
inspection.common.if.parts.disable.highlight.tail.call=如果尾语句是调用，则不要高亮显示公用部分
inspection.common.if.parts.family.else.if.description=可以合并 'else if'
inspection.common.if.parts.family.else.if=合并 'else if' 语句
inspection.common.if.parts.family=提取 'if' 语句的公用部分
inspection.common.if.parts.settings.highlight.when.tail.call=在最后一个公用语句为调用时高亮显示
inspection.compiler.javac.quirks.anno.array.comma.fix=移除尾随逗号
inspection.compiler.javac.quirks.anno.array.comma.problem=注解数组初始化程序中的逗号可能会导致某些Javac版本(例如JDK 5和JDK 6)中的编译错误.
inspection.compiler.javac.quirks.name=Javac兼容模式
inspection.compiler.javac.quirks.qualifier.type.args.fix=移除泛型参数
inspection.compiler.javac.quirks.qualifier.type.args.problem=限定符引用中的泛型可能会导致某些Javac版本(例如JDK 5和JDK 6)中的编译错误.
inspection.constant.on.wrong.side.of.a.comparison.side.option=常量应在比较的这一侧\:
inspection.contract.display.name=合同的问题
inspection.data.flow.redundant.instanceof.quickfix=替换为\!\= null
inspection.data.flow.simplify.boolean.expression.quickfix=简化逻辑表达式
inspection.data.flow.simplify.to.assignment.quickfix.name=简化正常作业
inspection.data.flow.turn.off.constant.references.quickfix=不要报告总是不变的值
inspection.data.flow.turn.off.nullable.returning.notnull.quickfix=不要报告总是返回非空值的方法
inspection.data.flow.turn.off.true.asserts.quickfix=不要报告总是为true的断言
inspection.duplicate.throws.display.name=重复抛出
inspection.duplicate.throws.ignore.subclassing.option=忽略其它子类化的异常
inspection.duplicate.throws.more.general.problem=在抛出列表,这是一个普通异常''{0}''.
inspection.duplicate.throws.problem=重复抛出
inspection.equals.hashcode.only.one.defined.problem.descriptor=类有{0}定义但没有定义{1}
inspection.export.results.can.be.final.description=声明可以具有 final 修饰符
inspection.field.not.used.in.to.string.description2=字段 ''{0}'' 未在 ''toString()'' 方法中使用
inspection.field.not.used.in.to.string.description=方法 ''{0}'' 未在 ''toString()'' 方法中使用
inspection.implicit.subclass.display.forClass=类 ''{0}'' 可以隐式子类化，并且不得为 final
inspection.implicit.subclass.display.name=final 声明不能在运行时被重写
inspection.implicit.subclass.extendable=使''{0}''可以覆盖
inspection.implicit.subclass.make.class.extendable=使类''{0}'' {1,choice,0\#|1\#和方法 {2} |1<和 {1} 个必须的方法}可扩展
inspection.infinite.loop.option=放置在 Thread.run 中时忽略
inspection.java.module.naming.terminal.digits=模块名称组件''{0}''应避免终端数字
inspection.java.module.naming=Java模块命名约定
inspection.local.can.be.final.display.name=局部变量或参数可以是 final
inspection.local.can.be.final.option1=报告方法参数
inspection.local.can.be.final.option2=报告抓参数
inspection.local.can.be.final.option3=报告foreach参数
inspection.local.can.be.final.option4=报告为隐式最终的变量
inspection.local.can.be.final.option=报告局部变量
inspection.module.exports.package.to.itself=模块导出/打开包本身
inspection.nullable.problems.NotNull.parameter.overrides.Nullable=@{0}参数注释不得覆盖@{1}参数
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated=注解@{0}的参数不应该覆盖非注解参数
inspection.nullable.problems.NotNull.parameter.receives.null.literal=参数@{0}不应该接收''null''作为参数
inspection.nullable.problems.Nullable.NotNull.conflict=不能同时与 @Nullable 和 @NotNull 注解
inspection.nullable.problems.Nullable.method.overrides.NotNull=@Nullable 注解的方法不能重写为 @NotNull 方法
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated=@{0}字段的构造函数参数可能会被@{0}注解
inspection.nullable.problems.annotated.field.getter.conflict=@{0}字段的Getter已经注解 @{1}
inspection.nullable.problems.annotated.field.getter.not.annotated=@{0}字段的Getter可能会注解 @{0}本身
inspection.nullable.problems.annotated.field.setter.parameter.conflict=@{0}字段的Setter已经注解 @{1}
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated=@{0}字段的Setter可能会注释 @{0}本身
inspection.nullable.problems.method.overrides.NotNull=未注解的方法重写为 @NotNull 注解的方法
inspection.nullable.problems.parameter.overrides.NotNull=未注释参数覆盖 @{0} 参数
inspection.nullable.problems.primitive.type.annotation=原始类型成员不能被注释
inspection.objects.equals.can.be.simplified.display.name=Objects.equals() 可以替换为 equals()
inspection.redundant.cast.problem.descriptor=转换{0}到{1}是冗余的
inspection.redundant.cast.remove.quickfix=移除多余的转换
inspection.redundant.field.initialization.option=仅在初始化为 null 时发出警告
inspection.redundant.requires.statement.description=冗余语句 ''requires {0}''
inspection.redundant.requires.statement.fix.family=删除冗余 'requires' 语句
inspection.redundant.requires.statement.fix.name=删除语句 ''requires {0}''
inspection.redundant.throws.problem.descriptor1=声明的异常{0}是从不扔在这个方法中,还是在其derivables
inspection.redundant.throws.problem.descriptor2=声明的异常{0}从未抛出
inspection.redundant.throws.problem.descriptor=声明的异常{0}在方法中从未抛出
inspection.redundant.throws.remove.quickfix=删除不必要的抛出声明
inspection.redundant.type.display.name=冗余类型参数
inspection.redundant.type.no.generics.method.reference.problem.descriptor=类型参数对于非泛型方法引用是冗余的
inspection.redundant.type.no.generics.problem.descriptor=类型参数对于非泛型方法调用是冗余的
inspection.redundant.type.problem.descriptor=显式的类型参数可以推断
inspection.redundant.type.remove.quickfix=删除显式的类型参数
inspection.reference.anonymous.name=匿名 ({0})
inspection.reference.implicit.constructor.name=隐式的构造函数{0}
inspection.reference.jsp.holder.method.anonymous.name=<% 页面内容 %>
inspection.requires.auto.module.message=自动导入模块需要'requires'指令
inspection.requires.auto.module.option=高亮显示传递依赖
inspection.requires.auto.module.transitive=自动模块需要'requires transitive'指令
inspection.requires.auto.module=对自动导入模块的依赖
inspection.same.return.value.display.name=方法返回相同的值
inspection.same.return.value.problem.descriptor1=方法和它的所有变量总是返回{0}
inspection.same.return.value.problem.descriptor2=此方法的所有实现始终都返回{0}
inspection.same.return.value.problem.descriptor=方法总是返回{0}
inspection.surround.requirenonnull.quickfix=替换为''Objects.requireNonNull({0})''
inspection.suspicious.array.method.call.display.name=可疑Arrays方法调用
inspection.suspicious.array.method.call.problem.arrays=Array类型不兼容：数组总是不同的
inspection.suspicious.array.method.call.problem.element=元素类型与数组类型不兼容
inspection.suspicious.collections.method.calls.display.name=可疑的集合方法调用
inspection.suspicious.collections.method.calls.problem.descriptor1=可疑的调用''{0}''
inspection.suspicious.collections.method.calls.problem.descriptor=''{0}''可能不包含对象类型''{1}''
inspection.suspicious.getter.setter.field.option=仅在存在字段匹配 getter/setter 名称时发出警告
inspection.suspicious.integer.div.assignment.option=报告可疑但可能准确的除法
inspection.test.only.problems.display.name=测试只有在生产代码的方法调用
inspection.test.only.problems.test.only.class.reference=测试类是在生产代码引用
inspection.test.only.problems.test.only.field.reference=仅在生产代码中引用测试字段
inspection.test.only.problems.test.only.method.call=测试只有在生产代码中调用方法
inspection.unary.plus.unary.binary.option=仅在混乱的二进制或一元表达式上下文中报告
inspection.unnecessary.super.qualifier.option=忽略说明 'super' 限定符
inspection.use.compare.method.fix.family.name=替换为单个比较方法
inspection.visibility.accept.quickfix=接受建议的访问级别
inspection.visibility.compose.suggestion=可以是 {0}
inspection.visibility.option.constants=为常量建议较弱的可见性
inspection.visibility.option.package.private.members=为类成员建议 package-private 可见性级别
inspection.visibility.package.private.top.level.classes=为顶级类建议 package-private 可见性级别
inspection.visibility.private.inner.members=<html>仅在从外部类引用时为内部类成员建议 private</html>
instance.member.guarded.by.static.0.loc=由 static“{0}”保护的实例成员 \#loc
instance.member.guarded.by.static.ref.loc=由 static \#ref 保护的实例成员 \#loc
junit.rule.classrule.option=报告 @ClassRule 问题
junit.rule.rule.option=报告 @Rule 问题
make.0.default.annotation=将“{0}”设为默认注解
make.default.the.last.case.family.name=使 'default' 为最后一个 case
make.final.and.annotate.as.safevarargs=设为 final 并注解为 @SafeVarargs
method.reference.mapped.to.comparator=映射到比较运算符接口的方法引用不会履行比较运算符约定
module.0.with.language.level.1.depends.on.module.2.with.language.level.3=语言级别为 {1} 的模块 {0} 取决于语言级别为 {3} 的模块 {2}
non.final.field.code.ref.code.in.immutable.class.loc=非最终字段 <code>\#ref</code> 位于 @Immutable 类中 \#loc
non.final.guarded.by.field.0.loc=非最终 @GuardedBy 字段“{0}”\#loc
non.final.guarded.by.field.ref.loc=非最终 @GuardedBy 字段 \#ref \#loc
non.null.type.argument.is.expected=应为非 null 类型参数
not.annotated.method.is.used.as.an.override.for.a.method.annotated.with.0=非注解方法被用作使用 {0} 注解的方法的重写
nullable.stuff.problems.overridden.method.parameters.are.not.annotated=覆盖方法参数不会被注释
nullable.stuff.problems.overridden.methods.are.not.annotated=重写的方法不是注释
parameter.can.be.null=参数可以为 null
parameter.is.always.not.null=参数始终为非 null
possible.heap.pollution.from.parameterized.vararg.type.loc=来自于参数化可变参数类型的可能的堆污染 \#loc
redundant.block.marker=冗余块标记
remove.block.marker.comments=移除块标记注释
remove.dependency=移除依赖项
remove.switch.branch.0=移除 switch 分支 ''{0}''
remove.switch.label.0=移除 switch 标签 ''{0}''
remove.switch.label=移除 switch 标签
replace.0.with=将“{0}”替换为“\=”
replace.anonymous.class.with.lambda.alternative=将匿名类替换为 lambda 替代项
replace.operator.assignment.with.assignment=将运算符赋值替换为赋值
replace.stringtokenizer.delimiters.parameter.with.unique.symbols=将 StringTokenizer 分隔符参数替换为唯一的符号
replace.var.with.explicit.type=将 'var' 替换为显式类型
replace.with.0=替换为 {0}
replace.with.comparator=替换为比较运算符
replace.with.constant.value=替换为常量值
replace.with.expression.lambda=替换为表达式 lambda
replace.with.lambda=替换为 lambda
report.suspicious.but.possibly.correct.method.calls=报告可疑的，但可能是正确的方法调用 (&R)
report.when.interface.is.not.annotated.with.functional.interface=在接口未使用 @FunctionalInterface 注解时报告
searching.for.overriding.methods=正在搜索重写方法
statement.lambda.can.be.replaced.with.expression.lambda=语句 lambda 可以替换为表达式 lambda
static.inheritrance.fix.replace.progress=正在替换 {0} 的用例
static.member.guarded.by.instance.0.loc=由实例“{0}”保护的 static 成员 \#loc
static.member.guarded.by.instance.ref.loc=由实例 \#ref 保护的 static 成员 \#loc
suppress.all.for.class=禁止类的所有检查
suppress.inspection.class=对类禁止
suppress.inspection.field=对字段禁止
suppress.inspection.member=对成员禁止
suppress.inspection.method=对方法禁止
suppress.inspection.module=对模块声明禁止
suspected.module.dependency.problem.descriptor=模块''{0}''不依赖于模块''{1}''. 虽然''{2}''不需要为输出依赖关系检查''{1}''
unknown.guardedby.reference.0.loc=未知的 @GuardedBy 引用“{0}”\#loc
unknown.guardedby.reference.ref.loc=未知的 @GuardedBy 引用 \#ref \#loc
unnecessary.module.dependency.display.name=不必要的模块依赖
unnecessary.module.dependency.problem.descriptor=模块''{0}''源不依赖于模块''{1}''源
unused.import.display.name=未使用的导入
unused.import.statement=未使用的导入语句
unused.library.display.name=未使用的库
unused.library.problem.descriptor=未使用的库''{0}''
unused.library.roots.problem.descriptor=未使用的根{0}从库''{1}''
var.can.be.replaced.with.explicit.type='var' 可以替换为显式类型
vararg.method.call.with.50.poly.arguments=具有超过 50 个 poly 参数的可变参数方法调用可能会导致编译和分析速度减慢
visible.for.testing.makes.little.sense.on.test.only.code=@VisibleForTesting 对 @TestOnly 代码意义不大
inspection.inconsistent.language.level.display.name=语言级别设置不一致
inspection.weaker.access.display.name=声明访问可能较弱
inspection.can.be.final.display.name=声明可以具有 final 修饰符
inspection.redundant.throws.display.name=冗余throws子句
inspection.java.9.redundant.requires.statement.display.name=module-info 中的 'requires' 语句冗余
inspection.numeric.overflow.display.name=数值上溢
inspection.redundant.cast.display.name=多余的类型转换
inspection.deprecated.is.still.used.display.name=弃用的成员仍在使用
inspection.deprecated.class.usage.inspection.display.name=API 中弃用的 API 的使用情况
inspection.field.access.not.guarded.display.name=无防护的字段访问或方法调用
inspection.instance.guarded.by.static.display.name=由 static 字段保护的实例成员
inspection.non.final.field.in.immutable.display.name=非 final 字段位于 @Immutable 类中
inspection.non.final.guard.display.name=非 final @GuardedBy 字段
inspection.static.guarded.by.instance.display.name=由实例字段或 this 防护的 static 成员
inspection.unknown.guard.display.name=未知 @GuardedBy 字段
inspection.use.compare.method.display.name=可以使用 'compare()' 方法比较数值
inspection.convert.2.diamond.display.name=显式类型可以替换为 <>
inspection.convert.2.lambda.display.name=匿名类型可以替换为 lambda
inspection.invalid.comparator.method.reference.display.name=用于比较器的方法引用无效
inspection.safe.varargs.detector.display.name=参数化可变参数类型可能导致堆污染
inspection.block.marker.comments.display.name=块标记注释
inspection.string.tokenizer.delimiter.display.name=java.util.StringTokenizer 中的分隔符重复
inspection.anonymous.has.lambda.alternative.display.name=匿名类型有较短的 lambda 替代项
inspection.java.8.list.sort.display.name=Collections.sort() 可以替换为 List.sort()
inspection.class.has.no.to.string.method.display.name=类不会覆盖 'toString()' 方法
inspection.field.not.used.in.to.string.display.name=字段未在 'toString()' 方法中使用
inspection.contract.checker.clause.syntax=约定子句的格式必须为 arg1, ..., argN -> 返回值
inspection.contract.checker.unknown.return.value=返回值必须为其中之一\: {0}。找到的是\: {1}
inspection.contract.checker.unknown.constraint=约束必须为其中之一\: {0}。找到的是\: {1}
inspection.contract.checker.empty.constraint=约束不应为空
inspection.contract.checker.unreachable.contract.clause=约定子句 ''{0}'' 无法访问\: 以前的约定涵盖了所有可能的情况
inspection.contract.checker.contract.clause.never.satisfied=从未满足约定子句 ''{0}''，因为以前的约定涵盖了其条件
inspection.contract.checker.pure.method.mutation.contract=纯方法不能有突变约定
inspection.contract.checker.parameter.count.mismatch=方法采用 {0} 个参数，而约定子句 ''{1}'' 预期为 {2}
inspection.contract.checker.primitive.parameter.nullability=参数 ''{0}'' 有基元类型 ''{1}''，因此 ''{2}'' 不适用
inspection.contract.checker.inferred.notnull.parameter.null=参数 ''{0}'' 被推断为非 null，因此 ''null'' 不适用
inspection.contract.checker.notnull.parameter.null=参数 ''{0}'' 被注解为非 null，因此 ''null'' 不适用
inspection.contract.checker.inferred.notnull.parameter.notnull=参数 ''{0}'' 被推断为非 null，因此 ''\!null'' 始终不满足
inspection.contract.checker.notnull.parameter.notnull=参数 ''{0}'' 被注解为非 null，因此 ''\!null'' 始终不满足
inspection.contract.checker.boolean.condition.for.nonboolean.parameter=参数 ''{0}'' 有 ''{1}'' 类型(应为布尔型)
inspection.contract.checker.contract.violated=违反约定子句 ''{0}''
inspection.contract.checker.no.exception.thrown=违反约定子句 ''{0}''\: 未抛出异常
inspection.contract.checker.method.always.fails.trivial=子句 ''{0}'' 的返回值可以替换为 ''fail''，因为方法总是失败
inspection.contract.checker.method.always.fails.nontrivial=子句 ''{0}'' 的返回值可以替换为 ''fail''，因为该子句中的方法总是失败
contract.return.validator.not.applicable.for.constructor=不适用于构造函数
contract.return.validator.not.applicable.static=不适用于 static 方法
contract.return.validator.not.applicable.primitive=不适用于基元返回类型 ''{0}''
contract.return.validator.return.type.must.be.boolean=方法返回类型必需为 'boolean'
contract.return.validator.method.return.incompatible.with.method.containing.class=方法返回类型应与包含类的方法兼容
contract.return.validator.too.few.parameters=不适用于 {0, choice, 0\#无参数|1\#有一个参数|2\#有 {0} 个参数} 的方法
contract.return.validator.incompatible.return.parameter.type=返回类型 ''{0}'' 必须可以从参数类型 ''{1}'' 转换而来
contract.return.value.validation.prefix=约定返回值 ''{0}''\:
suspicious.invocation.handler.implementation.display.name=可疑的 InvocationHandler 实现
suspicious.invocation.handler.implementation.method.unused.message=方法从未在 'invoke' 中使用\: 'hashCode'、'equals' 和 'toString' 不太可能正确实现
suspicious.invocation.handler.implementation.type.mismatch.message=代理方法 ''{0}()'' 时，可能返回不兼容类型\: 要求\: {1}; 得到\: {2}
suspicious.invocation.handler.implementation.null.returned.for.toString.message=代理方法 'toString()' 时，可能返回 null\: 不建议如此操作
suspicious.invocation.handler.implementation.null.returned.message=代理方法 ''{0}()'' 时，可能返回 null\: 这可能导致 NullPointerException
