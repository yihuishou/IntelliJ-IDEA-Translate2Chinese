flash.module.type.name=Flash 模块
flash.module.type.description=Flash 模块旨在用于开发 <b>Adobe Flash</ b> 以平台为目标的内容。<br>利用该模块提供的构建配置可为  web (Flash Player)、桌面 (Adobe AIR) 和 AIR 移动平台创建 <b>Flex</b> 或纯 <b>ActionScript</b> 应用程序和库。

debugger.waiting.player=等待 AIR 或 Flash Player 连接
remote.flash.debug.computer=<html>调试器正在等待 Flash 应用程序连接\: <br><ul><li>在此计算机上启动 Flash 或 AIR 应用程序。它将自动连接到调试器。</li><li>或右键单击此计算机或远程计算机上正在运行的 Flash Player，然后从上下文菜单中选择“调试器”。</li></ul>此计算机的 IP 地址：{0}</html>
remote.flash.debug.mobile.network=<html>在 {0} 设备上启动移动 AIR 应用程序以开始调试。<br>(必须打包该应用程序，才能通过网络进行调试)。<br><br>此计算机的 IP 地址\: {1}</html >
remote.flash.debug.mobile.usb=<html>在 {0} 设备上启动移动 AIR 应用程序以开始调试。<br>(必须打包该应用程序，才能通过 USB 进行调试，端口 {1})。
initializing.flex.debugger=初始化 Flex 调试器
flex.debugger.startup.error=Flex 调试器启动错误
flex.debugger.unexpected.communication.error=调试的播放器通信发生异常问题

must.accompany.includein.or.excludefrom.attribute={0} 必须伴随 includeIn 或 excludeFrom 属性。
flex.invalid.enumeration.value={0} 不在可接受的枚举值内
flex.break.point.title=Flex 断点
flex.invalid.integer.value=无效整数值
flex.invalid.number.value=无效数值

no.file.to.run=找不到 HTML 包装器或 SWF 文件来开始运行/调试
remote.url.is.not.accessible.title=远程 URL 不可访问
remote.url.is.not.accessible.message=尝试获取 ''{0}'' 时遇到以下 IO 异常\: \n\
{1}\n\
要继续吗?
flex.run.config.url.can.not.be.run.with.flash.player=无法使用 Flash Player 启动 URL
html.wrapper.can.not.be.run.with.flash.player=无法使用 Flash Player 启动 HTML 包装器
path.to.flash.player.not.set=未设置 Flash Player 的路径('Launch with' 选项)
flash.player.not.found=找不到 Flash Player 可执行文件\: {0}
run.trusted=将输出文件夹放到本地信任的沙盒中(&E)
flex.run.config.incorrect.url=错误的 URL
flex.run.config.url.not.set=未设置要启动的 URL 或文件
debugger.sdk.not.found=找不到 SDK\: {0}
file.not.found=文件未找到\:{0}
main.class.not.set=未指定主类
main.class.not.found=找不到主类 ''{0}''
rlm.main.class.not.set=未指定运行时加载模块的主类。
rlm.main.class.not.found=找不到运行时加载模块的主类\: {0}
rlm.main.class.equal.to.bc.main.class=运行时加载模块的主类等于主应用程序类\: ''{0}''
rlm.output.equal.to.bc.output=运行时加载模块的输出文件等于主应用程序的输出文件\: ''{0}''
output.file.name.not.specified=未指定输出文件名。
rlm.output.file.name.not.specified=未指定运行时加载模块的输出文件。
output.file.must.have.swf.extension=输出文件必须有 swf 扩展名。
rlm.output.file.must.have.swf.extension=运行时加载模块的输出文件必须有 swf 扩展名。
flex.sdk.version.unknown=未知版本
popup.title.step.into.function=单步进入函数
sdk.can.not.be.selected=无法在此处选择 SDK ''{0}''。\n\
请选择 Flex/AIR SDK。
select.flex.sdk=选择 Flex/AIR SDK
cannot.resolve.state=无效状态引用
configuration.not.valid=运行配置错误\: {0}
module.not.specified=模块未指定
module.not.found=找不到模块 ''{0}''
flexunit.not.found.for.bc=构建配置 ''{0}'' 的依赖项不包括 FlexUnit 库
no.test.method.specified=未指定测试方法
method.not.valid=方法 ''{0}'' 不存在或不适合在测试中运行
package.not.valid=缺少 ''{0}'' 包或此包为空
class.not.public=''{0}'' 不为 public
class.not.specified=未指定类
test.class.not.specified=未指定测试类
class.not.found=未找到类 ''{0}''
class.contains.no.tests=类 ''{0}'' 不包含测试
tests.in=测试''{0}''
no.free.port=找不到空闲端口
flexunit.startup.error=启动 FlexUnit 会话失败\: {0}
port.is.busy=端口 {0} 正忙

flexunit.inspections.group=FlexUnit
flexunit.inspection.testclassvisibility.displayname=测试类不为 public
flexunit.inspection.testmethodvisibility.displayname=测试方法不为 public
flexunit.inspection.testclassvisibility.message=测试类应为 public
flexunit.inspection.testmethodvisibility.message=测试方法应为 public
flexunit.inspection.testmethodisstatic.displayname=测试方法为 static
flexunit.inspection.testmethodisstatic.message=测试方法不应为 static
flexunit.fix.remove.static.modifier=移除 static 修饰符
flexunit.inspection.testmethodisproperty.displayname=测试方法为 getter/setter
flexunit.inspection.testmethodisproperty.message=测试方法不应为 getter 或 setter
flexunit.inspection.testmethodhasparameters.displayname=测试方法有必需的参数
flexunit.inspection.testmethodhasparameters.message=测试方法不应有必需的参数
flexunit.inspection.testmethodreturntype.displayname=测试方法应返回 void
flexunit.inspection.testmethodreturntype.message=测试方法应返回 void
flexunit.inspection.mixedapi.displayname=扩展 FlexUnit 1 或 Flunit TestCase 的类中的 FlexUnit 4 测试方法
flexunit.inspection.mixedapi.message=扩展 FlexUnit 1 或 Flunit TestCase 的类中的 FlexUnit 4 测试方法
flexunit.inspection.testclassinproductsource.displayname=产品源中的测试类
flexunit.inspection.testclassinproductsource.message=产品源中的测试类
flexunit.inspection.testclasswithnotests.displayname=测试类没有测试
flexunit.inspection.testclasswithnotests.message=测试类没有测试
flexunit.inspection.runnerclass.displayname=自定义运行程序类实现 IRunner 接口
flexunit.inspection.runnerclass.message=类未实现 IRunner 接口
flexunit.inspection.testmethodinsuite.message=测试方法位于套件中
flexunit.inspection.testmethodinsuite.displayname=测试方法位于套件中
flexunit.inspection.emptysuite.message=测试套件为空
flexunit.inspection.emptysuite.displayname=测试套件为空
flexunit.inspection.suitewithnorunner.displayname=测试套件未指定运行程序类
flexunit.inspection.suitewithnorunner.message=测试套件未指定运行程序类
flexunit.test.runner.caption=FlexUnit 测试运行程序
invalid.flex.compiler.heap.size=无效的 Flex 编译器堆大小
fcsh.out.of.memory.and.restarted=Flex 编译器 shell 内存不足，将会重启。在 {0} | 编译器 | Flex 编译器页面可以增加其堆大小
compiling.module=正在编译模块 ''{0}''...
unnamed=未命名
js.actionscript.specific.group.name=特定于 ActionScript
js.implicitly.internal.declaration.inspection.name=具有隐式访问类型的声明
js.implicitly.internal.declaration.problem=声明具有隐式包内部范围 \#loc
js.implicitly.internal.declaration.problem.add.internal.fix=添加显式 internal 修饰符
js.untyped.declaration.inspection.name=声明没有类型
js.untyped.variable.problem=变量 {0} 没有类型 \#loc
js.untyped.function.problem=函数 {0} 没有返回类型 \#loc
js.untyped.declaration.problem.addtype.fix=向声明中添加类型
js.field.can.be.local.name=可以为本地字段
js.field.can.be.converted.to.local=字段可以被转换为一个局部变量
js.convert.to.local.quick.fix=转换为当地

flash.builder=Flash Builder
flash.builder.project.import.title=Flash Builder 项目导入
sdk.for.imported.projects=所导入的 Flash Builder {0, choice, 1\#项目|2\#项目}的 SDK\: 
flash.builder.workspace.or.project.dir=Flash Builder 工作区或项目，*.fxp、*.fxpl 或 *.zip 文件(&F)
select.flash.builder.workspace.or.project=选择 *.fxp、*.fxpl 或 *.zip 文件、Flash Builder 工作区或项目
specify.flash.builder.workspace.or.project.dir=未设置文件或文件夹路径
dialog.title.import.from.flash.builder=从 Flash Builder 导入 {0}
folder.not.empty=文件夹非空\: \n\
{0}\n\
某些文件可能会被覆盖。\n\
\n\
是否继续?
folder.does.not.exist=文件夹不存在\: ''{0}''
file.or.folder.not.found=找不到文件或文件夹\: {0}
flash.builder.projects.not.found.in=在所选文件夹中找不到 Flash Builder 项目
not.flash.builder.project=所选文件不是 Flash Builder 项目
does.not.contain.flash.builder.projects=所选存档不包含 Flash Builder 项目
incorrect.file.format=所选存档的格式不正确
folder.to.unzip.one.FB.project=项目提取到
folder.to.unzip.several.FB.projects=找到多个项目。将它们提取到此对象的相应子文件夹
note.multiple.projects.extract.to.subfolders=注意\: 找到多个项目。它们将被提取到相应的子文件夹。
extract.single.to.subfolder.0=为提取的项目创建子文件夹 ''{0}''
project.location=项目位置
project.files.location=项目文件位置
open.project.0=打开项目 ''{0}''
failed.to.extract.project=提取项目失败\: \n\
{0}
project.name.empty=项目名称不能为空
project.path.empty=项目文件的位置不能为空
looking.for.flash.builder.projects=查找 Flash Builder 项目

adl.not.set.check.sdk.settings=未设置 AIR 调试启动器。检查 SDK ''{0}'' 的配置
adl.not.found.check.sdk.settings=在 ''{0}'' 处找不到 AIR 调试启动器。检查 SDK ''{1}'' 的配置
adl.not.found.check.sdk.installation=在 ''{0}'' 处找不到 AIR 调试启动器。检查 SDK ''{1}'' 的安装
air.runtime.not.set.check.sdk.settings=未设置 AIR 运行时。检查 SDK ''{0}'' 的配置
air.runtime.not.found.check.sdk.settings=在 ''{0}'' 处找不到 AIR 运行时。检查 SDK ''{1}'' 的配置
checking.url=正在检查 URL ''{0}''
bad.url=错误 URL\: {0}
no.response.from.server={0} 秒内服务器无响应
choose.event.class.title=选择事件类
compilation.skipped.because.nothing.changed.in=自上次编译以来，模块 ''{0}'' 中没有进行过任何更改。跳过...\n\
单击“构建”菜单中的“重建项目”以强制进行编译。
compilation.skipped.because.nothing.changed=自上次编译以来没有进行过任何更改。跳过...\n\
单击“构建”菜单中的“重建项目”以强制进行编译。
compilation.skipped=跳过编译
dumb.mode.flex.unit.warning=更新索引时无法运行 FlexUnit 测试。构建索引后，请再次执行此运行配置。
debugger.show.full.value=查看
breakpoint.condition.error=断点条件错误
failed.to.evaluate.breakpoint.condition=无法评估断点条件\: {0}\n\
\n\
要在断点处停止吗?
not.boolean.breakpoint.condition=无法评估断点条件\: {0}\n\
结果值不是布尔值\: {1}\n\
\n\
要在断点处停止吗?

error.creating.flash.player.trust.folder=SWF 文件未添加到本地信任的沙盒\n\
无法创建 FlashPlayerTrust 文件夹\: {0}
flash.player.trust.folder.does.not.exist=SWF 文件未添加到本地信任的沙盒\n\
FlashPlayerTrust 文件夹不存在
error.creating.idea.trust.cfg.file=SWF 文件未添加到本地信任的沙盒\n\
无法在 FlashPlayerTrust 文件夹 {1} 中创建 {0} 文件
could.not.find.swf.to.trust=找不到要添加到本地信任的沙盒的 SWF 文件
failed.to.update.idea.trust.cfg.file=无法更新 FlashPlayerTrust 文件夹 {1} 中的 {0} 文件

file.created=已创建 <a href\="">{0}</a>
html.wrapper.creation.failed=创建 HTML 包装器失败\n\
{0}
error.title=错误

root.tag.must.contain.language.namespace=根标签必须包含语言名称空间声明
different.language.namespaces=在 MXML 文件中声明了不同的语言名称空间
remove.namespace.declaration=移除命名空间声明
declare.namespace=声明命名空间 {0}
flex.choose.color.dialog.title=选择颜色
system.default.application=系统默认应用程序
launch.with.title=启动
cant.launch=无法使用 {1}\n\
打开 {0}\n\
错误\: {2}
css.files.title=要编译为 SWF 的 CSS 文件

livetemplate.description.iter=迭代 (for each..in)
livetemplate.description.itin=迭代 (for..in)
livetemplate.description.itar=遍历数组元素
livetemplate.description.ritar=反序遍历数组元素
flex.compiler.vm.options.title=ActionScript Flex 编译器 VM 选项(&F)

create.skin=创建皮肤 ''{0}''
invalid.element.name=无效的 {0} 名称\: {1}
element.name.empty={0} 名称为空
choose.host.component=选择主机组件
css.inspections.stray.brace=Flex CSS 中的杂散大括号
css.inspections.stray.closing.brace=右大括号没有相应的左大括号
css.inspections.stray.opening.brace=左大括号没有相应的右大括号
choose.parent.component.dialog.title=选择父级组件
intention.create.subclass.or.implement.interface=创建子类或实现接口
intention.create.event.handler=创建事件处理程序

threads=线程
processes=进程
using.builtin.compiler=使用内置的编译器 shell，最多 {0} 个并行线程
using.mxmlc.compc=使用 Flex SDK 中的 mxmlc/compc 工具，最多 {0} 个并行进程
or.asc.2.0=，或 ASC 2.0(若有)，用于纯 ActionScript 构建配置
see.flex.compiler.page=在 {0} | 编译器 Flex 编译器页面中查看编译器设置
can.not.use.built.in.compiler.shell=无法使用内置的编译器 shell，原因是为不同的构建配置配置了不同的 Flex SDK。

add.doc.url.button=添加文档 URL

generating.flex.configs=生成 Flex 编译器配置文件
generating.flex.config.for=为 {0} 生成 Flex 编译器配置文件
flexmojos.warning.short=<html>无法生成 Flex 编译器配置文件。<br><a href\="">详细信息...</a></html>
flexmojos.warning.detailed=<html><p>IntelliJ IDEA 无法生成 <b>Flex 编译器配置文件</b>和其他辅助文件<br>(target/[project_name]-config-report.xml and target/classes/config-[version]/*.*)</p><br><p>这些文件对于 Flexmojos 项目中正确进行代码突出显示、补全和编译必不可少。<br>要确保所需文件处于最新状态，请从命令行运行以下 Maven 命令\: </p><pre><b>mvn compile -DconfigurationReport\=true</b></pre></html>

flexmojos4.details.start=日志中提供了完整的信息(帮助 | 显示日志)\n\
\n\
{0}
flexmojos4.warning=无法生成 Flex 编译器配置文件。\n\
{0}
flexmojos4.warning.with.link=<html>无法生成 Flex 编译器配置文件。<br><a href\="">详细信息...</a></html>
flexmojos.maven.plugin.outdated.warning=请从您的 POM ({0}) 中删除过时的 idea-flexmojos-maven-plugin

flexmojos.project.import=Flexmojos 项目导入
run.when.ide.builder.turned.off=为<a href\="BuildConfiguration">构建配置 ''{0}''</a>(模块 ''{1}'')设置了<html>“跳过编译”标志。<br>启动的应用程序可能丢失或丢过时。<br><br><a href\="DisableWarning">禁用警告</a></html>
run.when.compile.before.run.turned.off=<html>此<a href\="RunConfiguration">运行配置</a>的“启动前构建”选项已关闭。<br>已启动的应用程序可能丢失或已过时。<br><br><a href\="DisableWarning">禁用警告</a></html>
flex.sdk.3.mac.debug.problem=<html>Flex SDK {0} 中的调试器不适用于 Flash Player11.x。<br/>建议在<a href\="RunConfiguration">运行配置</a>的“使用 SDK 中的调试器”字段选择 Flex SDK 4.x。
edit.configuration.title=编辑所选配置
replace.base.component.prompt=基本组件 ''{0}'' 替换为 ''{1}''?
replace.base.class.prompt=基类 ''{0}'' 替换为 ''{1}''?
create.edge.title=创建边缘
create.extends.relationship.command.name={0} 扩展 {1}
create.implements.relationship.command.name={0} 实现 {1}
base.component.needed.message=无法移除与基本组件的关系
remove.edge.title=移除边缘
remove.inheritance.link.prompt=移除 ''{0}'' 和 ''{1}'' 之间的继承链接?
remove.relationship.command.name=移除继承关系
move.0=移动{0}{1}
move.file.local.0=移动内部 {0} {1}
move.elements=移动指定的元素
move.command.name=移动{0},{1}
element.to.be.moved.to={0}被移动到{1}
elements.to.be.moved.to=要移至 {0} 的元素
references.in.code.to.0=在代码中引用到{0}
package.name.title=包名称\:
to.package.title=目标包\:
element.to.be.moved.to.upper.level=内部 {0} 将移至上层 ({1})
move.to.upper.level.command.name=将内部 {0} 移至 {1}
references.in.code.to.inner.0=内部 {0} 的代码中的引用
element.name={0} 名称(&N)\:
android.application.launched=在设备上启动的 Android 应用程序
ios.application.packaged.to.run=<html>iOS 应用程序包<a href\=""> {0} </a>已成功创建。<br>您现在可以使用 iTunes 将其安装在设备上。</html>
ios.application.packaged.to.debug=<html>iOS 应用程序包<a href\=""> {0} </a>已成功创建。<br>您现在可以使用 iTunes 在设备上进行安装。<br><br>调试器正在等待在该设备上启动的应用程序... </html>
ios.application.installed.to.run=已成功安装 iOS 应用程序 ''{0}''，\n\
现在您可以在设备上启动它了。
ios.application.installed.to.debug=已成功安装 iOS 应用程序 ''{0}''，\n\
现在您可以在设备上启动并开始调试了。
ios.simulator.application.launched=在 iOS 模拟器上启动的应用程序

css.flex.dialect.name=Flex
unexpected.empty.adt.output=ADT 工具无输出
air.mobile.version.problem.title=AIR 版本
air.ios.debug.via.usb.requires.3.4=要通过 USB 调试 iOS 应用程序，必须具备 <b>AIR 3.4 或更高版本。</b>
air.ios.simulator.requires.3.3=要在 iOS 模拟器上运行应用程序，必须具备 <b>AIR 3.3 或更高版本</b>。
air.captive.packaging.requires.3.0=要使用  captive runtime 创建 AIR 包，必须具备<b> AIR 3.0 或更高版本</b>。
air.mobile.ios.fast.packaging.requires.2.7=要以解释器模式(快速打包)创建 iOS 包，必须具备 <b>AIR 2.7 或更高版本</b>。
air.mobile.packaging.requires.2.6=要创建 AIR 移动包，必须具备 <b>AIR 2.6 或更高版本</b>。
air.mobile.packaging.version.problem=<html>{0}<br><br>SDK ''{1}'' 包含 AIR {2}。<br>您可以执行下面的一项操作\:<ul><li>在当前使用的 Flex SDK 之上解压缩 AIR SDK {3} 或更高版本</li><li>使用已包含 AIR {3} 或更高版本的 Flex SDK 的另一个版本</li></ul></html>
launch.android.application.title=启动 Android 应用程序
launching.android.application=启动 Android 应用程序 {0}
launch.ios.application.title=启动 iOS 应用程序
launching.ios.application=启动 iOS 应用程序 {0}
adb.forward.title=ADB 前向
check.ios.devices.title=检查 iOS 设备
checking.ios.devices=正在检查 iOS 设备
more.than.one.ios.device=多台 iOS 设备已连接到计算机
idb.forward=IDB 前向
idb.forward.title=IDB 前向
packaging.application=打包 {0} 应用程序
air.application.created=创建的 <html>AIR {0, choice, 1\#应用程序|2\#应用程序}\: <br>{1}</html>
dialog.edit.template.checkbox.mxml=MXML(&M)
air.runtime.version.title=AIR Runtime 版本
air.runtime.not.installed=设备上未安装 AIR Runtime。\n\
SDK ''{0}'' 包含 AIR Runtime {1}。\n\
\n\
您要安装吗?
update.air.runtime.question=设备上已安装 AIR Runtime。\n\
SDK ''{0}'' 包含 AIR Runtime {1}。\n\
\n\
您想安装更新的版本吗?
check.air.version.title=检查 AIR 版本
checking.air.version=正在检查 AIR 版本
uninstall.air.runtime.title=卸载 AIR Runtime
uninstalling.air.runtime=正在卸载 AIR Runtime
install.air.runtime.title=安装 AIR Runtime
installing.air.runtime=正在安装 AIR Runtime {0}
create.android.package.title=创建 Android 包
create.ios.package.title=创建 iOS 包
creating.android.package=正在创建 Android 包
creating.ios.package=正在创建 iOS 包
install.android.application.title=安装 Android 应用程序
install.ipa.on.simulator.title=在 iOS 模拟器上安装应用程序
install.ios.app.title=安装 iOS 应用程序
installing.0=正在安装 {0}
uninstall.android.application.title=卸载 Android 应用程序
uninstall.ios.simulator.application.title=从 iOS 模拟器卸载应用程序
uninstalling.0=正在卸载 {0}
clear.directive.state.specific.error='@Clear' 指令只能用于特定于状态的样式属性
clear.directive.IStyleClient.error='@Clear()' 指令仅允许实现 mx.styles.IStyleClient 接口的类的样式属性
unknown.color.error=未知颜色\: ''{0}''
sdk.not.set=未设置 SDK
output.file.name.not.set=未设置输出文件名
output.file.wrong.extension=输出文件名必须有 {0} 扩展名
not.a.css.runtime.stylesheet=文件 ''{0}'' 不能用作运行时样式表，仅允许使用 CSS 文件。
css.not.found=运行时样式表\: 文件不存在\: {0}
file.to.include.in.swc.not.found=要包含在 SWC 中的文件\: 文件 ''{0}'' 不存在
output.folder.not.set=未设置输出文件夹
flexunit.output.folder.not.set=未设置项目输出文件夹或其路径并非绝对路径(FlexUnit 需要绝对路径)
output.folder.not.absolute=输出文件夹的路径必须为绝对路径\: {0}
html.template.folder.not.set=未设置包含 HTML 包装器模板的文件夹
html.template.folder.not.found=不存在包含 HTML 包装器模板的文件夹\: ''{0}''
package.file.name.not.set=未设置 {0} 包文件名
packaging.options.empty.file.name={0} 个打包选项，要打包的文件\: 表中的路径为空
packaging.options.empty.relative.path={0} 个打包选项，要打包的文件\: 表中的相对路径为空
folder.to.package.includes.output={0} 个打包选项\: 要打包的文件夹包含输出文件夹\: {1}
packaging.options.bad.ios.sdk.path={0} 个打包选项\: 在 {1} 找不到 iOS SDK
ios.provisioning.profile.not.set=未设置 iOS 预置配置文件
ios.provisioning.profile.not.found=找不到 iOS 预置配置文件\: {0}
keystore.not.set={0} 个签名选项\: 未设置 keystore
keystore.not.found={0} 个签名选项\: 找不到 keystore 文件\: {1}
packaging.options.relative.path.not.matches={0} 个打包选项，要打包的文件\: 相对文件夹路径与其完整路径不匹配\: {1}
packaging.options.file.not.found={0} 个打包选项，找不到文件\: {1}
additional.config.file.not.found=找不到其他编译器配置文件\: {0}
bc.dependency.problem=发现禁止的依赖项\: \n\
构建配置 ''{0}'' ({2}，模块 ''{1}'')\n\
取决于构建配置 ''{3}'' ({5}，模块 ''{4}'')\n\
依赖项类型\: {6}
run.configuration.0=运行配置 ''{0}''
project.setup.problem=项目设置问题\: {0}
project.setup.problem.title=项目设置问题
bc.dependency.does.not.exist=构建配置 ''{0}'' (模块''{1}'') 不存在。\n\
设置为构建配置 ''{2}'' (模块 ''{3}'')的依赖项
bc.not.specified=未指定构建配置
module.does.not.contain.bc=模块 ''{0}'' 不包含构建配置 ''{1}'' 
bc.does.not.produce.app=构建配置 ''{0}'' (模块 ''{1}'')不会生成可运行的应用程序
android.disabled.in.bc=未为构建配置 ''{0}'' (模块 ''{1}'')启用 Android 支持
ios.disabled.in.bc=未为构建配置 ''{0}'' (模块 ''{1}'')启用 iOS 支持
bc.0.module.1.android.custom.descriptor.not.set=构建配置 ''{0}'' (模块 ''{1}'')\: \n\
未设置自定义 Android 应用描述符路径
bc.0.module.1.ios.custom.descriptor.not.set=构建配置 ''{0}'' (模块 ''{1}'')\: \n\
未设置自定义 iOS 应用描述符路径
bc.0.module.1.custom.descriptor.not.set=构建配置 ''{0}'' (模块 ''{1}'')\: \n\
未设置自定义应用描述符路径
bc.0.module.1.android.custom.descriptor.not.found=构建配置 ''{0}'' (模块 ''{1}'')\: \n\
找不到自定义 Android 应用描述符\: \n\
{2}
bc.0.module.1.ios.custom.descriptor.not.found=构建配置 ''{0}'' (模块 ''{1}'')\: \n\
找不到自定义 iOS 应用描述符\: \n\
{2}
bc.0.module.1.custom.descriptor.not.found=构建配置 ''{0}'' (模块 ''{1}'')\: \n\
找不到自定义应用描述符\: \n\
{2}
bc.0.module.1.air.version.mismatch.warning=构建配置 ''{0}'' (模块 ''{1}'')\:<br>应用程序描述符 ({2}) 中的 AIR 版本与 AIR SDK 版本不匹配\: {3}。<br>{4}
custom.descriptor.not.set=未设置自定义 {0} 应用描述符的路径
custom.descriptor.not.found=找不到自定义 {0} 应用描述符\: {1}
air.version.mismatch.warning=警告\: {0} 应用程序描述符 {1} ({2}) 中的 AIR 版本与 AIR SDK 版本不匹配\: {3}
same.output.files=输出文件与构建配置 ''{0}'' (模块 ''{1}'') 相同\: {2}
same.output.files.as.in.bcs=输出文件与构建{0, choice, 1\#配置|2\#配置} {1} 相同\: {2}
sdk.does.not.support.air.mobile=Flex SDK {0} 不支持 AIR 移动开发
sample.app.name.empty=未指定示例应用程序文件名
sample.app.incorrect.extension=示例应用程序必须具有 .mxml 或 .as 文件扩展名
failed.to.create.folder=创建文件夹 {0} 失败\: \n\
{1}
create.html.wrapper.template.title=创建 HTML 包装器模板
selected.path.not.folder=所选路径不是文件夹\: \n\
{0}
folder.not.empty.clear.or.overwrite=所选文件夹不为空。\n\
您要移除其内容还是保留现有文件(在后一种情况下，某些文件可能会被覆盖)?
folder.not.empty.clear.option=移除(R)
folder.not.empty.keep.option=&保持
folder.not.empty.cancel.option=取消
failed.to.delete=移除文件失败\: \n\
{0}
html.wrapper.in.sdk.not.found=在 SDK 安装中找不到包含 HTML 包装器模板的文件夹\: \n\
{0}
create.air.descriptor.template.title=创建 AIR 描述符模板
use.same.descriptor.for.android.and.ios=您想将创建的 AIR 描述符模板用于 Android 和 iOS 打包吗?
file.exists.replace.question=您要替换现有文件 ({0}) 吗?
default.compiler.options.for.module.title=模块 ''{0}'' 的默认编译器选项
default.compiler.options.for.project.title=项目 ''{0}'' 的默认编译器选项
overridden.in.config.file={0} 被其他编译器配置文件覆盖。实际值\: {1}
main.class.and.output.overridden.in.config.file=主类和输出路径在其他编译器配置文件中被覆盖
actual.value.from.config.file.0=配置文件中的实际值\: {0}
set.up.sdk.title=设置构建配置 SDK
choose.build.configuration.popup.title=模块 ''{0}'' 的活动 Flash 构建配置
active.bc.widget.tooltip=Flash 构建配置 ''{0}'' 用于模块 ''{1}'' 中的源代码突出显示和补全
active.bc.widget.empty.tooltip=<html>此窗格显示了上下文中该模块的活动 Flash 构建配置。<br>活动构建配置用于突出显示和补全源代码。</html>
active.bc.widget.empty.text=Flash 构建配置
flex.sdk.presentable.name=Flex/AIR SDK
add.build.configuration.title=添加构建配置(模块 ''{0}'')
copy.build.configuration=复制构建配置 ''{0}'' (模块 ''{1}'')
build.configurations.popup.separator.text=构建配置
module.sdk.label=模块 SDK(&S)\:
project.sdk.label=项目 SDK(&S)\:
bc.0.module.1.problem.2=构建配置 ''{0}'' (模块 ''{1}'')\: {2}
bc.tab.general.display.name=选项
bc.tab.dependencies.display.name=依赖
bc.tab.compiler.options.display.name=编译器选项
bc.tab.air.desktop.display.name=AIR 包
bc.tab.android.display.name=Android
bc.tab.ios.packaging.display.name=iOS
bc.problem.no.sdk=未定义 SDK。
bc.problem.sdk.not.found=找不到 Flex SDK ''{0}''。
bc.problem.dependency.module.not.found=缺少依赖项模块 ''{0}''。
bc.problem.dependency.bc.not.found=模块 ''{1}'' 中缺少依赖项构建配置 ''{0}''。
bc.structure.element.type.name=构建配置
can.not.package.bc=<html><b>{0}</b>\: {1}</html>
package.bc.with.disabled.compilation=<html>为以下构建{0, choice, 1\#配置|2＃配置} 禁用编译\: <br><br>{1}<br>现有 SWF {0, choice, 1\#文件|2\#文件} 可能已过时。<br><br>根据现有的SWF {0, choice, 1\#文件|2\#文件} 创建{0, choice, 1\#包|2\#包}?</html>
package.air.application.title=打包 AIR 应用程序
packaging.air.application=正在打包 {0} 应用程序\: {0}
failed.to.create.air.package=<html>无法打包 AIR 应用程序 {0}\: <br><br>{1}<br><br>[<a href\="adt.command.line">ADT 命令行</a>]</html>
failed.to.create.air.package.truncated=<html>无法打包 AIR 应用程序 {0}\: <br><br>{1}<br><br>[<a href\="full.error.message">完整错误消息</a>]<br>[<a href\="adt.command.line">ADT 目录行</a>]</html>
copying.0=正在拷贝{0}...
add.bc.dependency.dialog.title=添加依赖项
add.dependency.bc.dialog.label=选择要依赖的构建配置\: 
no.applicable.bcs=找不到适用的构建配置
choose.bc.dialog.title=选择 Flash 构建配置
choose.bc.dialog.label=库 ''{0}'' 将添加到选定的构建配置\: 
swc.libraries.root.detector.name=SWC 或 ANE 库
docs.root.detector.name=文档
as.libraries.root.detector.name=原始 ActionScript 库
sources.root.detector.name=库源文件
swc.folders.root.detector.name=包含 SWC 或 ANE 的文件夹
add.module.library.action.text=新建库...
documentation.order.root.type.name=文档
items.to.include.in.swc.dialog.title=要包含在 SWC 中的文件和文件夹
rlms.dialog.title=运行时加载的模块
choose.rlm.main.class.title=选择运行时加载的模块的主类
css.files.to.compile.dialog.title=要编译的 CSS 文件
different.debug.settings=无法同时为  {0, choice, 1\#Android |2\#iOS} 创建可调试包，也无法同时为  {0, choice, 1\#Android |2\#iOS} 创建不可调试的包
compilation.is.switched.off=编译已关闭，并且输出 Swf 不存在
main.class.is.not.a.subclass.of=主类 ''{0}'' 不是 {1} 的 public 子类。
change.bc.type.title=更改构建配置类型
bc.dialog.up.down.tooltip=使用上下键更改目标平台，按住 Shift 键更改输出类型
check.flash.app.compiled.before.launch.notification.group=启动前未编译 Flash 应用
0.module.1=''{0}'' (模块 ''{1}'')
open.project.structure=项目结构...
autodetected.source.root.type=ActionScript/Flex
create.bc.action.text=Flash 构建配置
create.bc.action.description=创建新的 Flash 构建配置
library.editor.title.plural=库
library.editor.title.singular=库
make.before.launch.warning.disabled=禁用有关跳过编译的警告。\n\
要再次启用，请使用“事件日志”工具窗口中的“设置”按钮。
sdk.version.unknown=无法读取 SDK ''{0}'' 的版本。确保 [SDK 主页]/flex-sdk-description.xml (或 [SDK 主页]/air-sdk-description.xml)文件未损坏，然后尝试重新创建 SDK
air.sdk.requires.pure.as=构建配置应标记为“纯 ActionScript”，因为 AIR SDK ''{0}'' 不包含 Flex 组件
html.wrapper.folder.clash=包含 HTML 包装器模板的文件夹与 {0} 冲突\: {1}
html.wrapper.folder.clash.for.dialog=路径与 {0} 冲突\: {1}
take.wrapper.template.from.sdk=从以下 Flex/AIR SDK 中获取 HTML 包装器模板(&T)\:
choose.library.files.description=<html>选择 *.swc 或 *.ane 文件和/或包含 *.swc、*.ane 或原始 ActionScript 文件的文件夹。<br>{0} 将分析所选文件夹的内容，并自动将其中包含的文件分配给适当的类别(类、来源和文档)。</html>
add.shared.library.dependency.action.text=项目或全局库...
add.dependency.popup.title=在其中添加依赖项\: 
add.dependency.action.name=添加依赖项
add.library.components.action.name=添加库组件(&L)...
uml.calculating.dependencies.message=计算依赖项
uml.dependencies.one.to.one=一对多
uml.dependencies.one.to.many=一对多
uml.dependencies.usages=用法
uml.dependencies.self=自我链接
uml.dependencies.create=创建
own.lib.used.as.3rd.party=对检测到的文件 {0} 的依赖，即构建配置 ''{1}'' (模块 ''{2}'')的输出。更为典型的情况是，一个构建配置依赖于另一个构建配置，而不是依赖于其输出。
instead.setup.dependency.on.bc=替换为对构建配置 ''{0}'' (模块 ''{1}'')的依赖
uml.create.relationship.label=<html>&laquo;创建&raquo;</html>
ios.simulator.on.mac.only.warning=iOS 模拟器仅在 Mac OS 中可用
ios.simulator.on.mac.only.button.text=iOS 模拟器(仅 Mac)
ios.simulator.sdk.not.set=未设置 iOS 模拟器 SDK 的路径
ios.simulator.sdk.not.found=找不到 iOS 模拟器 SDK\: {0}
cant.execute.flexunit1.for.pure.as.bc=无法为纯 ActionScript 构建配置执行 FlexUnit 1 测试。请使用 FlexUnit 4 或更高版本。
locales.dialog.label=Flex SDK ''{0}'' 支持的区域设置\: 
new.flex.component.command.name=创建 MXML 组件
create.flex.component.intention.name=创建 MXML 组件 ''{0}''
new.flex.component.action.description=创建新的 MXML 组件
new.flex.component.dialog.title=新的 MXML 组件
new.flex.component.uml.action.text=MXML 组件
parent.component.label.text=父组件(&C)\:
parallel.compilation.hint.title=提示
parallel.compilation.hint=独立 Flash 构建配置的并行编译<br/>可以提高编译性能。<br/><br/><a href\="enable">启用并行编译</a> <a href\="open">打开编译器设置 </a>
parallel.compilation.enabled=已启用并行编译
see.settings.compiler=要配置编译器设置，请使用<a href\="">设置->编译器</a>页面。
define.0=声明条件编译器定义 ''{0}''
failed.to.read.app.id=无法从以下文件读取应用程序 Id\: \n\
{0}
add.as.library.title=添加为库
bc.output.file.source.item={0}\: 仅输出文件 ({1})
bc.output.file.and.wrapper.source.item={0}\: 输出文件和 HTML 包装器
bc.output.folder.source.item={0}\: 整个输出文件夹的内容

# Annotator
javascript.validation.message.no.return.value.required.for.constructor=从构造函数中返回不需要返回值
configurable.FlexCompilerProjectConfigurable.display.name=ActionScript \\Flex 编译器(&F)
remove.annotation.from.class=从类中移除注释
this.will.remove.relationship.link.between.classes=这将移除类之间的关系