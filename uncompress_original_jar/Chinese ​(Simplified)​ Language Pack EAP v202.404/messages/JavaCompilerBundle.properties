message.category.error=错误
message.category.warning=警告
message.category.information=信息
message.category.statistics=统计
error.copying=错误 拷贝{0}\n到{1}\:\n{2}
file.copying.compiler.description=文件复制编译器
error.javac.out.of.memory=内存不足. 在 项目属性|编译器 设置中增加最大堆大小.
progress.loading.classes=加载类...
progress.compiling.class=编译 {0}...
progress.parsing.file=解析 {0}...
action.compile.description.module=模块 ''{0}''
action.compile.description.selected.files=选定文件
rebuild.lvcs.label.no.errors=''{0}''没有错误
rebuild.lvcs.label.with.errors=''{0}''没有错误
action.make.selected.modules.text=构建选定的模块 (_M)
message.resource.patterns.format.changed=资源模式的格式发生变化.\n{0} 无法转换现有的正则表达式模式\:\n{1}\n请以新格式输入模式字符串.\n每个资源模式可能包含以下通配符\:\n? - 一个字符\n* - 零或更多的字符\n\! - 否定模式 (仅在模式开始时允许)\\u4F7F用 ; (分号) 分隔资源模式;\n避免 "\!" 带有反斜杠 ("\")的字符.\n您可能还需要修改模板项目设置.\\u6309''{2}''接受输入的模式, ''{3}''将默认模式加载新格式.
pattern.conversion.dialog.title=模式转换
error.bad.resource.patterns=以下资源模式格式错误\:{0}
bad.resource.patterns.dialog.title=格式不正确的资源模式
compiler.results.export.text.prefix=行 ({0})
compiler.error.exception=错误\: {0}
status.compilation.aborted=编译中止
status.all.up.to.date=所有文件都是最新的
compiler.error.failed.to.delete=无法删除 {0}
compiler.build.messages.classes.check.uptodate=构建结果是所请求编译范围的最新结果。\n后续增量构建不会执行任何操作。
compiler.build.messages.classes.check.outdated=构建结果对于所请求的编译范围已过时。\n后续增量构建将针对更改的源码编译文件，并移除先前构建的过时结果。
progress.updating.caches=更新缓存...
compiler.content.name.rebuild=重建
compiler.content.name.recompile=重新编译
compiler.content.name.make=构建
modules.classpath.title=依赖
status.compilation.completed.successfully.with.warnings=成功编译完成 {0} {0,choice, 0\#个警告|1\#个警告|2\#个警告}
status.compilation.completed.successfully=编译成功完成
status.compilation.completed.successfully.with.warnings.and.errors=编译完成 {0} {0,choice, 0\#个错误|1\#个错误|2\#个错误} 和 {1} {1,choice, 0\#个警告|1\#个警告|2\#个警告}
progress.executing.precompile.tasks=执行预编译任务...
progress.executing.postcompile.tasks=执行后编译任务...
error.failed.to.create.directory=无法创建目录 {0}
error.chunk.modules.must.have.same.jdk=以下模块必须具有相同的JDK分配, 因为它们之间的循环依赖关系\:\n{0}\n请更新模块配置
error.chunk.modules.must.have.same.language.level=以下模块必须具有相同的语言级别,因为它们之间存在循环依赖关系\:\n{0}\n请更新模块配置
warning.sources.under.output.paths=目前是在编译器选项 "在重建时清除输出目录" 中.\n但是,源文件可能存在于以下输出路径中\:\n{0}\n将在不清除输出目录的情况下进行编译.
action.compiler.properties.text=编译器属性
actions.exclude.from.compile.text=从编译中排除
progress.checking.dependencies=检查依赖关系...
progress.found.dependent.files=找到{0}个依赖文件
error.compiler.internal.error=编译器内部错误. 进程以退出代码{0}终止
error.bad.class.file.format=损坏的文件格式\:\n{0}
java.compiler.description=Java编译器
resource.compiler.description=资源编译器
rmi.compiler.description=RMI编译器
error.jdk.not.specified=无法启动编译器\: 未指定SDK的模块{0,choice, 1\#|2\#\n}{1}  .\n在 项目结构 对话框中指定SDK.
error.output.not.specified=无法开始编译\: 没有指定输出路径为模块{0,choice, 1\#|2\#\n} {1}.\n在 项目结构 对话框中指定输出路径.
statistics.files.classes=文件\: {0} - 类\: {1}
compiler.javac.name=Javac
javac.error.jdk.home.missing=找不到JDK''{0}''的主目录''{1}''.\n更新JDK配置.
javac.error.unknown.jdk.version=无法确定JDK的版本 {0}.\n更新JDK配置.
compiler.configurable.display.name=编译器
label.option.compile.in.background=在后台编译 (&O)
label.option.clear.output.directory.on.rebuild=在重新构建时清除输出目录 (&L)
label.option.resource.patterns.text=资源模式\:
error.compiler.configurable.malformed.patterns=以下资源模式格式错误\:\n{0}
exclude.from.compile.table.path.column.name=路径
exclude.from.compile.table.recursively.column.name=递归
no.excludes=不排除
option.use.compiler.text=使用编译器\:
java.compiler.option.additional.command.line.parameters=附加命令行参数\:
java.compiler.option.generate.no.warnings=不生成警告
java.compiler.option.generate.debugging.info=生成调试信息
java.compiler.option.report.deprecated=报告使用已弃用的功能
javac.option.max.heap.size=最大堆大小 (MB)\:
javac.options.group.title=Javac 选项
rmic.option.generate.iiop.stubs=生成IIOP存根
rmic.option.enable.rmi.stubs=启用RMI存根生成
compile.progress.title=编译进度
statistics.error.count={0} 个错误
statistics.warnings.count={0} 个警告
compiler.running.dialog.title=编译器运行中
warning.compiler.running.on.project.close=编译器正在运行. 继续进行项目关闭?
warning.compiler.running.on.toolwindow.close=编译器正在运行. 终止它?
add.notnull.assertions=为非空注释的方法和参数,添加运行时断言 (&A)

compiler.eclipse.name=Eclipse
eclipse.options.group.title=Eclipse 选项

#artifacts
packaging.element.text.output.root=<输出根>
label.text.main.class=主类 (&M)\:
label.text.class.path=类路径 (&P)\:
element.type.name.artifact=工件
dialog.title.choose.artifacts=选择 Artifacts
node.text.0.directory.content=''{0}'' 目录内容
element.type.name.library.files=库文件
node.text.0.compile.output=''{0}'' 编译输出
node.text.0.test.compile.output=''{0}'' 测试编译输出
node.text.0.with.dependencies=''{0}'' 和依赖关系
node.text.0.module.sources=''{0}'' 源
element.type.name.module.source=模块源
element.type.name.module.output=模块输出
element.type.name.module.test.output=模块测试输出
element.type.name.directory=目录
element.type.name.archive=档案
artifact.type.plain=其它
build.artifacts.before.run.description.empty=编译 Artifacts
build.artifacts.before.run.description.single=编译 ''{0}'' artifact
build.artifacts.before.run.description.multiple=编译 {0} artifacts
build.artifacts.before.run.selector.title=编译 Artifacts

message.text.destination.is.directory={0} 目的地是一个目录.
message.text.error.copying.file.to.file=拷贝文件 ''{0}'' 到 ''{1}''错误.
message.text.compiling.item.deployment.descriptor.could.not.be.found=编译 {0}\: 无法找到部署项目''{1}''
message.text.compiling.module.message=编译 {0}\: {1}
message.text.xml.file.invalid=XML文件 ''{0}'' 无效
mesage.text.deployment.descriptor.file.not.exist=部署描述符文件 ''{0}'' 不存在
message.text.deployment.description.invalid.file=无效文件
warning.text.file.has.been.changed=文件在编译期间已更改, 跳过检查验证

dialog.message.compilation.of.unloaded.modules.failed=项目中有未加载的模块取决于更改的文件。<br>这些模块的编译已完成，但出现错误。
dialog.title.compilation.failed=编译失败
button.text.checkin.handler.commit=提交 (&C)
button.text.checkin.handler.show.errors=展示错误 (&S)
checkbox.text.compile.affected.unloaded.modules=编译受影响的已卸载模块 (&U)

#artifacts
dialog.title.output.directory.for.artifact=Artifact输出目录
chooser.description.select.output.directory.for.0.artifact=选择''{0}'' artifact的输出目录

#package file action
action.name.package.file=包文件
action.description.package.file=更新相应artifacts中的文件
message.tect.package.file.io.error=IO异常\:\n{0}
command.name.package.file=包文件
status.text.file.has.been.packaged=文件{1}已封装在{2}.
action.name.package.files=包文件

# validation
validation.display.name=验证
action.name.exclude.from.validation=从验证中排除
no.validators=没有验证器可用
label.option.autoshow.first.error=在编辑器中自动显示错误 (&E)
label.option.display.notification.popup=在构建完成时显示通知

compiler.ref.service.validation.task.name=向后引用索引验证
compiler.ref.service.validation.progress.text=验证反向参考指数
java.compiler.option.prefer.target.jdk.compiler=尽可能使用模块目标JDK的编译器
configurable.CompilerUIConfigurable.display.name=常规
configurable.AnnotationProcessorsConfigurable.display.name=注解处理器
settings.configure.annotations=配置注解(&C)…
settings.build.project.automatically=自动构建项目
settings.compile.independent.modules.in.parallel=并行编译独立模块
settings.rebuild.module.on.dependency.change=依赖关系更改时重建模块
settings.build.process.heap.size=构建进程堆大小 (MB)\:
settings.shared.build.process.vm.options=共享构建过程 VM 选项\:
settings.user.local.build.process.vm.options=用户本地构建过程 VM 选项 (重写共享选项)\:
settings.auto.build.only.works.while.not.running=(仅在不运行/不调试时工作)
settings.parallel.module.compile.may.require.larger.heap.size=(可能需要更大的堆)
settings.warning=<html>警告\!<br>如果已启用选项“重建时清除输出目录”，存储生成源的目录的全部内容将在重建时清除。</html>
settings.use.release.option.for.cross.compilation=使用 '--release' 选项进行交叉编译 (Java 9 及更高版本)
settings.project.bytecode.version=项目字节码版本\:
settings.per.module.bytecode.version=按模块字节码版本\:
settings.same.as.language.level=与语言级别相同
settings.all.modules.will.be.compiled.with.project.bytecode.version=所有模块都将使用项目字节码版本进行编译
settings.module.column=模块
settings.target.bytecode.version=目标字节码版本
settings.recommended.in.paths=(建议在路径中使用 '/' 进行跨平台配置)
settings.override.compiler.parameters.per.module=按模块重写编译器参数\:
settings.override.module.column=模块
settings.override.compilation.options.column=编译选项
settings.additional.compilation.options=其他编译选项也同样适用于所有模块
settings.enable.annotation.processing=启用注解处理
settings.obtain.processors.from.project.classpath=从项目类路径获取处理器
settings.processor.path=处理器路径\:
settings.use.processor.module.path.compiler.option.for.java.9.and.later=使用 --processor-module-path 编译器选项 (适用于 Java 9 及更高版本)
settings.module.content.root=模块内容根
settings.module.output.directory=模块输出目录
settings.annotation.processors=注解处理器\:
settings.compiler.will.run.all.automatically.discovered.processors=编译器将运行所有自动发现的处理器
settings.annotation.processor.options=注解处理器选项\:
settings.no.processor.specific.options.configured=未配置处理器特定选项
settings.module.path.warning=假设指定的路径是 'module path'\: JAR 或包含打包 java 模块的路径。\n要确保被发现并从模块路径运行，注解处理器应打包为 java 模块并使用模块声明中的 ServiceLoader 注册。
settings.store.generated.sources.relative.to=相对于下列位置存储生成源\:
settings.production.sources.directory=生产源目录\:
settings.column.option.name=选项名称
settings.column.value=值
settings.test.sources.directory=测试源目录\:
settings.processor.fq.name=处理器 FQ 名称
settings.validate.on.build=构建时验证
settings.exclude.from.validation=从验证中排除\:
settings.validators=验证器\:
no.compilation.problems.found=未找到编译问题
cannot.package.file=无法打包文件
packaging.files=正在打包文件
only.works.while.not.running.debugging=(仅在不运行/不调试时工作)
disabled.in.power.save.mode=(在省电模式下禁用)
path.to.ecj.compiler.tool=ecj 编译器工具的路径
choose.members=选择成员
all.modules=<所有模块>
create.jar.from.modules=从模块创建 JAR
cannot.delete.0=无法删除''{0}''。
cannot.clean.0.artifact=无法清理 ''{0}'' 工件
cleaning.artifacts=正在清理工件
clean.artifacts=清理工件
0.errors.1.warnings={0} 个错误，{1} 个警告
compilation.finished=编译已完成
meta.inf.manifest.mf.file.not.found.in.0=在 ''{0}'' 中未找到 META-INF/MANIFEST.MF 文件
0.manifest.properties=''{0}'' 清单属性\:
specify.path.to.manifest.mf.file=指定 MANIFEST.MF 文件的路径
edit.classpath=编辑类路径
synchronizing.output.directories=正在同步输出目录…
button.rebuild=重建
confirm.project.rebuild=确认项目重建
you.are.about.to.rebuild.the.whole.project=您将重建整个项目。\n运行“构建项目”?
class.can.have.more.common.super.class=类可以拥有更常见的超类
cannot.create.directory.0.1=无法创建目录 ''{0}''\: {1}
select.directory.for.meta.inf.manifest.mf.file=为 META-INF/MANIFEST.MF 文件选择目录
title.new.archive=新建存档
enter.archive.name=输入存档名称\:
action.text.move.to=移动到
title.create.new.profile=创建新的配置文件
dialog.message.profile.name=配置文件名称
title.new.directory=新建目录
dialog.message.enter.directory.name=输入目录名称\:
dialog.title.packaging.choose.module=选择模块
dialog.title.packaging.choose.library=选择库
node.excluded.flag.tooltip=排除
macro.output.path=输出路径
button.add=添加(&A)...
eclipse.compiler.cross.platform.help.message=(建议在路径中使用 '/' 进行跨平台配置)
eclipse.compiler.path.leave.empty.help.message=ECJ 批处理编译器工具路径(若留空，则使用捆绑包)\:
eclipse.compiler.proceed.on.errors.option=遇错误时继续进行