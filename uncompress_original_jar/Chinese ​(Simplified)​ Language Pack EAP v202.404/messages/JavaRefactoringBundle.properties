0.already.contains.field.1={0}已包含字段{1}.
0.already.contains.inner.class.named.1={0}已包含名为{1}的内部类.
0.already.has.parameter.named.1.use.this.name.anyway={0}已经有名为''{1}''的参数.仍然使用这个名称?
0.contains.call.with.null.argument.for.parameter.1={0}包含null参数调用的参数{1}
0.implements.1={0}实现{1}。
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class=0}{1},不会可以从{2}.
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0}方法是层次结构的一部分。您要删除多个参数吗？
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0}方法是层级的一部分。您想删除多个类型参数？
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0}是一个接口.方法的实现将被添加到所有直接实现类.继续进行吗?
0.is.an.interface.that.has.no.implementing.classes={0}是一个接口.没有实现类.
0.is.not.a.legal.java.identifier=''{0}''不是合法的java标识符
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0}是不可以从{1}.介绍了参数值,方法调用将不正确.
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0}在声明处未初始化。在接口中不允许这样的字段。
0.is.not.static.it.cannot.be.moved.to.the.interface={0} 不为 static。不能将其移至接口
0.is.used.for.writing.in.1={0}是用来写在{1}
0.or.all.directories.in.project={0} 或项目中的所有目录?
0.refactoring.is.supported.only.for.final.fields=仅 final 字段支持{0}重构
0.upcasts.an.instance.of.1.to.2={0}向上转型实例的{1}{2}.
0.uses.1.of.an.instance.of.a.2={0}{1}的使用的一个实例{2}.
0.uses.1.which.needs.class.instance={0}用{1},这需要的类实例.
0.uses.a.package.local.1={0}使用 package-private {1}
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0}使用非 static {1}，后者不作为参数传递
0.will.be.inaccessible.from.1={0}将无法从{1}
0.will.become.inaccessible.from.1={0}将变得无法从{1}.
0.will.hide.renamed.1={0}将隐藏更名为{1}
0.will.no.longer.override.1={0}将不再重写{1}
0.will.not.be.accessible.from.1.after.inlining={0}不可以从{1}在内联
0.will.override.renamed.1={0}将覆盖更名为{1}
a.package.local.class.0.will.no.longer.be.accessible.from.1=Package-local 类 {0} 将不再可以从{1}访问
accept.signature.change=接受签名变更
add.object.as.a.parameter.to.constructors.with.name=添加对象作为一个参数的构造函数与名称\:(
add.parameters.for.fields=添加参数字段\:
add.parameters.for.fields.to.constructors=添加参数字段构造函数\:
all.candidate.variables.have.types.not.in.project=所有的候选人不变量类型的项目
all.candidate.variables.have.unknown.types=所有的候选变量都未知类型
all.invocations.keep.the.method=内联所有引用并保留方法(&E)
all.references.and.remove.super.class=内联所有引用并删除类 (&A)
all.references.and.remove.the.class=内联所有引用并删除类 (&A)
all.references.and.remove.the.field=内联所有引用并删除字段 (&A)
all.references.keep.field=内联所有引用并保留字段(&E)
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=所有这些目录将被移动，并且所有对 {0} 的引用将被更改。
analyze.and.replace.usages=分析和替换用法
analyze.module.conflicts=分析模块冲突…
annotate.field.as.nonnls.checkbox=注释字段作为 @NonNls (&F)
anonymous.class.text=匿名类
anonymous.to.inner.enum.constant.cannot.refactor.message=枚举常量无法转换为内部类
anonymousToInner.class.name.label.text=类名\:
anonymousToInner.make.class.static.checkbox.text=将类设为 static(&S)
anonymousToInner.no.inner.class.name=需指定类名
anonymousToInner.parameters.panel.border.title=构造函数的参数
anonymousToInner.refactoring.name=转换匿名为内部
auto.rename.module.dialog.description=将具有以下名称的 Java 模块重命名为\:
auto.rename.module.dialog.title=重命名 Java 模块
auto.rename.module.entity=Java模块
boolean.method.result=布尔方法的结果
can.t.restore.context.for.method.extraction=无法为方法提取恢复上下文
cannot.find.or.create.destination.directory=无法找到或创建目标目录
cannot.introduce.field.in.interface=接口中不允许出现实例字段
cannot.introduce.field.in.record=记录中不允许出现实例字段
cannot.move=无法移动
cannot.move.inner.class.0.into.itself=不能移动内部类{0}到本身.
cannot.move.package.into.itself=无法移动包到其自身
cannot.replace.temp.with.query.in.interface=不能取代临时与查询界面.
caret.position.warning.message=脱字符号应置于要重构的字段、变量、方法或方法参数类型上
change.method.signature.action.name=更改方法签名
change.signature.default.value.missing.warning.message=缺少默认值。方法调用将包含空值，而不是新的参数值。
change.signature.use.any.checkbox=使用任意变量(&U)
changeClassSignature.bad.value=错误 {0} 值\: ''{1}'' 参数 ''{2}''
changeClassSignature.class.label.text=更改{0}的签名
changeClassSignature.no.type.parameters=这个类不能有类型参数
changeClassSignature.parameters.panel.border.title=参数
changeClassSignature.refactoring.name=更改类签名
changeSignature.bound.value.column=绑定值\:
changeSignature.cannot.resolve.return.type=返回类型''{0}''不能解决,继续吗?
changeSignature.default.value.column=默认值
changeSignature.exception.caller.chooser=选择要传递新异常的方法
changeSignature.exceptions.panel.border.title=异常
changeSignature.exceptions.wont.propagate=递归传播的异常的更改不会被执行
changeSignature.no.return.type=未指定返回类型
changeSignature.no.type.for.exception=指定一个类型给异常
changeSignature.no.type.for.parameter=指定一个类型给参数''{0}''
changeSignature.not.throwable.type=错误的异常类型''{0}'',应继承java.lang.Throwable
changeSignature.propagate.exceptions.title=传递异常... (&X)
changeSignature.vararg.not.last=可变参数应该在方法签名的最后
changeSignature.wrong.return.type=错误的返回类型\:''{0}''
changeSignature.wrong.type.for.exception=异常的错误类型\:''{0}''
changeSignature.wrong.type.for.parameter=的参数''{1}''错误类型\:''{0}''
checking.conflicts=正在检查冲突…
choose.the.ones.you.want.to.be.deleted=选择您想要的被删除.
class.0.already.exists=类{0}已存在
class.0.is.not.accessible.from.target.1=类{0}是不可以从目标{1}
class.0.not.found=类{0}未找到.
class.description=类{0}
class.does.not.exist.in.the.project=类不存在在这个项目.您想创建它吗?
class.does.not.have.base.classes.or.interfaces=类{0}没有基类或接口.
class.does.not.have.implicit.default.constructor=类{0}没有隐式的默认构造函数.
class.has.been.successfully.created=已成功创建类{0}.
class.is.abstract={0}为 abstract。
class.is.final.warning.message=类 {0} 为 final
class.is.interface={0}是一个接口.
class.is.never.used=类从未使用
class.name.prompt=类名\: (&N)
collect.overloads=收集重载…
comments.elements.header=匹配项被发现在注释、字符串和非标文件{0}
constructor.being.refactored.is.used.in.initializer.of.0=正在重构的构造函数在 {0} 的初始值设定项中使用。内部类 {1} 的非 static 工厂无法在此上下文中使用。生成的代码将不会编译。
constructor.description=构造函数{0}
constructor.with.builder.new.setter.prefix.dialog.message=新的 setter 前缀\:
constructor.with.builder.parameters.to.pass.to.the.builder.title=要传递到构建器的参数
constructor.with.builder.rename.setters.prefix.action.name=重命名 Setter 前缀
convert.anonymous.to.inner.action.name=转换匿名为内部...
convert.local.to.field.title=将局部转换为字段
convert.to.instance.method.title=转换为实例方法
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=所有引用类型参数的类型,不是在项目
convertToInstanceMethod.all.reference.type.parametres.have.unknown.types=所有的引用类型参数都未知类型
convertToInstanceMethod.method.is.not.static=无法执行重构\n\
方法 {0} 不为 static
convertToInstanceMethod.no.parameters.with.reference.type=有没有具有引用类型的参数
copy.class.clone.0.1=克隆{0}{1}
copy.class.copy.0.1=复制{0}{1}
copy.handler.clone.class=克隆类
copy.handler.copy.class=复制类
copy.handler.copy.class.with.dialog=复制类...
copy.handler.copy.classes.with.dialog=复制类…
copy.handler.is.not.available.during.indexing=编制索引期间无法复制类
current.class=当前类
dataflow.to.here.expand.progress=正在展开所有节点…{0}
dataflow.to.here.group.by.leaf.action.description=确定 null 是否可以流入此表达式
dataflow.to.here.group.by.leaf.action.text=按叶表达式空值分组{0, choice, 1\#|2\# (正在分析)}
dataflow.to.here.variable.dereferenced.tooltip=已取消引用变量
declaration.s.to.be.generified=声明(s)是泛型{0}
declare.final=声明 final(&F)
declare.generated.annotations=生成注释(&G)
declare.static.checkbox=声明 static(&S)
declare.static.pass.fields.checkbox=声明 static (作为参数传递字段)(&S)
declare.var.type=声明变量类型(&V)
declare.varargs.checkbox=声明可变参数 (&A)
default.visibility.border.title=默认可见性
delegate.members=委派成员 (&B)
delegating.field=正在委托字段
delete.variable.declaration=删除变量声明 (&D)
destination.directory.does.not.correspond.to.any.package=目标目录不对应于任何包
destination.package=目的包\: (&P)
directory.0.already.contains.1.named.2=目录已经包含了{0}{1}命名为"{2}"
directory.0.already.contains.a.file.named.1=目录{0}已经包含一个文件命名为"{1}"
do.not.replace=不要替换 (&N)
do.not.show.this.message.in.the.future=以后不再显示此消息 (&D)
do.you.want.to.process.overriding.methods.with.covariant.return.type=您想要使用协变返回类型处理覆盖方法?
dont.move.to.another.source.folder.option=不移动到另一个源文件夹(&D)
edit.migration.entry.title=编辑 类/包 迁移说明
edit.migration.map.title=编辑迁移地图
element.will.no.longer.be.accessible={0}将不再可以从{1}
encapsulate.fields..encapsulated.fields.visibility.border.title=封装字段的可见性
encapsulate.fields..package.local.radio=局部包 (&C)
encapsulate.fields.accessors.visibility.border.title=访问器可见性
encapsulate.fields.command.name=封装字段在{0}
encapsulate.fields.encapsulate.border.title=封装
encapsulate.fields.field.column.name=字段
encapsulate.fields.fields.to.be.encapsulated=字段封装
encapsulate.fields.fields.to.encapsulate.border.title=字段来封装
encapsulate.fields.get.access.checkbox=获取访问权限 (&G)
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.getter.exists=那已经是一个方法不同于{0}{1}的getter只返回类型.
encapsulate.fields.nothing.todo.warning.message=类具有要封装的字段
encapsulate.fields.private.radio=Private(&I)
encapsulate.fields.protected.radio=protected(&T)
encapsulate.fields.refactoring.cannot.be.applied.to.interface=封装字段重构不能应用到接口
encapsulate.fields.set.access.checkbox=设置访问权限 (&S)
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.setter.exists=那已经是一个方法{0},{1}有别于setter由返回类型只有.
encapsulate.fields.title=封装字段
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=使用访问器即使字段是可访问的
entity.name.constructor.parameter=参数
entity.name.inheritor=继承者
entity.name.test=测试
entity.name.variable=变量
entity.name.accessor=访问器
enum.description=枚举 {0}
error.cannot.resolve=不能解决{0}
error.incorrect.data=不正确的数据
error.not.supported.for.jsp={0}重构不支持JSP
error.not.supported.for.local=局部类不支持 {0} 重构
error.not.supported.for.package.info={0}重构不支持 package-info.java
error.wrong.caret.position.anonymous=光标应该定位在被重构的匿名类中
error.wrong.caret.position.constructor=光标应该定位在被重构的构造函数中
error.wrong.caret.position.local.name=光标应该定位在被重构的局部变量的名字中
error.wrong.caret.position.local.or.expression.name=光标应该定位在被重构的局部变量或表达式的名字中
error.wrong.caret.position.method=光标应该定位在被重构的方法中
error.wrong.name.input=错误的名称\:{0}
expand.method.reference.warning=方法用于方法引用.继续进行将导致转换为lambda表达式
expression.result=表达式结果
extract.chained.constructor.checkbox=提取链接构造函数 (&C)
extract.delegate.as.enum.checkbox=提取为枚举
extract.delegate.create.nested.checkbox=创建嵌套类
extract.delegate.generate.accessors.checkbox=生成访问器
extract.delegate.unable.create.warning.message=无法创建包含给定名称的类
extract.method.control.flow.analysis.failed=代码包含语法错误。无法执行必要的分析。
extract.method.error.prefix=无法提取方法。
extract.method.error.class.outside.used=局部类在所选块之外使用。
extract.method.error.class.outside.defined=局部类在所选块之外定义。
extract.method.error.many.outputs=有多个变量要返回。
extract.method.error.many.exits=有多个出口点。
extract.method.error.many.finals=存在对 final 字段的赋值。
extract.method.error.variable.in.expression=所选表达式内有一个要返回的变量。
extract.method.error.class.not.found=所选块应当是 java 类的一部分。
extract.method.object.anonymous.make.varargs.option=生成可变参数(&V)
extract.method.object.class.name=&类名\:
extract.method.object.create.anonymous.class=创建匿名类(&A)
extract.method.object.create.inner.class=创建内部类(&I)
extract.method.object.inner.class.visibility=可见性\:
extract.method.object.inner.make.static.option=设为 static(&S)
extract.method.object.inner.make.varargs.option=生成可变参数(&V)
extract.method.object.inner.visibility.package.local=package local(&K)
extract.method.object.inner.visibility.private=private(&V)
extract.method.object.inner.visibility.protected=protected(&O)
extract.method.object.inner.visibility.public=public(&B)
extract.method.object.method.name=&方法名称\:
extract.method.object.parameters=参数
extract.method.object.signature.preview=签名预览
extract.method.object.suggestion=是否要提取方法对象?
extract.parameters.to.replace.duplicates=提取参数以替换重复项
extract.subclass.command=提取子类
extractSuper.rename.original.class.to=重命名原始类到\: (&R)
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=工厂方法名称\:
failed.to.re.run.refactoring=无法重新运行重构
field.0.is.already.defined.in.the.1=字段{0}已经定义在{1}.
field.0.is.never.used=字段{0}从未使用过
field.0.is.not.accessible=字段{0}是不可以从{1}
field.0.will.hide.field.1.of.the.base.class=字段{0}将隐藏基类 {2} 的字段{1}.
field.declaration.radio=字段声明 (&D)
field.description=字段{0}
field.name=字段名称 (&F)\:
fields.to.be.refactored.should.belong.to.the.same.class=重构的字段应该属于同一个类.
functional.interface.broken=函数表达式要求功能界面准确的一种方法
generate.getter.for.delegated.component=为委派成员生成getter (&G)
generate.module.descriptors.analysing.message=正在分析依赖关系
generate.module.descriptors.build.required.message=无法生成模块描述符，因为该项目尚未构建
generate.module.descriptors.collecting.message=正在收集依赖关系
generate.module.descriptors.command.title=生成模块信息描述符
generate.module.descriptors.no.suitable.modules.message=未找到可能包含模块信息的模块
generate.module.descriptors.preparing.message=正在准备代码
generate.module.descriptors.rebuild.message=为了提高依赖关系计算的准确性，需要构建该项目。\n\
在生成模块信息描述符之前开始构建?
generate.module.descriptors.scanning.message=正在扫描编译器输出
generate.module.descriptors.title=生成模块描述符
generify.title=泛型
getter.and.setter.methods.found.for.the.field.0=Getter和setter方法发现的领域{0}.{1}它们吗?
getter.method.found.for.the.field.0=Getter方法发现田野{0}.{1}getter吗?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0}没有发现任何副本
ignore.button=忽略
information.title=信息
initializer.for.variable.cannot.be.a.constant.initializer=初始化变量的{0}不能初始化一个常数.
inline.action.name=内联
inline.anonymous.conflict.progress=正在搜索类“{0}”继承者…
inline.class.elements.header=类内联
inline.conflicts.progress=检查是否可以内联…
inline.constant.field.not.supported.for.enum.constants=枚举常量不支持 {0}
inline.field.command=内联场{0}
inline.field.elements.header=场内联
inline.field.field.name.label=字段{0}
inline.field.title=内联领域
inline.local.unable.try.catch.warning.message=无法在 try/catch 语句外内联
inline.local.used.as.resource.cannot.refactor.message=变量用作资源引用
inline.local.variable.declared.outside.cannot.refactor.message=变量在代码块外声明
inline.method.checking.tail.calls.progress=检查尾调用用法
inline.method.elements.header=方法内联
inline.method.object.action.name=内联对象
inline.method.object.suggestion.message=要内联对象和后续调用吗?
inline.parameter.cannot.find.initializer.warning.message=无法为参数找到常量初始值设定项
inline.parameter.confirmation=内联参数''{0}''与初始化''{1}''?
inline.parameter.error.hierarchy=内联参数不支持当方法是一个继承层次结构的一部分
inline.parameter.error.varargs=不支持内联可变参数
inline.parameter.method.usages.progress=正在搜索方法用法
inline.parameter.no.usages.warning.message=方法没有用法
inline.parameter.not.accessible.warning.message=在方法体内无法访问常量初始值设定项
inline.parameter.refactoring=内联参数
inline.parameter.replace.with.local.checkbox=替换为局部变量(e)\r (&E)
inline.parameter.write.usages.warning.message=不支持具有写入用法的内联参数
inline.pattern.variable.title=内联模式变量
inline.super.non.project.class.warning.message=无法内联非项目类
inline.to.anonymous.border.title=内联
inline.to.anonymous.command.name=内联类{0}
inline.to.anonymous.name.label=类{0}
inline.to.anonymous.no.abstract=abstract 类不能被内联
inline.to.anonymous.no.multiple.interfaces=实现多个接口的类不能被内联
inline.to.anonymous.no.superclass.and.interface=有超类和实现了接口的类不能被内联
inline.to.anonymous.refactoring=内联到匿名类
inline.vars.elements.header=变量以内联
inlined.method.implements.method.from.0=内联方法实现方法从{0}
inlined.method.overrides.method.from.0=从{0}内联方法重写方法
inlined.method.will.be.transformed.to.single.return.form=内联方法将转换为单个返回形式
inner.class.0.is.already.defined.in.class.1=内部类{0}已被定义在类{1}中.无论如何都继续?
inner.class.0.is.not.static=内部类 {0} 不为 static。\n\
仅 static 成员支持{1}重构。
inner.class.exists=名为''{0}''的内部类已经定义在类''{1}''中
inner.class.name=内部类名(&I)\:
instance.initializer.description=把类{0}的初始器实例化
instances.casted.to.java.lang.object=实例转换为java.lang.Object
instances.of.0.upcasted.to.1.were.found=实例的{0},{1}向上转型被发现.如果您继续下去,他们将被显示在一个单独的找到选项卡.
instances.upcasted.to.java.lang.object.found=实例向上转型到java.lang.Object对象发现
instances.upcasted.to.object=向上转型实例对象
interface.0.does.not.have.inheritors=接口{0}没有继承者.
interface.description=接口 {0}
interface.does.not.have.base.interfaces=接口{0}没有基本接口.
interface.has.been.successfully.created=已成功创建接口{0}.
introduce.constant.enum.cb=提取为枚举常量 (&E)
introduce.constant.field.of.type=常量(static final 字段)的类型(&T)\:
introduce.constant.introduce.to.class=提取参数到方法\:
introduce.constant.move.to.another.class.checkbox=移动到另一个类
introduce.constant.used.for.write.cannot.refactor.message=选定的表达式用于写入
introduce.field.field.of.type=类型的字段\: (&T)
introduce.field.static.field.of.type=static 字段的类型(&T)\:
introduce.functional.variable.pass.fields.checkbox=将字段作为参数传递 (&F)
introduce.local.variable.to.reassign.title=选择要重新分配的变量
introduce.parameter.command=提取参数{0}
introduce.parameter.convert.lambda=转换为 lambda (&C)
introduce.parameter.duplicates.progress=搜索方法重复项…
introduce.parameter.elements.header=增加参数到一个方法
introduce.parameter.object.create.inner.class=创建内部类(&I)
introduce.parameter.object.create.new.class=创建新类(&C)
introduce.parameter.object.escalate.visibility.option=升级可见性(&E)
introduce.parameter.object.existing.class.name=名称 (&N)
introduce.parameter.object.generate.accessors.option=生成访问器(&G)
introduce.parameter.object.inner.class.name=名称 (&N)
introduce.parameter.object.new.class.name=名称 (&N)
introduce.parameter.object.new.class.package.name=&包名称
introduce.parameter.object.use.existing.class=使用现有类(&U)
introduce.parameter.super.method.checkbox=重构 super 方法
introduce.parameter.to.method=提取参数到方法\:
introduced.variable.will.conflict.with.0=引入的变量与{0}冲突
introducing.variable.may.break.code.logic=引入变量可能打破代码逻辑。
invalid.expression.context=无效的表达式上下文.
invalid.target.package.name.specified=指定的目标包名称无效
invert.boolean.foreach=Foreach 参数初始值设定不能反转
invert.boolean.wrong.type=该方法的返回类型或类型的变量是重构应该是布尔
invocations.to.be.inlined=调用内联{0}
is.modified.in.loop.body={0}是修改在循环体.
javadoc.for.abstracts=JavaDoc的摘要
keep.original.signature=保留原始签名
lambda.to.reference.side.effect.warning.message=方法引用限定符中可能存在副作用。\n\
引入局部变量?
local.variable.description=局部变量{0}
local.will.be.hidden.renamed=重命名字段将隐藏{ 0 }
locate.caret.inside.a.method=定位插入符号在一个成员.
locate.duplicates.action.name=定位重复项
make.0.static=将{0}设为 static
make.method.static.title=将方法设为 static
make.static.command=将{0}设为 static
make.static.description.label=将{0} {1}设为 static
make.static.elements.header=要设为 static 的{0}
make.static.method.references.progress=搜索方法引用
make.static.methods.to.propagate.dialog.title=选择要传递 static 的方法
method.0.is.overridden.by.1=方法{0}被{1}重写。
method.0.will.hide.method.of.the.base.class=方法{0}将隐藏基类{1}的此方法。
method.0.will.implement.method.of.the.base.class=方法{0}将实现基类{1}的一个方法。
method.0.will.override.a.method.of.the.base.class=方法{0}将重写基类{1}的一个方法。
method.call.would.be.linked.to.0.after.rename=重命名后，方法调用将被链接到“{0}”
method.column=方法
method.description=方法{0}
method.does.not.have.a.body=方法{0}没有方法体。
method.duplicates.found.message=已找到 {0, choice, 1\#1 个代码段|2\#{0,number} 个代码段}
method.has.an.empty.body=方法有一个空的{0}身体.
method.is.not.a.constructor=方法是不是构造器。
migration.class=类
migration.dialog.ok.button.text=运行
migration.dialog.title=包和类迁移
migration.edit.button=编辑...
migration.entry.class=类
migration.entry.new.name=新名称\:
migration.entry.old.name=旧名称\:
migration.entry.package=包
migration.map.description.label=图描述\:
migration.map.name.prompt=地图的名字\:
migration.new.name.column.header=新名字
migration.no.usages.found.in.the.project=没有在项目发现用法
migration.old.name.column.header=旧名称
migration.package=包
migration.package.with.subpackages=包和子包
migration.remove.button=移除
migration.title=迁移
migration.type.column.header=类型
move.class=移动类…
move.class.refactoring.cannot.be.applied.to.anonymous.classes=移动类重构不能应用于匿名类
move.class.to.inner.command.name=移动{0},{1}
move.class.to.inner.move.to.self.error=不允许移动类到自身
move.class.to.inner.nonstatic.error=不允许将类移动到非 static 内部类
move.classes=移动类...
move.classes.and.packages=移动类和包…
move.classes.command=移动的{0},{1}包
move.classes.destination.make.inner=使内部类(
move.classes.destination.package.prompt=要打包\:
move.classes.destination.to.package=包装(dg
move.classes.invalid.package.name.warning.message=无效的包名称
move.classes.or.packages.title=移动
move.current.directory=移动当前 (&C)
move.directories=移动全部 (&A)
move.directories.to.another.source.root={0}目录移动到另一个源根(
move.directory.to.another.source.root=移动目录{0}的另一个源根(
move.enum.constant.cb=如果可能,移动为枚举常数 (&E)
move.everything.from.directories.to.another.directory=将一切从 {0} 目录移动到另一个目录
move.everything.to.another.directory=将一切从 {0} 移动到另一个目录
move.files.regrouping.command.name=正在重新分组…
move.files.to.new.directory.prompt=到目录\:
move.inner.class.action.name=移动内部类…
move.inner.class.command=移动内部类{0}
move.inner.class.to.another.class=移动内部类{0}到另一个类 (&M)
move.inner.class.to.be.moved=类移动
move.inner.class.to.upper.level=移动内部类{0}上水平(
move.inner.class.to.upper.level.action.name=将内部类移动到上一级别…
move.instance.method.delegate.title=移动实例方法...
move.instance.method.elements.header=移动实例方法
move.instance.method.handler.make.method.static=是否要将方法 ''{0}'' 设为 static 并随后移动?
move.members.action.name=移动成员…
move.method.enter.a.valid.name.for.parameter=请输入一个有效的参数名称
move.method.is.not.supported.for.0=移动实例方法不支持{0}
move.method.is.not.supported.for.constructors=移动方法不支持构造函数
move.method.is.not.supported.for.generic.classes=移动方法不支持泛型类
move.method.is.not.supported.for.non.project.methods=非项目方法不支持移动方法
move.method.this.parameter.label=为''{0}.this''参数选择一个名称
move.methods.used.in.extracted.block.only=移动仅在提取块中使用的方法
move.nonstatic.class.from.jsp.not.supported=不支持从 JSP 页面移动非 static 类
move.package.or.directory=移动包或目录…
move.package.refactoring.cannot.be.applied.to.default.package=移动包重构不能用于默认包
move.package.to.another.package=移动包"{0}"到另一个包(
move.packages.or.directories=移动包或目录…
move.packages.to.another.package={0}包移动到另一个包(
move.single.class.or.package.name.label=移动{0}{1}
move.specified.classes=移动指定的类
move.specified.classes.to=移动指定的类到\:
move.specified.packages=移动指定的包
move.to.inner.duplicate.inner.class=类{0}已包含一个名为{1}的内部类
moving.local.classes.is.not.supported=不支持移动局部类。
no.class.name.specified=未指定类名
no.exact.method.duplicates.were.found=<html><b>未找到确切的方法重复项</b>，但如下所示，变更的方法中有 {0} 个{0,choice, 1\#重复项|2\#重复项}</html>
no.initializer.present.for.the.field=没有初始化器出席现场
no.parameter.name.specified=未指定参数名称
no.usages.can.be.replaced=没有用途的{0}可以替换用法{1}
occurrences.to.be.migrated=匹配项被迁移的{0}
ok.button=确定
only.fields.variables.of.methods.of.valid.type.can.be.considered=仅字段,变量,方法参数或有效的类型的方法可以考虑。
package.description=包{0}
package.does.not.exist=包{0}不存在,是否创建它?
package.name.prompt=包名称(&G)\:
parameter.description=参数{0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=参数初始化包含{0},但并非所有调用的方法是,在它的阶级.
parameter.name.prompt=参数名称(&M) \: 
parameter.of.type=类型的参数\: (&T)
parameter.type.table.column.title=按类型分组
pass.outer.class.instance.as.parameter=使外部类实例作为一个参数 (&O)
please.enter.a.valid.target.package.name=请输入一个有效的目标包名称
press.the.do.migrate.button=按搜索结果面板\n\
底部的"迁移"按钮,使用迁移地图"{0}"\n\
进行迁移
preview.usages.to.be.changed=预览要改变的用法 (&P)
process.duplicates.change.signature.promt=要替换所有匹配项，需要更改方法签名。是否继续?
process.duplicates.title=处理重复项
process.methods.duplicates.title=过程方法复制的{2}({0},{1})
processing.progress.text=处理{0}
project.files.have.been.changed=已更改项目文件。\n\
要重新运行重构吗?
push.down.delete.warning.text={0}向下推动成员会导致它们被删除。要继续吗?
push.down.enum.no.constants.warning.text=枚举 {0} 没有要内联到的常量。
push.down.no.inheritors.class.warning.text=类 {0} 没有继承者。
push.down.no.inheritors.final.class.warning.text=final 类 {0} 没有继承者。
re.run.refactoring=重新运行重构
refactoring.cannot.be.applied.no.sources.attached={0}重构不能应用\:无源连接
refactoring.cannot.be.applied.to.abstract.methods={0}重构不能应用于 abstract 方法
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0}重构不能用于内联非链接构造函数
refactoring.cannot.be.applied.to.native.methods={0} 重构不能应用于原生方法
refactoring.cannot.be.applied.to.vararg.constructors={0}重构不能用于可变参数的构造器
refactoring.extract.method.dialog.duplicates.count={0,choice, 1\#1|2\#{0,number}} 个重复的代码{0,choice, 1\#段|2\#段}可以替换为提取的方法调用
refactoring.extract.method.dialog.duplicates.pending=搜索重复...
refactoring.extract.method.dialog.duplicates.progress=搜索副本
refactoring.extract.method.preview.button.refactor=执行重构 (&D)
refactoring.extract.method.preview.button.rerun=重新运行重构(&E)
refactoring.extract.method.preview.failed=无法提取方法
refactoring.extract.method.preview.group.duplicates=重复的代码段
refactoring.extract.method.preview.group.method=要提取的方法
refactoring.extract.method.preview.group.original=原始代码段
refactoring.extract.method.preview.preparing=正在准备差异
refactoring.extract.method.preview.updating=正在更新差异
refactoring.introduce.variable.enum.in.label.message=无法提取 switch 标签中的枚举常量
refactoring.is.not.supported.for.jsp.classes=重构不支持JSP类.
refactoring.is.not.supported.for.language={0}不支持{1}
refactoring.is.not.supported.for.local.and.jsp.classes=重构不支持局部和JSP类.
refactoring.is.not.supported.in.the.current.context={0}重构是不支持在当前上下文
references.in.code.to.elements.from.migration.map=在代码元素的引用从移民地图"{0}"{1}
references.to.0.to.be.replaced.with.references.to.1=引用''{0}''被引用为''{1}''
remove.parameter.0.no.longer.used=移除不再使用的参数''{0}''
rename.constructor.parameters.title=重命名构造器参数
rename.constructor.parameters.with.the.following.names.to=重命名参数具有以下名称\:
rename.inheritors.with.the.following.names.to=重命名继承者具有以下名称\:
rename.module.already.exists=模块''{0}''已经存在于项目中
rename.module.directory.command=将模块和目录重命名为 ''{0}''
rename.module.directory.title=重命名模块和目录(&A)
rename.overloads=重命名重载 (&O)
rename.overloads.dialog.title=重命名重载
rename.overloads.to.dialog.description=将重载重命名为\:
rename.parameter.in.hierarchy.to.dialog.description=将层次结构中的参数重命名为\:
rename.parameters.dialog.title=重命名参数
rename.tests=重命名测试 (&E)
rename.tests.title=重命名测试
rename.tests.with.the.following.names.to=重命名测试具有以下名称\:
rename.variables=重命名变量 (&V)
rename.variables.title=重命名变量
rename.variables.with.the.following.names.to=重命名变量具有以下名称\:
rename.accessors=重命名访问器(&A)
rename.accessors.title=重命名 Getter/Setter
rename.accessors.with.the.following.names.to=重命名具有以下名称的访问器\:
renamed.class.will.hide.0.in.1=重命名类将隐藏{0}在{1}
renaming.method.will.override.final.0=重命名方法将重写 final“{0}”
replace.all.fields=替换所有字段 (&R)
replace.all.occurrences.of.expression.0.occurrences=替换所有的匹配项({0})(&A)
replace.constructor.0.with.a.factory.method=用一个工厂方法替换构造器{0}
replace.constructor.builder.create.new=&创建新的
replace.constructor.builder.use.existing=使用现有项(&U)
replace.constructor.existing.builder.fqn=构建器类名 (完全限定)(&B)
replace.constructor.new.builder.class.name=构建器类名(&N)
replace.constructor.new.builder.package=新构建器的包(&P)
replace.constructor.with.factory.method=用工厂方法替换构造器
replace.constructor.with.factory.method.title=用工厂方法替换构造器
replace.constructor.with.factory.target.fq.name=在(完全限定名称)\:
replace.default.constructor.of.0.with.a.factory.method=用一个工厂方法替换{0}的默认构造器
replace.default.constructor.with.factory.method=用工厂方法替换默认的构造器
replace.fields.inaccessible.in.usage.context=替换上下文没有使用的字段 (&I)
replace.fields.used.in.expressions.with.their.getters=替换字段用于表情和他们的getter方法
replace.inheritance.from=替换委派继承从\: (&R)
replace.inheritance.with.delegation.command=使用{0}中的委托替换继承
replace.inheritance.with.delegation.elements.header=替换继承与代表团
replace.inheritance.with.delegation.title=用委派替换继承
replace.instance.qualifiers.with.class.references=替换实例与类引用限定符
replace.method.code.duplicates.title=替换重复代码
replace.method.duplicates.scope.chooser.message=分析范围
replace.method.duplicates.scope.chooser.title=指定{0}范围
replace.temp.with.query.title=取代临时与查询
replace.this.code.fragment.and.change.signature=方法的签名将被更改为{0}
replace.this.code.fragment.and.make.method.static=(方法将被设为 static)
replace.this.code.fragment.and.make.method.static.visible=(方法将被设为 static 和{0})
replace.this.code.fragment.and.make.method.visible=(方法将{0})
replace.with.method.call.does.not.work.for.constructors=替换为方法调用不工作为构造函数
replace.write.access.occurrences=替换白名单匹配项 (&L)
replacing.inheritance.with.delegation=替换继承与代表团
safe.delete.search.for.caller.method.usages.progress=搜索调用者方法用法…
safe.delete.select.members.to.propagate.dialog.title=选择要传播安全删除的成员
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=选择要传播参数删除的方法
select.migration.map=选择迁移地图\:
select.source.root.chooser.title=选择根源代码
selected.block.contains.invocation.of.another.class.constructor=选块包含调用另一个类的构造函数.
selected.block.contains.statement.outside.of.class=选定块在类外部包含声明
selected.block.should.represent.an.expression=选块应该代表一个表达式.
selected.expression.cannot.be.a.constant.initializer=选定的表达式不能初始化一个常数.
selected.expression.has.void.type=选定的表达式有空隙类型.
selected.expression.introduces.pattern.variable=选定的表达式引入模式变量 ''{0}''
setter.method.found.for.the.field.0=Setter方法发现田野{0}.{1}setter吗?
side.effects.detected.title=已检测到副作用
source.folder.0.has.package.prefix.1=源文件夹{0}已存在包前缀''{1}''\n\
 Package''{2}''不能被创建.
static.initializer.description=类 {0} 的 static 初始值设定项
superclass.cannot.be.extracted.from.an.enum=不能从一个枚举中提取超类.
synthetic.jsp.class.is.referenced.in.the.method=合成的jsp类是引用的方法
target.0.is.not.accessible.from.1=目标{0}是不可以从{1}
the.field.should.be.declared.in.a.class=应在类中声明该字段.
there.are.going.to.be.multiple.destination.files.with.the.same.name=有多个目标文件具有相同的名称。
there.are.multiple.exit.points.in.the.selected.code.fragment=选定的代码片段有多个出口点。
there.are.multiple.output.values.for.the.selected.code.fragment=选定的代码片段有多个输出值。
there.are.no.variables.that.have.reference.type=有没有具有引用类型的变量
there.are.unused.methods.that.override.methods.you.delete=有未使用的方法,覆盖方法您删除.
there.is.already.a.0.in.1=已存在一个{0}在{1}中
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=已经有一个{0}.它将冲突与一个介绍参数
there.is.already.a.0.it.will.conflict.with.the.renamed.1=已经有一个{0}.它将冲突与更名为{1}
there.is.already.type.parameter.in.0.with.name.1=名称为 {1} 的 {0} 中已存在类型参数
this.method=这种方法
this.reference.only.and.keep.super.class=这个仅供引用并保持内联的超类(&K)
this.reference.only.and.keep.the.class=内联这只引用和保持类(&K)
this.reference.only.and.keep.the.field=内联这只引用和保持字段(&K)
to.delete.with.usage.search=删除(使用搜索)
turn.refs.to.super.command=更换用法{0}和{1}
turnRefsToSuper.change.usages.to=更改{0}的使用到\: (&C)
turnRefsToSuper.use.superclass.in.instanceof=使用接口/超类在实例 (&U)
type.cook.command=泛型
type.cook.drop.obsolete.casts=删除废弃转换 (&D)
type.cook.elements.header=(年代)generify范围
type.cook.generify.objects=Generify对象(&O)
type.cook.leave.object.parameterized.types.raw=离开对象参数化类型生(&L)
type.cook.perform.exhaustive.search=执行彻底的搜索 (&E)
type.cook.preserve.raw.arrays=保存原始数组(&A)
type.cook.produce.wildcard.types=产生通配符类型(&W)
type.cook.ratio.generified={0,choice,-1\#不计算|0\#{0,number}/{1}}
type.cook.report=项目泛型\: {0}, 转换已移除\: {1}
type.migration.action.name=类型迁移
type.migration.choose.scope.title=选择可能出现变更签名的范围
type.migration.conflicts.found=找到的迁移冲突
type.migration.exclude.action.text=排除 (&E)
type.migration.include.action.text=包含 (&I)
type.migration.label=将{0}“{1}”迁移到
type.migration.migrate.button.text=迁移 (&M)
type.migration.no.conflicts.found=未找到迁移冲突
type.migration.no.scope.warning.message=未选择范围
type.migration.preview.warning.text=已找到 10 多个要迁移的根。要预览吗?
type.migration.reasons.to.migrate=已找到要迁移的原因
type.migration.rerun.button.text=返回类型迁移 (&R)
type.migration.select.suggestion=选择根以查找迁移的原因
type.of.the.selected.expression.cannot.be.determined=类型的选定的表达式不能确定.
unable.to.start.type.migration=无法启动类型迁移
unknown.expression.type=未知的表达式类型.
unused.overriding.methods.title=未使用重写方法
usages.detected.title=发现用法
use.interface.superclass.in.instanceof=使用接口/超类的实例
use.interface.where.possible.title=在可能处使用接口
use.super.references.prompt=在这个阶段{0}可以分析用途的{1},换成用法的{2}在可能的情况下.是否要继续?
use.variable.initializer.to.initialize.parameter=使用变量初始器到初始参数 (&I)
variable.0.is.changed.before.last.access=变量 ''{0}'' 在上次访问变量 ''{1}'' 前已更改。
variable.does.not.have.an.initializer=变量{0}没有初始化.
variable.is.accessed.for.writing=变量''{0}''可写.
variable.is.never.used.before.modification=修改之前从未使用变量{0}
variable.of.type=类型的变量\: (&T)
would.you.like.to.replace.default.constructor.of.0.with.factory.method=您想用一个工厂方法替换{0}的默认构造器吗？
wrap.return.value.create.inner.class=创建内部类(&I)
wrap.return.value.create.new.class=创建新类(&C)
wrap.return.value.existing.class.name=名称
wrap.return.value.inner.class.name=名称(&M)
wrap.return.value.new.class.name=名称 (&N)
wrap.return.value.new.class.package.name=&包名称
wrap.return.value.use.existing.class=使用现有类(&U)
wrap.return.value.wrapper.field=包装器字段(&F)

replace.inside.current.lambda=在当前 lambda 内创建变量
replace.as.separate.operation=提取为 ''{0}'' 操作
replace.all.read.and.write=替换读取和写入匹配项 (将更改语义\!)
replace.all.and.extract=替换所有 {0} 匹配项并提取为 ''{1}'' 操作
replace.lambda.chain.detected=检测到 lambda 链
replace.occurrences.inside.statement=替换{2, choice, 1\#|2\#外部} ''{1}'' 块中的 {0} 个匹配项
