system=系统
gdb=GDB
lldb=LLDB

cmake.toolwindow.title=CMake

language.cpp.configurable.name = C/C++
# suppress inspection "UnusedProperty"
language.cpp.settings.description = C/C++
language.cpp.clang-tidy.configurable.name = Clang-Tidy

cpp.module.type={0} 模块
cpp.module.type.description=提供编辑 {0} 文件的功能
cmake.project.generator.enter.project.location=输入项目位置
cmake.project.generator.project.location.path.should.be.absolute=项目位置路径应是绝对路径
cmake.project.generator.directory.is.not.writable=目录 ''{0}'' 不可写。\n请选择另一个目录。
cmake.action.settings=CMake 设置
cmake.action.showGeneratedFiles=在 {0} 中显示生成的文件
cmake.action.dropCacheAndReload=重置缓存并重新加载项目
cmake.action.dropCacheAndReload.description=删除 CMake 生成的所有文件并重新加载项目
cmake.checking.version=正在检查 CMake 版本…
cmake.c.library.project.generator=C 库
cmake.c.exe.project.generator=C 可执行文件
cmake.cpp.library.project.generator=C++ 库
cmake.cpp.exe.project.generator=C++ 可执行文件
cmake.cannot.create.new.project=无法创建新项目\: {0}
cmake.filesOutsideOfProject=某些源文件位于 CMakeLists.txt 目录之外。<br>您以后可以<a href\="change">更改项目根</a>或<a href\="ignore">将其忽略</a>。
cmake.action.loadCMakeProject=加载 CMake 项目
cmake.action.unloadCMakeProject=卸载 CMake 项目
cmake.action.reloadCMakeProject=重新加载 CMake 项目
cmake.loadCMakeNotification.text=CMake 项目未加载
cmake.loadCMakeNotification.action.load=加载 CMake 项目
cmake.loadCMakeNotification.action.select=选择 CMakeLists.txt 文件…
cmake.action.stopReload=停止 CMake 项目重新加载
cmake.action.editCmakeCache = 打开 CMakeCache 文件
cmake.action.autoReloadCmakeProject = 自动重新加载 CMake 项目
cmake.action.autoReloadCmakeProject.checkbox = 编辑时自动重新加载 CMake 项目
cmake.action.autoReloadCmakeProject.checkbox.hint = 项目将重新加载，无论外部变更上此选项如何，例如在 VCS 更新上
cmake.autoReloadNotification.text = CMake 项目需要重新加载
cmake.autoReloadNotification.reloadChanges = 重新加载变更
cmake.autoReloadNotification.enableAutoReload = 启用自动重新加载
cmake.loadingProgress = 正在加载 CMake 项目…
cmake.console.outputRestored = [先前的 CMake 输出已恢复\: {0}]
cmake.console.noOutput = [没有可用的先前 CMake 输出]
cmake.console.noProfiles = [无 CMake 配置文件]
cmake.console.reloadingCanceled = [已取消重新加载]
cmake.console.reloadingFinished = [已完成]
cmake.console.reloadingFinishedWithErrors = [无法重新加载]
cmake.action.showBuildConsole=显示带有文本的 CMake 构建控制台…

cmake.profile = 个人资料
cmake.all.targets.name=所有目标
cmake.settings.language.standard=语言标准\:
cmake.settings.library.type=库类型\:
cmake.run.configuration.display.name=CMake 应用程序
cmake.run.configuration.description=CMake 应用程序配置
cmake.build.configuration.name=构建 ''{0}''
cmake.build.all.name=全部构建
cmake.build.all.in.profile.name=在 ''{0}'' 中全部构建
cmake.rebuild.name=重建
cmake.rebuild.configuration.name=重建 ''{0}''
cmake.rebuild.all.name=全部重建
cmake.rebuild.all.in.profile.name=在 ''{0}'' 中全部重建
cmake.build.project.noProfileError.message=找不到任何 CMake 配置文件

cmake.settings.profile.empty=未添加配置文件。
cmake.settings.profile.empty.secondary.text=添加配置文件
cmake.settings.select.profile.empty.text=选择要配置的配置文件
cmake.settings.add.profile.empty.text=添加要配置的配置文件
cmake.settings.duplicating.names.prefix=CMake 配置文件
cmake.settings.auto.reload.checkbox=在编辑 CMakeLists.txt 时重新加载 CMake 项目
cmake.settings.auto.reload.checkbox.comment=外部更改始终会触发项目重新加载。例如 VCS 更新
cmake.settings.profiles.row.title=个人资料
cmake.settings.profiles.row.comment=<html>配置文件是一组命名的构建选项。例如，为调试和发布构建创建单独的配置文件，并在需要时在它们之间切换。</html>
cmake.settings.name.label=名称
cmake.settings.build.type.label=构建类型
cmake.settings.build.type.comment=对应于 <code>CMAKE_BUILD_TYPE</code>
cmake.settings.toolchain.manage.link.text=管理工具链...
cmake.settings.cmake.options.label=CMake 选项
cmake.settings.cmake.options.comment=使用 <code>-DVAR_NAME\=value</code> 以设置变量，选择 <code>-G</code> 以指定自定义生成器。
cmake.settings.cmake.options.link.text=所有 CMake 选项
cmake.settings.cmake.options.link.versioned.address=https\://cmake.org/cmake/help/v{0}.{1}/manual/cmake.1.html\#options
cmake.settings.cmake.options.link.latest.address=https\://cmake.org/cmake/help/latest/manual/cmake.1.html\#options
cmake.settings.generation.directory.label=构建目录
cmake.settings.generation.directory.default.project.hint=<br>您可以指定绝对路径或相对于项目根的路径<br>可用宏 '$PROJECT_DIR$'、'$PROJECT_NAME$' 和 '$USER_HOME$'
cmake.settings.build.option.label=构建选项
cmake.settings.build.option.comment=‘--’ 后面的参数传递给此构建，其他参数是 CMake 命令行参数。默认选项取决于工具链的环境。
cmake.settings.additional.environment.label=环境
cmake.settings.additional.environment.comment=用于 CMake 生成和构建的其他变量。这些值将添加到系统变量和工具链变量中。
cmake.settings.generationOptions.checkProgressMessage=正在检查 CMake 版本…
cmake.settings.generationOptions.warn.version.missing=无法确定 CMake 版本
cmake.settings.generationOptions.warn.version.min=用户指定的生成器需要 CMake {0} 或更高版本
cmake.settings.hint.queue.title=更新提示
cmake.settings.hint.task.title=正在更新提示…

cpp.build.description.1 = \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=[ {0} ]\=\=\=\=
cpp.build.description.2 = \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=[ {0} | {1} ]\=\=\=\=
cpp.build.description.3 = \=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=[ {0} | {1} | {2} ]\=\=\=\=

cmake.run.shouldGenerateConfigs=自动为新的 CMake 目标生成运行配置
cmake.run.shouldDeleteObsoleteConfigs=自动为缺失的 CMake 目标删除运行配置

cmake.install.name=安装
cmake.install.progress=正在安装...

clion.install.task.presentable.name=安装 {0}
clion.clean.task.presentable.name=清理 {0}

cpp.compileFile.name=编译
cpp.compileFile.progress=编译...
cpp.compileCurrentFile.task.name=编译 ''{0}''
cpp.compileCurrentFile.preBuild.message=正在编译 {0}''…
cpp.compileCurrentFile.preHeaderBuild.message=正在编译包括请求的 ''{1}'' 的 ''{0}''…
cpp.compileCurrentFile.error.message=无法编译文件 ''{0}''
cpp.compileCurrentFile.noRulesError.message=无法编译文件 ''{0}''。找不到此文件的构建规则
cpp.compileCurrentFile.resolveProgress.title=正在查找配置…
cpp.compileCurrentFile.action.selectedFiles.description=选定文件
cmake.macro.build.dir.description=当前 CMake 运行配置的构建目录
cmake.macro.generation.dir.description=当前 CMake 运行配置的生成目录
cmake.macro.product.file.description=当前 CMake 运行配置的产品文件
cmake.macro.program.arguments.description=当前 CMake 运行配置的程序参数
cmake.macro.build.type.name.description=当前 CMake 运行配置的构建类型名称
cmake.macro.target.name.description=当前 CMake 运行配置的目标名称
cmake.macro.executable.description=用于当前运行配置的 CMake 可执行文件
cmake.project.update.action.error=项目更新错误
cmake.import.new.project=从源新建 CMake 项目…
cmake.import.project.select.files=选择项目文件\:
cmake.import.project.user.include.directories=用户包含目录\:
cmake.import.project.scanning.folders=正在扫描文件夹
cmake.import.project.directory.to.import=选择要导入的目录
cmake.project.creation.fail=无法创建 CMake 项目
cmake.import.project.conflict=目录 ''{0}'' 已包含 {1} 项目
cmake.open.existing.project=打开现有项目
cmake.import.as.new.project=作为新的 CMake 项目导入
build.nextOccurrence=下一个 {0}
build.previousOccurrence=上一个 {0}
build.error=错误
build.warning=警告
gdbRemote.title=GDB 远程调试
gdbRemote.command='target remote' 参数\:
gdbRemote.command.hint=例如\: tcp\:host\:port、serial-device 等。
gdbRemote.symbolFile=符号文件\:
gdbRemote.symbolFile.select=选择符号文件
gdbRemote.symbolFile.invalid=符号文件 ''{0}'' 不存在
gdbRemote.sysroot = Sysroot\:
gdbRemote.sysroot.select = 选择 Sysroot
gdbRemote.sysroot.invalid = Sysroot 路径 ''{0}'' 不存在
gdbRemote.pathMappings = 路径映射：
gdbRemote.pathMappings.local = 本地
gdbRemote.pathMappings.remote = 远程
gdbRemote.pathMappings.empty = 无路径映射
gdbRemote.pathMappings.invalid = 路径映射无效\: 远程路径不应为空
gdbRemote.pathMappings.localDoesNotExist = 路径映射无效\: 本地路径不存在\: {0}

gdbRemote.debuggerNotSpecified = 未指定调试器
gdbRemote.debuggerNotSpecified.brief = 未指定 GDB

gdbRemote.toolchain.usesLLDB = {0} 尚不支持使用 LLDB 进行 GDB 远程调试
gdbRemote.toolchain.usesLLDB.brief = LLDB

gdbRemote.toolchain.incompatibleToolset = {0} 尚不支持 GDB 远程调试
gdbRemote.toolchain.incompatibleToolset.brief = {0}

gdbRemote.toolchain.debuggerNotSpecified = 没有为工具链 ''{0}'' 指定调试器
gdbRemote.toolchain.debuggerNotSpecified.brief = 未指定 GDB

gdbRemote.toolchain.debuggerDoesNotExist = GDB ''{0}'' 不存在
gdbRemote.toolchain.debuggerDoesNotExist.brief = {0}

gdbserver.title = GDB 服务器
gdbserver.select.executable = 选择 GDB 服务器可执行文件
gdbserver.executable.download = 下载可执行文件
gdbserver.starting=正在启动 GDB 服务器
gdbserver.startup.delay.text=GDB 服务器启动延迟
gdbserver.startup.delay.label = 启动延迟
gdbserver.startup.delay.label.ms = 毫秒
gdbserver.options.advanced = 高级 GDB 服务器选项
gdbserver.arguments=GDB 服务器参数\:
gdbserver.terminate=终止 GDB 服务器
gdbserver.download.type.ALWAYS=始终
gdbserver.download.type.UPDATED_ONLY=仅限已更新
gdbserver.download.type.NONE=无
dynamic.analysis.tools.configurable.name=动态分析工具
# suppress inspection "UnusedProperty"
dynamic.analysis.tools.settings.description=动态分析工具
dynamic.analysis.tools.sanitizers.configurable.name=Sanitizer
dynamic.analysis.tools.valgrind.configurable.name=Valgrind
sanitizers.progress=程序正在运行…
sanitizers.tabTitle=Sanitizer
sanitizers.runtime.flags.border.title=运行时标志
sanitizers.runtime.flags.hint=各工具解析相应环境变量中的选项
sanitizers.runtime.flags.hint.note=注意\: log_path、stack_trace_format、print_summary、print_stacktrace 将被覆盖
sanitizers.import.flags.button=从现有环境变量导入标志
sanitizers.compiler.min.version.supported=注\: 要启用此功能，需要 Clang (>\={0}) 或 GCC(>\={1})
sanitizers.llvmSymbolizer.notification.title=Google Sanitizers
sanitizers.llvmSymbolizer.notification.text=找不到 llvm-symbolizer。要通过导航获取堆栈跟踪，请将 *SAN_SYMBOLIZER_PATH 环境变量设置为指向 llvm-symbolizer 二进制文件，或确保 llvm-symbolizer 位于您的 PATH 中。
sanitizers.use.visual.representation.checkbox=为 Sanitizer 的输出使用视觉表示
valgrind.configurable.executable.label=Valgrind 可执行文件\:
valgrind.configurable.executable.dialog.title=Valgrind 可执行文件路径
valgrind.confugurable.analysisOptions.label=分析选项\:
valgrind.configurable.arguments.hint=这些参数将自动添加\:
valgrind.configurable.add.suppression.files.label=添加抑制文件\:
valgrind.configurable.no.suppression.files=无抑制文件
valgrind.fileNotFound=找不到 Valgrind 可执行文件\: ''{0}''<br><a href\="">配置</a>
valgrind.executor.run.action=运行 Valgrind Memcheck
valgrind.executor.run.action.with.configuration=通过 Valgrind Memcheck 运行 {0}
valgrind.executor.description=使用 Valgrind 内存检查器分析所选配置
valgrind.progress=Valgrind 正在运行…
valgrind.sanitizers=Valgrind 在启用 Google Sanitizers 的情况下可能无法正常工作
valgrind.suppress.action.title=选择抑制文件
valgrind.suppress.action.description=选择要添加抑制的文件
valgrind.argument.hint=--tool\=memcheck、--xml\=yes、--xml-file\=<file>、--gen-suppressions\=all、<program>、程序参数和所有抑制文件
memory.profile.panel.loading.preview.label=正在加载预览…
memory.profile.panel.preview.editor.title=预览编辑器
memory.profile.panel.frame.information.title=框架信息
memory.profile.panel.empty.preview=选择一个堆栈框架以获取更多信息
memory.profile.instruction.pointer.label=InstructionPointer\:
memory.profile.object.label=对象\:
memory.profile.function.label=函数\:
memory.profile.directory.label=目录：
memory.profile.file.label=文件\:
memory.profile.line.label=行\:
memory.profile.import.title=正在导入 {0} 结果
memory.profile.warnings.count={0} 个警告
coverage.error.hint=确保指定了编译器和链接器选项以收集覆盖率
cpp.project.action.changeContentRoot=更改项目根
external.build.configuration.name=构建\:''{0}''，清理\:''{1}''，工具链\: ''{2}''，工件\: ''{3}''
external.build.configuration.generalError=无法构建 ''{0}''
external.build.configuration.noBuildToolSpecified=没有为 ''{0}'' 指定构建工具
external.build.configuration.buildToolDisabled=构建工具对 ''{0}'' 不可用
external.tool.cannot.execute=无法执行外部工具 ''{0}''
external.run.configuration.name=自定义构建应用程序
external.run.configuration.description=具有自定义构建目标的应用程序配置
external.run.configuration.noBuildToolSpecified=没有为所选目标 ''{0}'' 指定构建工具。将不会构建。
external.run.configuration.buildToolDisabled=构建工具对所选目标 ''{0}'' 不可用。将不会构建。
external.run.configuration.targetsLink=配置自定义构建目标

external.configurable.name=自定义构建目标
external.configurable.build.field.label=构建\:
external.configurable.clean.field.label=清除\:
external.configurable.unnamed.target=未命名
external.configurable.targets.empty=未添加目标.
external.configurable.targets.empty.secondary.text=添加目标
external.configurable.select.target.empty.text=选择要配置的目标
external.configurable.add.target.empty.text=添加要配置的目标

external.configurable.name.not.specified=未指定外部构建目标的名称
external.configurable.duplicating.names.prefix=自定义构建目标
external.configurable.invalidComboboxTool.tooltip=未知工具 ''{0}''。
external.configurable.invalidComboboxTool.configurationException=未知工具 ''{0}''。请选择现有工具。

external.configuration.tool.type.name=工具

clion.project.tool.manager.presentable.name=工具

debug.attach.defaultGroupTitle=Native
remote.action.resync=与远程主机重新同步
remote.action.hosts.info=显示远程主机信息
remote.action.hosts.info.task=收集远程主机信息
remote.credentials=凭据
remote.gdb.server.configuration.name=远程 GDB 服务器
remote.gdb.server.configuration.description=使用第三方的 GDB 服务器下载并运行应用程序
remote.gdbserver.upload.path=上传路径
remote.gdbserver.select.upload.folder=选择上传文件夹
remote.gdbserver.upload.executable=上传可执行文件
remote.gdbserver.upload.executable.dialog.text=上传符号文件
remote.custom.executable=自定义 {0} 可执行文件

command.cannot.parse.message=无法为文件 ''{0}'' 和目录 ''{1}'' 解析命令字段。\n命令 ''{2}''
command.no.compiler.executable.message=没有为文件 ''{0}'' 和目录 ''{1}'' 指定编译器可执行文件。\n命令 ''{2}''
command.cannot.find.compiler.executable.message=无法找到编译器可执行文件\: ''{0}''。\n命令 ''{1}''
command.incorrect.file.message=指定的文件不正确\: ''{0}''。\n命令 ''{1}''
command.incorrect.directory.message=指定的目录不正确\: ''{0}''。\n命令 ''{1}''
command.object.success.message=命令对象解析成功
command.unknown.compiler.executable.message=未知的编译器可执行文件\: ''{0}''

compound.run.configuration.conversion.message = 运行配置将转换为新格式