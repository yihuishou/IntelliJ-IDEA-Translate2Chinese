add.action.name=添加
add.adding=正在添加文件…
annotate.action.name=注释

apply.conflict.dialog.description.label.text=在由{2}{3}执行的提交{1}的{0}过程中发生冲突

changes.retrieving=检索修订 {0} 的变更
checking.out=签出 {0}
commit.action.commit.and.rebase.text=Commit 并 Rebase...
commit.action.name=Comm&it
commit.author.diffs=<html>作者与默认不同</html>
commit.author=&作者\:
commit.partial.merge.message=不允许在{0}期间进行部分提交。\n\
提交中未包含以下文件。\n\
在包含所有文件的情况下执行提交?
commit.partial.merge.title=部分合并提交
common.current.branch.tooltip=当前已签出的分支。
common.current.branch=当前分支\:
common.git.root.tooltip=选择 Git VCS 根
common.git.root=Git 根(&R)\:
common.no.active.branch=<无活动分支>
common.refreshing=刷新文件
common.suffix.in.one.repository=在{0}
common.suffix.in.several.repositories=在 {0} 个存储库中

conflict.resolver.unmerged.files.check.error.notification.description.text=由于错误，无法检查工作树中是否存在未合并的文件。

login.dialog.label.login.to.url=登录 {0}
login.dialog.button.login=登录
login.dialog.prompt.enter.credentials=输入凭据\:
login.dialog.select.login.way.credentials=输入凭据
login.dialog.select.login.way.use.helper=使用凭据帮助程序
login.dialog.username.label=用户名：
login.dialog.password.label=密码\:
login.dialog.error.username.cant.be.empty=用户名不能为空
login.dialog.error.password.cant.be.empty=密码不能为空
login.dialog.login.with.selected.provider=使用 {0} 登录…

computing.annotation=正在计算 {0} 的注解
diff.find.error=正在查找差异的修订\: {0}
error.dialog.title=错误
error.list.title={0}错误\:
error.occurred.during=''{0}'' 期间发生错误
errors.message.item=\n\
   {0}
errors.message=Git 操作以多个错误结束\: {0}

# suppress inspection "UnusedProperty": used by 3-party plugins
fetch.action.name=获取

# suppress inspection "UnusedProperty": used by 3-party plugins
find.git.error.title=运行 Git 时出错
# suppress inspection "UnusedProperty": used by 3-party plugins
find.git.success.title=Git 执行成功
# suppress inspection "UnusedProperty": used by 3-party plugins
find.git.unsupported.message=<html><tt>{0}</tt><br>此版本不受支持，某些插件功能可能无法工作。<br>支持的最低版本是 <em>{1}</em>。</html>

git.error.exit=Git 进程退出，代码为 {0}
git.running=运行\: {0}

init.destination.directory.description=选择将在其中创建新 Git 存储库的目录。
init.destination.directory.title=创建 Git 存储库
init.warning.already.under.git=<html>所选目录 <tt>{0}</tt> 已在 Git 下。<br/>确定要创建新的 VCS 根吗?</html>
init.warning.title=Git 初始化
initializing.title=正在初始化存储库…
merge.action.name=合并
merge.add.log.information.tooltip=将日志信息添加到提交的消息(“--log”选项)
merge.add.log.information=添加日志信息(&L)
merge.branch.button=合并
merge.branch.title=合并变更
merge.branch.into.current.title=合并到 {0}
merge.branch.loading.branches.progress=正在加载未合并的分支...
merge.branches.tooltip=<html>分支的选择器。选择一个或多个要合并的分支(已合并的分支不显示)。</html>
merge.no.branch.selected.error=应选择该合并分支。
merge.no.matching.branch.error=没有匹配分支。
merge.nothing.to.merge.error=没有要合并的分支。
merge.branches=要合并的分支(&B)\:
merge.commit.message.tooltip=合并提交(如果已创建)的消息(“-m”选项)。
merge.commit.message=提交消息(&M)
merge.commit.message.label=提交消息\:
merge.default.strategy=<默认>
merge.options.modify=修改选项
merge.options.modify.popup.title=添加合并选项
merge.option.remove=移除选项
merge.option.no.ff=在可以快速转发的情况下也创建合并提交
merge.option.ff.only=仅在可以快进时合并
merge.option.squash=为合并的更改创建一个提交
merge.option.msg=指定合并提交消息
merge.option.no.commit=不提交合并结果
merge.option.no.verify=绕过预合并和提交消息挂钩
merge.branch.popup.empty.text=无分支
merge.no.commit.tooltip=强制不提交合并(“--no commit”选项)
merge.no.commit=不提交(&C)
merge.no.fast.forward.tooltip=禁用快进(“--no-ff”选项)
merge.no.fast.forward=不快进(&F)
merge.retrieving.branches=检索未合并的分支
merge.preparing.branches.list=正在准备分支列表
merge.failed.title=合并失败
merge.retrieving.branches.error=无法检索未合并的分支
merge.squash.commit=Squash 提交(&Q)
merge.branch.field.placeholder=指定分支
merge.squash.tooltip=将所有变更 squash 到单个提交(“--squash”选项)
merge.strategy.tooltip=要使用的合并策略(“-s”选项)
merge.strategy=策略(&S)\:
merge.tool.column.status.deleted=删除
merge.tool.column.status.modified=已修改
merge.tool.column.theirs.status=他人的
merge.tool.column.yours.status=您的
merging.title=将变更合并到{0}
paths.affected.title=提交{0}中受影响的路径
pull.action.name=拉取
pull.button=拉取
pull.get.branches.tooltip=从远程存储库获取分支名称。否则将使用本地缓存的信息。
pull.getting.remote.branches=正在获取远程分支…
pull.remote.tooltip=注册的远程名称或 URL。
pull.remote=远程(&M)\:
pull.title=拉取变更
pulling.title=从{0}中拉取变更
pull.branch.not.selected.error=应选择要从中拉取的分支。
pull.branch.no.matching.error=没有匹配分支。
pull.branch.nothing.to.pull=无分支
pull.branch.no.matching.remotes=无远程
pull.branch.field.placeholder=指定分支
pull.options.modify=修改选项
pull.options.modify.popup.title=添加拉取选项
pull.option.remove=移除选项
pull.option.ff.only=仅在可以快进时合并
pull.option.no.ff=在可以快速转发的情况下也创建合并提交
pull.option.squash.commit=为拉取的更改创建一个提交
pull.option.no.commit=不提交拉取结果
pull.option.rebase=在当前分支的顶部衍合传入变更

pull.dialog.title=拉取
pull.dialog.with.branch.title=拉取到{0}
pull.dialog.git.root=Git 根\:
pull.dialog.from=从\:
pull.dialog.update.tracking.info=更新本地分支跟踪信息
pull.dialog.fetch.shortcuts.hint=按 {0} 更新分支

operation.action.message=多个 Git 根有未完成的{0}进程，请选择要对其执行操作的根。

rebase.abort.and.rollback.dialog.message=仅中止{0}中的衍合还是同时回滚{1}中的衍合?
rebase.abort.and.rollback.dialog.no.button.text=仅中止
rebase.abort.and.rollback.dialog.yes.button.text=中止并回滚
rebase.abort.dialog.message=中止{0}中的衍合?
rebase.abort.dialog.ok.button.text=中止
rebase.abort.dialog.title=中止衍合
rebase.abort.notification.failed.title=衍合中止失败
rebase.abort.notification.successful.message=衍合中止成功
rebase.abort.notification.warning.rollback.failed.message={0}\:{1}{2} 中的回滚失败
rebase.abort.notification.warning.rollback.failed.title=衍合回滚失败
rebase.abort.notification.warning.rollback.failed.with.repo.message={0} 中的衍合中止成功，但 {1}\:{2}{3} 中的回滚失败
rebase.abort.progress.indicator.command.in.repo.title={0}在{1}
rebase.abort.rollback.successful.rebase.dialog.message=要回滚{0}中成功的衍合?
rebase.abort.rollback.successful.rebase.dialog.ok.button.text=回滚
rebase.confirmation.dialog.published.commits.button.cancel.text=取消
rebase.confirmation.dialog.published.commits.button.rebase.text=仍然衍合
rebase.confirmation.dialog.published.commits.message=<html>您正在尝试对已推送到受保护分支的某些提交进行衍合。<br/>对这些提交进行衍合将使提交重复，这是不推荐的，而且很可能是不需要的。</html>
rebase.confirmation.dialog.published.commits.title=衍合已发布的提交
rebase.conflict.diff.dialog.left.title=<html>从<b>{1}</b>衍合{0}</html>
rebase.conflict.diff.dialog.right.simple.title=<html>已衍合的提交</html>
rebase.conflict.diff.dialog.right.with.branch.title=<html>已衍合的提交和来自<b>{0}</b>的提交</html>
rebase.dialog.error.upstream.not.selected=选择上游。
rebase.dialog.error.base.not.selected=选择新基。
rebase.dialog.error.branch.or.tag.not.exist=没有这样的分支或标记。
rebase.dialog.error.branch.not.selected=选择要切换到的分支。
rebase.dialog.error.branch.invalid=分支 ''{0}'' 不存在。
rebase.dialog.error.rebase.in.progress=该 Git 根目录已经在进行交互式衍合。
rebase.dialog.label.branch.text=&分支\:
rebase.dialog.label.from.text=&从\:
rebase.dialog.progress.loading.branch.info=正在加载分支配置…
rebase.dialog.progress.loading.tags=正在加载标记…
rebase.dialog.start.rebase=衍合
rebase.dialog.title=Rebase
rebase.dialog.upstream.field.placeholder=指定分支或哈希
rebase.dialog.onto.field=指定新基
rebase.dialog.branch.field=指定分支
rebase.options.modify.dialog.title=添加衍合选项
rebase.option.onto=为衍合的提交指定新基
rebase.option.interactive=在衍合之前编辑提交
rebase.option.rebase.merges=重新创建提交拓扑
rebase.option.switch.to.branch=选择另一个要衍合的分支
rebase.entry.action.name.drop=删除
rebase.entry.action.name.edit=编辑
rebase.entry.action.name.fixup=修复
rebase.entry.action.name.pick=选取
rebase.entry.action.name.reword=改写
rebase.entry.action.name.squash=Squash
rebase.entry.action.name.unknown=未知
rebase.git.operation.name=衍合
rebase.interactive.dialog.discard.modifications.cancel=取消衍合
rebase.interactive.dialog.discard.modifications.continue=继续衍合
rebase.interactive.dialog.discard.modifications.discard=舍弃
rebase.interactive.dialog.discard.modifications.message=放弃变更并取消衍合?
rebase.interactive.dialog.git.commands.column.action=操作
rebase.interactive.dialog.git.commands.column.hash=哈希
rebase.interactive.dialog.git.commands.column.subject=主题
rebase.interactive.dialog.git.commands=Git 命令
rebase.interactive.dialog.reset.link.text=重置
rebase.interactive.dialog.reword.hint.text=按 {0} 应用变更
rebase.interactive.dialog.start.rebase=启动衍合
rebase.interactive.dialog.stop.to.edit.text=停止编辑
rebase.interactive.dialog.title=衍合提交
rebase.interactive.dialog.view.git.commands.text=查看 Git 命令
rebase.interactive.edit.commit.message.dialog.title=Git 提交消息
rebase.interactive.edit.commit.message.ok.action.title=继续衍合
rebase.interactive.noop.dialog.text=由于当前分支直接位于基分支的正下方或它们指向同一个提交，因此没有要衍合的提交('noop' 情况)。\n\
 继续吗? (这会将当前分支重置为基分支)
rebase.interactive.noop.dialog.title=Git Rebase
rebase.interactive.unstructured.editor.dialog.root.label=Git 根\: {0}
rebase.log.action.operation.rebase.name=衍合
rebase.log.action.operation.reword.name=改写
rebase.log.commit.editing.action.commit.not.in.head.error.text=该提交不在当前分支中
rebase.log.commit.editing.action.commit.pushed.to.protected.branch.error.text=该提交已被推送到受保护分支 ''{0}''
rebase.log.commit.editing.action.disabled.parents.description=所选提交已{0}父项
rebase.log.multiple.commit.editing.action.disabled.external.repository.description=选定的 {0, choice, 1\#项提交|2\#项提交} {0, choice,1\#是|2\#是}来自于外部存储库
rebase.log.multiple.commit.editing.action.disabled.multiple.repository.description=选定的 {0, choice, 1\#项提交|2\#项提交} {0, choice,1\#是|2\#是}来自于不同存储库
rebase.log.commit.editing.action.progress.containing.branches.title=正在搜索包含所选提交的分支…
rebase.log.commit.editing.action.prohibit.state.grafting=优选期间不能{0}
rebase.log.commit.editing.action.prohibit.state.merging=合并期间不能{0}
rebase.log.commit.editing.action.prohibit.state.rebasing=衍合期间不能{0}
rebase.log.commit.editing.action.prohibit.state.reverting=还原期间不能{0}
rebase.log.commit.editing.action.prohibit.state=不能{0}
rebase.log.undo.impossible.pushed.to.protected.branch.notification.text=来自当前分支的提交已被推送到受保护的分支 {0}
rebase.log.drop.action.custom.text=删除{0,choice,1\#提交|2\#提交}
rebase.log.drop.action.failure.title=无法删除提交
rebase.log.drop.progress.indicator.title=正在删除 {0, choice, 1\#项提交|2\#项提交}...
rebase.log.drop.success.notification.title=已删除 {0, choice, 1\#项提交|2\#项提交}
rebase.log.drop.undo.failed.title=撤消删除失败
rebase.log.drop.undo.impossible.title=无法撤消删除
rebase.log.drop.undo.progress.title=正在撤消删除...
rebase.log.multiple.commit.editing.action.cant.find.head=在包含选定{0,choice,1\#提交|2\#提交}的存储库中找不到 HEAD 分支
rebase.log.multiple.commit.editing.action.progress.indicator.action.possibility.check=正在检查是否允许编辑选定提交…
rebase.log.multiple.commit.editing.action.specific.commit.not.in.head=提交 {0} 不在当前分支中
rebase.log.multiple.commit.editing.action.specific.commit.root.or.merge=提交 {0} 有 {1} 个父项
rebase.log.create.fixup.commit.action.failure.title=无法创建修复提交
rebase.log.create.squash.commit.action.failure.title=无法创建 Squash 提交
rebase.log.interactive.action.failure.title=无法启动衍合
rebase.log.reword.action.failure.title=无法编辑提交消息
rebase.log.action.loading.commit.message.failed.message=无法加载{0,choice,1\#提交|2\#提交}的变更
rebase.log.reword.action.notification.successful.title=已更改提交消息
rebase.log.reword.action.notification.undo.failed.title=撤消提交消息编辑失败
rebase.log.reword.action.notification.undo.not.allowed.repository.changed.message=存储库已被更改
rebase.log.reword.action.notification.undo.not.allowed.title=无法撤消提交消息编辑
rebase.log.action.progress.indicator.loading.commit.message.title=正在加载{0,choice,1\#提交|2\#提交}详细信息…
rebase.log.squash.action.failure.title=无法 Squash 提交
rebase.log.squash.new.message.dialog.label=编辑已 squash 提交的消息
rebase.log.squash.new.message.dialog.title=已 Squash 提交消息
rebase.log.squash.progress.indicator.title=正在 Squash…
rebase.log.squash.success.notification.title=提交已压缩
rebase.log.squash.undo.failed.title=撤消压缩失败
rebase.log.squash.undo.impossible.title=无法撤消压缩
rebase.log.squash.undo.progress.title=正在撤消压缩...
rebase.log.reword.action.progress.indicator.title=正在改写…
rebase.log.reword.action.progress.indicator.undo.title=正在撤消改写…
rebase.log.reword.dialog.description.label=编辑由{1}执行的提交{0}的消息
rebase.log.reword.dialog.failed.pushed.to.protected.message=无法编辑选定{0,choice,1\#提交|2\#提交}\: 提交 {1} 已被推送至受保护分支 ''{2}''
rebase.log.reword.dialog.failed.repository.changed.message=无法编辑选定{0,choice,1\#提交|2\#提交}\: 存储库状态已被更改
rebase.log.reword.dialog.title=编辑提交消息
rebase.notification.action.abort.text=中止
rebase.notification.action.continue.text=继续
rebase.notification.action.retry.text=重试
rebase.notification.action.view.shelf.text=查看 Shelf…
rebase.notification.action.view.stash.text=查看存储…
rebase.notification.conflict.title=衍合由于冲突而停止
rebase.notification.editing.title=衍合已停止，可以进行编辑
rebase.notification.failed.continue.title=继续衍合失败
rebase.notification.failed.rebase.title=衍合失败
rebase.notification.failed.shelf.text=无法搁置本地未提交的变更\:<br/>{0}
rebase.notification.failed.stash.text=无法存储本地未提交的变更\:<br/>{0}
rebase.notification.no.rebase.in.progress.abort.title=无法中止衍合
rebase.notification.no.rebase.in.progress.continue.title=无法继续衍合
rebase.notification.no.rebase.in.progress.message=没有正在进行的衍合
rebase.notification.not.allowed.detached.message=您在 {0} 中处于游离的 HEAD 状态。<br/>无法衍合。
rebase.notification.not.allowed.empty.repository.message=存储库 {0} 为空。
rebase.notification.not.allowed.grafting.message={0}中有一个未完成的优选进程。<br/>您应该先完成该优选，然后再启动衍合。
rebase.notification.not.allowed.merging.message={0}中有一个未完成的合并进程。<br/>您应该先完成该合并，然后再启动衍合。
rebase.notification.not.allowed.message=无法在{0}中进行衍合。
rebase.notification.not.allowed.rebasing.message={0}中有一个未完成的衍合进程。<br/>您应该先完成该衍合，然后再启动另一个衍合。
rebase.notification.not.allowed.reverting.message={0}中有一个未完成的还原进程。<br/>您应该先完成该还原，然后再启动衍合。
rebase.notification.not.allowed.title=不允许衍合
rebase.notification.not.started.title=衍合未启动
rebase.notification.saved.local.changes.part.shelf.text=<br/>本地变更在衍合之前已搁置。
rebase.notification.saved.local.changes.part.stash.text=<br/>本地变更在衍合之前已存储。
rebase.notification.successful.rebased.checkout.message=已签出{0,choice,0\#|1\#{1}}并将其衍合{2,choice,0\#|1\#到 {3}}
rebase.notification.successful.rebased.message=已将{0,choice,0\#|1\#{1}}衍合{2,choice,0\#|1\#到{3}}
rebase.notification.successful.title=衍合成功
rebase.progress.indicator.aborting.title=正在中止衍合进程…
rebase.progress.indicator.conflicts.collecting.title=正在收集要解决的冲突…
rebase.progress.indicator.continue.title=正在继续衍合进程…
rebase.progress.indicator.preparing.title=正在准备衍合…
rebase.progress.indicator.retry.title=正在重试衍合进程…
rebase.progress.indicator.title=正在衍合…
rebase.simple.editor.dialog.title=Git 编辑器
rebase.update.project.abort.task.title=中止衍合…
rebase.update.project.conflict.error.notification.description=然后，您可以<b>继续衍合</b>。<br/>您也可以<b>中止衍合</b>以恢复原始分支并停止衍合。
rebase.update.project.conflict.error.notification.title=无法继续衍合
rebase.update.project.conflict.merge.description.label=检测到合并冲突。请先解决这些冲突，然后再继续衍合。
rebase.update.project.notification.abort.cancel.message=已取消中止衍合
rebase.update.project.notification.abort.error.message=中止衍合时出错
rebase.update.project.notification.abort.success.message=已中止衍合
rebase.update.project.notification.failed.message=无法继续衍合。{0}
rebase.update.project.notification.failed.title=衍合出错
merge.update.project.generic.error.title=无法完成更新
merge.update.project.conflict.merge.description.label=检测到合并冲突。请先解决这些冲突，然后再继续更新。

remove.removing=正在移除文件…
repository.action.missing.roots.misconfigured=配置的 Git 根都不在 Git 下。配置的目录中必须包含“.git”目录。
repository.action.missing.roots.title=没有 Git 根
repository.action.missing.roots.unconfigured.message=没有为项目配置 Git 根。
repository.not.found.error=无法为{0}找到已配置的 git 存储库
reset.action.name=重置头部…
reset.commit.invalid=指定的提交表达式未通过验证。
reset.commit.label=为提交(&C)\:
reset.commit.tooltip=由于重置操作而将成为当前 HEAD 的提交。
reset.title=重置头部
reset.type.tooltip=<html>重置类型(另请参见 <code>git reset</code> man 页面)\:<ul><li><b>混合</b>将重置索引，但不会重置工作树</li><li><b>软</b>将离开索引和工作树，只是移动 HEAD 指针</li><li><b>硬</b>将重置索引和工作树。<em>工作树中的变更会丢失</em></li></ul></html>
reset.type=重置类型(&T)\:
reset.validate=&验证
resetting.title=重置 HEAD…
restore.conflict.dialog.description.label.text=在{0}之前保存的未提交变更与 {1} 中的文件冲突
restore.conflict.diff.dialog.left.shelf.title=Shelf 中的未提交变更
restore.conflict.diff.dialog.left.stash.title=存储中的未提交变更
restore.conflict.diff.dialog.right.title=来自{0}的变更
preserving.process.local.changes.not.restored.error.title=未恢复本地变更
restore.notification.failed.shelf.message=在更新之前，未提交的变更已保存到 <a href\='saver'>shelf</a>。<br/>更新未完成，您的工作树中有未解决的合并<br/>请解决冲突，完成更新并手动恢复变更。
restore.notification.failed.stash.message=在更新之前，未提交的变更已保存到<a href\='saver'>存储</a>。<br/>更新未完成，您的工作树中有未解决的合并<br/>请解决冲突，完成更新并手动恢复变更。
restore.notification.failed.title=未恢复本地变更

reference.validating.progress.indicator.title=正在验证修订…

save.load.conflict.dialog.diff.left.title=您未提交的变更
save.load.conflict.dialog.diff.right.title=远程变更
save.notification.failed.shelf.text=试图在{0}之前在 shelf 中保存未提交的变更，但失败并出现错误。<br/>{1}
save.notification.failed.stash.text=试图在{0}之前在存储中保存未提交的变更，但失败并出现错误。<br/>{1}
save.notification.failed.title=无法保存未提交的变更

smart.operation.dialog.north.panel.label.shelf.text=<html>您对以下文件的本地变更将被{0}覆盖。<br/>{1} 可以搁置这些变更，{0}，并在之后取消搁置。</html>
smart.operation.dialog.north.panel.label.stash.text=<html>您对以下文件的本地变更将被{0}覆盖。<br/>{1} 可以存储这些变更，{0}，并在之后取消存储。</html>
smart.operation.dialog.ok.action.shelf.description=搁置本地变更，{0}，取消搁置
smart.operation.dialog.ok.action.stash.description=存储本地变更，{0}，取消存储
smart.operation.dialog.operation.name.and.overwrite.local.changes={0}并覆盖本地变更
smart.operation.dialog.git.operation.name.problem=Git {0}问题
smart.operation.dialog.smart.operation.name=智能{0}
smart.operation.dialog.don.t.operation.name=不{0}
ssh.ask.passphrase.title=SSH 密钥密码短语
ssh.ask.passphrase.message=SSH 密钥“{0}”的密码\:
ssh.changed.host.key=<html>主机 {0}\:{1} 的服务器主机密钥已更改为 {2} (类型{3})。\n\
是否接受更改的密钥?</html>
ssh.confirm.key.title=确认 SSH 服务器密钥
ssh.error.title=身份验证错误
ssh.keyboard.interactive.title=SSH 键盘交互式
ssh.keyboard.interactive.username=用户名：
ssh.new.host.key=<html>正在连接到具有密钥 {2} (类型 {3})的新主机 {0}\:{1,number,\#}。\n\
是否要将此主机添加到已知主机数据库?</html>
ssh.password.message=用户 {0} 的密码\:
ssh.password.title=SSH 密码登录

stash.action.name=Stash
stash.button=创建存储
stash.error.can.not.stash.changes.now=现在无法存储变更
stash.keep.index.tooltip=如果选中此复选框，已建立索引的变更将保留在索引中。
stash.keep.index=保留索引(&I)
stash.message.tooltip=在此处输入存储消息。
stash.message=&消息\:
stash.progress.indicator.title=正在存储来自 ''{0}'' 的变更…
stash.title=Stash
stash.unstash.conflict.dialog.description.label.text=更新前存储的未提交变更与更新后的文件冲突。
stash.unstash.progress.indicator.title=正在消除 ''{0}'' 的变更…
stash.unstash.unresolved.conflict.warning.notification.message=您未提交的变更已保存到<a href\='saver'>存储</a>。<br/>取消存储未完成，您的工作树中有未解决的合并<br/>请<a href\='resolve'>解决</a>冲突并删除存储。
stash.unstash.unresolved.conflict.warning.notification.title=本地变更已恢复，但存在冲突
stashing.title=存储变更…

tag.action.name=标签
tag.button=创建标签
tag.commit.label=&提交对话框\:
tag.commit.tooltip=输入要标记的提交或对象的名称，或留空以使用 HEAD。
tag.error.creating.message.file.message=无法创建消息文件\: {0}
tag.error.invalid.commit=该提交或对象名称无效。
tag.error.tag.exists=存在同名的标记。
tag.force.tooltip=强制创建标记，即使已存在另一个具有此名称的标记。
tag.force=强制(&F)
tag.getting.existing.tags=正在获取现有标记…
tag.message.label=&消息\:
tag.message.tooltip=如果消息不为空，则创建带注解的标记。
tag.name.label=标记名称(&N)\:
tag.name.tooltip=在此处输入新的标记名称。
tag.title=标签
tag.validate.tooltip=点击此按钮验证要标记的提交
tag.validate=&验证

unstash.action.name=取消存储
unstash.branch.label\:=作为新分支(&B)\:
unstash.branch.tooltip=如果输入非空名称，该存储将作为新分支签出。
unstash.button.apply=应用存储
unstash.button.branch=分支
unstash.button.pop=消除存储
unstash.clear.tooltip=删除存储库中的所有存储。
unstash.clear=&清除 (&C)
unstash.clearing.stashes=正在清除存储…
unstash.drop.tooltip=删除所选存储
unstash.drop=&删除
unstash.conflict.dialog.description.label.text=取消存储 {0} 时发生冲突
unstash.conflict.diff.dialog.left.title=本地变更
unstash.conflict.diff.dialog.right.title=来自存储的变更
unstash.dialog.remove.stash.progress.indicator.title=正在移除存储 {0}…
unstash.dialog.show.stashes.error.dialog.title=无法显示存储列表
unstash.dialog.stash.details.load.progress.indicator.title=正在加载存储详细信息…
unstash.dialog.stash.list.load.progress.indicator.title=正在加载存储列表…
unstash.dialog.unresolved.conflict.warning.notification.message=取消存储未完成，您的工作树中存在未解决的合并<br/>请<a href\='resolve'>解决</a>冲突。
unstash.dialog.unresolved.conflict.warning.notification.title=取消存储期间未解决冲突
unstash.pop.stash.tooltip=如果选中，则该存储在应用后会被删除。
unstash.pop.stash=消除存储(&P)
unstash.reinstate.index.tooltip=尝试复原索引以及工作树变更。
unstash.reinstate.index=复原索引(&I)
unstash.stashes=存储(&S)\:
unstash.title=取消暂存更改
unstash.unstashing=正在取消存储…
unstash.view.tooltip=查看所选存储
unstash.view=&查看
unstash.error.can.not.unstash.changes.now=现在无法取消存储变更
unstash.unstashed.with.conflicts.error.title=已取消存储，但存在冲突

update.options.display.name=Git 更新设置
update.options.type.default=分支默认(&D)
update.options.type.merge=&Merge
update.options.type=更新类型
update.notification.update.error=无法更新
update.notification.choose.upstream.branch=选择上游分支
update.process.text=更新项目

util.remote.renderer.none=<html><i>无</i></html>
util.remote.renderer.self=<html><i>当前存储库</i></html>
vfs.listener.add.single.prompt=要将以下文件添加到 Git 吗?\n\
{0}\n\
\n\
如果您选择“取消”，以后仍可以手动添加。
vfs.listener.add.single.title=将文件添加到 Git
vfs.listener.add.title=将文件添加到 Git
vfs.listener.checking.ignored=正在检查有无忽略的文件…
vfs.listener.delete.single.prompt=要从 Git 中删除以下文件吗?\n\
{0}\n\
\n\
如果您选择“取消”，以后仍可以手动删除。
vfs.listener.delete.single.title=从 Git 中删除文件
vfs.listener.delete.title=从 Git 中删除文件

git.commit.message.empty=请指定提交消息
git.commit.message.empty.title=提交消息为空

git.executable.detect.progress.title=正在检测 Git 可执行文件
git.executable.version.progress.title=正在识别 Git 版本
git.executable.version.is=Git 版本为 {0}
git.executable.error.file.not.found=没有此类文件\: {0}

git.executable.validation.error.start.title=无法运行 Git
git.executable.validation.error.version.title=Git 版本 {0} 不受支持
git.executable.validation.error.version.message=至少需要 {0}
git.executable.validation.error.wsl1.unsupported.message=不支持 WSL 版本 1，请参见 <a href\='https\://youtrack.jetbrains.com/issue/IDEA-242469'>IDEA-242469</a>
git.executable.validation.error.xcode.title=接受 XCode/iOS 许可证以运行 Git
git.executable.validation.error.xcode.message=运行“sudo xcodebuild -license”并重试(需要管理员权限)
git.executable.validation.cant.identify.executable.message=无法识别 git 可执行文件 {0} 的版本
git.executable.unknown.error.message=无法启动 Git 进程\: {0}
git.executable.unknown.wsl.distribution.error.message=未知 WSL 分发

git.executable.notification.title=无法启动 Git
git.executable.notification.description=Git 可执行文件的路径可能无效。

executable.error.git.not.installed=未安装 Git
executable.mac.fix.path.action=修复路径
executable.mac.error.invalid.path.to.command.line.tools=Command Line Tools 的路径无效

git.unstash.clear.confirmation.message=移除所有存储? 此操作无法撤消。
git.unstash.clear.confirmation.title=移除所有存储?
git.unstash.drop.confirmation.message=<html>要移除 {0} 吗?<br/>“{1}”</html>
git.unstash.drop.confirmation.title=移除存储 {0}?
vcs.history.action.gitlog=在 Git 日志中显示

# suppress inspection "UnusedProperty": used by 3-party plugins
vcs.history.action.gitlog.error=Git 日志未就绪

# suppress inspection "UnusedProperty": used by ExportSettingsActionKt
exportable.Git.Application.Settings.presentable.name=Git

git.add.to.exclude.file.action.text=.git/info/exclude
git.add.to.exclude.file.action.description=将条目添加到 .git/info/exclude
git.open.exclude.file.action.text=打开 .git/info/exclude
git.open.exclude.file.action.description=在编辑器中打开 .git/info/exclude

git.fetch.progress=正在获取...

action.CopyPathFromRepositoryRootProvider.text=存储库根路径
action.git4idea.commands.TestGitHttpLoginDialogAction.text=测试 Git 登录对话框
action.Git.Log.DeepCompare.text=无精选提交
action.Git.Log.DeepCompare.description=高亮显示尚未精选到当前分支的提交
group.Git.RepositoryContextMenu.text=存储库(_R)
group.Git.ContextMenu.text=Git(_G)
group.Git.Menu.text=Git(_G)
action.Git.Rebase.Skip.text=跳过提交
action.Git.Rebase.Continue.text=继续衍合
action.Git.Revert.Abort.text=中止还原
action.Git.CherryPick.Abort.text=中止精选
action.Git.Merge.Abort.text=中止合并
action.Git.Rebase.Abort.text=中止衍合
action.Git.Rebase.text=衍合...
action.Git.Pull.text=拉取...
action.Git.Fetch.text=获取
action.Git.Clone.text=克隆...
action.Git.Configure.Remotes.text=远程...
action.Git.Reset.text=重置 HEAD...
action.Git.Unstash.text=取消暂存更改...
action.Git.Stash.text=暂存更改...
action.Git.Merge.text=合并更改...
action.Git.Tag.text=标签...
action.Git.Branches.text=分支 (_B)...
action.Git.ResolveConflicts.text=解决冲突...
action.Git.CompareWithBranch.text=与分支比较...
action.Git.Add.text=添加
action.Git.Commit.And.Push.Executor.text=提交和推送 (&P)...
action.Git.Interactive.Rebase.text=从这里进行交互式衍合...
action.Git.Interactive.Rebase.description=显示交互式衍合的对话框，从中允许对提交执行 squash、修复、重新排序、移除和改写
action.Git.Squash.Into.Commit.text=Squash 到…
action.Git.Squash.Into.Commit.description=创建 squash 提交
action.Git.Fixup.To.Commit.text=修复...
action.Git.Fixup.To.Commit.description=创建修复提交
action.Git.Rename.Local.Branch.text=重命名...
action.Git.Rename.Local.Branch.description=重命名本地分支
action.Git.New.Branch.description=仅选择一个分支以继续创建新分支
action.Git.New.Branch.dialog.title=从 {0} 创建新分支
action.Git.Update.Selected.text=更新所选内容
action.Git.Update.Selected.description=获取远程跟踪{0, choice,1\#分支|2\#分支}，并快速前向移动选定的本地{1, choice,1\#分支|2\#分支}（类似于 `git fetch branch\:branch`）
action.Git.Update.Selected.description.already.running=更新已在运行
action.Git.Update.Selected.description.select.non.current=仅选择非当前分支
action.Git.Update.Selected.description.tracking.not.configured=没有为选定{0,choice,1\#分支|2\#分支}配置跟踪分支
action.Git.Delete.Branch.title=删除{0,choice,1\#分支|2\#分支}
action.Git.Compare.With.Current.title=与当前分支进行比较
action.Git.Compare.Selected.title=比较分支
action.Git.Compare.Selected.description=相互比较选定分支
action.Git.Compare.Selected.description.disabled=从同一存储库中选择分支
action.Git.Show.My.Branches.title=显示我的分支
action.Git.Show.My.Branches.description.not.support.indexing=某些存储库不支持索引。
action.Git.Show.My.Branches.description.not.all.roots.indexed=并没有为所有存储库编制索引。
action.Git.Show.My.Branches.description.not.graph.ready=该日志尚未就绪，请稍候。
action.Git.Show.My.Branches.description.is.my.branch=如果分支的所有独占提交都是由“我”(即当前 Git 作者)执行的，则此分支为“我的”。
action.Git.Show.My.Branches.description.calculating.branches.progress=正在计算我的分支
action.Git.Fetch.title=获取所有远程
action.Git.Fetch.description.fetch.in.progress=正在获取…
action.Git.Toggle.Favorite.title=标记/取消标记为收藏项
action.Git.Loading.Branches.progress=正在加载分支…
group.Git.Local.Branch.title=本地
group.Git.Remote.Branch.title=远程
action.Git.Checkout.Branch.text=签出所选内容...
action.Git.Checkout.Branch.description=签出所选分支
action.Git.Log.Hide.Branches.text=隐藏 Git 分支
action.Git.Log.Show.Branches.text=分支
action.Git.Reword.Commit.text=编辑提交消息...
action.Git.Reword.Commit.description=通过 git衍合或修正的改写选项更改提交消息
action.Git.Squash.Commits.text=Squash 提交…
action.Git.Drop.Commits.text=删除提交
action.Git.Uncommit.text=撤消提交...
action.Git.Uncommit.description=撤消上次提交，并将其更改置于选定的更改列表
action.Git.Revert.In.Log.text=恢复提交
action.Git.Revert.In.Log.description=生成新提交，从而恢复在原始提交中所做的更改
action.Git.Reset.In.Log.text=将当前分支重置为此处...
action.Git.CreateNewTag.text=新标记...
action.Git.CreateNewTag.description=创建指向此提交的新标签
action.Git.CreateNewBranch.text=新分支...
action.Git.CreateNewBranch.description=从所选提交开始创建新分支
group.Git.CheckoutGroup.text=检出
group.Git.CheckoutGroup.description=签出所选修订版或所选提交中的分支
action.Git.BrowseRepoAtRevision.text=在修订版中显示存储库
action.Git.Log.text=显示 Git 存储库日志...
action.Git.Init.text=创建 Git 存储库...
checkbox.dont.warn.again=不再警告
checkbox.run.git.hooks=运行 Git 挂钩
action.NotificationAction.text.resolve=解决...
action.NotificationAction.GitDeleteBranchOperation.text.restore=恢复
action.NotificationAction.GitDeleteBranchOperation.text.view.commits=查看提交
action.NotificationAction.GitDeleteBranchOperation.text.delete.tracked.branch=删除跟踪的分支
action.NotificationAction.GitDeleteTagOperation.text.restore=恢复
action.NotificationAction.GithubNotifications.text.configure=配置...
action.NotificationAction.GitMergeAction.text.view.commits=查看提交
action.NotificationAction.GitRewordOperation.text.undo=撤消
action.NotificationAction.GitUpdateSession.text.view.commits=查看提交
settings.git.incoming.change.strategy.text.auto=自动
settings.git.incoming.change.strategy.text.always=始终
settings.git.incoming.change.strategy.text.never=从不
settings.git.update.method.rebase.description=在传入变更之上衍合当前分支
settings.git.update.method.rebase=Rebase
settings.git.update.method.merge.description=将传入变更合并到当前分支
settings.git.update.method.merge=合并
settings.git.update.method.branch.default=分支默认
clone.dialog.checking.git.version=正在检查 Git 版本…
push.dialog.push.tags=推送标记
push.dialog.push.tags.combo.current.branch=当前分支
push.dialog.push.tags.combo.all=所有
push.dialog.target.panel.define.remote=定义远程
push.dialog.target.panel.add.remote=添加远程
push.dialog.target.panel.couldnt.add.remote=无法添加远程\: {0}
push.dialog.target.panel.adding.remote=添加远程…
push.dialog.target.panel.can.t.push=无法推送
push.dialog.target.panel.empty.repository=空存储库
push.dialog.target.panel.detached.head=游离的 HEAD
push.dialog.target.panel.new=新建
push.dialog.preview.commits.before.push=对于向不受保护分支的提交和推送，应在推送之前预览提交

install.download.and.install.action=下载安装
install.installing.progress=正在安装...
install.downloading.progress=正在下载...
install.success.message=已安装 Git
install.general.error=无法安装 Git
install.mac.error.couldnt.start.command.line.tools=无法启动 Command Line Tools 安装
install.mac.requesting.command.line.tools=请求 XCode Command Line Developer Tools

git.status.not.changed=未更改
git.status.renamed=已重命名
git.status.copied=已复制
git.status.type.changed=已更改类型
git.status.unmerged=已取消合并
git.status.untracked=已取消跟踪
git.status.index=在暂存区域中{0}
git.status.work.tree=在工作目录中{0}
git.status.unmerged.index=由我们{0}
git.status.unmerged.work.tree=由他人{0}
git.status.unmerged.both=两者{0}

git.status.bar.widget.name=Git 分支

git.light.status.bar.display.name=Git
git.light.status.bar.tooltip=当前 Git 分支\: {0}
git.light.status.bar.text=Git\: {0}

stage.tab.name=暂存区域
stage.tree.node.staged=待提交
stage.tree.node.unstaged=未暂存提交
stage.tree.node.unmerged=已取消合并
stage.tree.node.untracked=已取消跟踪
stage.tree.node.ignored=已忽略
stage.content.staged=已暂存
stage.content.local=本地
stage.commit.process=正在提交暂存变更…
stage.commit.successful=已提交 {0}\: {1}
stage.commit.failed=无法提交 {0}
stage.loading.status=正在加载变更…
stage.reset.action.text=重置
stage.reset.process=正在重置文件…
stage.reset.error.title=无法重置文件
stage.revert.action.text=还原
stage.revert.process=正在还原文件…
stage.revert.error.title=无法还原文件
stage.vfs.write.process=正在将 {0} 写入 Git 索引
stage.vfs.read.process=正在从 Git 索引读取 {0}
stage.vfs.refresh.process=正在刷新 Git 索引文件
stage.vfs.presentable.file.name=已暂存\: {0}
stage.vfs.editor.tab.tooltip=''{0}'' 的暂存版本
stage.vfs.editor.notification.text=这是暂存版本的 ''{0}''
stage.vfs.editor.notification.link=打开本地版本

branches.selected.branches.updated.title=已更新所选{0,choice,1\#分支|2\#分支}
branches.update.failed=更新失败
branches.updating.process=正在更新分支…
branches.checkout.failed.description=无法覆盖{0}分支，因为某些提交可能会丢失
branches.creation.failed.title=新分支创建失败
branches.checkout.failed.title=签出失败
branches.checking.existing.commits.process=正在检查现有提交…
branches.create.new.branch.dialog.title=创建新分支
branches.tag.0=标记 ''{0}''
branches.branch.0=分支 ''{0}''
in.branches.all.repositories=在所有存储库中
branches.tags=标签
branches.branches=分支
repositories=存储库
common.remote.branches=公共远程分支
common.local.branches=公共本地分支
update.checks.not.supported.git.2.9.required=不支持更新检查。需要 Git 2.9+
action.fetch.text=获取
fetching=正在获取...
branches.current.branch=当前分支
branches.tracking.branch.doesn.t.configured.for.s=没有为 {0} 配置跟踪分支
branches.update.is.already.running=更新已在运行
branches.fetch.remote.and.fast.forward=获取远程跟踪分支并快进 {0} (类似于 `git fetch {1}\:{1}`)
branches.update=更新
branches.checkout.and.rebase.onto.in.one.step=签出 {0}，并在一个步骤中将其衍合到 {1} (类似于 `git rebase HEAD {2}`)
branches.checkout.and.rebase.onto.current=签出并衍合到当前分支
branches.rebase.is.not.possible.in.the.detached.head.state=在游离的 HEAD 状态下无法衍合
branches.rebase.onto=将{0}衍合到{1}
branches.rebase.current.onto.selected=将当前分支衍合到所选分支
branches.merge.into=将{0}合并到{1}中
branches.merge.into.current=合并到当前分支
branches.compare.the.current.working.tree.with=将当前工作树与{0}中的树进行比较
branches.show.diff.with.working.tree=显示与工作树的差异
branches.show.commits.in=在{0}中显示{1}中缺少的提交
branches.compare.with.current=与当前分支进行比较
branches.new.branch.from.selected=从所选分支新建分支…
branches.checkout.s=签出 {0}
checkout.and.rebase=签出并衍合
checkout.0=签出 {0}
branch.0.already.exists.and.has.commits.which.do.not.exist.in.1.would.you.like.to.rebase.or.reset.them=分支 {0} 已存在，并且具有在{1}中不存在的提交。要衍合还是重置它们?
branches.checkout=检出
branches.renaming.branch.is.not.possible.before.the.first.commit=无法在第一次提交之前重命名分支
branches.rename.branch=重命名分支 {0}
branches.there.are.outgoing.commits=存在传出提交
branches.there.are.incoming.commits=存在传入提交
branches.there.are.incoming.and.outgoing.commits=存在传入和传出提交
branches.checkout.is.not.possible.before.the.first.commit=无法在第一次提交之前进行签出
branches.checkout.tag.or.revision=签出标记或修订…
branches.enter.reference.branch.tag.name.or.commit.hash=输入引用(分支、标记)名称或提交哈希\:
branches.remote.branches=远程分支
branches.remote.branches.in.repo={0} 中的远程分支
branches.local.branches=本地分支
branches.local.branches.in.repo={0} 中的本地分支
branches.update.info.process=正在更新分支信息…
git.rollback=&回滚

new.branch.dialog.operation.create.name=创建
new.branch.dialog.operation.create.description=在其他存储库中创建新分支
new.branch.dialog.operation.checkout.name=检出
new.branch.dialog.operation.checkout.description=签出现有分支，并在其他存储库中创建新分支
new.branch.dialog.operation.rename.name=重命名
new.branch.dialog.branch.name=新分支名称\:
new.branch.dialog.checkout.branch.checkbox=签出分支
new.branch.dialog.set.tracking.branch.checkbox=设置跟踪分支
new.branch.dialog.overwrite.existing.branch.checkbox=覆盖现有分支
new.branch.dialog.overwrite.existing.branch.warning=更改名称或覆盖现有分支
new.branch.dialog.error.branch.name.invalid=分支名称 {0} 无效
new.branch.dialog.error.branch.already.exists=分支名称 {0} 已存在
new.branch.dialog.error.branch.clashes.with.remote=分支名称 {0} 与同名的远程分支冲突
git.reset.mode.soft=软
git.reset.mode.soft.description=文件不会更改，差异将暂存以进行提交。
git.reset.mode.mixed=混合
git.reset.mode.mixed.description=文件不会更改，差异也不进行暂存。
git.reset.mode.hard=硬
git.reset.mode.hard.description=<nobr>文件将还原为所选提交的状态。<nobr/><br><nobr>警告\: 任何本地变更都将丢失。<nobr/>
git.reset.mode.keep=保持
git.reset.mode.keep.description=<nobr>文件将还原为所选提交的状态，<nobr/><br><nobr>但本地变更将保持不变。<nobr/>
git.reset.dialog.title=Git 重置
git.reset.dialog.description=<nobr>这会将当前分支头部重置为所选提交，<nobr/><br><nobr>并根据所选模式更新工作树和索引\:<nobr/>
git.reset.dialog.description.commit.details.by.author={0}，作者为 {1}
git.reset.dialog.description.source.in.repository={0}在{1}
git.reset.process=Git 重置
git.reset.button=重置
git.undo.action.cant.undo.commit.failure=无法撤消提交
git.undo.action.description=所选提交不是当前分支中的最后一次提交
git.undo.action.select.target.changelist.title=选择目标变更列表
git.undo.action.undoing.last.commit.process=正在撤消最后一次提交…
git.undo.action.refreshing.changes.process=正在刷新变更…
git.undo.action.could.not.load.changes.of.commit=无法加载 {0} 的变更
git.new.tag.dialog.title=在 {0}上创建新标记
git.new.tag.dialog.tag.name.label=输入新标记的名称

git.log.external.tab.description={0} 的日志
git.log.external.window.title=Git 日志
git.log.external.loading.process=正在加载 Git 日志…

git.log.cherry.picked.highlighter.select.branch.popup=选择源分支
git.log.cherry.picked.highlighter.process=正在比较分支…
git.log.cherry.picked.highlighter.error.message=无法与分支 {0} 进行比较
git.log.cherry.picked.highlighter.cancelled.message=已取消对 ''{0}'' 中未选取提交的高亮显示，因为分支筛选器已被更改。

git.log.action.checkout.group=检出
git.log.action.checkout.revision.short.text=修订 ''{0}''
git.log.action.checkout.revision.full.text=签出修订 ''{0}''
action.Git.CheckoutRevision.text=签出修订

git.log.diff.handler.process=正在计算 {0} 的差异
git.log.diff.handler.failed.message={0} 失败
git.log.diff.handler.paths.diff.title={2} 中 {0} 与 {1} 之间的变更
git.log.diff.handler.local.version.name=本地版本
git.log.diff.handler.local.version.content.title=本地

git.log.refGroup.local=本地

history.indexing.disabled.notification.text=显示的是旧式文件历史记录，因为索引不可用
history.indexing.disabled.notification.resume.link=恢复 Git 日志索引
history.indexing.disabled.notification.dismiss.link=不要再显示

git.history.diff.handler.choose.parent.popup=选择要比较的父项
git.history.diff.handler.load.changes.process=正在加载变更…
git.history.diff.handler.git.show.error=执行 git show {0}\:{1} 时出错
git.log.show.commit.in.log.process=搜索修订 {0}
git.compare.branches.empty.status={0} 包含来自 {1} 的所有提交
git.compare.branches.explanation.message=存在于 {0} 中但不存在于 {1} 中的提交
git.compare.branches.tab.name=比较
git.compare.branches.tab.suffix={0}和{1}
git.update.files.updated.in.commits=已更新 {1,choice,1\#{1} 个提交|2\#{1} 个提交}中的 {0,choice,1\#{0} 个文件|2\#{0} 个文件}
git.update.no.commits.matching.filters=没有与筛选器匹配的提交
git.update.commits.matching.filters={0,choice,1\#{0} 个提交|2\#{0} 个提交}与筛选器匹配
git.update.project.partially.updated.title=项目已部分更新
git.update.skipped.repositories=已跳过 {0} 个存储库\:
git.update.repo.was.skipped=已跳过 {0} ({1})

git.integration.created.git.repository.in=已在 {0} 中创建 Git 存储库
git.integration.could.not.git.init=无法 git init {0}

git.tag.could.not.create.tag=无法创建标记
git.tag.created.tag.successfully=已成功创建标记 {0}。

rename.branch.operation.name=重命名
git.rename.branch.rollback.successful=回滚成功
git.rename.branch.renamed.back.to=已重命名回 {0}
git.rename.branch.rollback.failed=回滚失败
git.rename.branch.could.not.rename.from.to=无法将 {0} 重命名为 {1}
git.rename.branch.was.renamed.to=分支 {0} 已被重命名为 {1}
git.rename.branch.you.may.rename.branch.back=您可以回滚(将分支重命名回 {0})以不让分支出现分叉。
git.rename.branch.has.succeeded.for.the.following.repositories=不过，以下{0,choice,1\#存储库|2\#存储库}的重命名已成功\:

update.process.progress.title=(更新中...)
update.process.generic.error.title=无法更新
update.process.error.message.unfinished.merge=您有未完成的合并。必须先解决这些冲突，然后才能更新。
update.process.error.message.unmerged.files=检测到未合并的文件。必须先解决这些冲突，然后才能更新。
update.process.error.description.unfinished.rebase=您有未完成的衍合进程。必须先解决这些冲突，然后才能更新。
update.process.error.additional.description.unfinished.rebase=然后，您可以<b>继续衍合</b>。<br/>您也可以<b>中止衍合</b>以恢复原始分支并停止衍合。

checkout.operation.could.not.checkout.error=无法签出 {0}
checkout.operation.revision.not.found=在{0,choice,0\#|1\#{1}中}未找到修订
checkout.operation.rollback=回滚
checkout.operation.could.not.checkout.error.title=无法签出 {0}
checkout.operation.checked.out=已签出 {0}
checkout.operation.checked.out.new.branch.from=已从 {1} 中签出新分支 {0}
checkout.operation.in={1,choice,0\#|1\#{2}中的}{0}
checkout.operation.force.checkout=强制签出(&F)
checkout.operation.name=检出
checkout.operation.error.during.rollback=回滚期间出错
checkout.operation.errors.during.deleting=删除{0}期间出错\:
checkout.operation.errors.during.checkout=签出期间出错\:
checkout.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滚(签回 {0})以不让分支出现分叉。
checkout.operation.previous.branch=上一个分支
checkout.operation.however.checkout.has.succeeded.for.the.following=不过，以下{0,choice,1\#存储库|2\#存储库}的签出已成功\:

delete.branch.operation.collecting.unmerged.commits.process=正在收集未合并的提交…
delete.branch.operation.restoring.branch.process=正在恢复分支 {0}…
delete.branch.operation.error.during.rollback.of.branch.deletion=分支删除回滚期间出错
delete.branch.operation.could.not.restore.branch.error=无法恢复{0}
delete.branch.operation.branch.was.not.deleted.error=分支 {0} 未删除
delete.branch.operation.deleted.branch=已删除分支 {0}
delete.branch.operation.deleted.branch.bold=<b>已删除的分支\:</b> {0}
delete.branch.operation.unmerged.commits.were.discarded=未合并的提交已被丢弃
delete.branch.operation.however.branch.deletion.has.succeeded.for.the.following=不过，以下{0,choice,1\#存储库|2\#存储库}的分支删除已成功\:
delete.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滚(在这些根中重新创建 {0})以不让分支出现分叉。

branch.operation.could.not.0.operation.name.1.reference=无法{0} {1}
branch.operation.in={0} ({1} 中)

checkout.new.branch.operation.could.not.create.new.branch=无法创建新分支 {0}
checkout.new.branch.operation.error.during.rollback=回滚期间出错
checkout.new.branch.operation.errors.during.deleting=删除 {0} 期间出错\:
checkout.new.branch.operation.errors.during.checkout=签出期间出错\:
checkout.new.branch.operation.rollback.successful=回滚成功
checkout.new.branch.operation.checked.out.0.and.deleted.1.on.2.3=已在{2,choice,1\#根|2\#根}{3}上签出 {0} 并删除 {1}
checkout.new.branch.operation.branch.was.created=已创建分支 {0}
checkout.new.branch.operation.however.checkout.has.succeeded.for.the.following=不过，{0,choice,1\#存储库|2\#存储库}的签出已成功\:
checkout.new.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滚(签回上一个分支并删除 {0})以不让分支出现分叉。

delete.branch.operation.name=分支删除
delete.remote.branch.operation.deleting.process=删除中{0}
delete.remote.branch.operation.deleted.remote.branch=已删除远程分支 {0}
delete.remote.branch.operation.also.deleted.local.branches=同时删除了本地{0,choice,1\#分支|2\#分支}\: {1}
delete.remote.branch.operation.failed.to.delete.remote.branch=无法删除远程分支 {0}

delete.remote.tag.operation.deleted.tag.on.remotes=<b>已删除{0,choice,1\#远程|2\#远程}上的标记\:</b> {1}
delete.remote.tag.operation.tag.does.not.exist.on.remotes=<b>标记在{0,choice,1\#远程|2\#远程}上不存在\:</b> {1}
delete.remote.tag.operation.failed.to.delete.tag.on.remotes=无法删除{1,choice,1\#远程|2\#远程}上的标记 {0}

merge.dialog.description.cherry.pick.label.text=优选{2,choice,0\#|1\#由 {3}{4} 执行的}{0,choice,1\#提交 {1}|2\#多个提交}期间出现冲突
merge.dialog.description.merge.label.text=将{0,choice,1\#分支 {1}|2\#分叉的分支}合并到{2,choice,1\#分支 {3}|2\#分叉的分支}
merge.dialog.description.rebase.with.hash.label.text=将{0,choice,0\#|1\#分支 {1}} 衍合到 {2}
merge.dialog.description.rebase.with.onto.branch.label.text=将{0,choice,0\#|1\#分支 {1}} 衍合到分支 {2}{3,choice,0\#|1\#，修订 {4}}
merge.dialog.description.rebase.without.onto.info.label.text=将{0,choice,0\#|1\#分支 {1}} 衍合到分叉的分支
merge.dialog.diff.left.title.cherry.pick.label.text=本地变更
merge.dialog.diff.left.title.default.branch.label.text=您的版本，分支 {0}
merge.dialog.diff.left.title.rebase.label.text=从{1}衍合{0}
merge.dialog.diff.right.title.cherry.pick.label.text=来自优选 {0} 的变更
merge.dialog.diff.right.title.default.with.hash.label.text=来自{0}的变更
merge.dialog.diff.right.title.default.with.onto.branch.label.text=来自分支 {0}{1,choice,0\#|1\#，修订 {2}} 的变更
merge.dialog.diff.right.title.default.without.onto.info.label.text=来自分叉分支的变更
merge.dialog.diff.right.title.rebase.with.branch.label.text=已衍合的提交和来自{0}的提交
merge.dialog.diff.right.title.rebase.without.branch.label.text=已衍合的提交
merge.dialog.diff.title.changes.from.branch.label.text=来自{0}的变更
merge.operation.name=合并
merge.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滚(重置为合并之前的提交)以不让分支出现分叉。
merge.operation.error.during.rollback=回滚期间出错
merge.operation.branch.merged.with.conflicts={0}已合并，但存在冲突
merge.operation.could.not.merge.branch=无法合并{0}
merge.operation.already.up.to.date=已是最新
merge.operation.however.merge.has.succeeded.for.the.following.repositories=不过，以下{0,choice,1\#存储库|2\#存储库}的合并已成功\:
merge.operation.merged.to=已将{0}合并到{1}
merge.operation.delete.branch=删除{0}

merge.unresolved.conflicts.remaining.notification.title=仍存在未解决的冲突
merge.unresolved.conflicts.remaining.notification.body=项目中仍存在未解决的冲突。

create.branch.operation.name=创建分支
create.branch.operation.could.not.create.new.branch=无法创建新分支 {0}
create.branch.operation.rollback.successful=回滚成功
create.branch.operation.deleted.branch=已删除 {0}
create.branch.operation.error.during.rollback=回滚期间出错
create.branch.operation.branch.created=已创建分支 {0}
create.branch.operation.however.the.branch.was.created.in.the.following.repositories=不过，已在以下{0,choice,1\#存储库|2\#存储库}中创建分支\:
create.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滚(删除 {0})以不让分支出现分叉。

branch.ui.handler.can.not.operation.name.because.of.unmerged.files=由于存在未合并的文件而无法{0}
branch.ui.handler.unmerged.files.error.notification=您必须先<a href\=''{0}''>解决</a>所有合并冲突，然后才能{1}。<br/>解决冲突之后，您可能还需要将文件提交到当前分支。
branch.ui.handler.merge.notification.description=以下文件存在未解决的冲突。您需要先解决它们，然后再{0}。
branch.ui.handler.merge.error.notification.title=仍然存在未解决的文件。
branch.ui.handler.rollback=回滚
branch.ui.handler.do.not.rollback=不回滚
branch.ui.handler.you.have.to.resolve.all.conflicts.before.operation.name=您必须先解决所有合并冲突，然后才能{0}。<br/>{1}
branch.ui.handler.delete.remote.branches=删除远程{0,choice,1\#分支|2\#分支}
branch.ui.handler.delete.all=全部删除
branch.ui.handler.delete.remote.branches.question=删除远程{0,choice,1\#分支|2\#分支} {1}?
branch.ui.handler.delete.tracking.local.branch.as.well=同时删除跟踪本地分支 {0}
branch.ui.handler.delete.tracking.local.branches=删除跟踪本地分支\:

delete.tag.operation.could.not.restore.tag=无法恢复 {0}
delete.tag.operation.error.during.rollback.of.tag.deletion=标记删除回滚期间出错
delete.tag.operation.restored.tag=已恢复标记 {0}
delete.tag.operation.rollback.successful=回滚成功
delete.tag.operation.restoring.tag.process=正在恢复标记 {0}…
delete.tag.operation.deleted.tag=<b>已删除的标记\:</b> {0}
delete.tag.operation.delete.on.remote=在{0,choice,1\#远程|2\#远程}上删除
delete.tag.operation.could.not.find.tag=无法找到标记 {0}
delete.tag.operation.could.not.find.tag.in=在{0}中无法找到标记
delete.tag.operation.tag.was.not.deleted=未删除标记 {0}
delete.tag.operation.however.tag.deletion.has.succeeded.for.the.following=不过，以下{0,choice,1\#存储库|2\#存储库}的标记删除已成功\:
delete.tag.operation.you.may.rollback.not.to.let.tags.diverge=您可以回滚(在这些根中重新创建 {0})以不让标记出现分叉。

branch.renaming.branch.process=正在将 {0} 重命名为 {1}…
branch.rebasing.process=正在衍合 {0}…
branch.rebasing.onto.process=正在衍合到 {0}…
branch.merging.process=正在合并 {0}…
branch.deleting.tag.process=正在删除标记 {0}…
branch.deleting.tag.on.remote.process=正在删除远程上的标记 {0}…
branch.deleting.remote.branch=删除中{0}...
branch.deleting.branch.process=删除中{0}...
branch.checking.out.new.branch.process=正在签出新分支 {0}…
branch.creating.branch.process=正在创建分支 {0}…
branch.checking.out.branch.from.process=正在从 {1} 签出 {0}…
branch.checking.out.process=正在签出 {0}…

branch.not.fully.merged.dialog.repository.label=存储库\: 
branch.not.fully.merged.dialog.title=分支未完全合并
branch.not.fully.merged.dialog.restore.button=&恢复
branch.not.fully.merged.dialog.all.commits.from.branch.were.merged=已合并来自分支 {0} 的所有提交
branch.not.fully.merged.dialog.the.branch.was.not.fully.merged.to=分支 {0} 未完全合并到 {1}。<br/>以下是未合并提交的列表。

merge.dialog.customizer.filter.by.conflicted.file.checkbox=按冲突文件筛选
merge.dialog.customizer.show.details.link.label=显示详细
merge.dialog.customizer.collecting.details.progress=正在收集提交详细信息…

branch.worker.could.not.create.tag=无法{1,choice,0\#|1\#|2\#在 {2} 中}创建标记 {0}

commit.options.sign.off.commit.checkbox=签署提交
commit.options.sign.off.commit.message.line=在提交消息末尾添加以下行\:<br/>Signed-off by\: {0}
commit.options.create.extra.commit.with.file.movements=使用文件移动创建额外提交

show.diff.between.dialog.title=显示 {0} 与当前工作树之间的差异
show.diff.between.dialog.no.differences.empty.text=无差异
show.diff.between.dialog.could.not.load.diff.with.branch.error=无法加载与 {0} 的差异\: {1}
annotations.options.detect.movements.across.files=检测跨文件的移动
annotations.options.detect.movements.within.file=检测文件内的移动
annotations.options.ignore.whitespaces=忽略空格
annotations.options.group=选项
progress.title.moving.files=正在移动文件…

editor.promo.commit.text=使用提交接口直接从 {0} 提交。
editor.promo.commit.try.link=尝试
editor.promo.help.link=了解更多
editor.promo.close.link=不要再显示

tracked.branch.fix.dialog.title=更新
tracked.branch.fix.dialog.ok.button.text=更新
tracked.branch.fix.dialog.set.as.tracked=设为跟踪分支
tracked.branch.fix.dialog.no.tracked.branch=跟踪分支未配置。
tracked.branch.fix.dialog.branch.placeholder=指定分支
progress.title.enabling.git=正在启用 Git...