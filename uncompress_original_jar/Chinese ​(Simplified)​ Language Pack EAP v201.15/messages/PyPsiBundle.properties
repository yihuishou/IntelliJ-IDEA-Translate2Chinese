# Message we display for inspection if user uses custom class type members that do not exist
custom.type.mimic.name=动态类基于 {0}

### Refactoring

refactoring.extract.method.error.interrupted.execution.flow=执行流中断时无法执行重构
refactoring.extract.method.error.star.import=无法使用代码块内的 star 导入语句执行重构
refactoring.extract.method.error.yield=无法使用代码块内的 'yield' 语句执行重构

### Annotators ###
ANN.deleting.none=删除 None
ANN.assign.to.none=赋值给 None
ANN.cant.assign.to.call=无法分配给函数调用
ANN.cant.delete.call=无法删除函数调用
ANN.cant.aug.assign.to.generator=无法增强分配给生成器表达式
ANN.cant.aug.assign.to.tuple.or.generator=无法增强分配给元组文字或生成器表达式
ANN.cant.assign.to.generator=无法分配给生成器表达式
ANN.cant.assign.to.operator=无法分配给运算符
ANN.cant.assign.to.parens=无法分配给 ()
ANN.cant.aug.assign.to.list.or.comprh=无法增强分配给列表文字或推导式
ANN.cant.assign.to.comprh=无法分配给列表推导式
ANN.cant.assign.to.dict.comprh=无法分配给字典推导式
ANN.cant.assign.to.set.comprh=无法分配给集合推导式
ANN.cant.aug.assign.to.comprh=无法增强分配给列表推导式
ANN.cant.aug.assign.to.dict.comprh=无法增强分配给字典推导式
ANN.cant.aug.assign.to.set.comprh=无法增强分配给集合推导式
ANN.cant.assign.to.literal=无法分配给文字
ANN.cant.delete.literal=无法删除文字
ANN.cant.assign.to.lambda=无法分配给 lambda

ANN.break.outside.loop='break' 在循环外
ANN.continue.outside.loop='continue' 在循环外

ANN.$0.assigned.before.global.decl=在全局声明前已分配名称 ''{0}''

ANN.duplicate.param.name=重复的参数名称
ANN.starred.param.after.kwparam=* 参数在 ** 参数后面
ANN.regular.param.after.vararg=正则参数在 * 参数后面
ANN.regular.param.after.keyword=正则参数在 ** 参数后面
ANN.non.default.param.after.default=默认参数后面跟随非默认参数
ANN.named.parameters.after.star=bare * 后面必须跟随命名参数
ANN.named.parameters.before.slash=命名参数必须位于 bare / 前面
ANN.tuple.py3=Python 3 中不支持元组参数解压缩
ANN.multiple.args=不允许多个 * 参数
ANN.multiple.kwargs=不允许多个 ** 参数
ANN.multiple.slash=不允许多个 / 参数
ANN.slash.param.after.vararg=/ 参数必须在 * 参数前面
ANN.slash.param.after.keyword=/ 参数必须在 ** 参数前面

ANN.star.import.at.top.only=仅在模块级别允许 'import *' 

ANN.missing.closing.quote=缺少右引号 [{0}]
ANN.missing.closing.triple.quotes=缺少右三引号

ANN.method.$0.removed.use.$1=方法 ''{0}'' 已移除，改为使用 ''{1}''
ANN.method.$0.removed=方法 ''{0}'' 已移除

### parsing
PARSE.expected.expression=表达式是预期的
PARSE.expected.rbracket=']' 预期
PARSE.expected.expr.or.comma.or.bracket=预期为表达式、',' 或 ']'
PARSE.expected.in=预期为 'in'
PARSE.expected.for.or.bracket=预期为 ']' 或 'for'
PARSE.expected.comma=',' 预期
PARSE.expected.colon='\:' 预期
PARSE.expected.rpar=')' 是预期的
PARSE.expected.lpar='(' 预期
PARSE.expected.rbrace='}' 预期
PARSE.expected.tick=预期为 '`'（反引号）
PARSE.expected.name=预期名字
PARSE.expected.colon.or.rbracket=预期为 '\:' 或 ']'
PARSE.expected.comma.or.rpar=预期为 ',' 或 ')'
PARSE.expected.else=预期为 'else'

PARSE.expected.identifier=标识符是预期的
PARSE.expected.comma.lpar.rpar=预期为 ',' 或 '(' 或 ')'
PARSE.expected.statement.break=预期语句中断
PARSE.expected.@.or.def=预期为 '@' 或 'def'
PARSE.expected.formal.param.name=预期为正式参数名称
PARSE.0.expected={0}是预期的
PARSE.expected.ellipsis='...' 是预期的

statement.expected.found.0=预期为语句，发现为 {0}
unexpected.indent=异常缩进
unindent.does.not.match.any.outer.indent=取消缩进不匹配任何外部缩进级别
except.or.finally.expected=应为 'except' 或 'finally'
expected.statement=预期为语句
dedent.expected=预期为向左缩进
indent.expected=预期缩进
indented.block.expected=预期为缩进的块
cannot.assign.to.yield.expression=无法分配给 'yield' 表达式
end.of.statement.expected=预期为语句结束
import.expected=预期为 'import'
def.or.with.or.for.expected=预期为 'def' 或 'with' 或 'for'
rbracket.or.comma.expected=预期为 ']' 或 ','
unexpected.expression.syntax=异常的表达式语法
tuple.expression.expected=预期为元组表达式
value.expression.expected=预期为值表达式
unexpected.expression.part=异常的表达式部分
unexpected.f.string.token=异常的格式化字符串令牌
can.t.assign.to.await.expression=无法分配给 await 表达式
for.expected=预期为 'for'
rarrow.expected='->' 预期
unexpected.tokens=意外令牌

PARSE.function.type.annotations.py2=Python 2 不支持类型注解
PARSE.function.return.type.annotations.py2=Python 2 不支持返回类型注解

PARSE.console.multiline.magic.warn=多行魔术不能用作表达式
PARSE.console.identifier.expected=标识符是预期的.
PARSE.console.help.request.warn=名称后面必须跟随帮助请求

### quick doc generator
QDOC.module.path.unknown=（模块路径未知）
QDOC.epydoc.python2.sdk.not.found=您需要配置好的 Python 2 SDK 来呈现 <a href\='http\://epydoc.sourceforge.net/'>Epydoc</a> 文档字符串
QDOC.local.sdk.not.found=您需要配置好的本地 Python SDK 来呈现文档字符串。
QDOC.assigned.to=已分配给：
QDOC.documentation.is.copied.from=文档复制自：
QDOC.accessor.kind=访问器种类：
QDOC.raises=引发：
QDOC.keyword.args=关键字参数：
QDOC.returns=返回\:
QDOC.params=参数\:

### Formatter
formatter.panel.dict.alignment.do.not.align=不对齐
formatter.panel.dict.alignment.align.on.colon=对齐冒号
formatter.panel.dict.alignment.align.on.value=对齐值

QFIX.add.field.to.class=添加字段到类
QFIX.added.constructor.$0.for.field.$1=添加了 __init__ 到类 <code>{0}</code><br/>，以适应新字段 <code>{1}</code>
QFIX.NAME.remove.parameter=删除参数
QFIX.rename.parameter.to.$0=重命名为 ''{0}''
QFIX.NAME.add.field.$0.to.class.$1=添加字段 ''{0}'' 到类 {1}
QFIX.NAME.remove.statement=移除语句
QFIX.failed.to.add.field=<br/>无法添加字段！<br/><br/>

#PyDefaultArgumentQuickFix
QFIX.default.argument=替换可变默认参数

QFIX.redundant.parentheses=移除冗余括号

QFIX.simplify.boolean.expression=简化布尔表达式
QFIX.simplify.$0=将布尔表达式替换为 ''{0}''

QFIX.chained.comparison=简化链式比较

INSP.GROUP.python=Python

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=未解析的引用
INSP.module.$0.not.found=找不到模块 ''{0}''
INSP.unresolved.ref.$0=未解析的引用 ''{0}''
INSP.unresolved.ref.$0.for.class.$1=类 ''{1}'' 的属性引用 ''{0}'' 未解析
INSP.cannot.find.$0.in.$1=在 ''{1}'' 中找不到引用 ''{0}''
INSP.unresolved.operator.ref=类 ''{0}'' 未定义 ''{1}''，所以不能对其实例使用 ''{2}'' 运算符
python.stub=Python 存根

# PyRedundantParenthesesInspection
INSP.NAME.redundant.parentheses=冗余括号
INSP.redundant.parens.ignore.empty.lists.of.base.classes=忽略基类的空列表
INSP.redundant.parens.ignore.tuples=忽略元组
INSP.redundant.parens.ignore.argument.of.operator=忽略 % 运算符的参数

# PySimplifyBooleanCheckInspection
INSP.NAME.check.can.be.simplified=可以简化布尔变量检查
INSP.expression.can.be.simplified=可以简化表达式
INSP.simplify.boolean.check.ignore.comparison.to.zero=忽略与零的比较

# Actions and associated commands
ACT.CMD.use.import=使用导入的模块
ACT.qualify.with.module=使用导入的模块进行限定
ACT.from.some.module.import=从...导入

### Quick fixes ###
QFIX.auto.import.family=导入
QFIX.auto.import.import.this.name=导入此名称
QFIX.auto.import.import.name=导入 ''{0}''

QFIX.local.auto.import.family=本地导入
QFIX.local.auto.import.import.locally=本地 {0}

python.docstring.file.type=python 文档字符串
python.function.type.annotation.file.type.description=Python PEP-484 函数类型注释
# PyUnusedLocalInspection
INSP.NAME.unused=未使用本地
INSP.unused.locals.parameter.isnot.used=未使用参数 ''{0}'' 值 
INSP.unused.locals.local.variable.isnot.used=未使用局部变量 ''{0}'' 值
INSP.unused.locals.replace.with.wildcard=替换为 _
INSP.unused.locals.local.function.isnot.used=未使用局部函数 ''{0}''
INSP.unused.locals.local.class.isnot.used=未使用局部类 ''{0}''

INSP.unused.locals.ignore.variables.starting.with=忽略以 '_' 开头的变量
INSP.unused.locals.ignore.range.iteration.variables=忽略范围迭代变量
INSP.unused.locals.ignore.lambda.parameters=忽略 lambda 参数
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=忽略元组解压缩时使用的变量

find.usages.unnamed=<未命名>
find.usages.keyword.argument=关键字参数
find.usages.variable=变量
find.usages.imported.module.alias=已导入模块别名
find.usages.class=类
find.usages.function=函数
find.usages.method=方法
find.usages.parameter=参数

python.find.usages=发现用法
python.find.usages.base.method.question=方法 {0} 覆盖类 {1} 的方法。\n是否要查找这种基本方法的用法？
python.find.usages.usage.in.superclass.list=超类列表中的用法
python.find.usages.usage.in.isinstance=isinstance() 中的用法
python.find.usages.untyped.probable.usage=无类型（可能）用法
python.find.usages.usage.in.import.statement=导入语句中的用法
