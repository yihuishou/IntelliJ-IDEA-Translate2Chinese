fix.insert.delegation.call=插入 ''{0}()'' 调用
fix.introduce.non.null.assertion=添加非空断言(\!\!)调用
fix.remove.non.null.assertion=移除不必要的非空断言(\!\!)
fix.add.annotation.target=添加注解目标
fix.add.const.modifier=添加 'const' 修饰符
fix.add.constructor.parameter=添加构造函数参数 ''{0}''
fix.make.data.class=使 ''{0}'' 成为数据类
fix.add.default.constructor=将默认构造函数添加到 'expect' 类
fix.add.explicit.import=添加显式导入
fix.add.function.body=添加函数体
fix.add.is.to.when=在 ''{0}'' 前面添加 ''is''
fix.add.new.line.after.annotations=在注解后面添加新行
fix.make.type.parameter.reified=使 {0} 具体化且使 {1} 内联
fix.add.return.last.expression=将 'return' 添加到上一个表达式
fix.add.return.before.expression=在表达式前面添加 'return'
fix.add.return.before.lambda.expression=在 lambda 表达式前面添加 'run'
fix.add.semicolon.lambda.expression=使用分号终止前面的调用
fix.add.spread.operator.after.sam=在作为 'vararg' 传递的数组之前添加延展操作符
fix.add.else.branch.when=添加 else 分支
fix.replace.with.assign.function.call=替换为 ''{0}'' 调用
fix.assign.to.property=分配给属性
fix.change.mutability.change.to.val=将 ''{0}'' 更改为 val
fix.change.type.argument=将类型参数更改为 {0}
fix.change.to.function.invocation=更改为函数调用
fix.change.to.mutable.type=将类型更改为 {0}

fix.change.to.property.access.family.remove=移除调用
fix.change.to.property.access.family.change=更改为属性访问

fix.change.to.labeled.return.family=更改为带标签的返回
fix.change.to.labeled.return.text=更改为 ''{0}''

fix.change.suspend.hierarchy.add=将 'suspend' 修饰符添加到层次结构中的所有函数
fix.change.suspend.hierarchy.remove=从层次结构中的所有函数中移除 'suspend' 修饰符
fix.change.progress.looking.inheritors=正在查找类 {0} 继承者…
fix.change.progress.analyzing.class.hierarchy=正在分析类层次结构…

fix.change.return.type.family=更改类型
fix.change.return.type.text.primary.constructor=将类 ''{1}'' 主构造函数的参数 ''{0}'' 类型更改为 ''{2}''
fix.change.return.type.text.function=将函数 ''{1}'' 的参数 ''{0}'' 类型更改为 ''{2}''
fix.change.return.type.lambda=将 lambda 表达式返回类型更改为 {0}
fix.change.return.type.remove.explicit.return.type=移除显式指定的返回类型
fix.change.return.type.remove.explicit.return.type.of=移除 {0} 的显式指定的返回类型
fix.change.return.type.return.type.text=将返回类型更改为 ''{0}''
fix.change.return.type.return.type.text.of=将 {0} 的返回类型更改为 ''{1}''
fix.change.return.type.type.text=改变类型到''{0}''
fix.change.return.type.type.text.of=将 {0} 的类型更改为 ''{1}''
fix.change.return.type.presentation.property=属性 {0}
fix.change.return.type.presentation.function=函数 {0}
fix.change.return.type.presentation.enclosing.function=封闭的函数
fix.change.return.type.presentation.enclosing=封闭的 {0}
fix.change.return.type.presentation.called.function=调用的函数
fix.change.return.type.presentation.accessed=访问的{0}
fix.change.return.type.presentation.called=调用的{0}
fix.change.return.type.presentation.base=基{0}

fix.cast.expression.family=强制转换表达式
fix.cast.expression.text=将表达式 ''{0}'' 转换为 ''{1}''

fix.change.accessor.family=更改访问器类型
fix.change.accessor.getter=将 getter 类型更改为 {0}
fix.change.accessor.setter.parameter=将 setter 参数类型更改为 {0}

fix.create.from.usage.dialog.title=从使用创建

fix.add.remaining.branches=添加剩余的分支
fix.add.remaining.branches.with.star.import=使用 * 导入添加剩余的分支

fix.add.type.annnotation.family=添加类型注解
fix.add.type.annnotation.text=将类型 ''{0}'' 添加到参数 ''{1}''

fix.add.tostring.call.family=添加 'toString()' 调用
fix.add.tostring.call.text=添加 'toString()' 调用
fix.add.tostring.call.text.safe=添加安全的 '?.toString()' 调用

fix.add.star.projection.family=添加星号投影
fix.add.star.projection.text=添加 ''{0}''

fix.change.to.star.projection.family=更改为星号投影
fix.change.to.star.projection.text=将类型参数更改为 {0}

fix.change.to.use.spread.operator.family=更改为使用延展操作符
fix.change.to.use.spread.operator.text=将 ''{0}'' 更改为 ''{1}''

fix.change.type.family=更改类型
fix.change.type.text=将类型从 ''{0}'' 更改为 ''{1}''

fix.add.suspend.modifier.function=使{0}挂起
fix.add.suspend.modifier.function.generic=使包含函数挂起
fix.add.suspend.modifier.receiver=使{0}类型挂起
fix.add.suspend.modifier.receiver.generic=使接收器类型挂起

fix.add.property.to.supertype.family=将属性添加到父类型
fix.add.property.to.supertype.text=将 ''{0}'' 添加到 ''{1}''
fix.add.property.to.supertype.text.generic=将属性添加到父类型…
fix.add.property.to.supertype.progress=将属性添加到类型
fix.add.property.to.supertype.choose.type=选择类型

fix.add.function.parameters.change.signature.constructor=更改构造函数 ''{0}'' 的签名
fix.add.function.parameters.change.signature.function=更改函数 ''{0}'' 的签名
fix.add.function.parameters.add.parameter.constructor=将第 {0,number,ordinal} 个{1,choice,1\#参数|2\#参数}添加到构造函数 ''{2}''
fix.add.function.parameters.add.parameter.function=将第 {0,number,ordinal} 个{1,choice,1\#参数|2\#参数}添加到函数 ''{2}''
fix.add.function.parameters.add.parameter.generic.constructor=将{0,choice,1\#参数|2\#参数}添加到构造函数 ''{1}''
fix.add.function.parameters.add.parameter.generic.function=将{0,choice,1\#参数|2\#参数}添加到函数 ''{1}''

fix.change.signature.family=更改函数/构造函数的签名
fix.change.signature.function.family=更改函数签名
fix.change.signature.function.text=将函数签名更改为 ''{0}''
fix.change.signature.function.text.generic=更改函数签名…
fix.change.signature.function.popup.title=选择签名
fix.change.signature.lambda=更改 lambda 表达式的签名
fix.change.signature.remove.parameter=删除参数 ''{0}''
fix.change.signature.unavailable=<不可用>
fix.change.signature.error=<错误>
fix.change.signature.unnamed.parameter=参数

fix.change.object.to.class=将 'object' 更改为 'class'

fix.add.function.supertype.family=将函数添加到父类型
fix.add.function.supertype.text=将函数添加到父类型…
fix.add.function.supertype.progress=将函数添加到类型
fix.add.function.supertype.choose.type=选择类型
fix.add.function.supertype.add.to=将 ''{0}'' 添加到 ''{1}''

fix.add.generic.upperbound.text=作为 {1} 的上限添加 ''{0}''
fix.add.generic.upperbound.family=添加泛型上限

fix.add.modifier.inline.parameter.family=将 ''{0}'' 添加到参数
fix.add.modifier.inline.parameter.text=将 ''{0}'' 添加到参数 ''{1}''

fix.add.modifier.inline.function.family=将 'inline' 添加到函数
fix.add.modifier.inline.function.text=将 ''inline'' 添加到函数 ''{0}''

fix.add.array.of.type.text=添加 {0} 包装器
fix.add.array.of.type.family=添加 'arrayOf' 包装器

fix.add.loop.label.text.generic=将标签添加到循环
fix.add.loop.label.text=将 ''{0}'' 添加到 {1}

fix.add.modifier.family=添加修饰符
fix.add.modifier.text=使{0} ''{1}''
fix.add.modifier.text.generic=添加 ''{0}'' 修饰符

fix.add.argument.name.family=将名称添加到参数
fix.add.argument.name.text.generic=将名称添加到参数…
fix.add.argument.name.text=将名称添加到参数\: ''{0}''
fix.add.argument.name.step.choose.parameter.name=选择参数名称

fix.change.feature.support.family=启用/禁用{0}支持
fix.change.feature.support.enabled=启用{0}支持
fix.change.feature.support.enabled.warning=启用{0}支持 (包含警告)
fix.change.feature.support.disabled=禁用{0}支持

fix.create.expect.actual=创建预期/实际声明
fix.create.missing.actual.members=添加缺少的实际成员

fix.create.declaration.error=无法生成 {0}\: {1}
fix.create.declaration.error.inaccessible.type=不可访问类型
fix.create.declaration.error.some.types.inaccessible=有些类型无法访问\:

fix.add.annotation.family=添加注解
fix.add.annotation.text.self=添加 ''@{0}'' 注解
fix.add.annotation.text.declaration=将 ''@{0}'' 注解添加到 ''{1}''
fix.add.annotation.text.containing.class=将 ''@{0}'' 注解添加到包含类 ''{1}''

fix.import=导入
fix.import.kind.delegate.accessors=委托访问器
fix.import.kind.component.functions=组件函数
fix.import.exclude=从自动导入中排除 ''{0}''

fix.move.file.to.package.family=将文件移动到包匹配目录
fix.move.file.to.package.text=将文件移动到{0}

fix.change.package.family=文件的包以匹配目录
fix.change.package.text=将文件的包更改为{0}

action.add.import.chooser.title=导入

goto.super.chooser.function.title=选择 super 函数
goto.super.chooser.property.title=选择超级属性
goto.super.chooser.class.title=选择父类或接口

inspection.unused.receiver.parameter=从未使用接收器参数
fix.unused.receiver.parameter.remove=移除冗余的接收器参数

inspection.migration.title=代码迁移
inspection.migration.profile.name=迁移

fix.create.from.usage.family=从使用创建
fix.create.from.usage.local.variable=创建局部变量 ''{0}''

overridden.marker.implementations.multiple=已经实现
overridden.marker.implementation=实现于 <br/>
overridden.marker.overrides.multiple=在子类中被覆盖
overridden.marker.overrides=覆盖于 <br/>

overridden.marker.implementations.choose.implementation.title=选择 {0} 的实现
overridden.marker.implementations.choose.implementation.find.usages=覆盖 {0} 的属性
overridden.marker.overrides.choose.implementation.title=选择 {0} 的 super 实现
overridden.marker.overrides.choose.implementation.find.usages={0} 的 super 实现

remove.expression = 移除 ''{0}''
unwrap.expression = 解开 ''{0}''
remove.else = 移除 ''{0}'' 中的 else
unwrap.else = 展开 ''{0}'' 中的 else

override.declaration.x.in.y={0}在{1}
override.declaration.x.implements.y={1} 中的 {0} 实现 {3} 中的 {2}。
override.declaration.x.overrides.y.in.class.list={0} 重写以下类/接口中的声明：{1} 是否要 {2} 基类声明？

override.declaration.unused.overriding.methods.title=未使用的覆盖成员
override.declaration.unused.overriding.methods.description=有未使用的成员覆盖了你删除的方法。
override.declaration.choose.to.delete=选择要删除的内容。
override.declaration.member=成员
override.declaration.delete.multiple.parameters={0}方法是层次结构的一部分。您要删除多个参数吗？

find.declaration.implementing.methods.checkbox=实现函数(&I)
find.declaration.overriding.methods.checkbox=重写函数(&R)
find.declaration.implementing.properties.checkbox=实现属性(&I)
find.declaration.overriding.properties.checkbox=重写属性(&R)
find.declaration.property.readers.checkbox=读取器
find.declaration.property.writers.checkbox=写入器
find.declaration.include.overloaded.methods.checkbox=包含重载函数和扩展(&V)
find.declaration.functions.usages.checkbox=函数的使用(&F)
find.declaration.properties.usages.checkbox=属性的使用(&P)
find.declaration.constructor.usages.checkbox=构造函数的使用(&C)
find.declaration.derived.classes.checkbox=派生类 (&D)
find.declaration.derived.interfaces.checkbox=派生接口(&I)

hierarchy.legend.member.is.defined.in.class=成员在类中定义
hierarchy.legend.member.defined.in.superclass=成员未在类中定义，但在超类中定义
hierarchy.legend.member.should.be.defined=应该定义成员，因为类不是抽象的

intention.change.package.text=更改包

intention.extract.declarations.from.file.text=从当前文件中提取声明
intention.extract.declarations.from.file.text.details=从当前文件中提取 ''{0}'' {1, choice, 0\#|1\#和子类}

intention.suppress.family=抑制警告
intention.suppress.text=禁止{1}{2}的 ''{0}''

kotlin.compiler.option.generate.no.warnings=报告编译器警告(&W)
kotlin.compiler.option.additional.command.line.parameters=附加命令行参数(&A)\:
kotlin.compiler.option.enable.new.inference.in.ide=启用 IDE 分析的新型推断算法

kotlin.compiler.jvm.option.panel.title=Kotlin 至 JVM

kotlin.compiler.js.option.panel.title=Kotlin 至 JavaScript
kotlin.compiler.js.option.generate.sourcemaps=生成源映射(&S)
kotlin.compiler.js.option.output.prefix=在生成的代码前添加文件(&P)：
kotlin.compiler.js.option.output.postfix=要附加到生成的代码的文件(&O)：
kotlin.compiler.js.option.output.copy.files=复制库运行时文件(&C)kotlin.compiler.js.option.output.copy.dir\=库运行时文件的输出目录(&U)\:

# Android Lint
android.klint.inspections.group.name=用于 Kotlin 的 Android Lint

# Scratch Files
scratch.run.button=运行临时文件
scratch.run.from.here.button=从这里运行临时文件
scratch.stop.button=停止临时文件执行
scratch.clear.button=清除结果
scratch.module.combobox=使用模块的类路径
scratch.is.repl.checkbox=使用 REPL
scratch.is.repl.checkbox.description=在 Kotlin REPL 中运行。只执行添加到草稿末尾的新表达式
scratch.is.interactive.checkbox=交互模式
scratch.is.interactive.checkbox.description=在你停止键入 {0} 秒后运行
scratch.make.before.run.checkbox=运行前构建模块
scratch.make.before.run.checkbox.description=在运行 scratch 之前构建模块 {0}。只有已编译的代码才能从此作用域访问
scratch.inlay.output.mode=嵌入式输出模式\n\n输出将显示在表达式旁边的代码编辑器中。非常适合短的单行输出。
scratch.side.panel.output.mode.description=侧边面板输出模式
scratch.side.panel.output.mode=侧边面板输出模式\n\n输出显示在单独的面板中。如果输出是长行或多行，则很有用。
scratch.inlay.output.mode.description=嵌入式输出模式

# Code insight
dialog.import.on.paste.title3=选择要移除的导入
copy.paste.reference.notification=<html>已添加 {0} 个{0, choice, 1\#导入|2\#导入}<p><span><a href\=''show''>检查添加的导入…</a></span></html>

plugin.verifier.compatibility.issue.title=兼容性问题
plugin.verifier.compatibility.issue.message=安装的 Kotlin 插件版本 ({0}) 与 {1} 不兼容。\n某些功能可能会中断。\n\n请重新安装 Kotlin 插件。

plugin.updater.notification.group=Kotlin 插件更新
plugin.updater.notification.title=Kotlin
plugin.updater.notification.message=Kotlin 插件有可用的新版本 {0}。<b><a href\="\#">安装</a></b>
plugin.updater.downloading=正在下载插件
plugin.updater.not.installed=未安装插件更新。<a href\="\#">有关详细信息，请参阅日志</a>
plugin.updater.not.installed.misc=未安装插件更新\: {0}。<a href\="\#">有关详细信息，请参阅日志</a>
plugin.updater.error.check.failed=Kotlin 插件更新检查失败
plugin.updater.error.unexpected.repository.response=意外插件库响应
plugin.updater.error.cant.find.plugin.version=在插件库响应中未找到插件版本
plugin.updater.error.custom.repository=检查自定义插件库 {0} 失败

quick.doc.text.enum.ordinal=枚举常数序号\: {0}
quick.doc.text.tailrec='tailrec' 将函数标记为<a href\="https\://kotlinlang.org/docs/reference/functions.html\#tail-recursive-functions">尾递归</a> (允许编译器将递归替换为迭代)
quick.doc.text.lateinit='lateinit' 允许初始化<a href\="https\://kotlinlang.org/docs/reference/properties.html\#late-initialized-properties-and-variables">构造函数外部的非 null 属性</a>
quick.doc.no.documentation=无可用文档
quick.doc.section.deprecated=过时的\:
quick.doc.section.replace.with=替换为\:
quick.doc.section.java.declaration=Java 声明\:
quick.doc.error.dumb.mode=索引更新期间元素信息不可用

action.decompile.java.name=反编译为 Java
action.decompile.busy.text=Kotlin 类文件

action.j2k.name=将 Java 转换为 Kotlin
action.j2k.task.name=将文件从 Java 转换为 Kotlin
action.j2k.correction.investigate=调查错误
action.j2k.correction.proceed=继续转换
action.j2k.correction.required=您项目其余部分的一些代码在执行此转换后可能需要更正。要查找此类代码并更正吗?
action.j2k.correction.errors.single=''{0}'' 包含语法错误，转换结果可能不正确
action.j2k.correction.errors.multiple=''{0}'' 和 {1} 其他 Java 文件包含语法错误，转换结果可能不正确
action.j2k.error.cant.save.result=无法保存转换结果\: {0}
action.j2k.error.cant.find.document=无法找到 ''{0}'' 的文档
action.j2k.error.read.only=文件''{0}''是只读的
action.j2k.errornothing.to.convert=没有要转换的内容\:<br>未找到可编写的 Java 文件

formatter.settings.title=Kotlin 格式化程序设置

action.generate.functions.already.defined=已为类 {1} 定义函数 {0}。要删除它们并继续吗?

action.generate.equals.choose.equals=选择要包含在 'equals()' 中的属性
action.generate.equals.choose.hashcode=选择要包含在 'hashCode()' 中的属性

action.generate.secondary.constructor.choose.properties=选择要通过构造函数初始化的属性
action.generate.secondary.constructor.error.already.exists=构造函数已存在

action.generate.test.support.choose.framework=选择框架
action.generate.test.support.generate.test.function=生成测试函数
action.generate.test.support.choose.test.name=选择测试名称\:
action.generate.test.support.edit.template=编辑模板
action.generate.test.support.error.no.template.found=没有找到 {0} 的模板\: {1}
action.generate.test.support.error.cant.convert.java.template=无法将 Java 模板转换为 Kotlin
action.generate.test.support.error.cant.generate.method=无法生成方法\: {0}

action.generate.tostring.name=生成 toString()
action.generate.tostring.template.single=单个模板
action.generate.tostring.template.multiple=包含串联的多个模板
action.generate.tostring.choose.implementation=选择实现\:
action.generate.tostring.generate.super.call=生成对 super.toString() 的调用

action.new.file.text=Kotlin 文件/类
action.new.file.description=为类生成新的 Kotlin 文件
action.new.file.dialog.title=新建 Kotlin 文件/类
action.new.file.dialog.file.title=文件
action.new.file.dialog.file.description=Kotlin 文件
action.new.file.dialog.class.title=类
action.new.file.dialog.class.description=Kotlin 类
action.new.file.dialog.interface.title=接口
action.new.file.dialog.interface.description=Kotlin 接口
action.new.file.dialog.enum.title=枚举类
action.new.file.dialog.enum.description=Kotlin 枚举
action.new.file.dialog.object.title=对象
action.new.file.dialog.object.description=Kotlin 对象
action.new.file.error.empty.name=名称不能为空
action.new.file.error.empty.name.part=名称不能有空白部分

action.new.script.name=Kotlin 脚本
action.new.script.description=创建新的 Kotlin 脚本
action.new.script.dialog.title=新建 Kotlin 脚本
action.new.script.template.name=Kotlin 脚本

action.new.worksheet.name=Kotlin 工作表
action.new.worksheet.description=创建新的 Kotlin 工作表
action.new.worksheet.dialog.title=新建 Kotlin 工作表
action.new.worksheet.template.name=Kotlin 工作表

breadcrumbs.tooltip.indexing=正在编制索引…

copy.paste.resolve.references=解析粘贴的引用

type.provider.anonymous.object=匿名对象
type.provider.unknown.type=类型未知
type.provider.smart.cast.from=(从 {0} 智能转换)
type.provider.no.expression.found=未找到表达式

optimize.imports.collect.unused.imports=收集未使用的导入
optimize.imports.task.removing.redundant.imports=正在移除冗余导入

kdoc.section.title.receiver=接收器
kdoc.section.title.parameters=参数
kdoc.section.title.returns=返回
kdoc.section.title.throws=抛出
kdoc.section.title.author=作者
kdoc.section.title.since=自从
kdoc.section.title.samples=示例
kdoc.section.title.see.also=请参阅
kdoc.comment.unresolved=未解决

livetemplate.description.main=main() 函数
livetemplate.description.soutp=将函数参数名称和值打印到 System.out
livetemplate.description.iter=迭代 iterable 的元素(for-in loop)
livetemplate.description.ifn=插入 'if null' 表达式
livetemplate.description.inn=插入 'if not null' 表达式
livetemplate.description.void=函数不返回任何内容
livetemplate.description.fun0=无参数函数
livetemplate.description.fun1=单参数函数
livetemplate.description.fun2=双参数函数
livetemplate.description.interface=接口
livetemplate.description.singleton=单例
livetemplate.description.closure=闭包(没有名称的函数)
livetemplate.description.anonymous=匿名类
livetemplate.description.exfun=扩展函数
livetemplate.description.exval=扩展只读属性
livetemplate.description.exvar=扩展读写属性

hints.progress.calculating.parameter.info=正在计算参数信息
hints.title.property.type.enabled=显示属性类型提示
hints.title.property.type.disabled=不显示属性类型提示
hints.title.locals.type.enabled=显示局部变量类型提示
hints.title.locals.type.disabled=不显示局部变量类型提示
hints.title.function.type.enabled=显示函数返回类型提示
hints.title.function.type.disabled=不显示函数返回类型提示
hints.title.parameter.type.enabled=显示参数类型提示
hints.title.parameter.type.disabled=不显示参数类型提示
hints.title.argument.name.enabled=显示参数名称提示
hints.title.argument.name.disabled=不显示参数名称提示
hints.title.return.expression.enabled=显示 lambda 返回表达式提示
hints.title.return.expression.disabled=不显示 lambda 返回表达式提示
hints.title.implicit.parameters.enabled=显示隐式接收器和 lambda 的参数的提示
hints.title.implicit.parameters.disabled=不显示隐式接收器和 lambda 的参数的提示
hints.title.suspend.calls.enabled=显示挂起调用提示
hints.title.suspend.calls.disabled=不显示挂起调用提示

presentation.text.paren=({0})
presentation.text.in.container.paren=(在{0})
presentation.text.in.container={0}在{1}
presentation.text.for.receiver.in.container.paren=({1}中的{0})
presentation.text.object.in.container={0}中的对象

project.view.class.initializer=类初始化器

copy.text.adding.imports=正在添加导入…
copy.text.clipboard.content.seems.to.be.java.code.do.you.want.to.convert.it.to.kotlin=剪贴板内容似乎是 Java 代码。要将其转换为 Kotlin 吗?
copy.text.convert.java.to.kotlin=将 Java 转换为 Kotlin
copy.text.copied.kotlin.code=复制的 kotlin 代码
copy.text.resolving.references=正在解析引用…
copy.title.convert.code.from.java=从 Java 转换代码

editor.checkbox.title.auto.add.val.keyword.to.data.inline.class.constructor.parameters=将 val 关键字自动添加到数据/内联类构造函数参数
editor.checkbox.title.convert.pasted.java.code.to.kotlin=将粘贴的 Java 代码转换为 Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=粘贴时不显示 Java 至 Kotlin 转换对话框
editor.title.kotlin=Kotlin

facet.checkbox.text.use.project.settings=使用项目设置
facet.column.name.options=选项
facet.column.name.plugin=插件
facet.error.text.at.least.one.target.platform.should.be.selected=应至少选择一个目标平台
facet.label.text.selected.target.platforms=选定的目标平台\:
facet.label.text.target.platform=目标平台\:
facet.label.text.the.project.is.imported.from.external.build.system.and.could.not.be.edited=项目从外部构建系统导入，无法编辑
facet.link.text.edit.project.settings=编辑项目设置
facet.name.compiler.plugins=编译器插件
facet.name.general=选项
facet.text.following.arguments.are.redundant=以下参数冗余\: {0}
facet.text.following.arguments.override.facet.settings=以下参数会重写 facet 设置\: {0}
facet.text.following.options.are.not.correct=以下选项不正确\:
facet.text.multiplatform=多平台

filters.text.inline.function.body=内联函数体
filters.text.inline.function.call.site=内联函数调用站点
filters.title.navigate.to=导航到

find.usages.class=类
find.usages.companion.object=伴生对象
find.usages.constructor=构造函数
find.usages.facade.class=外观类
find.usages.for.property=属性的{0}
find.usages.function=函数
find.usages.getter=getter
find.usages.import.alias=导入别名
find.usages.interface=接口
find.usages.label=标签
find.usages.lambda=lambda
find.usages.object=对象
find.usages.parameter=参数
find.usages.property.accessor=属性访问器
find.usages.property=属性
find.usages.setter=setter
find.usages.type.alias=类型别名
find.usages.type.parameter=类型参数
find.usages.variable=变量
find.usages.checkbox.name.expected.classes=预期类
find.usages.class.name.anonymous=匿名
find.usages.checkbox.name.expected.functions=预期函数
find.usages.text.find.usages.for.data.class.components.and.destruction.declarations=<p>数据类组件和破坏声明的查找用法<br/>可以<a href\="{0}">禁用一次</a>或<a href\="{1}">为项目禁用</a>。</p>
find.usages.tool.tip.text.disable.search.for.data.class.components.and.destruction.declarations.project.wide.setting=为数据类组件和破坏声明禁用搜索。(项目范围设置)
find.usages.checkbox.text.fast.data.class.component.search=快速数据类组件搜索
find.usages.checkbox.name.expected.properties=预期属性
find.usages.action.text.find.usages.of=查找以下对象的用法\:
find.usages.type.named.argument=命名参数
find.usages.type.type.alias=类型别名
find.usages.type.callable.reference = Callable 引用
find.usages.type.type.constraint = 类型约束
find.usages.type.value.parameter.type = 参数类型
find.usages.type.nonLocal.property.type = 类/对象属性类型
find.usages.type.function.return.type = 函数返回类型
find.usages.type.superType = 父类型
find.usages.type.is = \ 'is' 操作的目标类型
find.usages.type.class.object = 嵌套类/对象
find.usages.type.companion.object = 伴生对象
find.usages.type.function.call = 函数调用
find.usages.type.implicit.get = 隐式 'get'
find.usages.type.implicit.set = 隐式 'set'
find.usages.type.implicit.invoke = 隐式 'invoke'
find.usages.type.implicit.iteration = 隐式迭代
find.usages.type.property.delegation = 属性委托
find.usages.type.extension.receiver.type = 扩展接收器类型
find.usages.type.super.type.qualifier = super 类型限定符
find.usages.type.receiver = 接收器
find.usages.type.delegate = 代理
find.usages.type.packageDirective = Package 指令
find.usages.type.packageMemberAccess = 包成员访问

formatter.button.text.use.import.with.when.at.least=至少使用包含 '*' 的导入
formatter.button.text.use.import.with=使用包含 '*' 的导入
formatter.button.text.use.single.name.import=使用单个名称导入
formatter.checkbox.text.insert.imports.for.nested.classes=为嵌套类插入导入
formatter.text.names.used=\ 使用的名称
formatter.text.use.defaults.from=使用以下位置的默认值\:
formatter.title.after.colon.before.declaration.type=冒号后，声明类型前
formatter.title.after.colon.in.new.type.definition=新类型定义中的冒号后
formatter.title.align.when.branches.in.columns=对齐列中的 'when' 分支
formatter.title.around.arrow.in.function.types=函数类型中箭头周围
formatter.title.around.arrow.in=“when”子句中箭头周围
formatter.title.around.when.branches.with=带有 {} 的 'when' 分支周围
formatter.title.before.colon.after.declaration.name=冒号前，声明名称后
formatter.title.before.colon.in.new.type.definition=新类型定义中的冒号前
formatter.title.before.lambda.arrow=lambda 箭头前
formatter.title.chained.function.calls=链式函数调用
formatter.title.elvis.expressions=Elvis 表达式
formatter.title.expression.body.functions=表达式主体函数
formatter.title.function.annotations=函数注解
formatter.title.function.call.arguments=函数调用参数
formatter.title.function.declaration.parameters=函数声明参数
formatter.title.function.parentheses=函数括号
formatter.title.in.simple.one.line.methods=在简单的一行方法中
formatter.title.java.statics.and.enum.members=Java 静态和枚举成员
formatter.title.load.save=加载/保存
formatter.title.other=其它
formatter.title.property.annotations=属性注解
formatter.title.put.left.brace.on.new.line=将左大括号置于新行
formatter.title.range.operator=范围运算符 (..)
formatter.title.top.level.symbols=顶级符号
formatter.title.use.continuation.indent.in.conditions=在条件中使用延续缩进
formatter.title.use.continuation.indent=使用延续缩进
formatter.title.when.parentheses='when' 括号
formatter.title.when.statements='when' 语句

framework.name.kotlin.sdk=Kotlin SDK

hierarchy.text.anonymous=[匿名]
hierarchy.text.in=\ 在{0}

highlighter.action.text.go.to.actual.declarations=转到实际声明
highlighter.action.text.go.to.expected.declaration=转到预期声明
highlighter.action.text.go.to.implementations=转到实现
highlighter.action.text.go.to.overridden.methods=转到重写方法
highlighter.action.text.go.to.overridden.properties=转到重写属性
highlighter.action.text.go.to.subclasses=转到子类
highlighter.action.text.go.to.super.method=转到 super 方法
highlighter.action.text.go.to.super.property=转到 super 属性
highlighter.descriptor.text.android.extensions.property=属性和变量//Android 扩展合成属性
highlighter.descriptor.text.annotation=注释
highlighter.descriptor.text.arrow=括号和操作符//箭头
highlighter.descriptor.text.builtin.annotation=修饰符
highlighter.descriptor.text.builtin.keyword.val=关键字//'val'
highlighter.descriptor.text.builtin.keyword.var=关键字//'var'
highlighter.descriptor.text.builtin.keyword=关键字//关键字
highlighter.descriptor.text.captured.variable=属性和变量//闭包中捕获的变量和值
highlighter.descriptor.text.closure.braces=括号和操作符//Lambda 表达式大括号和箭头
highlighter.descriptor.text.colon=括号和操作符//冒号
highlighter.descriptor.text.constructor.call=函数//构造函数调用
highlighter.descriptor.text.double.colon=括号和操作符//双重冒号
highlighter.descriptor.text.dynamic.fun.call=函数//动态函数调用
highlighter.descriptor.text.dynamic.property=属性和变量//动态属性
highlighter.descriptor.text.enumEntry=类和接口//Enum entry
highlighter.descriptor.text.exclexcl=括号和操作符//非空断言
highlighter.descriptor.text.extension.fun.call=函数//扩展函数调用
highlighter.descriptor.text.extension.property=属性和变量//扩展属性
highlighter.descriptor.text.field=属性和变量//幕后字段变量
highlighter.descriptor.text.fun.call=函数//函数调用
highlighter.descriptor.text.fun=函数//函数声明
highlighter.descriptor.text.instance.property.custom.property.declaration=属性和变量//包含自定义属性声明的实例属性
highlighter.descriptor.text.instance.property=属性和变量//实例属性
highlighter.descriptor.text.it=参数//Lambda 表达式默认参数
highlighter.descriptor.text.kdoc.comment=注释//KDoc//KDoc 注释
highlighter.descriptor.text.kdoc.tag=注释//KDoc//KDoc 标记
highlighter.descriptor.text.kdoc.value=注释//KDoc//KDoc 标记中的链接
highlighter.descriptor.text.label=标签
highlighter.descriptor.text.local.variable=属性和变量//局部变量或值
highlighter.descriptor.text.named.argument=命名参数
highlighter.descriptor.text.object=类和接口//对象
highlighter.descriptor.text.package.fun.call=函数//包级函数调用
highlighter.descriptor.text.package.property.custom.property.declaration=属性和变量//包含自定义属性声明的包级属性
highlighter.descriptor.text.package.property=属性和变量//包级属性
highlighter.descriptor.text.quest=括号和操作符//类型为空性标记
highlighter.descriptor.text.safe.access=括号和操作符//安全访问的点
highlighter.descriptor.text.smart.cast.receiver=智能转换//智能转换隐式接收器
highlighter.descriptor.text.smart.cast=智能转换//智能转换值
highlighter.descriptor.text.smart.constant=智能转换//智能常量
highlighter.descriptor.text.string.escape=String//string 和模板大括号中的转义
highlighter.descriptor.text.suspend.fun.call=函数//挂起函数调用
highlighter.descriptor.text.synthetic.extension.property=属性和变量//合成扩展属性
highlighter.descriptor.text.typeAlias=类和接口//类型别名
highlighter.descriptor.text.var=属性和变量//Var(可变变量、参数或属性)
highlighter.descriptor.text.variable.as.function.call=属性和变量//变量作为函数调用
highlighter.descriptor.text.variable.as.function.like.call=属性和变量//变量作为函数类似调用
highlighter.message.suspend.function.call=挂起函数调用
highlighter.message.suspending.iteration=正在挂起迭代
highlighter.name.dsl.markers=DSL 标记
highlighter.name.dsl=Dsl//
highlighter.name.implemented.declaration=实现的声明
highlighter.name.implementing.declaration=实现声明
highlighter.name.kotlin.line.markers=Kotlin 行标记
highlighter.name.multiplatform.actual.declaration=多平台实际声明
highlighter.name.multiplatform.expect.declaration=多平台预期声明
highlighter.name.overridden.declaration=重写的声明
highlighter.name.overriding.declaration=重写声明
highlighter.name.style=样式
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=索引更新时无法导航到重写类
highlighter.prefix.text.has.actuals.in=在以下位置具有实际值\:
highlighter.text.click.for.navigate=点击 {0} 以导航
highlighter.text.has.functional.implementations=具有函数实现
highlighter.text.implements=实现
highlighter.text.in=''{1}'' 中的 {0}
highlighter.text.modules=\ ({0} 模块)
highlighter.text.or.press=\ 或按 {0}
highlighter.text.overrides=重写
highlighter.title.actuals.for={0} 的实际值
highlighter.title.choose.actual.for=选择 {0} 的实际值
highlighter.title.choose.expected.for=选择 {0} 的预期值
highlighter.title.expected.for={0} 的预期值
highlighter.title.overriding.declarations.of={0} 的重写声明
highlighter.title.searching.for.overriding.declarations=正在搜索重写声明
highlighter.title.searching.for.overriding.methods=正在搜索重写方法
highlighter.tool.tip.has.declaration.in.common.module=具有通用模块中的声明
highlighter.tool.tip.marker.annotation.for.dsl=DSL 的标记注解
highlighter.tool.tip.text.function=函数
highlighter.tool.tip.text.property=属性
highlighter.tool.tip.text.recursive.call=递归调用
highlighter.tool.tip.text.run.test=运行测试

import.optimizer.notification.text.unused.imports.not.found=没有找到未使用的导入
import.optimizer.progress.indicator.text.collect.imports.for=收集 {0} 的导入
import.optimizer.text.import={0, choice, 0\#导入|2\#导入}
import.optimizer.text.non.zero=移除的{0} {1}{2, choice, 0\#|1\#, 添加的{2} {3}}
import.optimizer.text.zero=重新排列的导入

internal.action.text.decompile.kotlin.bytecode=反编译 kotlin 字节码
internal.error.text.cannot.decompile=无法反编译 {0}
internal.indicator.text.decompiling=正在反编译 {0}
internal.title.decompiler.error=反编译器错误

version.title.no.runtime.found=未找到运行时
version.dialog.message.is.not.found.make.sure.plugin.is.properly.installed=未找到 {0}。请确保已正确安装插件。
version.message.is.deprecated.since.1.2.0.and.should.be.replaced.with={0} 自 1.2.0 起被弃用，应替换为 {1}

update.name.android.studio=Android Studio
update.reason.text.exception.during.verification=验证时出现异常\: {0}
update.reason.text.no.verified.versions.for.this.build=此构建没有经过验证的版本。
update.reason.text.unable.to.connect.to.compatibility.verification.repository=无法连接到兼容性验证存储库
update.reason.text.unable.to.parse.compatibility.verification.metadata=无法解析兼容性验证元数据
update.reason.text.version.to.be.verified=要验证的版本。

test.integration.button.text.cancel=取消
test.integration.button.text.rewrite=重写
test.integration.message.text.create.test.in.the.same.source.root=在相同的源根中创建测试?
test.integration.message.text.kotlin.class=Kotlin 类 ''{0}'' 已存在。要更新它吗?
test.integration.title.no.test.roots.found=未找到测试根

slicer.text.in=\ 在{0}
slicer.text.tracking.enclosing.lambda=\ (跟踪封闭的 lambda)
slicer.title.dataflow.from.here=流出此处的数据流
slicer.title.dataflow.to.here=流入此处的数据流
slicer.tool.tip.text.variable.dereferenced=已取消引用变量

script.action.text.ignore=忽略
script.action.text.open.settings=打开设置
script.action.text.show.all=全部显示
script.name.kotlin.scripting=Kotlin 脚本
script.progress.text.kotlin.scanning.dependencies.for.script.definitions=Kotlin\: 正在扫描脚本定义的依赖项…
script.text.multiple.script.definitions.are.applicable.for.this.script=多个脚本定义适用于此脚本。已使用 {0}

roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=为 Kotlin 项目中的非 JVM 模块更新源根

reporter.button.text.ignore=忽略更改
reporter.button.text.update=更新
reporter.message.text.you.re.running.kotlin.plugin.version=您正在运行 Kotlin 插件版本 {0}，最新版本是 {1}
reporter.text.can.t.report.exception.from.patched.plugin=无法从已修补的插件报告异常
reporter.title.update.kotlin.plugin=更新 Kotlin 插件

configuration.action.text.ignore=忽略
configuration.action.text.update=更新
configuration.description.always=始终
configuration.description.amd=AMD
configuration.description.commonjs=CommonJS
configuration.description.never=从不
configuration.description.plain.put.to.global.scope=普通 (应用于全局)
configuration.description.umd.detect.amd.or.commonjs.if.available.fallback.to.plain=UMD (如果可以，检测 AMD 或 CommonJS，回退到普通)
configuration.description.when.inlining.a.function.from.other.module.with.embedded.sources=从包含嵌入式源的其他模块内联函数时
configuration.error.text.shouldn.t.add.null.urls.to.custom.repositories=不应将 null url 添加到自定义库
configuration.feature.text.new.experimental.project.wizard=新实验性项目向导
configuration.feature.text.new.java.to.kotlin.converter=新 Java 到 Kotlin 转换器
configuration.message.enter.fully.qualified.method.name=输入完全限定方法名称\:
configuration.message.text.a.new.version.is.available=有可用的新版本 {0}
configuration.message.text.a.new.version.is.found=已发现新版本 {0}，但未经{1}验证。
configuration.message.text.update.check.failed=更新检查失败\: {0}
configuration.message.text.you.have.the.latest.version.of.the.plugin.installed=您已安装最新版本的插件。
configuration.message.verifier.disabled=(已禁用验证程序)
configuration.migration.text.api.version=API 版本\: {0} -> {1}
configuration.migration.text.detected.migration=检测到的迁移\:
configuration.migration.text.language.version=语言版本\: {0} -> {1}
configuration.migration.text.migrations.for.kotlin.code.are.available=可以迁移 Kotlin 代码
configuration.migration.text.run.migrations=运行迁移
configuration.migration.text.standard.library=标准库\: {0} -> {1}
configuration.migration.title.kotlin.migration=Kotlin 迁移
configuration.name.kotlin.compiler=Kotlin 编译器
configuration.name.kotlin=Kotlin
configuration.name.method=方法
configuration.status.text.installation.failed=安装失败
configuration.status.text.installing=正在安装...
configuration.text.add.exclusion=添加排除
configuration.text.and=和
configuration.text.other.s=其他
configuration.text.patched.original={0} (已修补\! 原始\: {1})
configuration.text.the.compiler.bundled.to.kotlin.plugin=捆绑到 Kotlin 插件的编译器版本 ({0}) 比用于构建模块的外部编译器版本旧\:
configuration.text.this.may.cause.different.set.of.errors.and.warnings.reported.in.ide.p=这可能会导致 IDE 中报告不同的错误和警告集。
configuration.title.choose.output.directory=选择输出目录
configuration.title.early.access.preview.1.3.x=抢先体验预览 1.3.x
configuration.title.early.access.preview.1.4.x=抢先体验预览 1.4.x
configuration.title.edit.exclusion=编辑排除
configuration.title.kotlin.compiler.js.option.output.postfix.browse.title=选择要附加到生成代码的文件
configuration.title.kotlin.compiler.js.option.output.prefix.browse.title=选择要预处理到生成代码的文件
configuration.title.outdated.bundled.kotlin.compiler=过时的捆绑 Kotlin 编译器
configuration.title.stable=稳定
configuration.warning.text.following.modules.override.project.settings=以下模块会重写项目设置\:
configuration.warning.text.modules.override.project.settings={0}模块会重写项目设置

#Refactoring
0.1.is.never.used=从未使用{0} ''{1}''
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} 已在 {2} 中检测到 {1} 代码片段，可以用 {3} 替换。您想要查看并替换 {1,choice,1\#它|2\#它们}吗?
0.usages.are.not.supported.by.the.inline.refactoring.they.won.t.be.processed=“内联”重构不支持 {0} 用法。将不会处理它们。
0.will.become.invisible.after.extraction={0} 在提取之后将变为不可见
0.will.no.longer.be.accessible.after.extraction={0} 在提取之后将不再可访问
action.text.append=追加
action.text.cancel=取消
action.text.overwrite=覆盖
button.text.move.nested.class.0.to.upper.level=将嵌套类 {0} 移动到上一级别(&N)
button.text.move.nested.class.0.to.another.class=将嵌套类 {0} 移动到另一个类(&M)
cannot.extract.method=找不到要提取的语句
cannot.extract.super.call=不能提取 super-call
cannot.inline.property.with.accessor.s.and.backing.field=无法使用访问器和支持字段内联属性
cannot.introduce.parameter.of.0.type=无法引入类型为 ''{0}'' 的参数
cannot.refactor.expression.has.unit.type=无法引入 unit 类型的表达
cannot.refactor.no.container=无法在此位置重构
cannot.refactor.no.expression=没有表达无法执行重构
cannot.refactor.no.type=没有类型无法执行重构
cannot.refactor.not.expression.to.extract=找不到要提取的表达式
cannot.refactor.not.expression=找不到要引入的表达式
cannot.refactor.package.expression=无法引入包引用
cannot.refactor.syntax.errors=由于错误的代码无法重构
cannot.refactor.synthesized.function=无法重构合成函数 ''{0}''
checkbox.text.declare.with.var=使用 var 声明(&V)
checkbox.text.delete.empty.source.files=删除空白源文件(&D)
checkbox.text.extension.property=扩展属性(&X)\: 
checkbox.text.introduce.default.value=引入默认值(&D)
checkbox.text.open.moved.files.in.editor=在编辑器中打开移动的成员
checkbox.text.replace.all.occurrences.0=替换所有匹配项 ({0})(&R)
checkbox.text.search.references=搜索引用(&R)
checkbox.text.specify.type.explicitly=显式指定类型(&T)
checkbox.text.update.package.directive=更新包指令 (Kotlin 文件)
column.name.receiver=接收器\:
column.name.val.var=Val/Var
declarations.are.used.outside.of.selected.code.fragment=下面的声明使用于选择的代码片段之外：
declarations.will.move.out.of.scope=以下声明在提取的函数体之外不可用：
description.a.reference.to.extracted.type.parameter=引用提取的类型参数
error.cant.refactor.vararg.functions=不能重构具有可变参数的函数
error.hint.text.cannot.inline.0.from.a.decompiled.file=无法从反编译文件内联 ''{0}''
error.text.can.t.change.signature.of.method=无法更改 {0} 方法的签名
error.text.can.t.copy.class.to.the.containing.file=无法将类复制到包含文件
error.text.can.t.generate.0.1=无法生成{0}\: {1}
error.text.can.t.introduce.lambda.parameter.for.this.expression=无法为此表达式引入 lambda 参数
error.text.can.t.introduce.property.for.this.expression=无法为此表达式引入属性
error.text.different.name.expected=应为不同名称
error.text.expression.has.no.type=表达式没有类型
error.text.extraction.from.expect.class.is.not.yet.supported=尚不支持从预期类提取
error.text.extraction.from.non.jvm.class.is.not.yet.supported=尚不支持从非 JVM 类提取
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=具有多个返回语句的函数不支持“内联函数”。
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=返回语句不在主体末尾的函数不支持“内联函数”。
error.text.interface.cannot.be.extracted.from.an.annotation.class=无法从注解类中提取接口
error.text.introduce.parameter.is.not.available.for.default.value=“引入参数”不适用于默认值
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=“引入参数”不适用于注解条目内部
error.text.invalid.default.receiver.value=默认接收器值无效
error.text.invalid.name=名称无效
error.text.invalid.parameter.name=参数名无效
error.text.invalid.parameter.type=参数类型无效
error.text.invalid.receiver.type=无效的接收器类型
error.text.invalid.return.type=返回类型无效
error.text.no.type.to.refactor=没有要重构的类型
error.text.refactoring.is.not.applicable.in.the.current.context=重构不适用于当前上下文
error.text.superclass.cannot.be.extracted.from.an.annotation.class=无法从注解类中提取超类
error.text.type.reference.is.expected=预期类型引用
error.types.in.generated.function=无法生成返回类型错误的函数
error.wrong.caret.position.function.or.constructor.name=插入符号应位于要重构的函数或构造函数的名称处。
extract.function=提取函数
family.name.update.usages.on.declarations.cut.paste=剪切/粘贴声明时更新用法
file.does.not.exist=文件 {0} 不存在。\n你想创建它吗？
function.name.is.invalid=函数名无效
introduce.parameter=引入参数
introduce.property=引入属性
introduce.type.parameter.to.declaration=将类型参数引入声明
introduce.type.parameter=引入类型参数
introduce.variable=引入变量
label.text.default.receiver.value=默认接收器值(&D)\:
label.text.destination.directory=目标目录(&D)\:
label.text.file.name=文件名(&N)\:
label.text.introduce.as=引入为(&I)\:
label.text.name=&名称\: 
label.text.package.name=包名称(&G)\:
label.text.receiver.type=接收器类型(&T)\:
label.text.target.file.name=目标文件名\:
label.text.to.file=补丁文件\: (&P)
label.text.to.package=目标包(&A)\:
label.text.type=&按类型分组\: 
label.text.update.package.directive=更新包指令(&U)
label.text.visibility=可见性(&V)\:
member.info.abstract.0=抽象{0}
member.info.companion.0=伴生{0}
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=“更改签名”不适用于动态调用的函数
message.do.not.show.for.local.variables.in.future=以后不为局部变量显示
message.text.return.type.cannot.be.resolved=返回类型''{0}''不能解决,继续吗?
message.text.type.alias.0.is.never.used=类型别名 ''{0}'' 从未使用
message.type.for.cannot.be.resolved=无法解析 {1} 的类型 ''{0}''。\n继续?
name.extract.interface=提取接口
name.inline.type.alias=内联类型别名
name.introduce.import.alias=引入导入别名
name.introduce.lambda.parameter=引入 Lambda 参数
name.introduce.parameter1=引入参数
name.introduce.type.alias=引入类型别名
name.kdoc.for.abstracts=摘要的 KDoc
naming.convention.will.be.violated.after.rename=重命名后将违反命名规范
non.kotlin.usage.0=非 Kotlin 用法\: {0}
parameter.name.is.invalid=参数名 ''{0}'' 无效
parameter.type.is.invalid=参数类型 ''{0}'' 无效
parameter.types.are.not.denotable=无法提取方法，因为以下类型在目标作用域中不可表示：
refactoring.move.non.kotlin.file=目标必须是 Kotlin 文件
return.type.is.invalid=返回类型无效
searching.usages.of.0.parameter=正在搜索 ''{0}'' 参数的用法
selected.code.fragment.has.multiple.exit.points=选择的代码片段具有多个退出点
selected.code.fragment.has.multiple.output.values=选择的代码片段具有 3 个以上的输出值：
selected.code.fragment.has.output.values.and.exit.points=选择的代码片段既有输出值，也有可选的退出点
setter.of.0.will.become.invisible.after.extraction = 提取后 {0} 的 Setter 将变为不可见
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' 必须随密封的父类及其全部子类一起移动
text.0.already.contains.1={0} 已包含 {1}
text.0.already.contains.nested.class.1={0} 已包含名为 {1} 的嵌套类
text.0.already.declared.in.1={0} 已在 {1} 中声明
text.0.have.no.inheritors.warning={0} 没有继承者\n向下推动成员会导致它们被删除。要继续吗?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={1} 中的 {0} 会在重构后重写 {2} 的相应成员
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} 继承自 {1}。\n它不会受重构影响
text.0.is.invalid.destination.package=''{0}'' 是无效的目标包名称
text.0.is.not.allowed.in.the.target.context=目标上下文中不允许出现 ''{0}''
text.0.is.not.valid.package.name={0} 不是有效的包名称
text.0.to.inline=要内联的 {0}
text.0.uses.1.which.is.not.accessible.from.2={0} 使用 {1}，后者无法从 {2} 访问
text.0.uses.1.which.will.be.inaccessible.after.move={0} 使用 {1}，后者在移动后将无法访问
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} 使用 {1}，后者无法从子类访问。
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} 使用内部 {1}，后者在移动后将无法访问
text.0.will.be.shadowed.by.1={0} 将被 {1} 隐藏
text.0.will.clash.with.existing.1.in.2=重命名后的 {0} 会与 {2} 中的现有 {1} 冲突
text.0.will.no.longer.be.accessible.after.signature.change={0} 在签名更改后将无法访问
text.all.declarations.must.belong.to.the.same.directory.or.class=所有声明必须属于同一目录或类
text.all=所有
text.anonymous=[匿名]
text.at.least.one.file.must.be.selected=应至少选择一个成员
text.callee.text.would.be.shown.here=此处将显示被调用方文本
text.caller.text.with.highlighted.callee.call.would.be.shown.here=此处将显示包含\n突出显示的被调用方调用的调用方文本
text.cannot.create.target.directory.0=无法创建目标目录 {0}
text.cannot.determine.source.directory=无法确定源目录
text.cannot.find.package.corresponding.to.0=无法找到 {0} 对应的包
text.cannot.find.target.package.name=无法找到目标包名称
text.cannot.inline.0.1.usages=无法内联 {0}/{1} 个用法
text.cannot.move.for.current.project=无法为当前项目移动
text.cannot.move.from.multiple.files=无法从多个源文件移动
text.cannot.move.inner.class.0.into.itself=无法将嵌套的类 {0} 移动到类自身
text.cannot.move.to.original.file=无法移动到原始文件
text.change.file.package.to.0=将文件的包更改为 ''{0}''
text.choose.containing.file=选择包含文件
text.class.0.already.contains.member.1={0} 已包含 {1}
text.class.0.already.exists.in.package.1=类 {0} 在包 {1} 中已存在
text.class.0.already.exists.in.the.target.scope=类 {0} 在目标范围中已存在
text.class.0.is.final={0} 为 final
text.constructor=构造函数
text.convert._it_.to.explicit.lambda.parameter=无法将 'it' 转换为显式 lambda 参数
text.create.destructuring.declaration=创建解构声明
text.create.single.variable=创建单个变量
text.declaration=声明
text.declarations.clash.move.0.destination.1.declared.in.scope.2=以下声明将冲突\: 移动 {0} 和在范围 {2} 中声明的目标 {1}
text.default.value=\ // 默认值 \= {0}
text.destination.class.should.be.kotlin.class=目标类必须为 Kotlin 类
text.do.you.want.to.rename.0.as.well=同时重命名 {0}() 吗?
text.do.you.want.to.rename.base.property.from.0=要从 {0} 重命名基本属性吗?
text.do.you.want.to.rename.base.property=要重命名基本属性吗?
text.duplicating.local.variable=正在复制局部变量 ''{0}''
text.duplicating.parameter=正在复制参数 ''{0}''
text.duplicating.property=正在复制属性 ''{0}''
text.explicit.receiver.is.already.present.in.call.element.0=显式接收器在调用元素中已存在\: {0}
text.extract.superclass=提取超类
text.failed.to.create.parent.directory.0=无法创建父目录\: {0}
text.file.0.already.exists.in.1=文件 {0} 在 {1} 中已存在
text.file.name.cannot.be.empty=文件名不能为空
text.function.already.exists=函数已存在\: ''{0}''
text.function.in.ticks.0=函数 ''{0}''
text.function=函数
text.implicit.companion.object.will.be.inaccessible.0=隐式伴生对象将无法访问\: {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=目标路径不正确。目录 {0} 不属于当前项目。
text.indirect.outer.instances.will.not.be.extracted.0=将不会提取间接外部实例\: {0}
text.inline.0.1.2=内联{0} ''{1}''? {2}
text.inline.0=内联{0}
text.inline.all.references.and.0.the.1=内联所有引用并{0}种类 {1}
text.inline.recursive.function.is.supported.only.on.references=仅在引用上支持内联递归函数
text.inline.this.reference.and.keep.the.0=内联此引用并保留 {0}
text.inlining.0.1=正在内联{0} {1}
text.inner.class.0.cannot.be.moved.to.intefrace={0} 是内部类。无法移动到接口
text.introduce.default.value=引入默认值(&D)
text.invalid.target.path.0=目标路径 {0} 无效
text.invalid.target.specified=指定的目标无效
text.keep=保持
text.lambda.parameter=lambda 参数
text.lambda.parameters=Lambda 参数(&P)\: 
text.lambda.return.type=Lambda 返回类型(&T)
text.lazy.property=延迟属性
text.local.property=属性
text.local.variable=局部变量
text.looking.for.usages=寻找使用中...
text.member.0.in.super.class.will.clash.with.existing.member.of.1=超类中的 {0} 将与 {1} 的现有成员冲突
text.member.extension.call.will.not.be.processed.0=不会处理成员扩展调用\: {0}
text.move.declaration.no.support.for.companion.objects=伴生对象不支持“移动声明”
text.move.declaration.no.support.for.enums=枚举条目不支持“移动声明”
text.move.declaration.supports.only.top.levels.and.nested.classes=仅顶级声明和嵌套类支持“移动声明”
text.move.declarations=移动声明
text.move.file.0=移动 {0}
text.move.refactoring.conflict.0=无法执行重构，因为以下文件已存在\:\n\n{0}
text.move.refactoring.not.available.during.indexing=当索引编制正在进行时，无法使用“移动”重构
text.moving.multiple.nested.classes.to.top.level.not.supported=不支持将多个嵌套类移动到顶级
text.Name=名称
text.nested.classes.to.upper.level=嵌套类到上一级
text.no.elements.to.move.are.selected=未选择要移动的元素
text.no.files.to.move=没有要移动的给定文件
text.no.name.provided.for.type.alias=没有为类型别名提供名称
text.no.package.corresponds.to.directory=此目录没有相应的包
text.non.kotlin.0.will.not.be.affected.by.refactoring=非 Kotlin {0} 将不会受重构影响
text.overload=重载
text.package.directive.dont.match.file.location=包指令与文件位置不匹配
text.parameter.0=参数 ''{0}''
text.parameter.name=参数名(&N)\:
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=参数引用无法安全地替换为 {0}，因为 {1} 在此上下文中不明确
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=参数引用无法安全地替换为 {0}，因为在此上下文中无法引用目标函数
text.parameter.type=参数类型(&T)\:
text.parameter=参数
text.parameters=&参数
text.proceed.with.extraction=继续提取
text.process.duplicates=处理重复项
text.processing.file.0=处理{0}
text.property.in.ticks.0=属性 ''{0}''
text.property.with.getter=包含 getter 的属性
text.property.with.initializer=包含初始值设定项的属性
text.property=属性
text.pushed.member.will.not.be.available.in.0=推送的成员无法在 ''{0}'' 中使用
text.qualified.call.will.not.be.processed.0=将不会处理限定调用\: {0}
text.receiver.can.t.be.safely.transformed.to.value.argument=接收器无法安全地转换为值参数\: {0}
text.receiver=接收器
text.refactoring.can.t.be.performed.on.the.selected.code.element=无法对选定的代码元素执行重构
text.refactoring.is.not.applicable.to.this.code.fragment=重构不适用于此代码段
text.references.in.code.to.0.1.and.its.declarations=在代码中引用{0} {1} 及其声明
text.remove.0.no.longer.used=移除不再使用的{0}
text.remove.question=移除 '?'
text.remove=移除
text.rename.as.part.of.phrase=重命名
text.rename.is.not.applicable.to.secondary.constructors=“重命名”不适用于辅助构造函数
text.rename.is.not.applicable.to.synthetic.declarations=“重命名”不适用于合成声明
text.rename.not.applicable.to.backing.field.reference=“重命名”不适用于支持字段引用
text.rename.not.applicable.to.dynamically.invoked.methods=“重命名”不适用于动态调用的成员
text.rename.overloads.title=重命名重载
text.rename.overloads.to=将重载重命名为\:
text.rename.parameters.in.hierarchy.to=将层次结构中的参数重命名为\:
text.rename.parameters.title=重命名参数
text.rename.warning=重命名警告
text.sealed.class.0.must.be.moved.with.all.its.subclasses=密封类 ''{0}'' 必须随其所有子类一起移动
text.select.target.code.block.file=选择目标代码块/文件
text.select.target.code.block=选择目标代码块
text.select.target.file=选择目标文件
text.the.following=以下
text.there.is.already.a.parameter={1} 中已存在参数 ''{0}''。它会与新参数冲突。
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter={1} 中已存在变量 ''{0}''。它会与新参数冲突。
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=类型别名无法引用在定义范围中无法访问的类型
text.type.alias.name.must.be.a.valid.identifier.0=类型别名名称必须为有效的标识符\: {0}
text.type.alias=类型别名
text.type.already.exists.in.the.target.scope=类型 {0} 在目标范围中已存在
text.type.parameter.names.must.be.distinct=类型参数名称必须不同
text.type.parameters=类型参数(&P)
text.type=类型
text.unexpected.element.type.0=意外元素类型\: {0}
text.update.usages.to.reflect.declaration.0.move=更新用法以反映{0, choice, 0\#声明n|1\#声明}移动
text.updating.usages.progress=正在更新用法…
text.variable=变量
title.change.signature=更改签名
title.inline.function=内联函数
title.introduce.parameter.to.declaration=将参数引入声明
title.move.nested.classes.to.upper.level=将嵌套类移动到上一级
title.select.target.code.block=选择目标代码块
unsupported.usage.0=不支持的用法\: {0}

do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=要在预期声明和所有相关实际声明中删除此参数吗?
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=要删除预期声明和所有相关实际声明吗?
delete.with.usage.search=删除 (通过用法搜索)

destination.not.found.for.package.0=没有为包 ''{0}'' 找到目标
leave.in.same.source.root=留在同一源根中
test.root.is.selected.while.the.source.root.is.expected=预期源根，但选择了测试根
source.root.is.selected.while.the.test.root.is.expected=预期测试根，但选择了源根
premature.end.of.template=模板过早结束
choose.target.class.or.interface=选择目标类或接口
text.abstract=抽象的
text.secondary.constructor=辅助构造函数
text.create=创建
text.member=成员
text.extension=扩展
text.object=对象
text.interface=接口
text.enum.constant=枚举常量
text.enum=枚举
text.annotation=注释
create.0.1=创建 {0} ''{1}''
choose.class.container=选择类容器
file.0.already.exists.but.does.not.correspond.to.kotlin.file=文件 {0} 已存在，但与 Kotlin 文件不对应
create.file=创建文件
create.0=创建 {0}
create.package.0=创建包 ''{0}''
text.type.parameter=类型{0, choice, 0\#参数|2\#参数}
create.0.in.1=在 {1} 中创建 {0}
searching.0=正在搜索 {0}…
create.property.0.as.constructor.parameter=作为构造函数参数创建属性 ''{0}''
create.parameter.0=创建参数 ''{0}''
add.property=添加属性
text.add=添加 '
property.0.to.1='' 属性 ''{0}'' 到 ''{1}''
add.method=添加方法
add.0.constructor.to.1=将 {0} 构造函数添加到 ''{1}''
text.secondary=辅助
text.primary=主
add.method.0.to.1=将方法 ''{0}'' 添加到 ''{1}''
create.actual.0.for.module.1.2=为模块 {1} 创建实际{0} ({2})
create.expected.0.in.common.module.1=在通用模块 {1} 中创建预期{0}
repair.actual.members=修复实际成员
these.declarations.cannot.be.transformed=无法转换这些声明\:
unknown.types=未知类型
choose.actual.members=选择实际成员
text.annotation.class=批注类
text.enum.class=枚举类
text.class=类
type.0.1.is.not.accessible.from.target.module=无法从目标模块访问{0, choice, 0\#类型|2\#类型} {1}
the.function.declaration.shouldn.t.have.a.default.implementation=函数声明不应具有默认实现
some.types.are.not.accessible.from.0.1=无法从 {0} 访问一些类型\:\n{1}
the.declaration.has.0.modifier=声明包含 ''{0}'' 修饰符
inaccessible.declaration=无法访问的声明
fix.with.asdynamic=使用 'asDynamic' 修复
migrate.type.parameter.list.syntax=迁移类型参数列表语法
replace.deprecated.symbol.usage=替换弃用的符号用法
replace.with.0=替换为''{0}''
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=通过此别名使用的 ''{0}'' 上有自己的 ''ReplaceWith''。请先替换用法。
replace.deprecated.symbol.usage.in.whole.project=替换整个项目中弃用的符号用法
applying.0=正在应用 ''{0}''
replace.usages.of.0.in.whole.project=替换整个项目中的 ''{0}'' 用法
replace.with.publishedapi.bridge.call=替换为 @PublishedApi 桥调用
replace.with.generated.publishedapi.bridge.call.0=替换为生成的 @PublishedApi 桥调用 ''{0}''
convert.sealed.sub.class.to.object.fix.family.name=将密封的子类转换为对象
generate.identity.equals.fix.family.name=通过标识生成 equals 和 hashCode
and.delete.initializer=并删除初始值设定项
change.to.val=更改为 val
change.to.var=更改为 var
change.type.of.0.to.1=将 {0} 的类型更改为 ''{1}''
change.type.to.0=改变类型到''{0}''
base.property.0=基本属性 {0}
make.0=使 {0}
make.0.1.explicitly=明确生成 ''{0}'' {1}
make.0.explicitly=明确生成{0}
use.inherited.visibility=使用继承的可见性
replace.with.in.when=将 ',' 替换为 '||'\:
remove.0=移除 ''.{0}''
remove.conversion.from.kclass.to.class=移除从 'KClass' 到 'Class' 的转换
convert.to.0=转换为 {0}
convert.expression.to.0.by.inserting.1=通过插入 ''.{1}'' 将表达式转换为 ''{0}''
convert.extension.property.initializer.to.getter=将扩展属性初始值设定项转换为 getter
convert.supertype.to.0=将父类型转换为 ''{0}''
convert.extension.function.type.to.regular.function.type=将扩展函数类型转换为常规函数类型
convert.to.notnull.delegate=转换为非 null 委托
convert.to.anonymous.object=转换为匿名对象
select.loop.statement.to.label=选择要标记的循环语句
select.lambda.to.label=选择要标记的 lambda
create.label=创建标签
create.label.0=创建标签 {0}@
convert.member.to.extension=将成员转换为扩展
replace.annotation=替换注解
replace.annotation.with.0=将注解替换为 {0}
add.initializer=添加初始值设定项
move.to.constructor.parameters=移动到构造函数参数
initialize.with.constructor.parameter=使用构造函数参数初始化
inline.type.parameter=内联类型参数
insert.explicit.delegation.call=插入显式委托调用
kotlin.add.required.module.fix.family.name=将 'requires' 指令添加到 module-info.java
the.anonymous.object=匿名对象
text.implement=实现
text.extend=扩展
let.0.1=使{0} {1}
let.type.implement.interface=使类型实现接口
0.interface.1={0}接口 ''{1}''
lift.assignment.out.of.try.expression=从 'try' 表达式中提取赋值
make.class.an.annotation.class=使类为注解类
make.0.an.annotation.class=使 ''{0}'' 为注解类
make.constructor.parameter.a.property.0=使构造函数参数为属性{0}
in.class.0=在类 ''{0}'' 中
add.0.to.module.1.compiler.arguments=将 ''{0}'' 添加到模块 {1} 编译器参数
add.an.opt.in.requirement.marker.compiler.argument=添加选择加入要求标记编译器参数
make.0.in.1.open=使 {1} 中的 ''{0}'' 打开
add.modifier=添加修饰符
make.private.and.0.1=设为 private 并{0} ''{1}''
text.overrides=重写
text.implements=实现
make.type.parameter.reified.and.function.inline=使类型参数具体化且使函数内联
change.all.usages.of.0.in.this.file.to.1=将此文件中所有的 ''{0}'' 用法例更改为 ''{1}''
change.all.usages.of.0.in.this.file.to.a.kotlin.class=将此文件中所有的 ''{0}'' 用法例更改为 Kotlin 类
change.to.kotlin.class=更改为 Kotlin 类
choose.an.appropriate.kotlin.class=选择适当的 Kotlin 类
add.empty.brackets.after.primary.constructor=在主构造函数后添加空括号
add.constructor.keyword=添加 'constructor' 关键字
move.annotation.to.receiver.type=将注解移动到接收器类型
move.type.parameter.constraint.to.where.clause=将类型参数约束移动到 'where' 子句
move.else.branch.to.the.end=将 else 分支移动到末尾
insert.number.conversion=插入数字转换
convert.expression.to.0=将表达式转换为 ''{0}''
remove.from.annotation.argument=从注解参数中移除 @
remove.default.parameter.value=移除默认参数值
remove.final.upper.bound=移除最终上限
remove.function.body=移除函数体
remove.redundant.0.modifier=移除冗余 ''{0}'' 修饰符
make.0.not.1=将{0}设为非 {1}
remove.0.modifier=移除 ''{0}'' 修饰符
remove.modifier=移除修饰符
remove.identifier.from.anonymous.function=从匿名函数中移除标识符
remove.constructor.call=移除构造函数调用
make.not.nullable=设为不可为 null
remove.useless=移除无用 '?'
remove.redundant=移除冗余的 '?'
remove.0.from.property=从属性中移除{0}
remove.parts.from.property=从属性中移除部分
text.initializer=初始化
text.setter=setter
text.getter=getter
remove.element=移除元素
for.0=对于 ''{0}''
remove.conflicting.import.0=移除冲突的导入 {0}
remove.type.parameters=移除类型参数
remove.type.arguments=删除显式的类型参数
remove.star=移除 '*'
remove.variable.0=移除变量 ''{0}''
remove.redundant.initializer=移除冗余的初始化器
remove.redundant.label=移除冗余标签
remove.single.lambda.parameter.declaration=移除单个 lambda 参数声明
remove.supertype=移除父类型
remove.0.variance.from.1=从 ''{1}'' 中移除 ''{0}'' 差异
remove.parameter.0=删除参数 ''{0}''
remove.redundant.assignment=删除冗余分配
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=在分配给变量 ''{0}'' 的表达式中发现可能的副作用<br>您可以\:<br>-\\&nbsp;<b>移除</b>整个赋值，或<br>-\\&nbsp;<b>将赋值右侧转换</b>为其自己的语句。<br>
remove.useless.cast=移除无用的转换
remove.useless.elvis.operator=移除无用的 elvis 运算符
remove.useless.is.check=移除无用的 is 检查
remove.val.var.from.parameter=从参数中移除 'val/var'
remove.0.from.parameter=从参数中移除 ''{0}''
remove.else.branch=移除 else 分支
rename.identifier.fix.text=重命名
rename.to.0=重命名为 ''{0}''
rename.parameter.to.match.overridden.method=移除参数以匹配重写的方法
rename.to.underscore=重命名为 _
replace.with.safe.this.call=替换为安全的 (this?.) 调用
replace.with.safe.call=替换为安全的 (?.) 调用
replace.scope.function.with.safe.call=将范围函数替换为 (?.) 调用
replace.with.dot.call=替换为点调用
replace.with.safe.call1=替换为安全的 (?.) 调用
replace.invalid.positioned.arguments.for.annotation=替换注解的无效定位参数
replace.jvmfield.with.const=将 '@JvmField' 替换为 'const'
replace.modifier=替换修饰符
update.obsolete.label.syntax=更新过时的标签语法
replace.with.label.0.at=替换为标签 {0}@
replace.cast.with.call.to.to.0=将转换替换为对 ''to{0}()'' 的调用
replace.cast.with.primitive.conversion.method=将转换替换为基元转换方法
replace.with.array.call=替换为数组调用
remove.expression.target=移除表达式目标
change.existent.retention.to.source=将现有保留更改为源
add.source.retention=添加源保留
round.using.0=使用 {0}() 舍入
simplify.0.to.1=将 {0} 简化为 ''{1}''
simplify.comparison=简化对比
specify.override.for.0.explicitly=为 ''{0}'' 显式指定重写
specify.override.explicitly=显式指定重写
specify.return.type.explicitly=显式指定返回类型
specify.type.explicitly=显式指定类型
add.constructor.parameters.from.0.1=从 {0}{1} 添加构造函数参数
change.to.constructor.invocation=更改为构造函数调用
add.constructor.parameters.from.superclass=从超类添加构造函数参数
surround.with.star.0=使用 *{0}(...) 环绕
surround.with.lambda=使用 lambda 环绕
surround.with.null.check=使用 null 检查环绕
convert.too.long.character.literal.to.string=将过长的字符文字转换为字符串
replace.array.of.boxed.with.array.of.primitive=将装箱数组替换为基元数组
migrate.unsupported.yield.syntax=迁移不受支持的 yield 语法
wrap.with=使用 [] 包装
wrap.with.array.literal=使用数组文字包装
wrap.with.collection.literal.call=使用集合文字调用包装
wrap.element.with.0.call=使用 ''{0}()'' 调用包装元素
replace.with.0.call=替换为 ''{0}()'' 调用
wrap.with.let.call=使用 ''?.let { ... }'' 调用包装
change.to.0=更改为 ''{0}''
change.to.correct.long.suffix.l=更改为正确的长后缀 'L'
change.to.correct.primitive.type=更改为正确的基元类型
0.from.1={0} 来自 {1}
checking.data.classes=正在检查数据类
checking.data.class.0.of.1=正在检查数据类 {0}/{1}…
difference.found.for.data.class.0.found.1.2=为数据类 {0} 找到差异。找到 {1} 个用法，但应为 {2}
title.error=错误
analyzed.0.classes.no.difference.found=已分析 {0} 类。未找到差异。
title.success=成功
can.t.finish.while.indexing.is.in.progress=当索引编制正在进行时，无法完成
enable.tremble.dumb.mode=启用静音震动模式
disable.tremble.dumb.mode=禁用静音震动模式
finding.implicit.nothing.s=正在查找隐式无内容
scanning.files.0.fo.1.file.2.occurrences.found=正在扫描文件\: 第 {0} 个，共 {1} 个。已找到 {2} 个匹配项
implicit.nothing.s=隐式无内容
not.found.in.0.files=在 {0} 个文件中未找到
titile.not.found=未找到
search.for.not.property.candidates=搜索非属性候选项
enter.package.fqname=输入包 FqName
searching.for.not.property.candidates=正在搜索非属性候选项
step.1.collecting.0.1.2=第 1 步\: 收集 {0}\:{1}\:{2}
step.2.0.of.1=第 2 步\: {0}/{1}
step.3.0.of.1=第 3 步\: {0}/{1}
title.done=已完成
revert.applied.imports=还原应用的导入
delete.0=删除{0}
replace.if.expression.with.elvis.expression=将 'if' 表达式替换为 elvis 表达式
report.also.on.statement=也在语句上报告
if.then.foldable.to=If-Then 可折叠为 '?\:'
replace.if.expression.with.safe.access.expression=将 'if' 表达式替换为安全访问表达式
remove.redundant.if.expression=移除冗余 'if' 表达式
replace.if.expression.with.safe.cast.expression=将 'if' 表达式替换为安全的转换表达式
simplify.foldable.if.then=简化可折叠的 if-then
foldable.if.then=可折叠的 if-then
introduce.when.subject=引入 'when' 主体
when.with.subject.should.be.used=应使用包含主体的 'when'
introduce.0.as.subject.0.when=将 ''{0}'' 作为 ''when'' 的主体引入
convert.call.chain.into.sequence.fix.text=将调用链转换为 'Sequence'
call.chain.length.to.transform=要转换的调用链长度\:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=可以将集合上的调用链转换为 'Sequence' 来改善性能
remove.useless.call.fix.text=移除无用的调用
rename.useless.call.fix.text=更改对 ''{0}'' 的调用
call.chain.on.collection.type.may.be.simplified=可以简化集合类型上的调用链
0.call.could.be.simplified.to.1={0} 调用可以简化为 {1}
simplify.call.fix.text=将 ''{0}'' 调用转换为 ''{1}''
simplify.call.chain.fix.text=将调用链合并为 ''{0}''
call.on.collection.type.may.be.reduced=可以简化集合类型上的调用
useless.call.on.collection.type=集合类型上存在无用调用
this.call.is.useless.with=此调用对 ?. 无用
useless.call.on.not.null.type=非 null 类型上存在无用调用
call.on.not.null.type.may.be.reduced=可以简化非 null 类型上的调用
replace.total.order.equality.with.ieee.754.equality=使用 IEEE 754 等式替换总订单等式
replace.with.binary.operator=替换为二进制运算符
call.replaceable.with.binary.operator=调用可替换为二进制运算符
replace.get.or.set.call.with.indexing.operator=将 get 或 set 调用替换为索引运算符
should.be.replaced.with.indexing=应替换为索引
replace.0.call.with.indexing.operator=将 ''{0}'' 调用替换为索引运算符
function.returning.0.with.a.name.that.does.not.end.with.1=返回名称不以 {1} 结尾的 {0} 的函数
add.call.or.unwrap.type.fix.text=将 ''.{0}()'' 添加到函数结果 (中断使用站点\!)
add.call.or.unwrap.type.fix.text1=解开 ''{0}'' 返回类型(中断 use-site\!)
reports.only.function.calls.from.kotlinx.coroutines=仅报告来自 kotlinx.coroutines 的函数调用
deferred.result.is.never.used=从未使用推迟的结果
function.0.returning.1.without.the.corresponding=函数 ''{0}'' 返回 ''{1}''，而相应的函数 ''{2}'' 未返回 ''{3}''
redundant.async.call.may.be.reduced.to.0=冗余 ''async'' 调用可简化为 ''{0}''
redundant.runcatching.call.may.be.reduced.to.0=冗余 ''runCatching'' 调用可简化为 ''{0}''
rename.to.fix.text=重命名为 ''{0}''
wrap.with.coroutine.scope.fix.text=使用 ''coroutineScope { ... }'' 包装函数体
wrap.with.coroutine.scope.fix.text2=使用 ''coroutineScope { ... }'' 包装调用
wrap.with.coroutine.scope.fix.text3=移除接收器并使用 ''coroutineScope { ... }'' 包装
wrap.with.coroutine.scope.fix.family.name=使用 coroutineScope 包装
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=由于挂起函数的 CoroutineScope 接收器，coroutineContext 不明确
replace.with.kotlin.analog.function.family.name=替换为 Kotlin 模拟
should.be.replaced.with.kotlin.function=应替换为 Kotlin 函数
replace.with.kotlin.analog.function.text=替换为 ''{0}'' 函数
add.documentation.fix.text=添加文档
missing.documentation=缺少文档
0.is.missing.documentation={0} 缺少文档
library.should.be.updated.to.be.compatible.with.kotlin.1.3=应更新库以与 Kotlin 1.3 兼容
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=从 1.3 起，禁止使用 MIN_VALUE 步骤调用 {0}
obsolete.coroutine.usage.in.whole.fix.family.name=修复项目中的实验性协同程序用法
apply.in.the.project.0=在项目中应用\: {0}
obsolete.coroutine.usage.fix.family.name=修复实验性协同程序用法
0.is.expected.to.be.used.since.kotlin.1.3=从 Kotlin 1.3 起，预期使用 ''{0}''
methods.are.absent.in.coroutines.class.since.1.3=从 1.3 起，协同程序类中不存在方法
experimental.coroutines.usages.are.obsolete.since.1.3=从 1.3 起，实验性协同程序用法遭到废弃
replace.substring.call.with.droplast.call=将 'substring' 调用替换为 'dropLast' 调用
replace.substring.call.with.indexing.operation.call=将 'substring' 调用替换为索引操作调用
replace.substring.call.with.substringbefore.call=将 'substring' 调用替换为 'substringBefore' 调用
replace.substring.call.with.substringafter.call=将 'substring' 调用替换为 'substringAfter' 调用
replace.substring.call.with.take.call=将 'substring' 调用替换为 'take' 调用
add.operator.modifier=添加 'operator' 修饰符
function.should.have.operator.modifier=函数应具有 'operator' 修饰符
type.parameter.can.have.0.variance=类型参数可以具有 {0} 差异
add.variance.fix.text=添加 ''{0}'' 差异
add.variance.fix.family.name=添加差异
generate.equals.and.hashcode.fix.text=生成 equals() 和 hashCode()
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode=数据类中的数组属性\: 建议重写 equals() / hashCode()
report.also.on.call.with.single.boolean.literal.argument=同时在包含单个布尔文字参数的调用上报告
boolean.literal.argument.without.parameter.name=不包含参数名称的布尔文字参数
constructor.parameter.is.never.used.as.a.property=构造函数参数从未被用作属性
property.is.explicitly.assigned.to.parameter.0.can=属性已明确分配给参数 {0}，可以直接在构造函数中声明
variable.is.never.modified.and.can.be.declared.immutable.using.val=变量从未被修改，且可以使用 'val' 声明为不可变
sealed.sub.class.has.no.state.and.no.overridden.equals=密封的子类没有状态，且没有重写的 equals
cascade.if.should.be.replaced.with.when=如果需要替换为 when，则级联
mark.as.deprecated.level.deprecationlevel.hidden=标记为 @Deprecated(..., 级别 \= DeprecationLevel.HIDDEN)
searching.for.imports.to.delete=正在搜索要删除的导入
delete.redundant.extension.property=删除冗余扩展属性
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=此属性与合成扩展冲突，应移除或重命名，以避免编译器中以后的变更破坏代码
condition.is.always.0=条件始终为 ''{0}''
remove.fix.text=删除表达式
simplify.fix.text=简化表达式
0.has.empty.body=''{0}'' 具有空白主体
convert.na.n.equality.quick.fix.text=替换为 'isNaN()'
equality.check.with.nan.should.be.replaced.with.isnan=包含 NaN 的相等检查应替换为 'isNaN()'
convert.pair.constructor.to.to.fix.text=转换为 'to'
can.be.converted.to.to=可以转换为 'to'
convert.to.a.range.check=转换为范围检查
two.comparisons.should.be.converted.to.a.range.check=两个比较应转换为范围检查
copy.method.of.data.class.is.called.without.named.arguments=数据类的 'copy' 方法在没有命名参数的情况下调用
private.data.class.constructor.is.exposed.via.the.generated.copy.method=private 数据类构造函数通过生成的 'copy' 方法公开。
remove.var.keyword.text=移除 var
delegating.to.var.property.does.not.take.its.changes.into.account=委托给 'var' 属性不会考虑其更改
add.replacewith.argument.to.specify.replacement.pattern=添加 'replaceWith' 参数以指定替换模式
deprecated.annotation.without.replacewith.argument=不包含 'replaceWith' 参数的 @Deprecated 注解
variable.name.0.matches.the.name.of.a.different.component=变量名称 ''{0}'' 与其他组件的名称匹配
replace.with.down.to.fix.text=替换为 'downTo'
this.range.is.empty.did.you.mean.to.use.downto=此范围为空。是否要使用 'downTo'?
equals.hashcode.in.object.declaration=对象声明中的 equals()/hashCode()
hash.code.text=生成 'hashCode()'
equals.text=生成 'equals()'
delete.equals.and.hash.code.fix.text=删除 equals()/hashCode()
redundant.explicit.this=冗余显式 this
explicit.this.expression.fix.family.name=移除冗余的 ''{0}''
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=将非常量 Kotlin 属性用作 Java 常量不正确。将在 1.4 中禁止
replace.if.with.elvis.operator=将 'if' 替换为 elvis 运算符
if.null.return.break.foldable.to=If-Null return/break/... 可折叠为 '?\:'
loop.parameter.0.is.unused=未使用循环参数 ''{0}''
replace.with.repeat.fix.family.name=替换为 'repeat()'
introduce.anonymous.parameter.fix.family.name=引入匿名参数
wrap.run.fix.text=转换为运行 { ... }
remove.braces.fix.text=移除大括号
function.with.and.inferred.return.type=包含 `\= { ... }` 和推断返回类型的函数
report.for.types.with.platform.arguments=为包含平台参数的类型报告
apply.only.to.public.or.protected.members=仅应用于 public 或 protected 成员
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=声明已从平台调用推断出类型，这可能导致未检查的为 null 性问题。将类型显式指定为可为 null 或不可为 null。
callable.reference.fix.family.name=添加显式 ''{0}''
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=Java 集合静态方法调用应替换为 Kotlin stdlib
replace.with.std.lib.fix.text=替换为 {0}.{1}
call.of.java.mutator.0.on.immutable.kotlin.collection.1=在不可变的 Kotlin 集合 ''{1}'' 上调用 Java 转变器 ''{0}''
replace.with.kotlin.s.foreach=替换为 Kotlin 的 forEach
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=Java Map.forEach 方法调用应替换为 Kotlin 的 forEach
remove.deprecated.symbol.import=移除弃用的符号导入
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=使用了冗余或弃用的语法或弃用的符号
equals.should.take.any.as.its.argument='equals' 应将 'Any?' 作为其参数
double.negation.fix.text=移除冗余求反
redundant.double.negation=冗余双重求反
equals.between.objects.of.inconvertible.types='equals()' 位于不可转换类型的对象之间
usage.of.kotlin.internal.declaration.from.different.module=使用了来自不同模块的 Kotlin 内部声明
junit.static.methods=JUnit 静态方法
redundant.override.fix.text=移除冗余重写方法
redundant.overriding.method=冗余重写方法
throwable.instance.0.is.not.thrown=未引发 Throwable 实例 ''{0}''
result.of.0.call.is.not.thrown=未引发 ''{0}'' 调用的结果
optimize.imports=优化导入
unused.import.directive=未使用的导入指令
lateinit.var.overrides.lateinit.var=lateinit var 重写 lateinit var
leaking.this.in.constructor.of.non.final.class.0=在非 final 类 {0} 的构造函数中泄漏 ''this''
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=在枚举类 {0} (具有可重写成员) 的构造函数中泄漏 ''this''
accessing.non.final.property.0.in.constructor=正在访问构造函数中的非 final 属性 {0}
calling.non.final.function.0.in.constructor=正在调用构造函数中的非 final 函数 {0}
text.can=可以
text.should=应当
text.Assignment=赋值
text.Return=返回
text.return=返回
0.1.be.lifted.out.of.2={0} {1} 从 ''{2}'' 中提取
lift.assignment.out.fix.text.0=从 ''{0}'' 中提取赋值
lift.return.out.fix.text.0=从 ' 中提取返回
change.main.function.return.type.to.unit.fix.text=添加显式 Unit 返回类型
change.main.function.return.type.to.unit.fix.text2=将返回类型更改为 Unit
0.should.return.unit={0} 应返回 Unit
junit.test=JUnit 测试
map.get.with.not.null.assertion.operator=包含非 null 断言运算符 (\!\!) 的 map.get()
replace.with.get.or.else.fix.text=替换为 'getOrElse' 调用
replace.with.get.value.call.fix.text=替换为 'getValue' 调用
replace.with.elvis.error.fix.text=替换为 '?\: error("")'
might.be.const=可能为 'const'
const.might.be.used.instead.of.jvmfield=可能使用了 'const'，而不是 '@JvmField'
text.Function=函数
text.Property=特性
0.1.could.be.private={0} ''{1}'' 可以为 private
diagnostic.name.should.be.replaced.by.the.new.one=诊断名称应替换为新名称
replace.diagnostic.name.fix.text={0} 替换为 {1}
replace.diagnostic.name.fix.family.name=替换诊断名称
lambda.argument.0.be.moved.out=Lambda 参数 {0} 从括号中移出
move.lambda.argument.out.of.parentheses=将 lambda 参数移出括号
suspicious.callable.reference.as.the.only.lambda.element=可疑的可调用引用作为唯一的 lambda 元素
inline.variable=内联变量
move.variable.declaration.into.when=将变量声明移动到 `when` 中
nothing.to.do=没有要执行的操作
variable.declaration.could.be.inlined=变量声明可以内联
variable.declaration.could.be.moved.into.when=变量声明可以移动到 `when` 中
may.contain.only.letters.digits.or.underscores=仅可以包含字母、数字或下划线
may.contain.only.letters.and.digits=仅可以包含字母和数字
should.not.contain.underscores.in.the.middle.or.the.end=中间或结尾不应包含下划线
should.not.start.with.an.underscore=不应以下划线开头
should.not.start.with.an.uppercase.letter=不应以大写字母开头
should.not.contain.underscores=不应包含下划线
should.start.with.a.lowercase.letter=应以小写字母开头
should.start.with.an.uppercase.letter=应以大写字母开头
doesn.t.match.regex.0=与正则表达式 ''{0}'' 不匹配
text.pattern=模式\:
package.name=包名称
text.part=部分
text.name=名称
text.Package=包
add.explicit.parameter.to.outer.lambda.fix.text=将显式参数名称添加到外部 lambda
implicit.parameter.it.of.enclosing.lambda.is.shadowed=封闭 lambda 的隐式参数 'it' 已被隐藏
equality.cehck.0.be.used.instead.of.elvis.for.nullable.boolean.check=使用相等检查 {0} 而不是 elvis 进行可为 null 的布尔检查
replace.with.equality.check.fix.text=替换为相等检查
null.checks.to.safe.call.check.fix.text=将链式 null 检查替换为安全的调用
null.checks.replaceable.with.safe.calls=null 检查可替换为安全的调用
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=可选预期注解在用于平台 {1} 的模块 {0} 中没有实际注解
call.of.inline.function.with.nullable.extension.receiver.can.provoke.npe.in.kotlin.1.2=调用包含可为 null 的扩展接收器的内联函数在 Kotlin 1.2+ 中可能引起 NPE
make.open.fix.text=使类开放
make.private.fix.text=设为 private
protected.visibility.is.effectively.private.in.a.final.class='protected' 可见性在 final 类中实际是 'private'
apply.also.to.private.members=同时应用于 private 成员
apply.also.to.internal.members=同时应用于内部成员
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=为确保 API 稳定性，建议显式指定声明类型
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=为确保 API 稳定性，建议显式指定 public 和 protected 声明类型
recursive.equals.call=递归 equals 调用
replace.with.field.fix.text=替换为 'field'
recursive.synthetic.property.accessor=递归合成属性访问器
recursive.property.accessor=递归属性访问器
remove.redundant.companion.reference.fix.text=移除冗余伴生引用
redundant.companion.reference=冗余伴生引用
remove.redundant.else.fix.text=移除冗余的 'else'
redundant.else=冗余的 'else'
remove.initializer.block.fix.text=移除初始值设定项块
redundant.empty.initializer.block=冗余空白初始值设定项块
remove.enum.constructor.invocation.fix.text=移除枚举构造函数调用
redundant.enum.constructor.invocation=冗余枚举构造函数调用
explicitly.given.type.is.redundant.here=显式给定类型在此处冗余
remove.redundant.getter.fix.text=移除冗余 getter
redundant.getter=冗余 getter
remove.redundant.if.text=移除冗余 'if' 语句
redundant.if.statement=冗余的 'if' 语句
delete.fix.family.name=移除箭头
redundant.lambda.arrow=冗余 lambda 箭头
remove.let.call=移除 `let` 调用
redundant.let.call.could.be.removed=可以移除冗余 `let` 调用
redundant.modality.modifier=冗余形式修饰符
this.type.probably.can.be.changed.to.nullable=此类型或许可以更改为可为 null
redundant.type.checks.for.object=对象的冗余类型检查
replace.with.equality.fix.text=用''{1}''替换''{0}''
redundant.0.call=冗余的''{0}''调用
remove.require.not.null.call.fix.text=移除''{0}''调用
remove.return.label.fix.text=移除冗余 ''@{0}''
redundant.0=冗余 ''@{0}''
remove.redundant.sam.constructors=移除冗余 SAM 构造函数
remove.redundant.sam.constructor=移除冗余 SAM 构造函数
redundant.sam.constructors=冗余 SAM 构造函数
redundant.sam.constructor=冗余 SAM 构造函数
fix.text=移除冗余分号
redundant.semicolon=冗余分号
remove.redundant.setter.fix.text=移除冗余 setter
redundant.setter=冗余 setter
redundant.suspend.modifier=冗余 'suspend' 修饰符
redundant.unit.return.type=冗余 'Unit' 返回类型
redundant.visibility.modifier=冗余可见性修饰符
remove.redundant.unit.fix.text=移除冗余 'Unit'
redundant.unit=冗余 'Unit'
remove.redundant.with.fix.text=移除冗余'with' 调用
redundant.with.call=冗余 'with' 调用
reformat.quick.fix.family.name=重新格式化文件
apply.only.to.modified.files.for.projects.under.a.version.control=仅应用于修改的文件 (对于版本控制下的项目)
file.is.not.properly.formatted=文件格式不正确
remove.jvmoverloads.annotation=移除 @JvmOverloads 注解
report.also.for.a.variables.without.a.whitespace.around=同时为周围没有空格的变量报告
remove.curly.braces=移除花括号
redundant.curly.braces.in.string.template=字符串模板中存在冗余花括号
remove.empty.parentheses.from.annotation.entry.fix.text=移除不必要的括号
parentheses.should.be.removed=应移除括号
remove.redundant.qualifier.name.quick.fix.text=移除冗余限定符名称
redundant.qualifier.name=冗余限定符名称
remove.redundant.backticks.quick.fix.text=移除冗余倒引号
remove.redundant.spread.operator.quickfix.text=移除冗余延展操作符
remove.to.string.fix.text=移除 'toString()' 调用
redundant.tostring.call.in.string.template=字符串模板中存在冗余 'toString()' 调用
redundant.setter.parameter.type=冗余 setter 参数类型
replace.with.contentequals=将 '\!\=' 替换为 'contentEquals'
replace.with.contentequals2=将 '\=\=' 替换为 'contentEquals'
replace.with.contentequals3=替换为 'contentEquals'
dangerous.array.comparison=危险的数组比较
replace.with.array.literal.fix.family.name=替换为 [...]
0.call.should.be.replaced.with.array.literal=''{0}'' 调用应替换为数组文字 [...]
replace.assert.boolean.with.assert.equality=将断言布尔替换为断言等式
replace.0.with.1=用''{1}''替换''{0}''
replace.collection.count.with.size.quick.fix.text=将 'count' 替换为 'size'
could.be.replaced.with.size=可以替换为 `size`
replace.with.kotlin.s.function.call=替换为 kotlin 的函数调用
replace.guard.clause.with.kotlin.s.function.call=将临界子句替换为 Kotlin 的函数调用
replace.index.loop.with.collection.loop.quick.fix.text=替换为元素的循环
replace.manual.range.with.indices.call.quick.fix.text=替换为索引
range.could.be.replaced.with.indices.call=范围可以替换为 '.indices' 调用
for.loop.over.indices.could.be.replaced.with.loop.over.elements=索引的循环可以替换为元素的循环
replace.negated.0.with.1=将求反的 ''{0}'' 替换为 ''{1}''
replace.with.elvis.return.fix.text=替换为 ''?\: return{0}''
replace.with.return=将 '\!\!' 替换为 '?\: return'
convert.put.to.assignment=将 put 转换为赋值
map.put.should.be.converted.to.assignment=map.put() 应转换为赋值
replace.int.range.end.inclusive.with.last.quick.fix.text=将 'endInclusive' 替换为 'last'
replace.int.range.start.with.first.quick.fix.text=将 'start' 替换为 'first'
could.be.replaced.with.unboxed.last=可以替换为未装箱的 `last`
could.be.replaced.with.unboxed.first=可以替换为未装箱的 `first`
replace.with.until.quick.fix.text=替换为 until
rangeto.or.the.call.should.be.replaced.with.until='rangeTo' 或 '..' 调用应替换为 'until'
replace.with.string.literal.fix.family.name=替换为字符串模板
string.format.call.can.be.replaced.with.string.templates=String.format 调用可以替换为字符串模板
replace.tostring.with.string.template=将 'toString' 替换为字符串模板
call.of.tostring.could.be.replaced.with.string.template='toString' 的调用可以替换为字符串模板
replace.to.with.infix.form.quickfix.text=将 'to' 替换为中缀形式
replace.with.enum.map.fix.text=替换为 EnumMap
replaceable.with.enummap=可替换为 EnumMap
replace.with.operator.assignment=替换为运算符赋值
replaceable.with.operator.assignment=可替换为运算符赋值
replace.with.0.eq=替换为''{0}\=''
replace.with.if.fix.text=替换为 'if' 类型检查
should.be.replaced.with.if.type.check=应替换为 'if' 类型检查
call.is.replaceable.with.another.scope.function=调用可替换为另一个范围函数
convert.scope.function.fix.family.name=转换为 ''{0}''
variable.0.is.assigned.to.itself=变量''{0}''是分配给自己
remove.self.assignment.fix.text=除去自身赋值
convert.to.nullable.type.fix.text=转换为可为 null 类型
constructor.has.non.null.self.reference.parameter=构造函数具有非 null 自引用参数
assign.backing.field.fix.text=分配支持字段
existing.backing.field.is.not.assigned.by.the.setter=现有支持字段未由 setter 分配
replace.with.error=替换为 '?\: error(...)'
replace.with.operator=替换为 '\!\!' 运算符
replace.assert.with.operator=将断言替换为运算符
assert.should.be.replaced.with.operator=断言应替换为运算符
simplify.negated.operation=简化求反运算
negated.operation.should.be.simplified=应简化求反运算
replace.negated.0.operation.with.1=将求反的 ''{0}'' 运算替换为 ''{1}''
simplify.when.fix.text=简化 'when'
this.when.is.simplifiable=此 'when' 可以简化
sort.modifiers=对修饰符排序
non.canonical.modifiers.order=非规范修饰符顺序
modifiers.should.follow.annotations=修饰符应遵循注解
remove.as.dynamic.call.fix.text=移除 'asDynamic' 调用
suspicious.asdynamic.member.invocation=可疑的 'asDynamic' 成员调用
0.create.new.1.under.the.hood=''{0}'' 在后台创建新的{1}
replace.with.filter.fix.text=替换为筛选器
change.type.to.mutable.fix.text=将类型更改为可变
replace.with.assignment.fix.text=替换为赋值 (原始为空)
join.with.initializer.fix.text=与初始值设定项联接
suspicious.combination.of.and=可疑的 \=\= 与 \=\=\= 组合
unlabeled.return.inside.lambda=lambda 中存在未标记的返回
suspicious.var.property.its.setter.does.not.influence.its.getter.result=可疑的 'var' 属性\: 它的 setter 不会影响其 getter 结果
variable.used.only.in.following.return.and.should.be.inlined=变量仅用在以下返回中且应内联
variable.is.same.as.0.and.should.be.inlined=变量与 ''{0}'' 相同且应内联
implicit.unsafe.cast.from.dynamic.to.0=从动态到 {0} 的隐式 (不安全) 转换
cast.explicitly.fix.text=显式转换
unused.equals.expression=未使用的 equals 表达式
since.kotlin.1.3.main.parameter.is.not.necessary=从 Kotlin 1.3 起，主参数不必要
remove.token.from.function.declaration=从函数声明中移除 '\=' 令牌
unused.return.value.of.a.function.with.lambda.expression.body=包含 lambda 表达式主体的函数未使用的返回值
safe.delete.constructor=安全删除构造函数
remove.unary.operator.fix.text=移除未使用的一元运算符
unused.unary.operator=未使用的一元运算符
one.line.return=一行返回
return.when='返回 when'
block.body=块主体
use.expression.body.instead.of.0=使用表达式主体，而不是{0}
convert.to.expression.body.fix.text=转换为表达式主体
when.has.only.else.branch.and.should.be.simplified='when' 仅包含 'else' 分支且应简化
wrap.unary.operator.quickfix.text=使用 () 包装一元运算符和值