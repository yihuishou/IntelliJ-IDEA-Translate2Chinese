readonly.occurences.found=在只读文件中找到匹配项
progress.text=寻找使用中...
usageView.tabText=重构预览
usageView.usagesText=用法
usageView.need.reRun=不能执行重构操作.有改变用途后的代码已经被发现.请,再执行使用搜索.
usageView.doAction=执行重构 (&D)
statusBar.refactoring.result={0, choice, 1\#1 个匹配项|2\#{0,number} 个匹配项}已更改
statusBar.noUsages=未找到匹配项
inner.class.exists=名为''{0}''的内部类已经定义在类''{1}''中
error.wrong.caret.position.method.or.class.name=光标应该定位在被重构的方法或类的名字中
error.wrong.caret.position.method.or.variable.name=光标应该定位在被重构的方法或变量的名字中
error.wrong.caret.position.class=光标应该定位在被重构的类中
error.wrong.caret.position.method.or.local.name=光标应该定位在被重构的元素的名字中
error.wrong.caret.position.symbol.to.rename=光标应该定位在被重构的符号中
error.wrong.caret.position.symbol.to.refactor=光标应该定位在被重构的符号中
error.out.of.project.element=选定的{0}不在项目中
error.out.of.project.element.default=所选元素不位于项目内部
error.in.injected.lang.prefix.suffix=选定的{0}在被重构文件的只读文件中
error.cannot.be.renamed=此元素不能被重命名
to.refactor=重构
changeSignature.no.type.for.parameter=指定一个类型给参数''{0}''
changeSignature.refactoring.name=更改签名
column.name.name=名称\:
changeSignature.default.value.label=默认值\:
parameters.border.title=参数
changeSignature.propagate.parameters.title=传递参数...(&G)
changeSignature.parameter.caller.chooser=选择要传递新参数的方法
changeSignature.return.type.prompt=返回类型\: (&T)
changeSignature.name.prompt=名称\: (&N)
name.prompt=名称 (&N)
signature.preview.border.title=签名预览
changeSignature.parameters.wont.propagate=递归传播的参数的更改不会被执行
changeSignature.wrong.return.type=错误的返回类型\:''{0}''
changeSignature.no.return.type=未指定返回类型
changeSignature.wrong.type.for.parameter=的参数''{1}''错误类型\:''{0}''
changeSignature.no.default.value=新参数''{0}''已被添加.指定一个默认值被用于该方法的所有现有的电话.
changeSignature.cannot.resolve.parameter.type=类型''{0}''参数''{1}''不能解决继续吗?
move.classes.destination.package.prompt=目标包\:
search.in.comments.and.strings=在注释和字符中搜索 (&C)
search.for.text.occurrences=搜索文本匹配项 (&T)
visibility.as.is=保留原样(&A)
visibility.escalate=升级(&E)
visibility.public=public(&B)
visibility.protected=protected(&O)
visibility.private=private(&V)
visibility.package.local=Package local(&K)
visibility.border.title=可见性
default.visibility.border.title=默认可见性
visibility.combo.title=可见性(&V)\:
moveInstanceMethod.select.an.instance.parameter=选择一个实例表达式(&I)\:
destination.package=目的包\: (&P)
choose.destination.package=选择目的包
interface.name.prompt=接口名称(&I)\:
package.for.new.interface=包为新界面\: (&P)
no.class.name.specified=未指定类名
no.parameter.name.specified=未指定参数名称
pull.up.members.to=把成员的{0}\:
members.to.be.pulled.up=成员被拉起(&B)
make.abstract=抽象化
javadoc.for.abstracts=JavaDoc的摘要
extractIncludeFile.name=提取包含文件
file.already.exist=文件{0}已经存在
file.already.exist.title=提取包含文件
name.for.extracted.include.file=提取包含文件名称(默认扩展\: {0})(&N)
extract.to.directory=提取目录\: (&D)
select.target.directory=选择目标目录
select.target.directory.description=将此目录中创建文件
create.directory=创建目录
superclass.name=超类名称(&S)\:
package.for.new.superclass=新超类的包\: (&P)
package.for.original.class=原始类的包\: (&P)
package.for.original.interface=原始接口的包\: (&P)
ExtractSuperClass.superclass=超类
members.to.form.superclass=超类的成员 (&B)
no.superclass.name.specified=未指定超类名称
extract.superclass.from=从中提取超类\:
extractSuper.extract=提取{0} (&X)
extractSuper.rename.original.class=重命名原始类并在可能的情况下使用{0} (&E)
extractSuper.rename.original.class.to=重命名原始类到\: (&R)
extractSuperInterface.interface=接口
members.to.form.interface=成员形成接口(&B)
extract.interface.from=提取接口从\:
rename.implementation.class.to=重命名实现类\:
rename.original.interface.to=重命名原始接口到\:
extractSuperInterface.javadoc=JavaDoc
no.interface.name.specified=未指定接口名称
replace.all.occurences=替换所有的匹配项({0}匹配项) (&A)
introduce.parameter.title=提取字段
no.field.name.specified=未指定字段名称
field.exists=字段名称{0}已经存在于类''{1}''中,继续吗?
choose.destination.class=选择目的类
# introduce variable
introduce.variable.title=提取变量
refactoring.introduce.context.error=不能执行重构在这个上下文
refactoring.introduceVariable=提取变量重构
refactoring.introduce.selection.error=使用选定的元素不能执行重构
refactoring.introduce.name.error=错误的名称
refactoring.introduce.name.used.error=这个名字已经使用
refactoring.introduce.variable.scope.error=与现有的变量名冲突
refactoring.introduce.placing.error=不能提取{0}变量

cannot.perform.refactoring=不能执行重构
move.instance.method.title=移动实例方法
move.method.is.not.supported.when.method.is.part.of.inheritance.hierarchy=不支持移动方法当方法是一个继承层次结构的一部分
extract.interface.title=提取接口
extract.interface.command.name=提取接口{0}从{1}
extract.method.title=提取方法
selected.block.contains.invocation.of.another.class.constructor=选块包含调用另一个类的构造函数.
selected.block.should.represent.a.set.of.statements.or.an.expression=选块应该代表一组语句或表达式
press.escape.to.remove.the.highlighting=按逃到删除高亮显示
extract.superclass.title=提取超类
extract.superclass.command.name=提取超类{0}从{1}
superclass.cannot.be.extracted.from.an.interface=不能从一个接口中提取超类.
superclass.cannot.be.extracted.from.an.enum=不能从一个枚举中提取超类.
inline.title=内联
introduce.constant.title=提取常量
introduce.selection.error=不能用选定的元素执行重构
introduce.field.title=提取常量
selected.block.should.represent.an.expression=选块应该代表一个表达式.
is.not.supported.in.the.current.context={0}是不支持在当前上下文.
to.rename=重命名
refactoring.is.not.supported.in.the.current.context={0}重构是不支持在当前上下文
cannot.introduce.variable.in.super.constructor.call=不能提取变量在超级构造函数调用
no.selection=没有选择.
selection.does.not.form.a.fragment.for.extraction=选择不会形成一个片段提取.
cannot.extract.selected.elements.into.include.file=不能提取选定的元素包含文件.
the.language.for.selected.elements.has.no.associated.file.type=语言为选中的元素没有相关的文件类型
extract.include.file.title=提取包含文件
replace.fragment=替换片段
idea.has.found.fragments.that.can.be.replaced.with.include.directive={0}找到了可以用包含指令替换的片段,您想复查它们吗?
remove.duplicates.command=删除重复的
constructor.cannot.be.made.static=构造函数不能是静态的.
this.member.does.not.seem.to.belong.to.any.class=此成员似乎不属于任何类.
member.is.already.static=成员已经是静态的.
cannot.make.abstract.method.static=不能把抽象方法静态化
inner.classes.cannot.have.static.members=内部类不能有静态成员.
pull.members.up.title=把成员向上移动
the.caret.should.be.positioned.inside.a.class.to.pull.members.from=插入符号应该定位在一个类来拉成员.
class.does.not.have.base.classes.interfaces.in.current.project={0}没有在当前项目的基类/接口。
pullUp.command=从{0}向上移动成员
push.members.down.title=向下移动成员
the.caret.should.be.positioned.inside.a.class.to.push.members.from=插入符号应该定位在一个类来推动成员
move.title=移动
ask.to.move.related.file=<html>相关文件中找到\: <code>{0}</code>.<br/>移动它吗？</html>
ask.to.move.related.files=<html>相关文件中找到\: <br/><code>{0}</code><br/><br/>移动它们吗？</html>
the.caret.should.be.positioned.at.the.class.method.or.field.to.be.refactored=光标应该定位在被重构的类/方法/字段中
select.refactoring.title=选择重构
what.would.you.like.to.do=您想做什么?
package.occurs.in.package.prefixes.of.the.following.source.folders.n=包{0}发生在包前缀下列源文件夹\:
these.package.prefixes.will.be.changed=这些包前缀将被改变.
rename.title=重命名
rename.not.supported=操作不被支持.
related.file=相关文件
rename.related.file.dialog.description=重命名相关文件\:
multiple.directories.correspond.to.package=多个目录对应方案
directories.and.all.references.to.package.will.be.renamed=是否只重命名整个包或目录{0}?
rename.package.button.text=重命名包 (&P)
rename.directory.button.text=重命名目录 (&D)
rename.directories= 重命名全部 (&A)
rename.current.directory= 重命名当前 (&C)
warning.title=警告
safe.delete.title=安全删除
variable.has.no.initializer=变量{0}没有初始化.
variable.has.no.dominating.definition=无法找到一个定义内联.
variable.is.never.used=变量{0}从未使用
variable.is.accessed.for.writing.and.used.with.inlined=另一个变量''{0}''定义配合使用内联一个.
0.with.1.visibility.is.not.accessible.from.2=可见性为 {1} 的{0}将无法从{2}访问
no.members.selected=没有成员选择
0.already.exists.in.the.target.class={0}已经存在在目标类中.
there.is.already.a.0.in.the.1.it.will.conflict.with.the.renamed.parameter=已有一个{0}在{1}中。它会与重命名的参数冲突。
changing.signature.of.0=改变签名的{0}
there.is.already.a.0.in.1.it.will.conflict.with.the.new.parameter=已有一个{0}在{1}中。它会与新的参数冲突。
0.to.change.signature={0}改变签名
New.name.of.method.is.not.java.identifier=方法的新名称不是Java标识符
references.to.be.changed=引用是改变了{0}
javadoc.as.is=保留原样 (&A)
javadoc.copy=复制 (&C)
javadoc.move=移动 (&M)
add.object.as.a.parameter.with.name=添加对象作为参数名称\: (&O)
0.already.contains.field.1={0}已包含字段{1}.
0.is.already.overridden.in.1={0}已经覆盖在{1}.方法将不会被下推到这类.
0.already.contains.inner.class.named.1={0}已包含名为{1}的内部类.
0.uses.1.which.is.pushed.down={0}{1},它使用被推下
refactoring.cannot.be.performed=重构不能执行
column.name.type=类型\:
column.name.any.var=任何var
column.name.default.value=默认值
caller.chooser.caller.method=调用方法
caller.chooser.callee.method=调用方法
caller.chooser.looking.for.callers=寻找调用者...
copy.class.copy.0.1=复制{0}{1}
invalid.target.package.name.specified=指定的目标包名称无效
invalid.target.package.name.default.package=无法移动类至默认包
error.title=错误
cannot.create.directory=无法创建目录
no.target.directory.specified=未指定目标目录
copy.files.new.name.label=新名字\: (&N)
no.new.name.specified=未指定新名称
copy.files.copy.specified.files.label=复制指定的文件
copy.files.copy.specified.directories.label=复制指定的目录
copy.files.copy.specified.mixed.label=复制指定的文件和目录
copy.files.to.directory.label=到目录\: (&D)
the.file.will.be.copied.to.this.directory=文件将被复制到此目录
copy.files.clone.title=克隆
copy.files.copy.title=复制
copy.files.clone.file.0=克隆文件{0}
copy.files.copy.file.0=复制文件{0}
copy.files.clone.directory.0=克隆目录{0}
copy.files.copy.directory.0=复制目录{0}
copy.handler.copy.class=复制类
copy.handler.clone.files.directories=克隆文件/目录
copy.handler.copy.files.directories=复制文件/目录
encapsulate.fields.options.border.title=选项
encapsulate.fields.no.fields.selected=没有字段可选择
invocations.to.be.inlined=调用内联{0}
classes.to.push.down.members.to=将成员推送到{0}类
references.in.code.to.elements.from.migration.map=在代码元素的引用从移民地图"{0}"{1}
press.the.do.migrate.button=按搜索结果面板\n底部的"迁移"按钮,使用迁移地图"{0}"\n进行迁移
references.in.code=引用代码{0}
safe.delete.comment.occurences.header=匹配项被发现在注释、字符串和非标文件{0}.这些匹配项不会改变
move.single.element.elements.header={0}被移动到{1}
references.in.code.to.0.1=在代码中引用到{0}{1}
move.classes.elements.header=类将被移动至{0}
move.packages.elements.header=包将被移动至{0}
references.found.in.code=引用代码中发现
references.found.in.generated.code=引用在生成的代码中找到
comments.elements.header=匹配项被发现在注释、字符串和非标文件{0}
move.files.elements.header=文件移动到{0}
move.directories.elements.header=目录移动到{0}
replace.all.occurences.checkbox=替换所有的匹配项 (&A)
initialize.in.border.title=初始化在
setup.method.radio=设置方法(
current.method.radio=当前方法 (&M)
class.constructors.radio=类构造函数 (&C)
extract.subclass.command=提取子类
extract.superclass.elements.header=提取超类成员到目录
declare.static.checkbox=声明静态 (&S)
declare.static.pass.fields.checkbox=声明 &static (通过域作为参数)
declare.folded.parameters=折叠参数 (&F)
extract.method.method.panel.border=方法
move.members.elements.header=要移动的成员
move.members.move.members.from.label=移动成员\:
move.members.to.fully.qualified.name.label=(完全限定名称)\:
move.members.members.to.be.moved.border.title=成员需要移动(静态唯一的)(
no.destination.class.specified=未指定目标类
0.is.not.a.legal.fq.name=''{0}''不是合法的FQ名称
create.class.command=创建类{0}
source.and.destination.classes.should.be.different=源和目标类应该不同
class.0.does.not.exist=类{0}不存在.您想创建它吗?
move.members.title=移动成员
members.to.be.moved.should.belong.to.the.same.class=要移动的成员应该属于同一类。
field.0.is.not.static=字段{0}不是静态的.{1}重构是只支持静态成员.
0.refactoring.cannot.be.applied.to.constructors={0}重构不能应用于构造器
method.0.is.not.static=方法{0}不是静态的。{1}重构只支持静态成员。
inline.field.border.title=内联
all.references.and.remove.the.local=内联和删除的所有引用的变量(&A)
this.reference.only.and.keep.the.variable=仅此内联引用,并保持变量
inline.variable.title=内联变量
variable.is.referenced.in.multiple.files=变量{0}在多个文件中引用
inline.command=内联{0}
inline.local.variable.prompt=内联局部变量''{0}''？
inline.local.variable.definition.prompt=内联局部变量''{0}''定义？
occurences.string=({0,choice,1\#1 个匹配项|2\#{0,number} 个匹配项})
occurrences.string=({0,choice,1\#1 个匹配项|2\#{0,number} 个匹配项})
inline.method.title=内联方法
inline.method.method.label=方法{0}
inline.method.border.title=内联
all.invocations.and.remove.the.method=内联所有调用和删除方法 (&A)
all.invocations.in.project=所有调用在项目(&A)
this.invocation.only.and.keep.the.method=此调用内联方法(只有和保持
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow={0}重构是返回语句时不支持中断执行流
refactoring.is.not.supported.for.recursive.methods={0}重构不能用于移除递归的方法。您只能内联单独的方法调用。
refactoring.cannot.be.applied=不能应用 {0} 重构
inline.method.command=内联方法{0}
0.that.is.used.in.inlined.method.is.not.accessible.from.call.site.s.in.1={0}中使用内联方法不可以从调用站点(s)在{1}
interface.has.been.successfully.created=已成功创建接口{0}.
class.has.been.successfully.created=已成功创建类{0}.
use.super.references.prompt=在这个阶段{0}可以分析用途的{1},换成用法的{2}在可能的情况下.是否要继续?
analyze.and.replace.usages=分析和替换用法
there.are.multiple.output.values.for.the.selected.code.fragment=选定的代码片段有多个输出值。
fields.0.are.not.accessible=字段{0}不可以从{1}
0.is.not.static.it.cannot.be.moved.to.the.interface={0}不是静态的.不能将它移动到该接口
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0}在声明处未初始化。在接口中不允许这样的字段。
0.already.contains.a.1={0}已包含{1}
0.uses.1.which.is.not.accessible.from.the.superclass={0}用{1},这不是可以从超类
0.uses.1.which.is.not.moved.to.the.superclass={0}用{1},这不是搬到超类
push.members.from.0.down.label=推动成员从{0}下来
members.to.be.pushed.down.panel.title=成员被下移 (&B)
keep.abstract.column.header=保持抽象
push.down.javadoc.panel.title=JavaDoc的摘要
push.down.members.elements.header=压低成员来自
interface.0.does.not.have.inheritors=接口{0}没有继承者.
functional.interface.broken=函数表达式要求功能界面准确的一种方法
class.0.does.not.have.inheritors=类{0}没有继承者.
push.down.will.delete.members=推动成员下来将导致它们被删除.您想创建一个新的子类?
edit.migration.map.title=编辑迁移地图
migration.map.name.prompt=地图的名字\:
migration.map.description.label=图描述\:
migration.add.button=添加...
migration.move.up.button=向上移动
migration.move.down.button=向下移动
migration.type.column.header=类型
migration.old.name.column.header=旧名称
migration.new.name.column.header=新名字
migration.class=类
edit.migration.entry.title=编辑 类/包 迁移说明
migration.entry.class=类
migration.entry.old.name=旧名称\:
migration.entry.new.name=新名称\:
migration.new.button=新...
migration.map.set.migration.maps=迁移映射
migration.no.usages.found.in.the.project=没有在项目发现用法
migration.title=迁移
move.classes.move.to.another.source.folder=搬到另一个源文件夹(&F)
do.you.wish.to.continue=要继续吗?
moving.directories.command=移动目录中...
move.instance.method.command=移动实例方法
move.inner.to.upper.level.title=移动内部,上水平
move.specified.files=移动指定的文件
move.specified.directories=移动指定的目录
move.file.0=移动文件{0}
move.directory.0=移动目录{0}
move.files.to.directory.label=到目录\:
the.file.will.be.moved.to.this.directory=文件将被移到此目录
searching.for.variables=搜索变量中...
searching.for.duplicates=搜索副本...
factory.method.name.label=工厂方法名称\:
replace.constructor.with.factory.target.fq.name=在(完全限定名称)\:
class.0.not.found=类{0}未找到.
occurrences.found.in.comments.strings.and.non.java.files=匹配项被发现在注释、字符串和非标文件
occurrences.found.in.comments.strings.non.java.files.and.generated.code=出现在注释,发现字符串,无代码文件和生成的代码
0.referenced.in.1.will.not.be.accessible.in.module.2={0},{1},引用不会被访问在模块{2}
0.referenced.in.1.will.not.be.accessible.from.module.2={0},{1}中引用,不可以从模块{2}
0.referenced.in.1.will.not.be.accessible.from.production.of.module.2={0},{1}中引用,不可以从生产来源的模块{2}
choose.destination.directory=选择目标目录
directory.chooser.hide.non.existent.checkBox.text=隐藏不存在的 (&H)
safe.delete.command=删除中{0}
select.all.button=全选 (&A)
unselect.all.button=取消选择所有 (&U)
automatic.renamer.enity.name.column={0}的名字
automatic.renamer.rename.to.column=重命名为
rename.0.and.its.usages.to=重命名{0}和它的用法\:
rename.variables=重命名变量 (&V)
rename.inheritors=重命名继承者 (&I)
rename.parameters.hierarchy=重命名参数在层次结构(
rename.overloads=重命名重载 (&O)
rename.bound.forms=重命名绑定表单 (&F)
inner.class.0.is.already.defined.in.class.1=内部类{0}已被定义在类{1}中.无论如何都继续?
class.0.already.exists=类{0}已存在
renaming.something=重命名一些
renaming.0.1.to.2=将{0}{1}重命名为{2}
renaming.command.name=重命名{0}
0.to.be.renamed.to.1.2={0}将被重命名为{1}{2}
references.in.code.to.0=在代码中引用到{0}
rename.variables.title=重命名变量
rename.variables.with.the.following.names.to=重命名变量具有以下名称\:
entity.name.variable=变量
rename.bound.forms.title=重命名绑定形式
rename.forms.with.the.following.names.to=重命名形式具有以下名称\:
entity.name.form=形式
rename.inheritors.title=重命名继承者
rename.inheritors.with.the.following.names.to=重命名继承者具有以下名称\:
entity.name.inheritor=继承者
attempting.to.delete.targets.node.text=试图删除
retry.command=重试
rerun.safe.delete=重新运行安全删除 (&R)
delete.title=删除
items.to.be.deleted=项已被删除
usages.detected=发现用法
delete.anyway.button=无论如何都删除 (&D)
ask.to.delete.related.file=<html>相关文件中找到\: <code>{0}</code>.<br/>删除它吗？</html>
ask.to.delete.related.files=<html>相关文件中找到\: <br/><code>{0}</code><br/><br/>删除它们吗？</html>
the.following.problems.were.found=发现以下问题\:
cancel.button=取消 (&N)
view.usages=查看用法 (&V)
anonymous.class.text=匿名类
problems.detected.title=发现问题
continue.button=继续 (&C)
do.you.wish.to.ignore.them.and.continue=要忽略它们并继续吗?
delegation.panel.method.calls.label=方法调用\:
delegation.panel.modify.radio=修改 (&M)
delegation.panel.delegate.via.overloading.method=代表通过重载方法 (&L)
member.column=成员
refactor.button=重构 (&R)
preview.button=预览 (&P)
yes.button=是 (&Y)
no.button=否 (&N)
replace.this.code.fragment=这段代码替换吗?
process.duplicates.title=处理重复项
process.methods.duplicates.title=过程方法复制的{2}({0},{1})
0.has.detected.1.code.fragments.in.this.file.that.can.be.replaced.with.a.call.to.extracted.method={0} 已检测到 {1} 代码 {1,choice,1\#fragment|2\#fragments} 在该文件中,可以调用一个提取的方法代替。您想检测和替换 {1,choice,1\#it|2\#them}?
replace.button=替换
method.duplicates.method.label=方法{0}
interface.member.dependency.required.by.interfaces=所要求的接口
member.info.implements.0=实现{0}
member.info.extends.0=扩展{0}
used.by.0=被{0}使用
uses.0=使用{0}
file.description=文件{0}
directory.description=目录{0}
0.is.located.in.a.jar.file={0}位于jar文件中
0.is.read.only={0}是只读的.
method.0.is.already.defined.in.the.1=方法{0}已定义在{1}.
current.class=当前类
0.has.1.usages.that.are.not.safe.to.delete={ 0 } { 1,选择,1
safe.delete.of.those.0.in.comments.strings.non.code={ 0,选择,1
safe.delete.conflict.title=删除代码中发现的引用可能不安全
pushed.members.will.not.be.visible.from.certain.call.sites=推动会员将不可见从特定调用地点.
invert.boolean.title=逆布尔
invert.boolean.refs.to.invert=引用是倒{0}
invert.boolean.elements.header={0}转化
please.enter.a.valid.name.for.inverted.element=请输入一个有效的名字倒{0}
invert.boolean.name.of.inverted.element=名字倒 {0}(&N)\:
invert.0.1=转化的{0}{1}及其用法
inline.to.anonymous.no.inheritors=类有子类不能内联
unsupported.refs.found=不支持的参考文献发现在{0}文件
inline.parameter.command.name=内联参数{0}
move.to.different.language=目标类{2}有不同的语言比{0}{1}
dont.support.inner.classes=重构无效\:{0}不支持内部类
move.specified.elements=移动指定的元素
rename.directory.title=重命名目录 (&D)
rename.module.title=重命名模块 (&M)
# extract method
refactoring.extract.method.dialog.title=提取方法
refactoring.extract.method.dialog.method.name=方法名称\:
refactoring.extract.method.dialog.parameters=参数
refactoring.extract.method.dialog.output.variables=输出变量
refactoring.extract.method.dialog.signature.preview=签名预览
refactoring.extract.method.dialog.empty=空
change.signature.leave.blank.default.value=留空(&B)
change.signature.feel.lucky=感到幸运 (&L)
change.signature.use.selected.value=使用所选值 (&V)
refactoring.extract.method.from.duplicate.code=从重复的代码中提取方法
search.for.references=搜索引用 (&F)
0.is.not.an.identifier=<b><code>{0}</code></b>不是一个正确的标识用在 <b><code>{1}</code></b>
rename.directory.command.name=重命名目录
rename.directories.command.name=重命名目录
target.destination.folder=目标目录\: (&D)
detecting.possible.conflicts=检测可能的冲突...
path.completion.shortcut=使用{0}的路径完成

rename.project.action.title=重命名项目...
rename.project.handler.title=重命名项目(&P)
enter.new.project.name=输入新项目的名称\:
rename.project=重命名项目
renames.project=重命名项目
introduce.functional.parameter.title=提取函数参数
introduce.functional.variable.title=提取函数变量
refactoring.introduce.parameter.object.references.to.be.modified=引用被修改
refactoring.introduce.parameter.object.method.whose.parameters.are.to.wrapped=其参数为包装的方法
refactoring.introduce.parameter.object.command.name=引入了参数类{0} 到{1}()
refactoring.introduce.parameter.object.method.to.extract.parameters.from.label=从方法中提取参数
refactoring.introduce.parameter.object.title=引入参数对象

copy.files.and.directories=复制文件和目录…
copy.directories=复制目录…
copy.directory=复制目录…
copy.files=复制文件…
copy.file=复制文件…
move.files.and.directories=移动文件和目录…
move.directory=移动目录…
move.directories.with.dialog= 移动目录…
move.files=移动文件…
move.file=移动文件…

open.copy.in.editor=在编辑器中打开副本
open.in.editor.label=在编辑器中打开(&O)
name.is.not.a.valid.file.name=名称不是有效的文件名

introduce.target.chooser.expressions.title=表达式
suggested.refactoring.usages=用法
suggested.refactoring.overrides=重写
suggested.refactoring.implementations=实现
suggested.refactoring.update.button.text=更新
suggested.refactoring.next.button.text=下一个
suggested.refactoring.rename.button.text=重命名
suggested.refactoring.rename.with.preview.button.text=使用预览重命名
suggested.refactoring.ignore.button.text=忽略更改
suggested.refactoring.rename.gutter.icon.tooltip=将 ''{0}'' 的用法重命名为 ''{1}''… {2}
suggested.refactoring.rename.intention.text=将 ''{0}'' 的用法重命名为 ''{1}''
suggested.refactoring.rename.popup.text=将 ''{0}'' 的用法重命名为 ''{1}''
suggested.refactoring.rename.text.occurrences=将 ''{0}'' 重命名为 ''{1}'' 时在注释和字符串中发现匹配项。您也想将它们重命名吗?
suggested.refactoring.rename.text.occurrences.title=重命名文本匹配项
suggested.refactoring.change.signature.intention.text=更新 {0} 以反映签名更改…
suggested.refactoring.change.signature.gutter.icon.tooltip=更新 ''{1}'' 的 {0} 以反映签名更改… {2}
suggested.refactoring.change.signature.label.text=更新 {0} 以反映签名更改\:
suggested.refactoring.parameter.values.label.text=为新参数添加值\:
suggested.refactoring.parameter.values.placeholder=可选值
suggested.refactoring.use.any.variable.checkbox.text=使用任意变量
suggested.refactoring.use.any.variable.checkbox.hint=如果调用位置存在合适类型的单个变量，则会将其用作参数值
suggested.refactoring.disabled.gutter.icon.tooltip=签名已更改，但用法无任何更新
suggested.refactoring.rename.command.name=重命名用法
suggested.refactoring.change.signature.command.name=更新{0}

automatic.renaming.dialog.rename.selected.title=重命名选中项
automatic.renaming.dialog.new.name.label=新名字
automatic.renaming.dialog.identifier.invalid.error=标识符 ''{0}'' 无效
refactoring.prepare.progress=准备…
refactoring.preprocess.usages.progress=预处理用法
refactoring.index.corruption.notifiction=检测到索引损坏。请重试重构 - 将自动重建索引
refactoring.dumb.mode.notification=在索引准备就绪前，重构不可用
action.show.conflicts.in.view.text=在视图中显示冲突
conflicts.tab.name=文件合并冲突
change.signature.default.value.description=在调用此方法时，如果恰好找到了一个正确类型的变量，请使用它。否则请留空。
change.signature.default.value.chooser.title=需要参数“{0}”的默认值
rename.package.with.lib.message=包 ''{0}'' 包含无法重命名的库中的目录。是否要重命名当前的{1,choice,1\#目录|2\#模块目录}?
rename.package.with.lib.multiple.message=包 ''{0}'' 包含无法重命名的库中的目录。是否要重命名当前的{1,choice,1\#目录|2\#模块目录}或项目中的所有目录?
refactor.this.title=重构此
safe.delete.not.available.indexing=编制索引期间，无法使用“安全删除”重构
rename.not.all.usages.title=并非所有用法都已重命名
rename.not.all.usages.message=<html>已安全跳过以下用法\:<br>{0}</html>
rename.string.occurrences.found.title=找到字符串匹配项
rename.related.files.option.name=重命名相关文件(具有相同的名称)
refactoring.indexing.warning.title=索引
refactoring.not.available.indexing=编制索引期间，无法使用重构
introduce.normalize.declaration.command.name=标准化声明
inplace.refactoring.cancel.current=取消当前重构
inplace.refactoring.abandon.started=放弃已开始的重构
inplace.refactoring.navigate.to.started=导航到已开始的重构
inplace.refactoring.continue.started=继续已开始的重构
inplace.change.signature.preview.label=已执行签名修改\:
extract.method.replace.duplicate.command.name=替换重复项
extract.include.file.action.title=提取包含文件...
label.change.signature.in.all.calls.to.this.method.leave.the.parameter.blank=在对此方法的所有调用中，将参数留空
checkbox.introduce.parameter.object.keep.method.as.delegate=使方法保持为委托(&D)
border.title.introduce.parameter.class=参数类
border.title.introduce.parameters.to.extract=要提取的参数