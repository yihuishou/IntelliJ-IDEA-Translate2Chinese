### Quick fixes ###
QFIX.optimize.imports=优化导入

QFIX.add.import.add.import=添加 "''{0}''"

QFIX.add.parameter.self=添加参数 ''{0}''
QFIX.add.super=添加超类调用

QFIX.add.property=添加此字段的属性
QFIX.use.property=使用此字段的属性

QFIX.make.public=设为 public

QFIX.convert.to.new.style=转换为新样式类

QFIX.change.base.class=更改基类

QFIX.create.property=创建属性

QFIX.add.encoding=添加编码声明

QFIX.NAME.parameters=函数和方法的参数


QFIX.NAME.add.method.$0.to.class.$1=添加方法 {0}() 到类 {1}
QFIX.failed.to.add.method=<br/>无法添加方法！<br/><br/>

QFIX.NAME.add.function.$0.to.module.$1=在模块 {1} 中创建函数 {0}() 
QFIX.failed.to.add.function=<br/>无法添加函数！<br/><br/>

QFIX.action.failed=操作失败

QFIX.remove.trailing.semicolon=移除尾随分号

QFIX.dict.creation=替换字典创建
QFIX.list.creation=替换列表创建

QFIX.classic.class.transform=从对象继承

QFIX.add.global=添加全局语句

QFIX.move.from.future.import=将 'from __future__ import' 移至正确位置

QFIX.replace.equality=替换相等

QFIX.augment.assignment=将赋值替换为增强赋值

QFIX.statement.effect=替换为函数调用
QFIX.statement.effect.move.docstring=将文档字符串移至正确位置

QFIX.statement.effect.introduce.variable=引入变量

QFIX.unresolved.reference=将 ''{0}'' 替换为 ''{1}.{0}''

QFIX.unresolved.reference.add.param.$0=创建参数 ''{0}''
QFIX.unresolved.reference.add.param=创建引用参数

# UnresolvedRefCreateFunctionQuickFix
QFIX.unresolved.reference.create.function=创建函数
QFIX.NAME.unresolved.reference.create.function=创建函数 ''{0}''

QFIX.introduce.variable=为语句引入变量

# RemoveUnnecessaryBackslashQuickFix
QFIX.remove.unnecessary.backslash=移除表达式中不必要的反斜杠

# ConvertDocstringQuickFix
QFIX.convert.single.quoted.docstring=将文档字符串转换为三/双引号字符串形式

#UnresolvedRefTrueFalseQuickFix
QFIX.unresolved.reference.replace.$0=替换为 {0}

#RemoveArgumentEqualDefaultQuickFix
QFIX.remove.argument.equal.default=移除等于默认值的参数

# ReplaceFunctionWithSetLiteralQuickFix
QFIX.replace.function.set.with.literal=将函数调用替换为集合文字

#DocstringQuickFix
QFIX.docstring.add.$0=添加文档字符串参数 ''{0}''
QFIX.docstring.remove.$0=移除文档字符串参数 ''{0}''
QFIX.docstring.insert.stub=插入文档字符串

#RemoveDecoratorQuickFix
QFIX.remove.decorator=移除装饰器

#PyRenameUnresolvedRefQuickFix
QFIX.rename.unresolved.reference=重命名引用

#PyMoveAttributeToInitQuickFix
QFIX.move.attribute=将属性移至 __init__ 方法

#PyMakeMethodStaticQuickFix
QFIX.NAME.make.static=使之为静态方法

#PyMakeFunctionFromMethodQuickFix
QFIX.NAME.make.function=从方法中生成函数

#PyMakeFunctionReturnTypeQuickFix
QFIX.NAME.make.$0.return.$1=使''{0}''返回''{1}''

#PyImplementMethodsQuickFix
QFIX.NAME.implement.methods=实现抽象方法

QFIX.NAME.remove.assignment=移除赋值

QFIX.NAME.update.parameters=更新参数

QFIX.NAME.remove.call=移除调用

QFIX.NAME.move.except.up=上移 except 子句

QFIX.NAME.remove.dict.key=移除此键

QFIX.NAME.add.specifier=添加格式说明符

QFIX.NAME.add.exception.base=添加 Exception 基类

QFIX.NAME.change.signature=Change signature
QFIX.change.signature.of=更改{0}的签名

QFIX.NAME.remove.argument=移除参数



QFIX.NAME.rename.argument=重命名参数
QFIX.NAME.rename.element=重命名元素

QFIX.NAME.wrap.in.exception=使用 Exception 调用包装

QFIX.NAME.make.list=将元组替换为列表

#PyRemoveUnderscoresInNumericLiteralsQuickFix
QFIX.NAME.remove.underscores.in.numeric=移除数字文字中的下划线

# InstallAndImportQuickFix
QFIX.install.and.import.package=安装和导入包
QFIX.NAME.install.and.import.package=安装和导入包 ''{0}''

QFIX.create.function.in.module=在模块中创建函数
QFIX.ignore.unresolved.reference=忽略未解析的引用
QFIX.ignore.unresolved.reference.0=忽略未解析的引用 ''{0}''
QFIX.mark.all.unresolved.attributes.of.0.as.ignored=将所有未解析的 ''{0}'' 属性标记为已忽略
QFIX.fill.paragraph=填充段落
QFIX.add.qualifier=添加限定符
QFIX.rename.parameter=重命名参数
QFIX.fix.docstring=修复文档字符串
QFIX.create.class=创建类
QFIX.create.class.0=创建类 ''{0}''
QFIX.create.class.in.module=在模块 {1} 中创建类 ''{0}''
QFIX.remove.trailing.blank.lines=移除尾随的空白行
QFIX.convert.indents=转换缩进
QFIX.convert.indents.to.tabs=将缩进转换为制表符
QFIX.convert.indents.to.spaces=将缩进转换为空格
QFIX.generating.skeletons.for.binary.module=正在为二进制模块生成框架
QFIX.generate.binary.stubs=生成二进制存根
QFIX.replace.with.true.or.false=替换为 True 或 False
QFIX.add.method.to.class=添加方法到类
QFIX.reformat.file=重新格式化文件
QFIX.bold.html.text=<b>{0}</b>
QFIX.replace.with.type.name=替换为类型名称
QFIX.remove.function.annotations=移除函数注解
QFIX.replace.with.target.name=替换为目标名称
QFIX.remove.generic.parameters=移除泛型参数
QFIX.replace.with.square.brackets=替换为方括号
QFIX.surround.with.square.brackets=用方括号环绕
QFIX.remove.square.brackets=移除方括号

# Intentions: INTN
INTN.Family.convert.import.unqualify=将 'import module' 转换为 'from module import'
INTN.Family.convert.import.qualify=将 'from 模块 import' 转换为 'import 模块'
INTN.Family.toggle.import.alias=切换导入别名
INTN.Family.convert.except.part=将 except 部分转换为支持的形式
INTN.Family.convert.set.literal=将集合文字转换为支持的形式
INTN.Family.convert.builtin=转换内置模块导入
INTN.Family.convert.dict.comp.expression=转换字典推导表达式
INTN.Family.convert.string=将单引号字符串转换为双引号字符串

INTN.convert.to.from.$0.import.$1=转换为 ''from {0} import {1}''
INTN.convert.to.import.$0=转换为 ''import {0}''

INTN.alias.for.$0.dialog.title=''{0}'' 的别名：
INTN.add.alias.for.import.$0=添加别名到 ''{0}''
INTN.remove.alias.for.import.$0=移除别名 ''{0}''

INTN.Family.migration.to.python3=迁移到 Python 3

INTN.convert.except.to=将 'except exceptClass, Target' 转换为 'except exceptClass as Target'

INTN.convert.set.literal.to=将集合文字转换为 'set' 方法调用

INTN.convert.builtin.import=将内置模块导入转换为支持的形式

INTN.convert.dict.comp.to=将字典推导式转换为 'dict' 方法调用

INTN.replace.noteq.operator=替换不等运算符

INTN.remove.leading.$0=移除前导 {0}
INTN.remove.leading.prefix=移除前缀

INTN.remove.trailing.suffix=移除尾随后缀

INTN.replace.list.comprehensions=将列表推导式转换为支持的形式

INTN.replace.list.comprehensions.with.for=将列表推导式转换为 for 循环

INTN.replace.octal.numeric.literal=将八进制数字文字转换为支持的形式

INTN.replace.raise.statement=将 raise 语句转换为支持的形式

INTN.replace.backquote.expression=替换反引号表达式

INTN.replace.method=替换当前 Python 版本中不支持的方法

INTN.split.if=拆分 if
INTN.split.if.text=拆分为 2 个 if

INTN.negate.comparison=Negate Comparison
INTN.negate.$0.to.$1=将 ''{0}'' 求反为 ''{1}''

INTN.string.concatenation.to.format=将字符串串联替换为格式运算符
INTN.replace.plus.with.format.operator=将 + 替换为字符串格式化运算符
INTN.replace.plus.with.str.format=将 + 替换为 str.format 方法调用

# ConvertFormatOperatorToMethodIntention
INTN.format.operator.to.method=将格式运算符用法转换为 str.format 方法调用

# PyConvertToFStringIntention
INTN.convert.to.fstring.literal=转换为格式化字符串文字
INTN.replace.with.method=替换为 str.format 方法调用

INTN.flip.comparison=Flip Comparison
INTN.flip.$0=Flip 'equals'
INTN.flip.$0.to.$1=将 ''{0}'' 翻转为 ''{1}''

INTN.convert.string=将单引号字符串转换为双引号字符串

INTN.join.if=联接 if
INTN.join.if.text=联接两个 if

INTN.convert.dict.constructor.to.dict.literal=将 dict 构造函数转换为文字形式
INTN.convert.dict.literal.to.dict.constructor=将 dict 文字转换为 dict 构造函数

INTN.quoted.string=在单引号字符串和双引号字符串之间转换
INTN.quoted.string.single.to.double=将单引号字符串转换为双引号字符串
INTN.quoted.string.double.to.single=将双引号字符串转换为单引号字符串

INTN.convert.lambda.to.function=将 lambda 转换为函数

INTN.convert.variadic.param=将可变参数转换为正常参数

# PyConvertTripleQuotedStringIntention
INTN.triple.quoted.string=将三引号字符串转换为单引号字符串

# PyBaseConvertCollectionLiteralIntention
INTN.convert.collection.literal.family=将集合转换为 {0}
INTN.convert.collection.literal.text=将 {0} 转换为 {1}

# PyConvertTypeCommentToVariableAnnotation
INTN.convert.type.comment.to.variable.annotation.family=将类型注释转换为变量注解
INTN.convert.type.comment.to.variable.annotation.text=转换为变量注解


INTN.demorgan.law=德摩根定律 

# PyTransformConditionalExpressionIntention
INTN.transform.into.if.else.statement=将条件表达式转换为 if/else 语句

# PyConvertTripleQuotedStringIntention
INTN.doc.string.stub=插入文档字符串存根

#SpecifyTypeInDocstringIntention
INTN.specify.type=指定文档字符串中引用的类型
INTN.specify.return.type=指定文档字符串中的返回类型
INTN.add.parameters.to.docstring=添加参数到文档字符串

#SpecifyTypeInPy3AnnotationsIntention
INTN.specify.type.in.annotation=使用注解指定引用类型
INTN.specify.return.type.in.annotation=使用注解指定返回类型

#PyAnnotateTypesIntention/PyAnnotateVariableTypeIntention
INTN.add.type.hints.for.function.family=为函数添加类型提示
INTN.add.type.hints.for.function=为函数 ''{0}'' 添加类型提示
INTN.add.type.hint.for.variable.family=为变量添加类型提示
INTN.add.type.hint.for.variable=为变量 ''{0}'' 添加类型提示
INTN.add.type.hint.for.variable.PEP484.incompatible.type=类型 ''{0}'' 不能以 PEP 484 格式内联表示

#TypeAssertionIntention
INTN.insert.assertion=插入类型断言

#PyYieldFromIntention
INTN.yield.from=将包含 'yield 的显式迭代转换为 'yield from' 表达式

#PyConvertStaticMethodToFunctionIntention
INTN.convert.static.method.to.function=将静态方法转换为函数

#PyConvertMethodToPropertyIntention
INTN.convert.method.to.property=将方法转换为属性

#PyConvertImportIntentionAction
INTN.convert.relative.to.absolute=将相对导入转换为绝对导入
INTN.convert.absolute.to.relative=将绝对导入转换为相对导入

INTN.add.alias.title=添加别名

# Conflict checker
CONFLICT.name.$0.obscured=名称 ''{0}'' 被局部定义遮掩
CONFLICT.name.$0.obscured.cannot.convert=名称 ''{0}'' 被遮掩。无法转换。
CONFLICT.occurrence.sing=匹配项
CONFLICT.occurrence.pl=匹配项

### Surround with templates ###
surround.with.whileelse.template=while / else
surround.with.return.template=返回
surround.with.try.except.template=try / except

##########################################################################################################################
# Unwrap
##########################################################################################################################
unwrap.if=解开 if...
unwrap.while=解开 while...
unwrap.for=解开 for...
unwrap.with=解开 with...
unwrap.try=解开 try...
unwrap.else=解开 else...
unwrap.elif=解开 elif...
remove.else=移除 else...
remove.elif=移除 elif...

### Inspections: INSP ###
INSP.GROUP.python=Python
INSP.GROUP.mako=Mako

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=错误的调用参数
INSP.cannot.appear.past.keyword.arg=无法显示过去的关键字参数或 *arg 或 **kwarg
INSP.unexpected.arg=异常参数
INSP.unexpected.arg(s)=异常参数
INSP.parameter.$0.unfilled=参数 ''{0}'' 未填
INSP.parameter(s).unfilled=参数未填
INSP.possible.callees=可能的被调用方
INSP.func.$0.lacks.first.arg=函数 ''{0}'' 缺乏位置参数
INSP.expected.dict.got.$0=预期为字典，得到的是 {0}
INSP.expected.iter.got.$0=预期为迭代，得到的是 {0}
INSP.more.args.that.pos.params=多个值解析为一个位置参数
INSP.multiple.values.resolve.to.positional.$0=多个值解析为一个位置参数 ''{0}''
INSP.cannot.analyze=无法分析此参数列表

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=第一个参数有问题的方法
INSP.must.have.first.parameter=方法必须有第一个参数，通常叫做 ''{0}''
INSP.probably.mistyped.self=你不是指 'self' 吗？
INSP.usually.named.self=方法的第一个参数通常叫做 'self'
INSP.usually.named.$0=这些方法的第一个参数通常叫做 ''{0}''
INSP.first.param.must.not.be.tuple=非静态方法的第一个参数不能是元组

# PyNestedDecoratorsInspection
INSP.NAME.nested.decorators=装饰器嵌套有问题
INSP.decorator.receives.unexpected.builtin=此装饰器不会收到所预期的可调用；内置装饰器返回特殊对象

# PyRedeclarationInspection
INSP.NAME.redeclaration=已重新声明无用法的名称
INSP.redeclared.name=已重新声明上文定义的无用法的 ''{0}''

# PyUnresolvedReferencesInspection
INSP.try.except.import.error=包含 ''except ImportError'' 的 try 块中的 ''{0}'' 也应在 except 块中定义
INSP.unused.import.statement=未使用的导入语句 <code>\#ref</code>

# PyInterpreterInspection
INSP.NAME.invalid.interpreter=配置的解释器无效

# ReturnValueFromInitInspection
INSP.NAME.init.return=返回值的 __init__ 方法
INSP.cant.return.value.from.init=无法从 __init__ 返回值

# PyUnreachableCodeInspection
INSP.NAME.unreachable.code=不可到达的代码
INSP.unreachable.code=此代码无法访问

# PyMethodFirstArgAssignmentInspection
INSP.NAME.first.arg.assign=方法的第一个参数重新赋值
INSP.first.arg.$0.assigned=方法参数 ''{0}'' 已重新赋值

# PyStringFormatInspection
INSP.NAME.str.format=字符串格式化操作出错
INSP.format.requires.no.mapping=格式无需映射
INSP.key.$0.has.no.arg=键 ''{0}'' 没有相应的参数
INSP.unexpected.type.$0=意外类型 {0}
INSP.too.few.keys=映射键太少
INSP.no.format.specifier.char=缺少格式说明符
INSP.format.requires.mapping=格式需要映射
INSP.too.many.args.for.fmt.string=格式字符串的参数太多
INSP.too.few.args.for.fmt.string=格式字符串的参数太少
INSP.incompatible.options=块 "{0}" 中的格式选项不兼容
INSP.unused.mapping = 映射键 "{0}" 未使用
INSP.unsupported.format.character=格式字符 ''{0}'' 不受支持
INSP.manual.to.auto.field.numbering=无法从手动字段规范切换到自动字段编号
INSP.auto.to.manual.field.numbering=无法从自动字段编号切换到手动字段规范

# PyMethodOverridingInspection
INSP.NAME.method.over=方法签名与被覆盖方法的签名不匹配
INSP.signature.mismatch=方法 ''{0}'' 的签名与类 ''{1}'' 中基本方法的签名不匹配

# PyInitNewSignatureInspection
INSP.NAME.new.init.signature=__new__ 和 __init__ 的签名不兼容
INSP.new.incompatible.to.init=签名不兼容 __init__
INSP.init.incompatible.to.new=签名不兼容 __new__

# PyTrailingSemicolonInspection
INSP.NAME.trailing.semicolon=语句中的尾随分号



# PyUnboundLocalVariableInspection
INSP.NAME.unbound=未绑定的局部变量
INSP.unbound.local.variable=局部变量 ''{0}'' 可在赋值前引用
INSP.unbound.nonlocal.variable=非局部变量 ''{0}'' 必须绑定在外部函数范围中
INSP.unbound.name.undefined=可以未定义名称 ''{0}''
INSP.unbound.function.too.large=函数 ''{0}'' 太大，无法分析

# PyDictCreationInspection
INSP.NAME.dict.creation=字典创建可以通过字典文字进行重写

# PyListCreationInspection
INSP.NAME.list.creation=列表创建可以通过列表文字重写

# PyExceptClausesOrderInspection
INSP.NAME.bad.except.clauses.order=except 子句顺序错误
INSP.class.$0.already.caught=已捕获异常类 ''{0}''
INSP.class.$0.superclass.$1.already.caught=已捕获异常类 ''{1}'' 的超类 ''{0}''

# PyTupleAssignmentBalanceInspection
INSP.NAME.incorrect.assignment=元组赋值 balance 不正确

# PyClassicStyleClassInspection
INSP.NAME.classic.class.usage=经典样式类用法
INSP.classic.class.usage.old.style.class=老式类
INSP.classic.class.usage.old.style.class.ancestors=老式类，因为它所继承的所有类都是老式类


# PyExceptionInheritance
INSP.NAME.exception.not.inherit=不是从标准 'Exception' 类集成异常

# PyDefaultArgumentInspection
INSP.NAME.default.argument=默认参数可变

# PyIncorrectDocstringInspection
INSP.NAME.incorrect.docstring=错误的文档字符串
INSP.missing.parameter.in.docstring=文档字符串中缺少参数 {0}
INSP.unexpected.parameter.in.docstring=文档字符串中的参数 {0} 异常

# PyMissingOrEmptyDocstringInspection
INSP.NAME.missing.or.empty.docstring=缺少文档字符串或为空
INSP.no.docstring=缺少文档字符串
INSP.empty.docstring=文档字符串为空

# PyDocstringTypesInspection
INSP.NAME.docstring.types=文档字符串中的类型与推断的类型不匹配

# PyStatementEffectInspection
INSP.NAME.statement.effect=语句无效
INSP.NAME.statement.message=语句似乎无效


# PyFromFutureImportInspection
INSP.NAME.from.future.import=from __future__ import 必须是第一条可执行语句

# PyComparisonWithNoneInspection
INSP.NAME.comparison.with.none=使用相等运算符执行了与 None 比较

# PyStringExceptionInspection
INSP.NAME.raising.string.exception=引发字符串异常

# PySuperArgumentsInspection
INSP.NAME.wrong.super.arguments=用于调用 super 的参数错误
INSP.$0.is.not.superclass.of.$1=''{0}'' 不是 ''{1}'' 的实例或子类

# PyByteLiteralInspection
INSP.NAME.byte.literal=字节文字包含字符 > 255

# PynonAsciiCharInspection
INSP.NAME.non.ascii=文件包含非 ASCII 字符

# PyMandatoryEncodingInspection
INSP.NAME.mandatory.encoding=未为文件指定编码

# PyTupleItemAssignmentInspection
INSP.NAME.tuple.item.assignment=元组项目赋值
INSP.tuples.never.assign.items=元组不支持项目赋值

# PyPropertyAccessInspection
INSP.NAME.property.access=访问属性
INSP.property.$0.cant.be.set=无法设置属性 ''{0}''
INSP.property.$0.cant.be.read=无法读取属性 ''{0}''
INSP.property.$0.cant.be.deleted=无法删除属性 ''{0}''

# PyPropertyDefinitionInspection
INSP.NAME.property.definition=属性定义
INSP.doc.param.should.be.str=doc 参数应为字符串
INSP.strange.arg.want.callable=奇怪参数；预期为可调用
INSP.func.property.name.mismatch=函数和装饰器的名称不匹配；未创建属性访问器
INSP.getter.return.smth=Getter 应返回或生成某些内容
INSP.setter.should.not.return=setter 不应返回值
INSP.deleter.should.not.return=删除程序不应返回值
INSP.getter.signature.advice=Getter 签名应为 (self)
INSP.setter.signature.advice=Setter 签名应为 (self, value)
INSP.deleter.signature.advice=删除程序签名应为 (self)
INSP.accessor.first.param.is.$0=访问器的第一个参数通常称为 ''{0}''

# PyCallByClassInspection
INSP.NAME.different.class.call=使用不同类的实例按类调用方法
INSP.instance.of.$0.excpected=预期为 {0} 的实例，而不是类本身
INSP.passing.$0.instead.of.$1=传递 {0} 而不是 {1}。这是有意为之吗？

# PyBroadExceptionInspection
INSP.NAME.too.broad.exception.clauses=异常子句太宽泛

# PyDictDuplicateKeysInspection
INSP.NAME.duplicate.keys=字典包含重复键


# PyAugmentAssignmentInspection
INSP.NAME.augment.assignment=赋值可以替换为增强赋值

# PyChainedComparsonsInspection
INSP.NAME.chained.comparisons=可以简化链式比较

# PyAttributeOutsideInitInspection
INSP.NAME.attribute.outside.init=实例属性在 __init__ 外部定义
INSP.attribute.$0.outside.init=实例属性 {0} 在 __init__ 外部定义

# PyProtectedMemberInspection
INSP.protected.member.$0.access=访问类的 protected 成员 {0}
INSP.protected.member.$0.access.module=访问模块的 protected 成员 {0}

# PyArgumentEqualDefaultInspection
INSP.NAME.argument.equal.default=传递给函数的实参等于默认参数值
INSP.argument.equals.to.default=实参等于默认参数值

# PyAbstractClassInspection
INSP.NAME.abstract.class=类必须实现所有抽象方法
INSP.NAME.abstract.class.$0.must.implement=类 {0} 必须实现所有抽象方法

# PyOldStyleClassesInspection
INSP.NAME.oldstyle.class=老式类包含新式类功能
INSP.oldstyle.class.slots=老式类包含 __slots__ 定义
INSP.oldstyle.class.getattribute=老式类包含 __getattribute__ 定义
INSP.oldstyle.class.super=老式类包含对 super 方法的调用

# PyCompatibilityInspection
INSP.NAME.compatibility=代码兼容性检查

# PyUnnecessaryBackslashInspection
INSP.NAME.unnecessary.backslash=不必要的反斜杠

# PySingleQuotedDocstringInspection
INSP.NAME.single.quoted.docstring=单引号引用的文档字符串
INSP.message.single.quoted.docstring=应对文档字符串使用三-双引号引用的字符串。

# PyMissingConstructorInspection
INSP.NAME.missing.super.constructor=缺少对超类 __init__ 的调用
INSP.missing.super.constructor.message=缺少对超类 __init__ 的调用

# PySetFunctionToLiteralInspection
INSP.NAME.set.function.to.literal=函数调用可以替换为集合文字

# PyDecoratorInspection
INSP.NAME.decorator.outside.class=类外部方法中的特定于类的装饰器

# PyPackageRequirementsInspection
INSP.NAME.requirements=包要求

# PyMethodMayBeStaticInspection
INSP.NAME.method.may.be.static=可以是静态方法
INSP.method.may.be.static=方法 <code>\#ref</code> 可以是 'static'

# PyClassHasNoInitInspection
INSP.NAME.class.has.no.init=类没有 __init__ 方法
INSP.class.has.no.init=类没有 __init__ 方法
INSP.parent.$0.has.no.init=父级 ''{0}'' 没有 __init__ 方法

#PyNoneFunctionAssignmentInspection
INSP.NAME.none.function.assignment=分配不返回任何内容  (None) 的函数调用
INSP.none.function.assignment=函数 ''{0}'' 不返回任何内容

#PyGlobalUndefinedInspection
INSP.NAME.global.undefined=全局变量在模块级别未定义
INSP.NAME.global.$0.undefined=全局变量 ''{0}'' 在模块级别未定义

#PyAssignmentToLoopOrWithParameterInspection
INSP.NAME.assignment.to.loop.or.with.parameter.display.name=赋值给 'for' 循环或 'with' 语句参数
INSP.NAME.assignment.to.loop.or.with.parameter.display.message=已在上面的 ''for'' 循环或 ''with'' 语句中声明变量 ''{0}''

#PyAsyncCallInspection
INSP.NAME.coroutine.is.not.awaited=未等待协同程序 ''{0}''

# PyTestParametrizedInspection
INSP.NAME.pytest-parametrized=检查由 pytest 参数化装饰的函数是否有正确的参数

# PyHighlightingAnnotator
INSP.python.trailing.suffix.not.support=Python 不支持尾随 ''{0}''

INSP.abstract.class.set.as.metaclass=设置 ''{0}'' 为元类
INSP.abstract.class.add.to.superclasses=添加 ''{0}'' 至超类
INSP.compatibility.this.syntax.available.only.since.py3=此语法仅在 py3 以上的版本中可用
INSP.compatibility.check.for.compatibility.with.python.versions=检查与 python 版本的兼容性：
INSP.docstring.types.fix.docstring=修复文档字符串
INSP.docstring.types.change.type=将 {0} 类型从 {1} 更改为 {2}
INSP.interpreter.configure.python.interpreter=配置 Python 解释器
INSP.interpreter.interpreter.settings=解释器设置
INSP.interpreter.use.interpreter=使用 {0}
INSP.interpreter.use.suggested.interpreter=使用建议的解释器
INSP.mandatory.encoding.encoding.comment.format=编码注释格式：
INSP.mandatory.encoding.select.default.encoding=选择默认编码： 
INSP.mandatory.encoding.no.encoding.specified.for.file=未为文件指定编码
INSP.method.parameters.metaclass.method.first.argument.name=元类方法第一个参数的名称
INSP.missing.type.hints.add.type.hints=添加类型提示
INSP.missing.type.hints.add.type.hints.for=为 ''{0}'' 添加类型提示
INSP.missing.type.hints.only.when.types.are.known.collected.from.run.time.or.inferred=仅当类型已知时（从运行时收集或推断）
form.debugger.save.call.signatures=保存调用签名
INSP.package.requirements.requirements.have.been.ignored=已忽略需求
INSP.package.requirements.requirement.has.been.ignored=已忽略 ''{0}''
INSP.package.requirements.add.import=添加导入
INSP.package.requirements.administrator.privileges.required=需要管理员权限
INSP.package.requirements.administrator.privileges.required.description=将包安装到 ''{0}'' 需要具备管理员权限。\n\
\n\
将每个项目的虚拟环境配置为项目解释器，\n\
以避免将包安装到文件系统的受保护区域。
INSP.package.requirements.administrator.privileges.required.button.configure=配置
INSP.package.requirements.administrator.privileges.required.button.install.anyway=仍要安装
INSP.pep8.ignore.base.class=忽略基类
INSP.pep8.ignore.method.names.for.descendants.of.class=忽略类后代的方法名称
INSP.protected.member.ignore.annotations=忽略注解
INSP.protected.member.ignore.test.functions=忽略测试函数
INSP.shadowing.builtins.ignore.shadowed.built.in.name=忽略有阴影的内置名称

INSP.stub.packages.compatibility.ignore=忽略 ''{0}'' 兼容性
INSP.arguments.not.declared.but.provided.by.decorator=以下参数未声明，而是由修饰器提供：{0}

INSP.abstract.class=类必须实现所有抽象方法
INSP.assigning.function.call.that.doesnt.return.anything=分配不返回任何内容的函数调用
INSP.assignment.to.loop.or.with.parameter=赋值给 'for' 循环或 'with' 语句参数
INSP.async.call=未等待协同程序
INSP.attribute.outside.init=实例属性在 __init__ 外部定义
INSP.calling.non.callable=尝试调用不可调用的对象
INSP.dataclass.definition.and.usages=数据类定义和用法
INSP.deprecated.function.class.or.module=已弃用函数、类或模块
INSP.dunder.slots=类中 __slots__ 的定义
INSP.final.classes.methods.and.variables=final 类、方法和变量
INSP.global.undefined=模块级别未定义全局变量
INSP.inconsistent.indentation=缩进不一致
INSP.mandatory.encoding=未为文件指定编码
INSP.missing.type.hints=缺少函数定义的类型提示
INSP.named.tuple=Namedtuple 定义
INSP.overloads.in.regular.python.files=常规 Python 文件中的重载
INSP.pep8.naming=PEP 8 命名惯例违规
INSP.pep8.coding.style.violation=PEP 8 编码样式违规
INSP.protected.member=访问类或模块的 protected 成员
INSP.protocol.definition.and.usages=协议定义和用法
INSP.shadowing.builtins=隐藏内置
INSP.shadowing.names=正在从外部范围隐藏名称
INSP.stub.packages.compatibility=存根包兼容性检查
INSP.stub.packages=存根包广播程序
INSP.type.checker=类型检查器
INSP.type.hints=类型提示定义和用法
INSP.typed.dict=TypedDict 定义和用法

# Refactoring
refactoring.will.not.be.accessible=成员，您在试图根据 ''{0}'' 移动，进行重构后将无法访问此对象
refactoring.error.file.exists=文件"{0}" 已存在
refactoring.error.directory.exists=目录 "{0}" 已存在

# introduce
refactoring.introduce.name.error=错误的名称
refactoring.introduce.selection.error=使用选定的元素不能执行重构

# introduce variable
refactoring.introduce.variable.dialog.title=提取变量
refactoring.introduce.variable.scope.error=名称与现有变量或参数冲突

# introduce constant
refactoring.introduce.constant.dialog.title=提取常量
refactoring.introduce.constant.scope.error=已在范围中声明名称

# introduce parameter
refactoring.introduce.parameter.dialog.title=提取字段

# pull up
refactoring.pull.up.dialog.title=向上拉取成员至
refactoring.pull.up.dialog.move.members.to.class=将成员移至类
refactoring.pull.up.dialog.members.to.be.moved=将移动以下成员
refactoring.pull.up.error.cannot.perform.refactoring.using.selected.elements=无法使用所选元素执行向上拉取成员
refactoring.pull.up.error.cannot.perform.refactoring.not.inside.class=无法执行向上拉取成员：不在此类中
refactoring.pull.up.error.cannot.perform.refactoring.no.base.classes=类 {0} 没有超级类，或者所有超类都不能用于重构

# push down
refactoring.push.down.dialog.title=从中向下推送成员
refactoring.push.down.error.cannot.perform.refactoring.using.selected.elements=无法使用所选元素执行向下推送成员
refactoring.push.down.error.cannot.perform.refactoring.not.inside.class=无法执行向下拉取成员：不在此类中

# inline
refactoring.inline.local.multiassignment=定义在链式赋值中

# inline function
refactoring.inline.function.title=内联函数
refactoring.inline.this.only=仅内联此调用并保留声明
refactoring.inline.function=内联函数 {0}
refactoring.inline.method=内联方法 {0}
refactoring.inline.all.keep.declaration=内联所有调用并保留声明
refactoring.inline.all.remove.declaration=内联所有调用并移除声明
refactoring.inline.function.is.decorator=函数 {0} 用作修饰器，无法内联。不会移除函数定义
refactoring.inline.function.is.reference=函数 {0} 用作引用，无法内联。不会移除函数定义
refactoring.inline.function.uses.unpacking=函数 {0} 用作参数解压缩，无法内联。不会移除函数定义
refactoring.inline.function.generator=无法内联生成器
refactoring.inline.function.async=无法内联异步函数
refactoring.inline.function.constructor=无法内联构造函数调用
refactoring.inline.function.builtin=无法内联内置函数
refactoring.inline.function.special.method=无法内联特殊方法
refactoring.inline.function.skeleton.only=无法从二进制模块内联函数
refactoring.inline.function.decorator=无法内联包含装饰器的函数
refactoring.inline.function.self.referrent=无法内联引用自身的函数
refactoring.inline.function.star=无法内联包含 * 参数的函数
refactoring.inline.function.overrides.method=无法内联覆盖其他方法的方法
refactoring.inline.function.is.overridden=无法内联被覆盖的方法
refactoring.inline.function.global=无法内联包含全局变量的函数
refactoring.inline.function.nonlocal=无法内联包含非局部变量的函数
refactoring.inline.function.nested=无法内联包含其他函数声明的函数
refactoring.inline.function.interrupts.flow=无法内联中断控制流的函数

# extract method
refactoring.extract.method=提取方法
refactoring.extract.method.error.bad.selection=无法使用所选元素执行提取方法
refactoring.extract.method.error.name.clash=方法名称与现有名称冲突
refactoring.extract.method.error.returns=无法提取代码片段内包含返回指令的方法
refactoring.extract.method.error.local.variable.modifications=无法从代码片段内包含局部变量修改的表达式执行重构
refactoring.extract.method.error.local.variable.modifications.and.returns=无法从代码片段内包含局部变量修改和返回指令的表达式执行重构
refactoring.extract.method.error.empty.fragment=无法从空代码片段执行重构

refactoring.extract.method.error.class.level=无法在类级别执行重构

# extract superclass
refactoring.extract.super.target.path.outside.roots=目标目录在项目外部。必须在内容根内
refactoring.extract.super.target.class.already.exists=此模块中已存在类 ''{0}''
refactoring.extract.super.name.0.must.be.ident=名称 ''{0}'' 无效。必须为有效的 Python 标识符
refactoring.extract.super.class.no.members.allowed=无法提取任何成员

# move
refactoring.move.choose.destination.file.title=选择目标文件
refactoring.move.error.destination.file.contains.class.$0=目标文件已包含名称为 ''{0}'' 的类
refactoring.move.error.destination.file.contains.function.$0=目标文件已包含名称为 ''{0}'' 的函数
refactoring.move.error.destination.file.contains.global.variable.$0=目标文件已包含名称为 ''{0}'' 的全局变量
refactoring.move.error.cannot.use.module.name.$0=无法在导入中使用模块名称 ''{0}''

# move module members (top-level)
refactoring.move.module.members=移动模块成员
refactoring.move.module.members.dialog.title=移动模块成员
refactoring.move.module.members.dialog.table.title=批量移动 (&M)
refactoring.move.module.members.dialog.description.class=移动类 {0}
refactoring.move.module.members.dialog.description.function=移动函数 {0}
refactoring.move.module.members.dialog.description.variable=移动全局变量 {0}
refactoring.move.module.members.dialog.description.selection=移动选择的元素
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=无法将元素放入非 Python 文件中
refactoring.move.module.members.error.selection=使用选定的元素不能执行重构

# Make function top-level
refactoring.make.method.top.level.dialog.title=使之为顶层方法
refactoring.make.method.top.level.dialog.description=将方法 {0} 移至顶层

refactoring.make.local.function.top.level.dialog.title=使之为顶层局部函数
refactoring.make.local.function.top.level.dialog.description=将局部函数 {0} 移至顶层

refactoring.make.function.top.level.error.nonlocal.writes=无法移动包含非局部写入的函数
refactoring.make.function.top.level.error.self.reads=无法从外部范围移动包含 "self" 参数用法的函数
refactoring.make.function.top.level.error.outer.scope.reads=无法从外部范围移动引用名称的方法
refactoring.make.function.top.level.error.private.attributes=无法移动引用 private 实例属性的方法
refactoring.make.function.top.level.error.attribute.writes=无法移动写入实例属性的方法
refactoring.make.function.top.level.error.method.calls=无法移动调用同一类其他方法的方法
refactoring.make.function.top.level.error.special.usage.of.self=无法移动包含 "self" 参数特殊用法的方法



#change signature
refactoring.change.signature.usage.view.declarations.header=要重构的函数
refactoring.change.signature.dialog.validation.name.defined=范围中已定义名称
refactoring.change.signature.dialog.validation.function.name=函数名称不正确
refactoring.change.signature.dialog.validation.parameter.name=参数名称不正确
refactoring.change.signature.dialog.validation.multiple.star=不允许多个 * 参数
refactoring.change.signature.dialog.validation.multiple.double.star=不允许多个 ** 参数
refactoring.change.signature.dialog.validation.default.missing=缺少默认值
refactoring.change.signature.dialog.validation.parameter.missing=缺少参数名称
refactoring.change.signature.dialog.default.value.checkbox=在签名中使用默认值：
refactoring.change.signature.dialog.name.label=名称\:
refactoring.change.signature.find.usages.of.base.class={1} 的方法 {0}\n\
重写了 {2} 的方法。\n\
要重构该基方法吗？
refactoring.change.signature.error.wrong.caret.position.method.name=脱字符号应置于要重构的方法的名称处
refactoring.change.signature.error.lambda.call=脱字符号位于 lambda 调用
refactoring.change.signature.error.tuple.parameters=函数包含元组参数
refactoring.change.signature.error.not.under.source.root=函数不在源根下

# convert module to package
refactoring.convert.module.to.package.title=将模块转换为包

# convert module
refactoring.convert.package.to.module.title=将模块转换为包
refactoring.convert.package.to.module.error.not.empty.package=包 "{0}" 非空

refactoring.occurrences.count={0}（{1} 个匹配项）
refactoring.introduce.field.setup.method=setUp() 方法
refactoring.introduce.field.cannot.be.used.in.static.methods=静态方法中不能使用引入字段重构
refactoring.introduce.field.not.in.class=无法引入字段：不在类中
refactoring.rename.containing.file.with.the.following.name.to=将具有以下名称的包含文件重命名为\:
refactoring.rename.containing.file.title=重命名包含的文件
refactoring.rename.containing.file=重命名包含的文件
refactoring.rename.parameter.in.hierarchy.to=以层次结构重命名参数\:
refactoring.rename.parameters.title=重命名参数
refactoring.rename.parameters.in.hierarchy=重命名层次结构中的参数
refactoring.rename=重命名
refactoring.rename.not.valid.identifier=名称 ''{0}'' 不是有效的 Python 标识符。无法更新 ''{1}'' 中的导入语句
refactoring.rename.inheritor.classes.with.the.following.names.to=将具有以下名称的继承者类重命名为：
refactoring.rename.inheritors.title=重命名继承者
refactoring.rename.inheritors=重命名继承者

### Annotators ###
ANN.default.except.must.be.last=默认 'except\:' 必须为最后一个

ANN.$0.both.global.and.param=名称 ''{0}'' 同时用作参数和全局变量

ANN.assignment.to.keyword=关键字赋值
ANN.cannot.assign.to.debug=无法分配给 __debug__
ANN.unparenthesized.assignment.expressions.are.prohibited.0=非父级赋值表达式禁止 {0}
ANN.assignment.expressions.within.a.comprehension.cannot.be.used.in.a.class.body=推导式中的赋值表达式不能在类主体中使用
ANN.ignore.errors.like.this=忽略这样的错误
ANN.function.cannot.be.async=函数 "{0}" 不能是异步函数
ANN.python.does.not.support.yield.from.inside.async.functions=Python 不支持在异步函数中使用 'yield from'
ANN.yield.outside.of.function='yield' 在函数外部
ANN.non.empty.return.inside.asynchronous.generator=异步生成器内部的 'return' 非空
ANN.return.outside.of.function='return' 在函数外部
ANN.can.t.use.starred.expression.here=这里不能使用星号表达式
ANN.illegal.target.for.variable.annotation=变量注解目标非法
ANN.variable.annotation.cannot.be.combined.with.tuple.unpacking=变量注解不能与元组解压缩相结合
ANN.variable.annotation.cannot.be.used.in.assignment.with.multiple.targets=变量注解不能用于具有多个目标的赋值

python.run.select.script=选择脚本
python.run.configuration=Python 运行配置
python.run.python=Python

testing.form.inspect.only.subclasses.of.unittest.testcase=仅检查 unittest.TestCase 的子类

runcfg.tests.cant_rerun=无法重新运行测试，因为无法解析测试 ID。尝试删除运行配置，并通过右键单击创建新配置。
runcfg.tests.empty_suite=空套件

### doctest run conf
runcfg.doctest.display_name=Doctest
runcfg.doctest.description=Python doctest 运行配置

### nosetests run conf
runcfg.nosetests.display_name=Nosetest
runcfg.nosetests.description=Python nosetest 运行配置

### nosetests run configuration custom options
python.testing.nose.custom.options.regex.pattern=正则表达式模式\:
python.testing.nose.custom.options.keywords=关键字\:
python.testing.nose.custom.options.parameters=参数\:
python.testing.nose.custom.options.additional.arguments=其他参数\:

### pytest run conf
runcfg.pytest.display_name=pytest
runcfg.pytest.description=pytest 运行配置
runcfg.pytest.target=&目标\:
runcfg.pytest.parameters=&选项\:
runcfg.pytest.keywords=&关键字\:

### trial run conf
runcfg.trial.display_name=Twisted Trial

### test run configuration
runcfg.test.display_name=Python 测试
runcfg.test.description=PyCharm 支持 Python 框架

### tox
runcfg.tox.runner=tox 运行程序
runcfg.tox=tox

### unittest run configuration
runcfg.unittest.display_name=Unittest
runcfg.unittest.description=Python unittest 运行配置
runcfg.unittest.no_script_name=请指定脚本名称
runcfg.unittest.no_module_name=请指定模块限定名称
runcfg.unittest.no_class_name=请指定类名
runcfg.unittest.no_method_name=请指定方法名称
runcfg.unittest.no_folder_name=请指定包含测试的文件夹
runcfg.unittest.incorrect.script=测试脚本名称应以 "test" 前缀开头
runcfg.unittest.dlg.tests_group_title=测试\:
runcfg.unittest.dlg.test_script_label=脚本\:
runcfg.unittest.dlg.class_label=类\:
runcfg.unittest.dlg.method_label=方法\:
runcfg.unittest.dlg.function_label=函数\:
runcfg.unittest.dlg.folder_path=文件夹：
runcfg.unittest.dlg.test_type_title=测试\:
runcfg.unittest.dlg.all_in_folder_title=全部在文件夹中
runcfg.unittest.dlg.all_in_script_title=脚本
runcfg.unittest.dlg.test_class_title=类
runcfg.unittest.dlg.test_method_title=方法
runcfg.unittest.dlg.folder_title=测试文件夹：
runcfg.unittest.no_valid_sdk=请选择有效的 Python 解释器
runcfg.unittest.no_module_sdk=请选择包含有效 Python SDK 的模块
runcfg.unittest.no_sdk=请指定 Python SDK
runcfg.unittest.dlg.select.folder.path=选择文件夹路径：
runcfg.unittest.dlg.select.script.path=选择脚本路径：
runcfg.unittest.dlg.interpreter_options_title=解释器选项：
runcfg.unittest.dlg.messages.working.dir=工作目录\:
runcfg.labels.script_parameters=&参数\:
runcfg.labels.script=&脚本\:
runcfg.labels.environment_variables=环境变量 (&E)：
runcfg.labels.interpreter=使用指定的解释器 (&U)：
runcfg.labels.use.sdk.of.module=使用模块 SDK：
runcfg.labels.interpreter_options=解释器选项 (&O)：
runcfg.labels.working_directory=工作目录 (&W)\:
runcfg.captions.script_parameters_dialog=输入脚本参数
runcfg.captions.interpreter_options_dialog=输入解释器选项
runcfg.labels.python.interpreter=Python 解释器 (&P)：
runcfg.labels.add.content.roots.to.pythonpath=将内容根添加到 PYTHONPATH
runcfg.labels.add.source.roots.to.pythonpath=将源根添加到 PYTHONPATH
runcfg.labels.path.mappings=路径映射
runcfg.labels.project=项目 (&J)：
runcfg.labels.script.path=脚本路径
runcfg.labels.module.name=模块名称
runcfg.labels.custom.name=自定义
runcfg.labels.execution=执行
sdk.error.invalid.interpreter.name.$0=Python 解释器名称 ''{0}'' 无效！
sdk.select.path=选择 Python 解释器
runcfg.unittest.dlg.pattern=模式\:

runcfg.testing.no.test.framework=在选定的解释器中找不到 {0} 运行程序

# Consoles messages
python.console=Python控制台
python.console.history.root=Python 控制台
python.console.run.anything.provider=运行 Python 控制台

# UI messages
MSG.title.bad.sdk=无效的 Python SDK
MSG.cant.setup.sdk.$0=无法\n\
在 {0} 设置 python SDK。\n\
此 SDK 似乎无效。


#Buildout
buildout=Buildout
buildout.unresolved.part.inspection=Buildout 配置未解析的元件检查
buildout.unresolved.part.inspection.msg=未解析的元件引用
buildout.configurable.enable.buildout.support.checkbox.text=启用 buildout 支持 (&E)
runcfg.unittest.dlg.test_function_title=函数
runcfg.unittest.dlg.keywords=关键字\:
run.configuration.remote.debug.name=Python 远程调试
run.configuration.remote.debug.visible.name=Python 调试服务器
run.configuration.type.description=启动服务器进行远程调试
run.configuration.show.command.line.action.name=显示 Python 提示

unable.to.stop=无法停止当前正在运行的进程。先手动终止此进程。

#Debug

debug.popup.title.step.into.function=单步进入函数

debug.notification.group=Python调试器
debug.notification.title.connection.failed=连接 Python 调试器失败

remote.debug.info=信息
remote.debug.server.hint=启动此调试配置以启动调试服务器。
remote.debug.server.hint1.5=更新脚本：
remote.debug.server.hint2=1. 将 pydevd-pycharm.egg 从 PyCharm 安装目录添加到 Python 路径或执行：
remote.debug.server.hint3=pip 安装 pydevd-pycharm
remote.debug.server.hint4=2. 添加以下命令以连接至调试服务器：
remote.debug.settings=设置
remote.debug.remote.host=远程主机
remote.debug.port=端口
remote.debug.use.path.mapping=使用路径映射
remote.debug.remote.root.folder=远程路径前缀：
remote.debug.local.root.folder=本地路径前缀：
remote.debug.local.host=IDE 主机名：
remote.debug.redirect.output=将输出重定向到控制台
remote.debug.suspend.on.connect=连接后挂起

python.sdk.getting.remote.interpreter.version=正在获取远程解释器版本
python.sdk.directory.macro.description=此目录包含为项目选择的 Python 解释器
python.sdk.run.wait=稍候...
python.sdk.scanning.installed.packages=正在扫描已安装的包...
python.sdk.updating.skeletons=正在更新框架...
python.sdk.updating.python.paths=正在更新 Python 路径
python.sdk.unpacking.pre.generated.skeletons=正在解压缩预生成的框架...
python.sdk.popup.title=项目解释器
python.sdk.popup.interpreter.settings=解释器设置...
python.sdk.popup.add.interpreter=添加解释器...
python.sdk.switch.to=切换到 {0}
python.sdk.installing=正在安装 {0}
python.sdk.downloading=下载中{0}
python.sdk.running=正在运行 {0}
python.sdk.installing.windows.warning=Windows 可能需要您批准后才能安装 Python。请检查任务栏。
python.sdk.select.conda.path.title=选择 Conda 可执行文件路径
python.sdk.conda.path=Conda 可执行文件：
python.sdk.select.location.for.conda.title=选择 Conda 环境的位置
python.sdk.creating.conda.environment.title=正在创建 Conda 环境
python.sdk.select.location.for.virtualenv.title=选择虚拟环境的位置
python.sdk.creating.virtualenv.title=正在创建虚拟环境
python.sdk.add.python.interpreter.title=添加 Python 解释器
python.sdk.python.interpreter.title.0=项目解释器\: {0}
python.sdk.new.environment.kind=新 {0} 环境
python.sdk.next=下一个
python.sdk.previous=上一个
python.sdk.finish=完成
python.sdk.interpreter.field.is.empty=解释器字段为空
python.sdk.setting.up.pipenv.title=正在设置 Pipenv 环境
python.sdk.install.requirements.from.pipenv.lock=Pipfile.lock 中的安装要求
python.sdk.pipenv.executable.not.found=找不到 Pipenv 可执行文件
python.sdk.pipenv.executable=Pipenv 可执行文件：
python.sdk.pipenv.associated.object=已关联 {0}：
python.sdk.file.not.found=找不到文件 {0}
python.sdk.cannot.execute=无法执行 {0}
python.sdk.pipenv.has.been.selected=已添加 Pipenv 解释器，选择解释器列表中的 ''{0}''
python.sdk.there.is.no.interpreter=无解释器
python.sdk.no.interpreter.configured.warning=未为此项目配置 Python 解释器
python.sdk.no.interpreter.configured.owner=未为 {0} 配置 Python 解释器
python.sdk.no.interpreter.selection=未选择 Python 解释器
python.sdk.choose.valid.interpreter=选择有效的 Python 解释器
python.sdk.common.options.environment=环境
python.sdk.rendering.project.default=项目默认设置
python.sdk.rendering.project.default.0=项目默认值 ({0})
python.sdk.failed.to.install.title=无法安装 {0}
python.sdk.installation.has.been.cancelled.title={0} 安装已被取消
python.sdk.failed.to.create.interpreter.title=无法创建解释器

# SDK / skeletons
sdk.some.skeletons.failed=无法生成某些框架
sdk.error.dialog.problems=框架生成问题
sdk.gen.cleaning.up=正在清理框架...
sdk.gen.launching.generator=正在启动框架生成器...
sdk.gen.reloading=正在重新加载生成的框架...
sdk.gen.unpacking.prebuilt=正在解压缩预建框架...
sdk.gen.updating.interpreter=正在更新 Python 解释器
sdk.scanning.installed.packages=正在扫描已安装的包
sdk.gen.stubs.for.binary.modules=生成二进制模块 {0} 的存根
sdk.gen.failed.notification.title=无法刷新远程解释器的框架

# Active SDK configurable and related dialogs
active.sdk.dialog.show.all.item=全部显示...
active.sdk.dialog.project.interpreter=项目解释器：
active.sdk.dialog.project.interpreter.path.mappings=路径映射：
active.sdk.dialog.project.interpreter.path.mappings.default.project.error=打开或创建项目以配置映射

sdk.details.step.add=添加...
sdk.details.step.create.virtual.env=创建 VirtualEnv
sdk.details.step.create.conda.env=创建 Conda 环境
sdk.details.step.show.all=全部显示...

sdk.details.dialog.title=项目解释器
sdk.details.dialog.hide.all.virtual.envs=隐藏与其他项目关联的虚拟环境
sdk.details.dialog.show.interpreter.paths=显示所选解释器的路径
sdk.details.dialog.error.duplicate.name=请为解释器指定唯一的名称

sdk.edit.dialog.title=编辑 Python 解释器
sdk.edit.dialog.associate.virtual.env.with.path=关联此虚拟环境与 {0}
sdk.edit.dialog.associate.virtual.env.current.project=关联此环境与当前项目
sdk.edit.dialog.specify.interpreter.path=指定解释器路径

sdk.paths.dialog.title=解释器路径
sdk.paths.dialog.reload.paths=重新加载路径列表
sdk.paths.dialog.added.by.user.suffix=（用户已添加）
sdk.paths.dialog.removed.by.user.suffix=（用户已移除）

sdk.create.venv.dialog.creating.venv=正在创建虚拟环境
sdk.create.venv.dialog.make.available.to.all.projects=可用于所有项目
sdk.create.venv.dialog.select.venv.location=选择虚拟环境的位置
sdk.create.venv.dialog.error.not.empty.directory=目录不为空
sdk.create.venv.dialog.error.empty.venv.name=VirtualEnv 名称不能为空
sdk.create.venv.dialog.error.empty.venv.location=目标目录路径不能为空
sdk.create.venv.dialog.error.invalid.directory.name=无效目录名称
sdk.create.venv.dialog.error.failed.to.create.venv=创建虚拟环境失败

sdk.create.venv.dialog.title=创建虚拟环境
sdk.create.venv.dialog.label.name=名称\:
sdk.create.venv.dialog.label.location=位置\:
sdk.create.venv.dialog.label.base.interpreter=基本解释器：
sdk.create.venv.dialog.label.inherit.global.site.packages=继承全局站点包
sdk.create.venv.dialog.error.no.base.interpreter=选择基本解释器

sdk.create.venv.conda.dialog.title=创建 Conda 环境
sdk.create.venv.conda.dialog.error.no.python.version=选择 python 版本
sdk.create.venv.conda.dialog.label.location=位置\:
sdk.create.venv.conda.dialog.label.python.version=Python 版本：

# remote interpreters
remote.interpreter.add.title=添加远程解释器
remote.interpreter.configure.title=配置远程 Python 解释器
remote.interpreter.configure.path.title=选择 Python 解释器
remote.interpreter.configure.temp.files.path.title=为 PyCharm 帮助程序选择文件夹
remote.interpreter.default.interpreter.path=/usr/bin/python
remote.interpreter.docker.default.interpreter.path=python
remote.interpreter.unspecified.interpreter.path=指定 Python 解释器路径
remote.interpreter.unspecified.temp.files.path=为 PyCharm 帮助程序指定路径
remote.interpreter.configure.path.label=Python 解释器路径：
remote.interpreter.configure.temp.files.path.label=PyCharm 帮助程序路径：
remote.interpreter.error.plugin.missing=缺少远程主机访问插件。请在 {0} 中启用此插件。
remote.interpreter.configure.ssh.run_as_root_via_sudo.checkbox=使用此解释器通过 sudo 以根权限执行代码
remote.interpreter.configure.ssh.run_as_root_via_sudo.help=仅在通过 SSH 连接启动远程解释器时才调用 Sudo。这些文件将通过用户权限被复制到远程服务器。
remote.interpreter.unsupported.python.sdk.type=不受支持的 Python SDK 类型
remote.interpreter.support.is.not.available={0} 支持不可用。\n\
请检查相应插件。
remote.interpreter.remote.server.permissions=无法浏览远程服务器。请确保您具备权限。

# CommandLine
commandLine.inspection.name=命令行检查
commandLine.inspection.badCommand=命令错误或未知。确保此命令真正存在。
commandLine.inspection.badOption=选项错误或未知。确保此选项真正存在。
commandLine.inspection.badArgument=参数不能具有此值。使用自动补全检查可能值的列表。
commandLine.inspection.excessArgument=参数过多或此处无法使用参数
# What to display if argument is available here, but no name provided
commandLine.argumentHint.defaultName=参数
# What to display of user entered junk
commandLine.commandNotFound={0}：找不到命令

# Window with actions
# "X" button title
windowWithActions.closeWindow=关闭窗口
# "Stop" button title
windowWithActions.stopProcess=停止当前运行的进程

formatter.imports.panel.title=导入
formatter.imports.panel.optimize.imports=优化导入
formatter.imports.panel.sort.imports=对导入语句排序
formatter.imports.panel.sort.names.in.from.imports=对 "from" 导入中的导入名称排序
formatter.imports.panel.from.imports.structure.title="from" 导入结构
formatter.imports.panel.from.imports.leave.as.is=保持原样
formatter.imports.panel.from.imports.join.with.same.source=使用相同的源联接导入
formatter.imports.panel.from.imports.always.split=始终拆分导入
formatter.imports.panel.sort.by.type=在组中分别对 plain 导入和 "from" 导入进行排序
formatter.imports.panel.sort.case.insensitively=不区分大小写排序

formatter.panel.dict.alignment.label=字典对齐：
formatter.panel.add.trailing.line.feed=在文件末尾添加换行

formatter.panel.use.continuation.indent.for.title=为此内容使用继续缩进
formatter.panel.use.continuation.indent.for.arguments=方法调用参数
formatter.panel.use.continuation.indent.for.collection.literals=集合和推导

formatter.left.bracket = 左中括号
formatter.around.eq.in.named.parameter = 在命名参数中的 \= 周围 
formatter.around.eq.in.keyword.argument = 在关键字参数中 \= 的周围
formatter.braces = 大括号
formatter.before.backslash = 之前 '\'
formatter.before.hash = 之前 '\#'
formatter.after.hash = 之后 '\#'
formatter.around.top.level.imports = 在顶层导入后：
formatter.after.local.imports=在本地导入后面：
formatter.before.first.method=在第一个方法前面：
formatter.around.top.level.classes.and.function=围绕顶层类和函数：
formatter.around.multiplicative.operators=乘法运算符 (*, @, /, %)
formatter.around.power.operator=幂运算符 (**)
formatter.single.clause.statements=单子句语句
formatter.multi.clause.statements=多子句语句
formatter.force.new.line.after.colon=在冒号后强制使用新行
formatter.align.when.multiline=多行时对齐
formatter.collections.and.comprehensions=集合和推导
formatter.from.import.statements="From" 导入语句
formatter.from.import.statements.force.parentheses.if.multiline=如有多行，强制使用括号
formatter.from.import.statements.force.comma.if.multline=如有多行，强制使用尾随逗号
formatter.dictionary.literals=字典文字
formatter.hang.closing.brackets=挂起右中括号

smartKeys.insert.backslash.in.statement.on.enter=在语句内按 Enter 时插入反斜杠
smartKeys.insert.self.in.method=定义方法时插入 'self'
smartKeys.insert.type.placeholder.in.docstring.stub=在文档注释存根中插入类型占位符

show.expression.type.no.expression.found=未找到表达式
runcfg.labels.module=模块\:
remote.interpreter.wsl.default.interpreter.path=/usr/bin/python
remote.interpreter.failed.to.obtain.credentials=无法获取 Python SDK {0} 的连接凭据

action.SetNextStatement.text=跳转到光标(&J)
action.SetNextStatement.description=跳转到脱字符号所在的行
action.StepIntoMyCode.text=单步执行我的代码
action.StepIntoMyCode.description=跳到已执行的下一行，并忽略库
action.PyConvertPackageToModuleAction.text=转换为 Python 模块
action.PyConvertPackageToModuleAction.description=创建同名模块，并将 __init__.py 的内容移至该模块
action.PyConvertModuleToPackage.text=转换为 Python 包
action.PyConvertModuleToPackage.description=创建同名的包，并将模块内容移至其 __init__.py
action.PyDebugger.ViewAsGroup.text=作为...查看
action.PyDebugger.ViewArray.text=作为数组查看
action.PythonGenerateDictionaries.text=生成 Python 拼写检查器字典
group.PyPackagingMenu.text=打包
action.CleanPyc.text=清除 Python 编译文件
action.CleanPyc.description=删除所选目录及其子目录中已编译的字节码文件
action.PySyncPythonRequirements.text=同步 Python 要求...
action.PySyncPythonRequirements.description=同步 Python 要求文件与项目中使用的包
action.CompuleQrc.text=编译 .qrc 文件
action.NewPythonPackage.text=Python 包
action.NewPythonPackage.description=在其中创建新目录和 __init__.py
action.PyConsoleRenameAction.text=重命名控制台
action.ExecuteInPyConsoleAction.text=在控制台中执行所选内容
action.ExecuteInPyConsoleAction.description=在 Python/Django 控制台中执行选定的代码片段
action.com.jetbrains.python.console.RunPythonOrDebugConsoleAction.text=Python 或调试控制台
action.com.jetbrains.python.console.RunPythonOrDebugConsoleAction.description=允许在运行调试会话时快速运行 Python 控制台或调试控制台
action.ForceStepInto.text=强制单步执行 (_R)
action.ForceStepInto.description=步入，忽略库，构造器等的步进过滤器。
configurable.Tab.display.name=Buildout
configurable.PyConsoleOptionsConfigurable.display.name=控制台
configurable.PyConsoleOptionsConfigurable.child.display.name=Python控制台
configurable.BuildoutConfigurable.display.name=Buildout
configurable.BuildoutModulesConfigurable.display.name=Buildout 支持
configurable.PySmartKeysOptions.display.name=Python
configurable.PyContentEntriesModuleConfigurable.display.name=项目结构
configurable.PythonContentEntriesConfigurable.display.name=项目结构
configurable.PyActiveSdkModuleConfigurable.display.name=项目解释器
configurable.PyDependenciesConfigurable.display.name=项目依赖项
configurable.PyIntegratedToolsConfigurable.display.name=Python 集成工具
configurable.PyIntegratedToolsModulesConfigurable.display.name=Python 集成工具
configurable.PyScientificConfigurable.display.name=Python Scientific
configurable.PythonSdkEditorTab.display.name=Python SDK
configurable.PyDebuggerConfigurable.display.name=Python调试器
configurable.PyActiveSdkModuleConfigurable.python.interpreter.display.name=Python 解释器
configurable.PyTemplateLanguageModulesConfigurable.template.languages.display.name=模板语言
configurable.PyTemplateLanguageModulesConfigurable.python.template.languages.display.name=Python 模板语言
flask.name=Flask
settings.default.remote.interpreter=默认 Python 远程解释器
action.DumbAware.PydevConsoleRunnerImpl.text.stop.console=停止控制台
action.DumbAware.PydevConsoleRunnerImpl.description.stop.python.console=停止 Python 控制台
action.DumbAware.ConcurrencyToolWindowPanel.text.stop.process=停止进程
action.DumbAware.ConcurrencyToolWindowPanel.description.stop.process=停止进程
action.AnActionButton.text.use.conda.package.manager=使用 Conda 包管理器
action.AnActionButton.text.show.early.releases=显示早期版本
action.PyManagePackages.text=管理 Python 包...
action.RunPythonToolwindowAction.text=Python控制台

# qt actions
qt.error.failed.run.qt.designer=无法运行 Qt 设计器：{0}
qt.qrc.compiler.select.output.path=选择输出目录\:
qt.qrc.compile.files=编译 {0} .Qrc 文件
qt.qrc.compile=编译 {0}
qt.compile.qrc.file=编译 .Qrc 文件
qt.run.error=运行 {0} 出错：{1}
qt.cannot.find.pyrcc4.or.pysidercc=找不到所选 Python 解释器的 pyrcc4 或 pyside-rcc
qt.run.designer.error=错误

python.module.name=Python 模块
python.module.description=Python 模块用于开发 <b>Python</b> 应用程序。
python.module.description.extended=支持的技术包括 <b>Django、Google App Engine、Mako、Jinja2</b> 等等。

action.create.python.file.title=Python 文件
action.create.python.file.description=从指定的模板创建 Python 文件
acton.run.file.in.python.console.title=运行 Python 控制台中的文件
action.run.file.in.python.console.description=运行 Python 控制台中的当前文件
action.cleaning.up.pyc.files=正在清理 .Pyc 文件...

buildout.facet.title=Buildout 支持
buildout.configurable.choose.a.buildout.script=选择 Buildout 脚本
buildout.configurable.select.the.target.script=选择将调用代码的目标脚本
buildout.color.comment=注释
buildout.color.key.value.separator=键值分隔符
buildout.color.value=值
buildout.color.key=键
buildout.color.section.name=节名
buildout.config=Buildout 配置
buildout.config.language=Buildout 配置
buildout.config.script.name.validation.error.message=请指定 Buildout 脚本
buildout.config.script.file.invalid.message=无效脚本文件 ''{0}''

code.insight.select.methods.to.override=选择要重写的方法
code.insight.select.methods.to.implement=选择实现的方法
code.insight.create.test=创建测试
code.insight.select.target.directory=选择目标目录
code.insight.encoding.comment.format=编码注释格式：
code.insight.select.default.encoding=选择默认编码： 
code.insight.type.hints.are.not.installed=未安装类型提示
code.insight.install.type.hints.content=它们可以使代码洞察更出色。
code.insight.install.type.hints.action=安装存根包
code.insight.ignore.type.hints=忽略更改
code.insight.ignore.packages.qfix=忽略 {0,choice1\# 个包|2\# 个包}
configurable.pipenv.auto.detected=已自动检测：{0}
configurable.choose.path.to.the.package.requirements.file=选择包需求文件的路径：
configurable.choose.working.directory=请选择工作目录：
configurable.select.working.directory=选择工作目录

console.waiting.for.repl.response.with.timeout=正在等待 REPL 响应，超时 {0} 秒
console.waiting.for.repl.response=正在等待 REPL 响应
console.repl.communication=REPL 通信
console.getting.description=正在获取说明
console.close.console.communication=关闭控制台通信
console.executing.code.in.console=正在执行控制台中的代码...
console.new.console.description=创建新的 python 控制台
console.new.console=新建控制台
console.error.connecting.debugger=连接调试器出错
console.cannot.connect.to.debugger=无法连接到调试器
console.attach.debugger.description=对控制台中执行的代码启用追踪
console.attach.debugger=附加调试器
console.restarting.console=正在重启控制台
console.command.executor=Python 控制台命令执行器
connecting.to.console.progress=正在连接控制台...
connecting.to.console.title=连接控制台
console.show.variables.title=显示变量
console.show.variables.description=显示活动控制台变量

compile.cython.extensions.title=编译 Cython 扩展
compile.cython.extensions.help=工作原理
compile.cython.extensions.install=安装
compile.cython.extensions.notification=Python 调试器扩展可用

create.python.file.action.new.python.file=新建 Python 文件
create.python.file.action.python.file=Python 文件
create.python.file.action.python.unit.test=Python 单元测试
create.python.file.action.python.stub=Python 存根
create.python.file.script.action=创建 Python 脚本 {0}

debugger.attach.to.process.filter.names=<html>为<b>附加到进程</b>显示名称中包含这些内容的进程：</html>
debugger.watch.return.values.description=启用监视，以查看所执行函数返回的值
debugger.exception.breakpoint.ignore.library.files=忽略库文件
debugger.exception.breakpoint.on.raise=引发时
debugger.exception.breakpoint.on.termination=终止时
debugger.exception.breakpoint.type=Python 异常断点
debugger.exception.breakpoint.activation.policy=激活策略
debugger.delete.signature.cache=删除缓存
debugger.cleaning.signature.cache=清理动态收集类型的缓存
debugger.simplified.view.description=禁用监视类、函数和模块对象
debugger.simplified.view.text=简化变量视图
debugger.data.view.colored=已着色
debugger.data.view.close.selected.viewer=关闭所选查看器
debugger.data.view.close.viewer=关闭查看器
debugger.data.view.open.new.container.viewer=打开新容器查看器
debugger.data.view.view.new.container=查看新容器
debugger.data.view.data=数据
debugger.data.view.close=关闭
debugger.data.view.resize.automatically=自动调整大小
debugger.data.view.colored.cells=已着色单元
debugger.numeric.view.as.dataframe=作为 DataFrame 查看
debugger.numeric.view.as.array=作为数组查看
debugger.stepping.filter=步进筛选器
debugger.stepping.filter.specify.pattern=指定 glob 模式（允许使用 '*'、'?' 和 '[seq]'，分号 ';' 用作名称分隔符）：
debugger.stepping.no.script.filters=未配置脚本筛选器
debugger.sending.close.message=正在向 Python 控制台发送关闭消息...
debugger.waiting.to.finish=正在等待 Python 控制台进程结束...
debugger.variables.loading.policy=变量加载策略
debugger.variables.loading.synchronously.text=同步
debugger.variables.loading.synchronously.description=同步加载变量值
debugger.variables.loading.asynchronously.text=异步
debugger.variables.loading.asynchronously.description=异步加载变量值
debugger.variables.loading.on.demand.text=按需
debugger.variables.loading.on.demand.description=按需加载变量值
debugger.variables.view.loading.timed.out=加载超时
debugger.variables.view.switch.to.loading.on.demand=切换为按需加载
debugger.variables.view.warning.message=无法加载多个变量的值  
debugger.exception.breakpoint.select.exception.class=选择异常类
debugger.watch.show.return.values=显示返回值
debugger.data.view.connected.to.python.console=已连接到 Python 控制台
debugger.data.view.connected.to.debug.session=已连接到调试会话 ''{0}''
debugger.data.view.empty.text=运行 Python 控制台或调试器以查看可用数据

pydev.console.runner.settings=设置
pydev.console.runner.error.running.console=运行控制台出错
pydev.console.runner.python.console.debugger=Python 控制台调试器
pydev.console.runner.unknown.error=未知错误
pydev.console.console.process.terminated.with.error=控制台进程因错误而终止：\n\
{0}{1}
pydev.console.console.process.terminated.with.exit.code=控制台进程终止，退出代码为 {0}，输出：{1}
pydev.console.couldnt.connect.to.console.process=无法连接到控制台进程。
pydev.console.debugger.connected=\n\
调试器已连接。\n\

pydev.console.couldnt.read.integer.value.from.stream=无法读取流中的整数值
pydev.console.python.interpreter.is.not.selected=未选择 Python 解释器。请先安装 Python 解释器。

external.documentation.python.plugin=Python 外部文档
external.documentation.pycharm=外部文档
external.documentation.edit.documentation.url=编辑文档 URL
external.documentation.title=Python 外部文档
external.documentation.configure.description=未为模块 {0} 配置外部文档 URL。\n\
现在要配置吗？


python.colors.python=Python
python.colors.type.annotation=类型注解
python.colors.class.definition=类定义
python.colors.decorator=装饰器
python.colors.built.in.name=内置名称
python.colors.special.names.usage=特殊名称//用法
python.colors.special.names.definition=特殊名称//定义
python.colors.keyword.argument=关键字参数
python.colors.parameters.self.parameter=参数//'self' 参数
python.colors.parameters.parameter=参数//参数
python.colors.functions.method.call=函数//方法调用
python.colors.functions.function.call=函数//函数调用
python.colors.functions.function.definition=函数//函数定义
python.colors.braces.and.operators.dot=括号和运算符//圆点
python.colors.braces.and.operators.comma=括号和操作符//逗号
python.colors.braces.and.operators.braces=括号和运算符//花括号
python.colors.braces.and.operators.brackets=括号和操作符//括号
python.colors.braces.and.operators.parentheses=括号和运算符//括号
python.colors.braces.and.operators.operation.sign=括号和操作符//操作符号
python.colors.docstring.tag=文档字符串//标签
python.colors.docstring.text=文档字符串//文本
python.colors.string.f.string.format.specifier.start=字符串//格式化字符串//格式说明符开始
python.colors.string.f.string.type.conversion=字符串//格式化字符串///类型转换
python.colors.string.f.string.expression.braces=字符串//格式化字符串///表达式大括号
python.colors.string.escape.sequence.invalid=字符串//转义序列//无效
python.colors.string.escape.sequence.valid=字符串//转义序列//有效
python.colors.string.text.unicode=字符串//文本 (unicode)
python.colors.string.binary.bytes=字符串//二进制（字节）
python.colors.line.comment=行注释
python.colors.keyword=关键字
python.colors.number=数字

python.new.project.synchronization.not.configured=未配置同步
python.new.project.remote.path.not.provided=未提供远程路径
python.new.project.more.settings=更多设置(&E)
python.new.project.install.failed.title=安装 {0} 失败

python.project.view.remote.libraries=远程库
python.project.view.py.skeletons=二进制框架
python.project.view.typeshed.stubs=Typeshed 存根
python.project.view.user.skeletons.node=扩展定义

python.packaging.installing.packaging.tools=正在安装打包工具...
python.packaging.installing.packages=正在安装包...
python.packaging.warning=警告
python.packaging.create.setup.py=创建 setup.py
python.packaging.failed.to.run.task=无法运行任务：{0}
python.packaging.run.setup.py.task=运行 setup.py 任务...
python.packaging.expand.options=展开选项 >>
python.packaging.collapse.options=<< 折叠选项
python.packaging.run.setup.task.0=运行安装任务 {0}
python.packaging.command.line=命令行
python.packaging.install=安装
python.packaging.choose.packages.to.install=选择要安装的包
python.packaging.removing.conda.channel=移除 Conda 通道
python.packaging.adding.conda.channel=添加 Conda 通道
python.packaging.failed.to.install.packaging.tools.title=无法安装 Python 打包工具

# Example of produced message:
#    You are attempting to uninstall MarkupSafe package which is required for Jinja2 package
#
#    Do you want to proceed?
python.packaging.dialog.description.attempt.to.uninstall.for.one.dependent.package.single.package.description={1} 所需的 {0} 包
python.packaging.dialog.description.attempt.to.uninstall.for.one.dependent.package=您将要卸载 {0} {1, choice, 1\#包|2\#包}\n\
\n\
是否继续?

# Example of produced message:
#    You are attempting to uninstall packages which are required for another packages.
#
#    Jinja2 -> Flask
#    muffin -> muffin-jinja2
#
#    Do you want to proceed?
python.packaging.dialog.description.attempt.to.uninstall.for.several.dependent.packages.single.package.description={0} -> {1}
python.packaging.dialog.description.attempt.to.uninstall.for.several.dependent.packages=您将要卸载其他包所需的包。\n\
\n\
{0}\n\
\n\
是否继续?

python.packaging.notification.description.details.link=详细信息…
python.packaging.notification.description.installed.all.requirements=已安装所有要求
python.packaging.notification.description.installed.packages=已安装包\: {0}
python.packaging.notification.description.installed.python.packaging.tools=已安装 Python 打包工具
python.packaging.notification.description.uninstalled.packages=已卸载包\: {0}
python.packaging.notification.title.error.occurred={0}\: 发生错误。
python.packaging.notification.title.install.packages.failed=安装包失败
python.packaging.notification.title.packages.installed.successfully=已成功安装包
python.packaging.notification.title.packages.uninstalled.successfully=已成功卸载包
python.packaging.notification.title.uninstall.packages.failed=卸载包失败
python.packaging.progress.text.installing.specific.package=正在安装包 ''{0}''…
python.packaging.progress.title.installing.packages=正在安装包
python.packaging.progress.title.uninstalling.packages=正在卸载包

python.unresolved.reference.inspection.install.package=安装包 {0}

# UI forms

form.qt.compile.qrc.output.file=输出文件：
form.buildout.config.set.to.buildout.dir.bin.django.py.for.proper.django.support=设置为 <buildout-dir>/bin/django.py 以获取适当的 Django 支持 
form.buildout.config.use.paths.from.script=使用脚本中的路径 (&S)：
form.auto.import.from.module.import.name=从 <module> 导入 <name>
form.auto.import.import.module.name=导入 <module>.<name>
form.auto.import.preferred.import.style=首选的导入样式：
form.auto.import.python=Python
form.auto.import.auto.import.show.popup=显示导入弹出窗口
form.create.test.target.directory=目标目录
form.create.test.test.class.name=测试类名
form.create.test.test.file.name=测试文件名
form.edit.sdk.associate.this.virtual.environment.with.current.project=关联此虚拟环境与当前项目 (&A)
form.edit.sdk.interpreter.path=解释器路径(&I)\:
form.edit.sdk.label.create.connection.pool.options.name=名称\:
form.edit.sdk.html.href.remove.association=<html><a href\=\"\#\">移除关联</a>
form.integrated.tools.analyze.python.code.in.docstrings=分析文档字符串中的 Python 代码
form.integrated.tools.default.test.runner=默认测试运行程序：
form.integrated.tools.docstring.format=文档字符串格式：
form.integrated.tools.package.requirements.file=包需求文件：
form.integrated.tools.path.to.pipenv.executable=Pipenv 可执行文件路径：
form.integrated.tools.render.external.documentation.for.stdlib=渲染 stdlib 的外部文档
form.integrated.tools.sphinx.working.directory=Sphinx 工作目录：
form.integrated.tools.treat.txt.files.as.restructuredtext=将 *.txt 文件视为 reStructuredText
form.console.options.always.show.debug.console=始终显示调试控制台
form.console.options.settings.title.system.settings=常规设置
form.console.options.show.console.variables.by.default=默认显示控制台变量
form.console.options.use.existing.console.for.run.with.python.console=为“通过 Python 控制台运行”使用现有控制台
form.console.options.use.ipython.if.available=使用 IPython（如有）
form.console.specific.options.starting.script=正在启动脚本
form.debugger.for.attach.to.process.show.processes.with.names.containing=为“附加到进程”显示名称中包含这些内容的进程：
form.debugger.attach.to.subprocess.automatically.while.debugging=调试时自动附加到子进程
form.debugger.clear.caches=清除缓存
form.debugger.clear.caches.action=清除缓存
form.debugger.collect.run.time.types.information.for.code.insight=收集运行时类型信息以获取代码洞察
form.debugger.gevent.compatible=Gevent 兼容
form.debugger.pyqt.compatible=PyQt 兼容
form.debugger.remote.interpreter.docker.default.interpreter.path=python
form.data.viewer.current.slice=当前切片。
form.data.viewer.dialog.show.svn.map.table.header.column.format.title=格式
form.data.viewer.format=格式\:
form.debugger.stepping.checkbox.text.do.not.step.into.library.scripts=不要单步执行库脚本
form.debugger.stepping.do.not.step.into.scripts=不单步执行脚本\:
form.debugger.stepping.always.do.smart.step.into=始终进行智能单步执行
form.documentation.entry.insert=&插入
form.documentation.entry.module.name=模块名称 (&M)：
form.documentation.entry.url.path.pattern=URL/路径模式 (U)：
form.documentation.entry.available.macros=可用的宏
form.remote.path.remote.project.location=远程项目位置：
form.introduce.name=名称\:
form.introduce.field.initialize.in=&初始化在
form.move.module.members.from=从\:
form.move.module.members.to=到\:
form.python.run.configuration.emulate.terminal.in.output.console=模拟输出控制台中的终端
form.python.run.configuration.redirect.input.from=重定向输入自\:
form.python.run.configuration.run.with.python.console=使用 Python 控制台运行
form.test.shared.target=目标\:
form.test.shared.test=测试
form.test.run.configuration.params=参数\:
form.test.run.configuration.specify.nosetests.command.line.options=指定 nosetest 命令行选项
form.test.run.configuration.unittest=Unittest
form.pytest.legacy.path.to.a.file.or.directory.that.contains.the.tests.to.be.executed=包含待执行测试的文件或目录的路径
form.pytest.legacy.py.tests=py.tests
form.pytest.legacy.specify.py.tests.command.line.options=指定 py.tests 命令行选项
form.pytest.legacy.specify.the.keywords.to.search.for.the.required.tests.k.command.line.option.in.py.tests=指定要为所需测试搜索的关键字。py.tests 中的 -k 命令行选项
form.tox.configuration.arguments=参数
form.tox.configuration.run.only.environment=仅运行环境
form.tox.configuration.runcfg.tox=tox
py.module.dependencies.configurable.list.title=项目取决于这些项目：
py.sdk.editor.python.interpreter.label.text=Python 解释器：
# Python reStructuredText forms
rest.configuration.editor.open.output.file.in.browser.label.text=在浏览器中打开输出文件
sphinx.ask.for.working.directory.label.text=Sphinx 工作目录



pure.python.project=纯 Python
project.cannot.be.generated=无法生成项目
error.in.project.generation=项目生成出错

sdk.has.been.configured.as.the.project.interpreter={0} 已配置为项目解释器
configure.python.interpreter=配置 Python 解释器...
configuring.python.interpreter=正在配置 Python 解释器
configuring.interpreters.link=<html><a href\="\#">配置解释器
looking.for.previous.interpreter=正在查找以前用过的解释器
looking.for.related.venv=正在查找与项目相关的虚拟环境
looking.for.pipfile=正在查找 Pipfile
install.packages.from.pipfile=安装 Pipfile 中的包
looking.for.default.interpreter=正在查找新项目的默认解释器设置
looking.for.previous.system.interpreter=正在查找以前用过的系统级解释器
looking.for.system.interpreter=正在查找系统级解释器
current.interpreter=当前解释器：{0}
python.facet.name=Python
enable.in.python.3=在 Python 3+ 中启用
ignore.overridden.functions=忽略被覆盖的函数
choose.packages.to.install=选择要安装的包：
manage.python.packages=管理 Python 包
interpreter=解释器：
base.interpreter=基本解释器：
available.to.all.projects=可用于所有项目


framework.support.python.sdk.combobox.label=Python SDK\:
integrated.tools.configurable.docstrings=文档字符串
integrated.tools.configurable.restructuredtext=reStructuredText
integrated.tools.configurable.packaging=打包
integrated.tools.configurable.testing=测试
integrated.tools.configurable.pipenv=Pipenv
command.line.parser.error.message=参数与其值之间的空格异常

python.package.installation.notification.message={0} 将安装在选定的解释器上
python.package.and.packaging.tools.installation.notification.message=Python 打包工具和 {0} 将安装在选定的解释器上

python.execute.selection.action.execute.selection.in.console=执行 Python 控制台中的选定内容
python.execute.selection.action.execute.line.in.console=执行 Python 控制台中的代码行

python.add.sdk.panel.name.conda.environment=Conda 环境
python.add.sdk.panel.name.existing.environment=现有环境
python.add.sdk.panel.name.existing.interpreter=现有解释器
python.add.sdk.panel.name.new.environment.using=使用此工具新建环境
python.add.sdk.panel.name.new.environment=新环境
python.add.sdk.panel.name.new.project.interpreter=新项目解释器
python.add.sdk.panel.name.pipenv.environment=Pipenv 环境
python.add.sdk.panel.name.system.interpreter=系统解释器
python.add.sdk.panel.name.virtualenv.environment=Virtualenv 环境

python.requirements.version.label=需求版本：
python.requirements.version.separator.no.version=不指定版本
python.requirements.version.separator.strong.eq=强相等
python.requirements.version.separator.gte=大于或等于
python.requirements.version.separator.compatible=兼容版本
python.requirements.remove.unused=移除未使用的需求
python.requirements.modify.base.files=修改基本文件（使用 -r 或 --requirement 定义的文件）
python.requirements.keep.matching.specifier=如果现有版本与当前版本相匹配，则保留现有版本说明符
python.requirements.quickfix.family.name=将导入的包添加到需求中...
python.requirements.analyzing.imports.title=正在分析项目中的导入
python.requirements.action.name=同步 Python 需求
python.requirements.error.ends.with.slash=解析需求出错：文件以 '/' 符号结尾。
python.requirements.error.no.packages=检索包列表时出错。
python.requirements.error.no.interpreter=已配置同步需求所需的解释器。
python.requirements.warning.unhandled.lines=无法分析需求文件中的条目：{0}
python.requirements.info.file.ref.dropped=基本文件中的某些需求未更新：{0}
python.requirements.balloon=同步 Python 需求
python.requirements.file.empty=需求文件为空

toolwindow.stripe.SciView=SciView
toolwindow.stripe.Python_Console=Python 控制台

python.install.framework.ensure.installed=正在确保 {0} 已安装
python.install.framework.checking.is.installed=正在检查 {0} 是否安装…
python.install.framework.installing=正在安装 {0}...

python.compatibility.inspection.advertiser.notifications.group.title=Python 兼容性检查广播程序
python.compatibility.inspection.advertiser.notifications.title=Python 版本兼容性

python.compatibility.inspection.advertiser.using.future.imports.warning.message=您的源代码包含 __future__ 导入。<br/>要启用代码兼容性检查吗?<br/><a href\="\#yes">是</a>\\&nbsp;\\&nbsp;<a href\="\#no">否</a>

python.compatibility.inspection.advertiser.using.six.warning.message=您的源代码导入了 'six' 包。<br/>要启用代码兼容性检查吗?<br/><a href\="\#yes">是</a>\\&nbsp;\\&nbsp;<a href\="\#no">否</a>

# Both placeholders are Python versions like 2.7, 3.7, etc.
python.compatibility.inspection.advertiser.version.stale.python3.version.warning.message=已为最高 {0} 的 Python 版本配置了代码兼容性检查。<br/>要为 Python {1} 启用吗?<br/><a href\="\#yes">是</a>\\&nbsp;\\&nbsp;<a href\="\#no">否</a>