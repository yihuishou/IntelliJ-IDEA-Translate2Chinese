action.ChangePHPInterpreter.text=更改 PHP 解释器
action.ChangePHPInterpreter.description=更改项目 PHP 解释器
action.MessDetectorAddToIgnored.text=添加到 PHPMD 忽略列表
action.MessDetectorAddToIgnored.description=添加到 PHP Mess Detector 忽略列表
action.PhpCSFixerAddToIgnored.text=添加到 PHP CS Fixer 忽略列表
action.PhpCSFixerAddToIgnored.description=添加到 PHP CS Fixer 忽略列表
action.PhpCSAddToIgnored.text=添加到 PHPCS 忽略列表
action.PhpCSAddToIgnored.description=添加到 PHP_CodeSniffer 忽略列表
group.PHPQualityToolsAddToIgnoredList.text=添加到忽略列表…
action.ComposerShowLogAction.text=显示日志
action.ComposerShowLogAction.description=显示包含该 composer.json 的 Composer 操作日志
action.ComposerClearCacheAction.text=清除缓存
action.ComposerClearCacheAction.description=删除 Composer 缓存目录中的所有内容
action.ComposerSelfUpdateAction.text=自我更新
action.ComposerSelfUpdateAction.description=将 Composer 本身更新到最新版本
group.ComposerToolsGroup.text=Composer
action.com.jetbrains.php.composer.ComposerInitSupportAction.text=初始化 Composer...
action.com.jetbrains.php.composer.ComposerInitSupportAction.description=初始化 Composer
group.ComposerGroup.text=Composer
action.ComposerDiagnoseAction.text=诊断
action.ComposerDiagnoseAction.description=检查常见的 Composer 问题
action.ComposerLicensesAction.text=列出许可证
action.ComposerLicensesAction.description=列出安装的每个包的名称、版本和许可证
action.ComposerStatusAction.text=检查依赖项中的更改
action.ComposerStatusAction.description=检查任何依赖项中有无本地更改
action.ComposerDryRunUpdate.text=模拟更新
action.ComposerDryRunUpdate.description=模拟更新，但不实际更新
action.ComposerDumpAutoloadAction.text=转储自动加载器...
action.ComposerDumpAutoloadAction.description=重新生成自动加载类的列表
action.ComposerValidateAction.text=验证...
action.ComposerValidateAction.description=检查 composer.json 是否有效
action.ComposerAddDependencyAction.text=管理依赖项...
action.ComposerAddDependencyAction.description=管理 Composer 依赖项
action.ComposerUpdateAction.text=更新
action.ComposerUpdateAction.description=从 Composer.json 安装最新版本的包
action.ComposerInstallAction.text=安装
action.ComposerInstallAction.description=考虑到 composer.lock，因此安装 composer.json 中的包
action.com.jetbrains.php.internal.PhpViewControlFlowAction.text=当前文件的 PHP 控制流
action.com.jetbrains.php.internal.PhpShowFQNInternalAction.text=显示 PHP FQN
action.com.jetbrains.php.internal.PhpShowTypeInfoAction.text=显示 PHP 类型信息
action.ProfilerJumpToSource.text=跳转到源码
action.ProfilerJumpToSource.description=跳转到源码
action.XdebugAnalyzeProfilerSnapshotAction.text=分析 Xdebug 分析器快照...
group.DBGPProxyGroup.text=DBGp 代理
action.PhpDebuggerCopyType.text=Copy Type
action.XDebugger.CopyPath.text=复制路径
action.PhpDetectPsroRoots.text=检测 PSR-0 命名空间根
action.PhpDetectPsroRoots.description=将检测源命名空间根
action.PhpListenDebugAction.text=侦听调试连接
action.PhpListenDebugAction.description=侦听调试连接
action.PhpMakeStaticAction.text=设为静态
action.PhpMakeStaticAction.description=设为静态类方法
action.PhpNewTest.text=PHP 测试
action.PhpNewTest.description=创建新的 PHP 测试
group.PhpNewTestGroup.text=PHP 测试
action.PhpUnitGenerateTearDownMethod.text=TearDown 方法
action.PhpUnitGenerateTearDownMethod.description=创建 PHPUnit tearDown 方法
action.PhpUnitGenerateSetUpMethod.text=SetUp 方法
action.PhpUnitGenerateSetUpMethod.description=创建 PHPUnit setUp 方法
action.PhpUnitGenerateTestMethod.text=测试方法
action.PhpUnitGenerateTestMethod.description=创建 PHPUnit 测试方法
action.PhpGeneratePhpDocBlocks.text=PHPDoc 块...
action.PhpGeneratePhpDocBlocks.description=为函数、类和字段添加 PHPDoc 块。
action.PhpGenerateSetters.text=Setter...
action.PhpGenerateSetters.description=为 private 类字段创建 setter。
action.PhpGenerateGettersAndSetters.text=Getter 和 Setter...
action.PhpGenerateGettersAndSetters.description=为 private 类字段创建 getter 和 setter。
action.PhpGenerateGetters.text=Getter...
action.PhpGenerateGetters.description=为 private 类字段创建 getter。
action.PhpGenerateConstructor.text=构造函数...
action.PhpGenerateConstructor.description=创建构造函数。

php.keyword=关键字
php.variable=变量
php.string=字符串
php.single.quote.string=单引号字符串
php.number=数字
php.operations=运算
php.marker=启动/结束脚本标记
php.valid.string.escape=有效字符串转义
php.predefined.function=预定义函数

tab.structureview.view=PHP

# php colors page elements
color.settings.name=PHP
color.settings.php.scripting=PHP 代码//后台
color.settings.php.tags=PHP 代码//标签
color.settings.keyword=关键字
color.settings.comment=注释
color.settings.number=数字
color.settings.string=字符串//字符
color.settings.escape_sequence=字符串//转义序列
color.settings.operation=大括号和运算符//运算符
color.settings.brackets=括号和操作符//括号
color.settings.parentheses=括号和运算符//括号
color.settings.braces=括号和操作符//大括号
color.settings.bad_character=未知字符
color.settings.comma=括号和操作符//逗号
color.settings.semicolon=括号和运算符//分号
color.settings.heredoc_id=Heredoc//Heredoc ID
color.settings.heredoc_content=Heredoc//Heredoc 内容
color.settings.var=标识符//变量
color.settings.var_var=标识符//可变变量
color.settings.this.var=标识符//'$this' 变量
color.settings.identifier=标识符//默认值
color.settings.constant=标识符//常数
color.settings.function=函数和方法//声明
color.settings.parameter=函数和方法//参数
color.settings.function.call=函数和方法//函数调用
color.settings.instance.method=函数和方法//实例方法调用
color.settings.instance.protected.method=函数和方法//protected 实例方法调用
color.settings.instance.private.method=函数和方法//private 实例方法调用
color.settings.static.method=函数和方法//静态方法调用
color.settings.magic.member=标识符//魔幻成员访问
color.settings.class=类和属性//类
color.settings.interface=类和属性//接口
color.settings.static.field=类和属性//静态属性
color.settings.instance.field=类和属性//实例属性
color.settings.instance.protected.field=类和属性//protected 实例属性
color.settings.instance.private.field=类和属性//private 实例属性
color.settings.doccomment=PHPDoc//文本
color.settings.doctag=PHPDoc//标签
color.settings.docmarkup=PHPDoc//标记
color.settings.doc.identifier=PHPDoc//标识符
color.settings.doc.parameter=PHPDoc//参数
color.settings.doc.var=PHPDoc//变量
color.settings.doc.method.identifier=PHPDoc//方法声明
color.settings.doc.property.identifier=PHPDoc//属性
color.settings.exec_command=Shell 命令
color.settings.concatenation=字符串//串联
color.settings.predefined.symbols=标识符//预定义符号
color.settings.goto.label=标识符//转到标签
color.settings.alias.reference=标识符//别名引用
color.settings.alias.primitive.type.hint=标识符//基元类型提示

# annotations
annotation.variable.variable=可变变量
annotation.new.expression.interface=无法实例化接口 ''{0}''
annotation.new.expression.trait=无法实例化特征 ''{0}''
annotation.new.expression.abstract=无法实例化抽象类 ''{0}''
annotation.expression.is.not.allowed.as.class.constant.value=表达式不允许为类常量值

#folding
folding.checkbox.collapse.imports=导入
folding.checkbox.collapse.method.body=方法体
folding.checkbox.collapse.function.body=函数体
folding.checkbox.collapse.php.tags=标记
folding.checkbox.collapse.heredocs.and.nowdocs=HEREDOC\\NOWDOC
folding.checkbox.collapse.classes=类主体

#gutter
gutter.overriding.select.title=选择要导航的父方法
gutter.overriden.select.subclass.title=选择 {0} 的子类
gutter.overriden.select.implementation.title=选择 {0} 的实现
#gutter-pinned
gutter.pin.overriding.select.title={0} 的父项
gutter.pin.overriden.select.subclass.title={0}的实现
gutter.pin.overriden.select.implementation.title={0}的实现

# inspections
inspection.group=PHP
inspection.group.general=选项
inspection.group.unused=未使用的
inspection.group.unused.quickfix.label=未使用的元素
inspection.group.unused.quickfix.message=未使用的元素\: ''{0}''
inspection.group.undefined=未定义
inspection.group.control.flow=控制流
inspection.group.php.doc=PHPDoc
inspection.group.probably.bug=可能的错误
inspection.group.type.compatibility=类型兼容性
inspection.group.code.style=代码风格
inspection.group.code.smell=代码异味
inspection.group.naming.convention=命名约定


inspection.dead.code.problem.empty.constant.synopsis=常量从未使用。
inspection.dead.code.problem.single.constant.synopsis=常量有一个用法，但无法到达。
inspection.dead.code.problem.multiple.constant.synopsis=常量有 {0, choice, 1\#1 个用法|2\#{0,number} 个用法}，但无法从入口点到达。
inspection.dead.code.problem.empty.function.synopsis=函数从未使用。
inspection.dead.code.problem.recursive.suspicious.function.synopsis=所有函数用法均属于不存在可从入口点到达的成员的调用链。
inspection.dead.code.problem.suspicious.function.synopsis=函数无法从入口点到达。
inspection.dead.code.problem.trait.synopsis=特征从未使用。
inspection.dead.code.problem.class.nousages.synopsis=类从未使用.
inspection.dead.code.problem.trait.additional.unreachable=特征没有可到达用法。
inspection.dead.code.problem.trait.additional.reachable=特征具有可到达用法。
inspection.dead.code.problem.class.abstract.several.implementations={0} 具有{1, choice, 1\#直接或间接实现|2\# {1,number} 个直接或间接实现}，但<ul><li>其从未实例化或</li><li>不存在可从入口点到达的实例化。</li></ul>

inspection.hierarchyChecks=类层次结构检查
inspection.hierarchyChecks.descr=类必须被声明为 abstract 或实现 {0}
inspection.hierarchyChecks.field.type.redeclaration.must.not.be.defined=类型不得定义(如基类 ''{0}'' 中)
inspection.hierarchyChecks.field.type.redeclaration.match.super.type=类型必须为 ''{0}''(如基类 ''{1}'' 中)
inspection.wrong_param_type=应为 ''{1}'' 类型的参数，提供的是 ''{0}''
inspection.missing_param=缺少所需参数 ''${0}''
inspection.optional.before.required=可选参数在需要前提供
#inspection -> Super class incompatible with interface
inspection.super.incompatible.with.interface.declaration.must.be.compatible=''{0}'' 的声明必须与 ''{1}'' 兼容

#inspection -> Wrong Exception order
inspection.wrong.exception.order.problem.batch=已捕获异常 '\#ref'
inspection.wrong.exception.order.problem.same=已捕获异常 ''{0}''
inspection.wrong.exception.order.problem.super=已捕获异常类 ''{1}'' 的超类 ''{0}''

inspection.wrong.exception.order.fix.move.display.name=将 ''catch'' 子句移动到 ''{0}'' 前
inspection.wrong.exception.order.fix.move.family.name=移动 'catch' 子句
inspection.wrong.exception.order.fix.delete.display.name=删除 'catch' 子句

#inspection -> Wrong Exception class
inspection.wrong.exception.type.problem.throw = 已抛出对象必须为 'Exception' 或 'Throwable' 的实例
inspection.wrong.exception.type.problem.catch = 无法捕获非派生自 'Exception' 或 'Throwable' 基类的对象

#inspection -> Assigned value never used
inspection.unused.assignment.error.description = 从不使用分配的值

#inspection -> Wrong foreach argument
inspection.wrong.foreach.argument.type=提供给 'foreach' 的参数无效
inspection.wrong.foreach.argument.type.problem.batch=提供给 'foreach' 的参数无效
inspection.wrong.foreach.argument.type.problem=提供给 ''foreach'' 的参数无效。预期类型\: ''array'' 或 ''object''，提供的是 ''{0}''。

#inspection -> Redundant PHPDoc
inspection.redundant.phpdoc=冗余 PHPDoc 注释

#inspection -> Unused local variable
inspection.unused.local.variable.problem=未使用的局部变量 ''{0}''。{1}
inspection.unused.local.variable.problem.batch=局部变量 '\#ref' 未在任何位置使用
inspection.unused.local.variable.problem.case1=变量的值未在任何位置使用。
inspection.unused.local.variable.problem.case2=变量的值被立即覆盖。
inspection.unused.local.variable.problem.case3=变量中存储的引用未在任何位置使用。
inspection.unused.local.variable.problem.case4=变量中存储的引用被立即覆盖。
inspection.unused.local.variable.problem.used.only.in.closure.use.statements=变量的值仅在闭包 'use' 列表中使用。
inspection.unused.local.variable.option.description.foreach=在 'list()' 中或存在 'foreach' 键时忽略 foreach 值
inspection.unused.local.variable.option.description.catch=忽略 'catch' 子句中的变量
inspection.unused.local.variable.option.description.list=忽略 'list()' 中的变量
inspection.unused.local.variable.option.description.file.scope=在全局空间中启用检查
inspection.unused.local.variable.option.description.null=忽略 'null' 的赋值
inspection.unused.local.variable.option.indirect.access=忽略通过 'get_defined_vars()' 访问的变量
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.title=发现副作用
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.message=分配给 ''{0}'' 的表达式可能含有副作用。\n\
您可以\:\n\
- 完全<b>移除</b>变量赋值\n\
- 将分配的表达式<b>转换</b>成单独的语句

#inspection -> Unused parameter
inspection.unused.parameter.problem=未使用的参数 ''{0}''。{1}
inspection.unused.parameter.problem.batch=未使用的参数 '\#ref'
inspection.unused.parameter.problem.case1=参数值未在任何位置使用。
inspection.unused.parameter.problem.case2=参数值被立即覆盖。
inspection.unused.parameter.problem.case3=参数中存储的引用未在任何位置使用。
inspection.unused.parameter.problem.case4=参数中存储的引用被立即覆盖。
inspection.unused.parameter.option.description.empty.body=忽略带有空主体的方法/函数的参数
inspection.unused.parameter.option.description.empty.abstract=忽略抽象类方法的参数
inspection.unused.parameter.option.description.empty.override=忽略重写方法的参数
inspection.unused.parameter.option.description.empty.anonymous=忽略匿名函数的参数
inspection.unused.parameter.option.description.parameter.count=不报告通过 'func_num_args()' 访问的参数

#inspection -> Unused private method
inspection.unused.private.method.problem.batch=未使用的 private 方法 '\#ref'
inspection.unused.private.method.option.ignore.constructor=忽略方法 '__construct' 用法
inspection.unused.private.method.option.ignore.clone=忽略方法 '__clone' 用法

#inspection -> Undefined callback
inspection.undefined.callback.method=在类 ''{1}'' 中未找到方法 ''{0}''
inspection.undefined.callback.field=在类 ''{1}'' 中未找到属性 ''{0}''
inspection.undefined.callback.class=未定义的类 ''{0}''
inspection.undefined.callback.function=未定义的函数 ''{0}''
inspection.undefined.callback.dont.report.exist.checkbox=忽略来自 '*_exists' 和 'is_callable' 函数的回调
inspection.undefined.callback.dont.report.ambiguity.checkbox=不明确时不报告

#inspection -> Missing parent call
inspection.missing.parent.call.message=缺少父方法调用

#inspection -> Missing parent constructor call
inspection.missing.parent.constructor.call.message=缺少父构造函数调用

#inspection - > Undefined variable
inspection.undefined.variable.display.name=未定义的变量
inspection.undefined.variable.problem1=未定义的变量 '\#ref'
inspection.undefined.variable.problem2=变量 '\#ref' 可能未定义
inspection.undefined.variable.option.description.enable.in.file.scope=在全局空间中启用检查
inspection.undefined.variable.option.description.report.can.be.undefined=报告变量可能未定义
inspection.undefined.variable.option.description.ignore.include=在包含 include 语句的文件中报告

#inspection -> Wrong String concatenation operator
inspection.wrong.string.concatenation.operator.problem=字符串串联运算符错误
inspection.wrong.string.concatenation.operator.problem.batch=字符串串联运算符错误
inspection.wrong.string.concatenation.operator.option.ignore.magic=忽略通过魔术方法访问的属性

#inspection -> Dynamic method called as static
inspection.dynamic.method.called.as.static.problem=非静态方法 '\#ref' 不应被静态调用
inspection.dynamic.method.called.as.static.problem.magic=非静态方法 '\#ref' 不应被静态调用，但类具有 '__magic' 方法。

#inspection -> Static method called as dynamic
inspection.static.method.called.as.dynamic.problem=静态方法 '\#ref' 不应被动态调用
inspection.static.method.called.as.dynamic.problem.magic=静态方法 '\#ref' 不应被动态调用，但类具有 '__magic' 方法。

#inspection -> Assignment in condition
inspection.assignment.in.condition=条件中的赋值
inspection.assignment.in.condition.move.assignment.out.of.condition.fix.name=从条件中移出赋值

#inspection -> Division by zero
inspection.division.by.zero=除以零

#inspection -> Dynamic namepsace
inspection.namepsace.dynamic=命名空间声明中不允许动态变量

#inspection -> Unreachable Statement
inspection.unreachable.statement=无法访问的语句
inspection.unreachable.statement.problem=无法访问的语句

#inspection -> Missing doc comment
inspection.missing.doc.comment=缺少 PHPDoc 注释
inspection.missing.doc.comment.problem=缺少 PHPDoc 注释
inspection.missing.doc.comment.problem.batch={0} 缺少 PHPDoc 注释
inspection.missing.doc.comment.options.panel.constant=常量(&O)
inspection.missing.doc.comment.options.panel.function=&函数
inspection.missing.doc.comment.options.panel.class=&类
inspection.missing.doc.comment.options.panel.method=&方法
inspection.missing.doc.comment.options.panel.field=&特性
inspection.missing.doc.comment.options.panel.class.constant=类常量(&A)

#inspection -> Silly assignment
inspection.silly.assignment=不实用的赋值
inspection.silly.assignment.problem=赋值左右两侧相等

#inspection -> Illegal array key type
inspection.illegal.array.key.type=非法数组键类型
inspection.illegal.array.key.type.problem=非法数组键类型

#inspection -> Illegal string offset
inspection.illegal.string.offset.problem=非法字符串偏移 {0}

#inspection -> Missing @return tag
inspection.doc.missing.return.tag=缺少 @return 标记
inspection.doc.missing.return.tag.problem=函数/方法 PHPDoc 注释中缺少 @return 标记
inspection.doc.missing.return.tag.option.skip.on.empty=忽略没有 @param 的 PHPDoc
inspection.doc.missing.return.tag.option.skip.on.present.type.hint=忽略带有返回类型提示的 PHPDoc

#inspection -> Doc signature inspection
inspection.doc.signature=PHPDoc 注释与函数/方法签名不匹配
inspection.doc.signature.option.allow.missing.parameters.with.type.hints=允许类型提示中缺失参数

#inspection -> Missing @throws tag
inspection.doc.throws=缺少 @throws 标记
inspection.doc.throws.problem=PHPDoc 注释不包含所有必需的 @throws 标记
inspection.doc.throws.option.skip.on.empty.phpdoc=忽略没有 @param/@return 的 PHPDoc

#inspection -> Inconsistent return points
inspection.missing.inconsistent.return.points=不一致的返回点
inspection.inconsistent.return.points.problem1=缺少 'return' 语句
inspection.inconsistent.return.points.problem1.yield=缺少 'yield' 语句
inspection.inconsistent.return.points.problem2=缺少返回参数
inspection.inconsistent.return.points.option.treat.return=在 'void' 函数/方法中以相同方式对待 'return null' 和 'return'

#inspection -> Redundant closing tag
inspection.redundant.closing.tag.problem=冗余结束标记
inspection.redundant.closing.tag.fix.remove=移除结束标记

#inspection -> Void function result used
inspection.void.function.result.used.display.name=使用了 void 函数结果
inspection.void.function.result.used.problem1=使用了 ''void'' 函数 ''{0}'' 结果
inspection.void.function.result.used.problem2=使用了 ''void'' 方法 ''{0}'' 结果

#inspection -> Expression result unused
inspection.expression.result.unused.display.name=未使用表达式结果
inspection.expression.result.unused.problem=表达式结果未在任何位置使用

#inspection -> Missing 'break' statement
inspection.missing.break.statement.display.name=缺少 'break' 语句
inspection.missing.break.statement.problem=缺少 'break' 语句

#inspection -> Nested vs outer 'foreach' variables conflict
inspection.nested.vs.outer.foreach.variables.conflict.display.name=嵌套与外部 'foreach' 变量冲突
inspection.nested.vs.outer.foreach.variables.conflict.problem1=变量 ''{0}'' 作为键用于内部和外部 ''foreach'' 循环
inspection.nested.vs.outer.foreach.variables.conflict.problem2=变量 ''{0}'' 作为值用于内部和外部 ''foreach'' 循环

#inspection -> Foreach array is used as value
inspection.foreach.array.is.used.as.value.display.name=Foreach 数组用作值
inspection.foreach.array.is.used.as.value.problem=变量 ''{0}'' 已用作 ''array expression''

#inspection -> Usage of a silence operator
inspection.usage.of.silence.operator.problem=使用了沉默运算符

#inspection -> Language level
inspection.language.level.display.name=语言级别

#switch language level quick fix
inspection.language.level.quick.fix.switch.language.level.name.0=切换到 PHP {0} 语言级别

#switch language level in composer file manually quick fix
inspection.language.level.quick.fix.switch.language.level.in.composer.manually.0=手动切换到 composer.json 中的 PHP {0} 语言级别
inspection.language.level.quick.fix.switch.language.level.in.composer.0=切换到 composer.json 中的 PHP {0} 语言级别


inspection.disabled.quality.tool.inspection.fix=启用检查
inspection.disabled.quality.tool.inspection.open.fix=打开检查设置

inspection.disabled.quality.tool.inspection= {0} 检查已禁用

inspection.json.not.installed.packages=未安装包
inspection.json.all.not.installed.packages=未安装包
inspection.json.not.installed.packages.update.fix=更新所有包
inspection.json.not.installed.package.update.fix=更新包
inspection.json.not.installed.packages.install.fix=安装包
inspection.json.duplicated.packages.0=require 和 require-dev 中存在重复的 ''{0}'' 条目
inspection.json.duplicated.packages.fix=从 require-dev 中移除重复项

#inspection -> Duplicate array keys
inspection.duplicate.array.keys.display.name=重复的数组键
inspection.duplicate.array.keys.problem=重复的数组键

#inspection -> Duplicate PhpDoc type
inspection.duplicate.phpdoc.type.problem=重复的类型 ''{0}''
inspection.duplicate.phpdoc.type.fix=从标记中移除重复类型

#inspection -> Undefined constant
inspection.undefined.constant.display.name=未定义的常量
inspection.undefined.constant.problem1=未定义的常量 '\#ref'
inspection.undefined.constant.problem2=常量 '\#ref' 可能未定义

#inspection -> Undefined function
inspection.undefined.function.display.name=未定义的函数
inspection.undefined.function.problem1=未定义的函数 '\#ref'
inspection.undefined.function.problem2=函数 '\#ref' 可能未定义

#inspection -> Undefined property
inspection.undefined.field.problem1=通过魔术方法访问的属性
inspection.undefined.field.problem2=属性动态声明
inspection.undefined.field.notify.access.magic.method=通过魔术方法访问属性的通知
inspection.undefined.field.notify.dynamic.declaration=动态属性声明的通知

#inspection -> Undefined provider
inspection.undefined.phpunit.provider=未定义的 PHPUnit 数据提供程序 ''{0}''

#inspection -> PHPUnit missing target for test
inspection.phpunit.missing.target.element.ref=未找到 '\#ref' 的测试目标元素

#inspection -> Covered function reference is provided without '::'
inspection.phpunit.covers.function.without.scope.resolution.operator=提供的覆盖{0}引用没有 ''\:\:''

#inspection -> Deprecated assertEquals/assertNotEquals usage
inspection.phpunit.asserts.assertEquals.parameters.many=可选的 {0} 个参数已弃用
inspection.phpunit.asserts.assertEquals.parameters.single=可选的 {0} 个参数已弃用
inspection.phpunit.asserts.assertEquals.parameters.empty=带有此类参数的调用已弃用

#inspection -> Usage assertCount/assertSameSize methods instead of assertEquals
inspection.phpunit.asserts.assert.with.count.function=可以使用方法 {0} 代替 {1}

#inspection -> Misordered assertEquals/assertNotEquals arguments
inspection.phpunit.asserts.assertEquals.misordered.arguments={0} 参数的顺序错误

#inspection -> Method assertArrayHasKey/assertArrayNotHasKey can be used instead
inspection.phpunit.asserts.array.has.key.can.be.used.instead=可以改用方法 {0}

#inspection -> Deprecated expectException usage
inspection.phpunit.expectException=对将 expectException() 用于 {0} 的支持已弃用，将在 PHPUnit 10 中移除。请改用 {1}()。

#inspection -> Unnecessary fully qualified name
inspection.unnecessary.qualifier.already.imported.message=限定符不必要，可以移除
inspection.unnecessary.fully.qualified.name.option.enable.file.scope=在文件范围内启用
inspection.unnecessary.fully.qualified.name.option.ignore.global.namespace=忽略全局命名空间

#inspection -> Fully qualified name usage
inspection.fully.qualified.name.usage=限定符可以替换为导入
inspection.fully.qualified.name.usage.option.enable.file.scope=在文件范围内启用
inspection.fully.qualified.name.usage.name.option.ignore.global.namespace=忽略全局命名空间

#inspection -> Multiple classes declaration in one file
inspection.multiple.classes.declarations.in.one.file=在此文件中声明了另一个类
#inspection -> Namespace name is not matched with project structure
inspection.illegal.psr.class.path.namespace.name.is.not.matched.to.psr0=命名空间名称与 PSR-0/PSR-4 项目结构不匹配
inspection.illegal.psr.class.path.class.is.not.matched.to.psr0=类名与包含的文件名不匹配

#inspection -> Traditional Syntax Array Declaration Inspection
inspection.traditional.syntax.array.literal.detected=使用了传统语法数组文字

#inspection -> Too Many Parameters
inspection.too.many.parameters=参数数量超出指定限值
inspection.too.many.parameters.max.number.of.parameters=最大参数数量
inspection.too.many.parameters.ignore.constructors=忽略构造函数

#inspection -> Parameters count mismatch
inspection.method.parameters.count.mismatch=为方法调用提供了 {0} 个参数，但方法签名使用了 {1} 个参数
inspection.method.parameters.count.mismatch.option.ignore.underscore=忽略最后一个参数为 $_ 的函数/方法
inspection.method.parameters.count.mismatch.option.ignore.func.get.arg=忽略带有 func_get_arg/func_get_args 调用的函数/方法

#inspection -> Method __toString is not implemented
inspection.method.to.string.is.not.implemented.strict.mode=检查每种表达式类型是否存在 __toString
inspection.method.to.string.is.not.implemented=没有为类 ''{0}'' 实现方法 ''__toString''

#inspection -> Method or class is not case sensitive
inspection.codeSmell.function.call.is.not.casesensitive=函数/方法调用中的大小写与声明中的大小写不匹配
inspection.codeSmell.class.call.is.not.casesensitive=类用法中的大小写与声明中的大小写不匹配
inspection.codeSmell.namespace.reference.is.not.casesensitive=命名空间引用中的大小写与声明中的大小写不匹配

#inspection -> Method visibility shouldn't be overridden
inspection.codeSmell.overriding.method.visibility.description=方法可见性不应被重写

#inspection -> Usage of a variable variable
inspection.variable.variable=使用了可变变量

#inspection -> Strict type checking rules violation
inspection.strict.type.checking.parameter=应为 ''{0}'' 类型的参数，提供的是 ''{1}''
inspection.strict.type.checking.parameter.batch=参数 '\#ref' 类型与声明不兼容
inspection.strict.type.checking.return=返回值必须为 ''{0}'' 类型，返回的是 ''{1}''
inspection.strict.type.checking.return.batch=返回值类型与声明不兼容
inspection.strict.type.checking.option=为所有文件启用
inspection.strict.type.checking.field.assignment=属性必须为 ''{0}'' 类型，提供的是 ''{1}''

#inspection -> Incompatible return type
inspection.incompatible.return.type=返回值应为 ''{0}''，返回的是 ''{1}''
inspection.incompatible.return.type.batch=返回值类型与声明不兼容
inspection.incompatible.return.type.strict.type.checking=严格类型检查
#inspection -> Missing strict types declaration
inspection.missing.strict.types.declaration=缺少严格类型声明
inspection.missing.strict.types.declaration.add.declaration=添加严格类型声明

#inspection -> Magic method visibility
inspection.magic.method.visibility.must.be.public=魔术方法 ''{0}'' 必须为 public
inspection.magic.method.visibility.must.be.static=魔术方法 ''{0}'' 必须为 static
inspection.magic.method.visibility.cannot.be.static=魔术方法 ''{0}'' 不能为 static

#inspection -> Naming convention
inspection.naming.convention.problem.descriptor.short={0} 名称 <code>\#ref</code> 太短（{1} < {2}）\#loc
inspection.naming.convention.problem.descriptor.long={0} 名称 <code>\#ref</code> 太长（{1} > {2}）\#loc
inspection.naming.convention.element.descriptor.regexp={0} 名称 <code>\#ref</code> 不匹配正则表达式 ''{1}'' \#loc
inspection.naming.convention.element.description.class=类
inspection.naming.convention.element.description.method=方法
inspection.naming.convention.element.description.property=特性
inspection.naming.convention.element.description.variable=变量
inspection.naming.convention.element.description.function=函数
inspection.naming.convention.element.description.constant=常量

#inspection -> Replaceable assignment
inspection.assignment.replaceable.with=<code>\#ref</code> 可以替换为 ''{0}'' \#loc

#inspection -> Constructor style
inspection.constructor.style=旧式构造函数

#inspection -> Statement has empty body
inspection.statement.has.empty.body.comments.count.as.content=注释计为内容
inspection.statement.has.empty.body.ignore.empty.while=忽略无主体的 'while' 循环
inspection.statement.has.empty.body.ignore.empty.for=忽略无主体的 'for' 循环

#inspection -> Convert loop to array_map
inspection.loop.can.be.converted.to.arraymap=循环可以转换为 'array_map' 调用

#inspection -> Convert loop to array_filter
inspection.loop.can.be.converted.to.arrayfilter=循环可以转换为 'array_filter' 调用

#inspection -> Convert loop to array_fill
inspection.loop.can.be.converted.to.arrayfill=循环可以转换为 'array_fill' 调用

#inspection -> Convert array_map to loop
inspection.arraymap.can.be.converted.to.loop='array_map' 调用可以转换为循环

#inspection -> Convert array_filter to loop
inspection.arrayfilter.can.be.converted.to.loop='array_filter' 调用可以转换为循环

#inspection -> Convert array_fill to loop
inspection.arrayfill.can.be.converted.to.loop='array_fill' 调用可以转换为循环

#inspection -> Ignored class alias declaration
inspection.ignored.class.alias.declaration=忽略了类别名声明

#inspection -> Format function parameters mismatch
inspection.format.function.parameters.mismatch.parameter=参数未映射到任何转换规范
inspection.format.function.parameters.mismatch.conversion.specification=转换规范未映射到任何参数

inspection.export.results.const=常量
inspection.export.results.back.traces=反向跟踪

inspection.unused.symbol.check.fields=属性
inspection.unused.symbol.check.methods=方法
inspection.unused.symbol.check.classes=类
inspection.unused.symbol.check.constants=常量
inspection.unused.symbol.check.anonymous_classes=匿名
inspection.unused.symbol.check.functions=函数
inspection.unused.symbol.check.magic_method=魔术方法
inspection.unused.symbol.export.calls=调用
inspection.unused.symbol.export.call=调用
inspection.unused.symbol.export.label=标签
inspection.unused.symbol.export.reachable_element=可到达
inspection.unused.symbol.export.entry=入口点
inspection.unused.symbol.export.abstract=抽象的
inspection.unused.symbol.export.closure=结束
inspection.unused.symbol.export.test_method=测试

inspection.composer.file.reference.problem=路径 ''{0}'' 未找到

#inspection -> Method may be static
inspection.method.may.be.static=方法可以是 'static'

#inspection -> Missing field type
inspection.missing.field.type=缺少属性的类型声明

inspection.unpacked.argument.type.mismatch=仅可解压缩数组和 Traversable，获得的是{0}

inspection.closure.can.be.converted.to.arrow.function=闭包可以转换为箭头函数

inspection.field.assignment.type.mismatch=类型不兼容\: 应为 ''{0}'' 类型的属性，提供的是 ''{1}''

inspection.duplicate.switch.case.body=''switch'' 中的分支是 ''{0}'' 分支的重复项

inspection.switch.without.default.case='Switch' 没有默认分支

inspection.doc.field.type.mismatch=属性类型不匹配

inspection.nested.ternary.expression=嵌套三元表达式自 PHP 7.4 已弃用

inspection.statement.without.braces=控制语句主体无大括号
inspection.statement.without.braces.fix.name=将大括号添加到 ''{0}'' 语句

inspection.single.statement.with.braces=单语句主体带大括号
inspection.single.statement.with.braces.fix.name=从 ''{0} 语句中移除大括号

inspection.curly.braces.access.syntax.usage=花括号访问语法自 PHP 7.4 已弃用

inspection.expression.have.same.operands=表达式有相同操作数

inspection.deprecated.cast={0} 转换自 PHP {1} 已弃用
inspection.deprecated.implode.usage=带参数(数组，字符串)调用的 {0} 自 PHP 7.4 已弃用

quickfix.replace.curly.braces.with.brackets=将花括号替换为中括号

#quickfix
quickfix.is.not.available.in.dump.mode=在索引更新期间，''{0}'' 快速修复不可用
quickfix.cannot.apply.quick.fix=无法应用快速修复
quickfix.cannot.find.class.reference=无法找到要解析的类引用
quickfix.cannot.find.target.class=无法从引用 ''{0}'' 解析类
quickfix.multiple.target.class.resolve=类 ''{0}'' 有多个声明
quickfix.import.base.no.candidates=无法找到要导入的候选项

#quickfix -> PhpCaseSensitiveQuickFix
quickfix.overriding.method.visibility=移除可见性重写

#quick fix for:
quickfix.create.class=创建类
quickfix.failed.to.create.class=无法创建类 ''{0}''

#quic fix for:{PhpConstructorStyleInspection} -> Convert constructor to new style
quickfix.convert.to.new.style.constructor=将构造函数转换为新样式

#quick fix for: {PhpUnderfinedVariableInspection} -> Create parameter
quickfix.create.parameter=创建参数
quickfix.create.parameter.selected.function.method.has.usages=所选函数/方法具有用法

#quick fix for: {PhpUnderfinedVariableInspection} -> Add to use
quickfix.add.to.use=添加到闭包 'use' 结构

#quickfix -> PhpImportClassQuickFix
quickfix.import.class.name=导入类
quickfix.import.class.popup.title=要导入的类

#quickfix -> PhpImportConstantQuickFix
quickfix.import.constant.name=导入常量
quickfix.import.constant.popup.title=要导入的常量

#quickfix -> PhpImportFunctionQuickFix
quickfix.import.function.name=导入函数
quickfix.import.function.popup.title=要导入的函数

#quickfix -> PhpAddFieldDeclarationQuickFix
quickfix.add.field.dialog.title=添加属性

#quickfix -> PhpAddMethodDeclarationQuickFix
quickfix.add.method.dialog.title=添加方法

#quickfix -> MakeCallDynamicQuickFix
quickfix.can.not.find.static.method.reference=无法找到静态方法引用

#quickfix -> MakeCallStaticQuickFix
quickfix.make.call.static.name=使调用为静态
quickfix.can.not.find.dynamic.method.reference=无法找到动态方法引用

#quickfix -> PhpAddFunctionFromCallback/PhpAddMethodFromCallback/PhpAddFieldFromCallback
quickfix.create.from.callback.family.name=从回调创建
quickfix.create.field.from.callback.name=从回调创建属性
quickfix.create.field.from.callback.invalid.element=无法从回调提取属性名称
quickfix.create.field.from.callback.unresolved.class.ref=无法从回调创建属性。无法解析目标类引用。
quickfix.create.field.from.callback.ambiguity.class.ref=无法从回调创建属性。类引用解析中不明确。
quickfix.create.method.from.callback.name=从回调创建方法
quickfix.create.method.from.callback.invalid.element=无法从回调提取方法名称
quickfix.create.method.from.callback.unresolved.class.ref=无法从回调创建方法。无法解析目标类引用。
quickfix.create.method.from.callback.ambiguity.class.ref=无法从回调创建方法。解析的类引用不明确。
quickfix.create.function.from.callback.name=从回调创建函数
quickfix.create.function.from.callback.invalid.element=无法从函数回调提取 FQN
quickfix.create.function.from.callback.another.namespace=无法在 ''{0}'' 命名空间中创建函数

#quickfix -> PhpChangeParameterTypeQuickFix/PhpChangeReturnTypeQuickFix/PhpExtendReturnTypeQuickFix
quickfix.strict.type.checking.change.parameter.type.name=将{0, choice, 1\#第 1 个|2\#第 2 个|3\#第 3 个|4\#第 {0,number} 个}参数的类型从 ''{1}'' 更改为 ''{2}''
quickfix.strict.type.checking.change.parameter.type.family=更改参数类型
quickfix.strict.type.checking.change.return.type.name=将返回类型从 ''{0}'' 更改为 ''{1}''
quickfix.strict.type.checking.change.return.type.family=更改返回类型
quickfix.strict.type.checking.extend.return.type.name=将返回类型从 ''{0}'' 扩展为 ''{1}''
quickfix.strict.type.checking.extend.return.type.family=扩展返回类型

#quickfix -> PhpCaseSensitiveQuickFix
quickfix.case.sensitive.name=更改 {0} 的大小写以匹配其声明

#quickfix -> Replace assignment with operator assignment
quickfix.replace.assignment.with.operator.assignment.family.name=Replace Assignment with Operator Assignment
quickfix.replace.assignment.with.operator.assignment.name=将 ''\='' 替换为 ''{0}\=''

#quickfix -> Replace assignment with prefix expression
quickfix.replace.assignment.with.prefix.expression.family.name=将赋值替换为前缀表达式
quickfix.replace.assignment.operator.with.prefix.expression.family.name=将赋值运算符替换为前缀表达式

quickfix.replace.one.operator.with.another=用''{1}''替换''{0}''

#quickfix -> Convert loop to array_map
quickfix.convert.loop.to.arraymap=将循环转换为 'array_map' 调用

#quickfix -> Convert loop to array_filter
quickfix.convert.loop.to.arrayfilter=将循环转换为 'array_filter' 调用

#quickfix -> Convert loop to array_fill
quickfix.convert.loop.to.arrayfilll=将循环转换为 'array_fill' 调用

#quickfix -> Convert array_map to loop
quickfix.convert.arraymap.to.loop=将 'array_map' 调用转换为循环

#quickfix -> Convert array_filter to loop
quickfix.convert.arrayfilter.to.loop=将 'array_filter' 调用转换为循环

#quickfix -> Convert array_fill to loop
quickfix.convert.arrayfill.to.loop=将 'array_fill' 调用转换为循环

#quickfix -> PHPUnit create missing target class
quickfix.phpunit.create.target.class.error.filename.exists=存在文件 {0}

#quickfix -> Replace current method with alternative 
quickfix.phpunit.replace.current.method.with.alternative=替换为 {0}

#quickfix -> Drop redundant optional parameters
quickfix.phpunit.drop.redundant.optional.parameters=删除冗余的可选参数

#quickfix -> Flip misordered assertEquals/assertNotEquals arguments
quickfix.phpunit.assert.equals.flip.compared.arguments=翻转比较参数

#quickfix -> Unnecessary qualifier
quickfix.remove.unnecessary.qualifier=移除不必要的限定符
quickfix.remove.unnecessary.qualifier.on.class.name=简化 FQN

#quickfix -> Disable for global namespace
quickfix.disable.inspection.for.global.namespace=为全局命名空间禁用检查

#quickfix -> Make method static
quickfix.make.method.static=使 'static'

#quickfix -> Change field type
quickfix.change.field.type.to.match.super=更改类型以匹配 super
quickfix.change.field.type.add.inferred.type.family.name=作为属性的类型添加推断的类型
quickfix.change.field.type.add.inferred.type.name=作为属性的类型添加 ''{0}''
quickfix.change.field.type.add.inferred.type.error.read.only=无法修改只读文件 ''{0}''
quickfix.change.field.type.add.inferred.type.error.non.project=无法修改非项目文件 ''{0}''

#quickfix -> Remove redundant PHPDoc
quickfix.remove.phpdoc=移除冗余 PHPDoc 注释

quickfix.phpdoc.update.type=更新 PHPDoc 类型

quickfix.replace.nested.ternary.expression=将三元表达式替换为 {0} 关联版本

quickfix.set.inheritance.between.classes=使{0} {1} {2}

quickfix.navigate.to.duplicate.array.key=导航到重复键

#quickfix -> Delete return argument
quickfix.delete.return.argument=删除返回参数

#intentions

#intentions Replace ?: expression with If
intention.replace.ternary.expression.with.if=将 '?\:' 替换为 if

#intentions Replace If with ?: expression
intention.replace.if.with.ternaryExpression=简化 If

#intentions -> Convert To Short Syntax
intention.convert.to.short.syntax=将数组转换为短语法
intention.convert.to.traditional.syntax=将数组转换为传统语法

#intentions -> Convert To Short Syntax (list)
intention.convert.to.short.syntax.list=将列表转换为短语法
intention.convert.to.traditional.syntax.list=将列表转换为传统语法

#intentions -> Declare Field
intention.declare.missing.field=声明属性

#intentions -> Declare Property
intention.declare.missing.property=添加 @property

#intentions -> Flip Binary Expression
intention.flip.binary.expression.family.name=Flip Binary Expression
intention.flip.binary.expression.text1=Flip 'equals'
intention.flip.binary.expression.text2=翻转 ''{0}'' (可能更改语义)
intention.flip.binary.expression.text3=翻转 ''{0}'' (更改语义)

#intentions -> Namespace Bracing
intention.namespace.bracing=将命名空间转换为带大括号

#intentions -> Smart Line Split
intention.line.split=在两个字符串和串联中拆分字符串

#intentions -> Split comma-separated values
intention.split.comma.separated.values=将逗号分隔的值拆分为多行
intention.join.comma.separated.values=将逗号分隔的值合并为一行

#intentions -> Swap Call Arguments
intention.swap.call.arguments.family.name=交换调用参数
intention.swap.call.arguments.text1=交换 ''{0}'' 和 ''{1}''

#intention -> Add variable PHPDoc comment
intention.variable.add.phpdoc.comment.family.name=添加 PHPDoc 注释

#intention -> Import class
intention.import.class=作为别名导入类
intention.import.class.alias.name=别名\:
intention.import.class.alias.already.exists=已导入具有相同别名的类

#intention -> Simplify FQN
intention.simplify.fqn=简化 FQN

#intention -> Generate PHPDoc
intention.generate.phpdoc=生成 PHPDoc

#intention -> Surround With Call
intention.can.not.find.statement.to.surround=无法找到要环绕的目标语句。
intention.statement.to.surround.failed.message=无法用 ''{0}'' 环绕语句。

#intention -> Replace quotes
intention.replace.quotes=无法替换引号 - 转义符号无效且不受支持

#intention -> Replace with alias
intention.replace.class.with.alias=替换为别名

#intention -> Inline alias
intention.inline.alias=内联别名

#intention -> Add constructor parameters
intention.add.constructor.parameters=添加构造函数参数
intention.add.constructor.parameters.fields.chooser.dialog.title=选择要在构造函数中初始化的属性

#intention -> Implement the interface
intention.implement.interface=实现接口

intention.merge.condition.with.outer=与外部条件合并

#navigation -> Goto Super Method
navigation.goto.super.method.is.not.available=索引更新期间无法在此处导航

#run and debug
url.must.not.be.empty={0} 不得为空
web.path=Web 路径
default.browser=默认(通用)
connection.failed=连接失败\: {0}
debug.connection.error=连接错误\: {0}

#dbgp debugging protocol
dbgp.invalid.packet=数据包无效

#annotator
annotator.duplicate.use.statement=无法使用 ''{0}''，因为该名称已被使用
annotator.reserved.class.name=无法使用 ''{0}'' 作为类名，因为该名称已被保留
annotator.invalid.class.name=''{0}'' 是无效的类名
annotator.special.class.name=无法将 {0} 用作 {1}，因为 ''{1}'' 是一个特殊的类名
annotator.cannot.break.continue=无法中断/继续{0}级别
annotator.jump.out.of.finally=不允许跳出 finally 块
php.annotator.expecting.interface=应为接口引用
php.annotator.expecting.class=预期为类引用
php.annotator.exchange.extends.implements.keyword=改变''{0} {2}''到''{1} {2}''
php.annotator.strict.types.first.statement='strict_types' 声明必须是脚本中的第一个语句
php.annotator.strict.types.block.mode='strict_types' 声明不能使用块模式
php.annotator.heredoc.indent.validation.mixed.space.and.tab.characters=结束标识符缩进中混用了空格和制表符字符
php.annotator.heredoc.indent.validation.wrong.content.indent=缩进错误\:应与结束标记缩进相同
php.annotator.typed.property.illegal.value=''{0}'' 类型的属性可能没有默认值
php.annotator.typed.property.type.mismatch=默认值只能是 ''{0}'' 类型
php.annotator.typed.property.type.mismatch.fix.nullable=使属性类型可为 null
php.annotator.typed.property.type.mismatch.fix.change=将属性类型更改为 ''{0}''
php.annotator.typed.property.type.mismatch.fix.family=更改属性类型以匹配默认值的类型
php.annotator.typed.property.callable.is.illegal=属性不能有 'callable' 类型
php.annotator.return.type.non.nullable.null.returned=无法返回 'null'\: 返回类型不可为 null
php.annotator.return.type.make.nullable.fix=使返回类型可为 null
php.annotator.void.function.must.not.return.value=void 函数不得返回值
php.surround.with.if=if

#quality tool
quality.tool.configuration.tool.path.is.empty=所选配置的 {0} 路径为空
quality.tool.configuration.can.not.find.configuration.by.id=按 ID 无法找到 {0} 配置\: ''{1}''
quality.tool.configuration.default.interpreter.is.not.found=默认选择 {0} 配置解释器，但未指定解释器
quality.tool.configuration.for.interpreter.is.not.found=找不到解释器的 {0} 配置\: ''{1}''
quality.tool.configuration.interpreter.is.undefined={0} 配置的解释器未指定或无效
quality.tool.configurable.by.interpreter.selected.is.not.supported={0} 解释器无法用于运行{1}
quality.tool.can.not.create.temporary.file=无法创建临时文件
quality.tool.configuration.interpreter.was.reloaded=解释器信息已成功更新
quality.tool.configurable.by.interpreter.interpreter.is.project.level.warning={0} 保存在 IDE 设置中，但是所选解释器在项目设置中定义
quality.tool.phpcs.custom.rules.warning=选择 'Custom' 编码标准类型以选择自定义规则集。
quality.tool.phpcs.custom.rules.validation.not.xml=所选规则集不是 XML
guality.tool.configuration.show.ignored.files=显示忽略的文件
quality.tool.phpcs.installed.paths=已安装的标准路径
quality.tool.phpcs.specify.installed.paths=指定具有已安装标准路径的目录
quality.tool.empty.path.phpcs=Phpcs 路径为空
quality.tool.unknown.problem=未知问题
quality.tool.phpcbf.location=PHPCBF 位置
quality.tool.phpcbf.location.descr=选择有效的 phpcbf 启动器
quality.tool.phpcbf.settings=PHP Code Beautifier and Fixer 设置
quality.tool.phpcbf.path=phpcbf 路径\:
quality.tool.phpcbf.reformat.action=PHP Code Beautifier and Fixer\: 修复整个文件
quality.tool.phpcbf.name=PHP Code Beautifier and Fixer
quality.tool.selected.file.is.not.phpcbf=所选文件不是 phpcbf 可执行文件
quality.tool.file.not.found.phpcbf=找不到文件 {0}
quality.tool.file.not.phpcbf=所选文件不是 phpcbf
quality.tool.directory={0} 是目录
quality.tool.cs.fixer.custom.rules.warning=选择 'Custom' 类型以选择您的配置。
quality.tool.php_cs.custom.rules.validation.not.php_cs=PHP CS Fixer (.php_cs 或 .php_cs.dist)不支持所选规则集
quality.tool.php_cs.dir.does.not.contain.custom=该目录不包含受支持的{0}或{1}
quality.tool.php.dir.does.not.contain=该目录不包含{0}
quality.tool.can.not.determine.version=无法确定工具版本，得到 ‘{0}’
quality.tool.file.not.found=找不到文件。
quality.tool.file.x.not.found=找不到文件 {0}.
quality.tool.path.must.not.be.empty=路径不能为空。
quality.tool.can.not.retrieve.standards=无法检索可用规则集，请检查 PHP CS Fixer 工具配置。
quality.tool.phpcs.can.not.retrieve.standards=无法检索可用标准，请检查 PHP_CodeSniffer 工具配置。
quality.tool.stardards.has.been.updated=已安装的规则集列表已更新。
quality.tool.coding.stardards.has.been.updated=已安装的编码标准列表已更新。
quality.tool.cs.fixer.allow.risky.rules=允许风险规则
quality.tool.cs.fixer.reformat.action=PHP CS Fixer\: 修复整个文件
quality.tool.cs.fixer.ruleset=规则集\:

quality.tool.phpmd.custom.rules.not.supported=所选解释器不支持自定义规则

quality.tool.phpcs.required.phpcs.version=所需的 PHP_CodeSniffer 版本为 1.5.0 或更高，找到的是 {0}
quality.tool.php.cs.fixer.required.phpcs.version=支持的 PHP CS Fixer 版本为 2.8.0 或更高，找到的是 {0}

quality.tool.label.check.files.with.extensions=检查带扩展名的文件\:
quality.tool.label.coding.standard=编码标准\:
quality.tool.checkbox.installed.standard.paths=已安装的标准路径\:
quality.tool.checkbox.show.sniff.name=显示 sniff 名称
quality.tool.checkbox.show.warning.as=将警告显示为\:
quality.tool.label.tool.path=工具路径\:
quality.tool.label.tool.process.timeout.sec.1.30=工具处理超时，[1...30] 秒\:
quality.tool.button.validate=验证
quality.tool.label.validation.label=验证标签
quality.tool.label.custom.rulesets=自定义规则集\:
quality.tool.phpcs.label.path.to.ruleset=规则集路径\:
quality.tool.label.label=标签
quality.tool.label.configuration=配置\:

#phpunit messages
php.unit.local.run.display.name=PHPUnit
php.unit.local.run.description=PHPUnit
php.file.name.empty=未指定测试文件
php.directory.name.empty=未指定测试目录
php.file.not.found=文件 ''{0}'' 不存在
php.directory.not.found=未找到目录 ''{0}''
php.not.directory=''{0}''不是一个目录。
php.class.not.found=在测试文件中找不到类 ''{0}''
php.not.test.method=类 ''{1}'' 中的方法 ''{0}'' 不是测试方法
php.method.not.found=在类 ''{1}'' 中未找到方法 ''{0}''
php.method.name.empty=未指定测试方法
php.xml.file.path.empty=未指定 XML 文件
php.unit.include.group=包含
php.unit.exclude.group=类排除过滤器
php.unit.group.name=分组名
php.unit.radio.button.composite=复合
php.unit.test.runner.options=测试运行程序选项
php.unit.checkbox.use.alternative.patterns.base.path=使用替代模式基路径\:
php.unit.optional=可选
php.unit.label.test.file.template=测试文件模板(&T)\:

php.choose.dir=选择测试目录

php.class.duplicate=测试文件包含几个名为 ''{0}'' 的类
file.not.in.project=文件 ''{0}'' 不在源根目录下
directory.not.in.project=目录 ''{0}'' 不在内容根目录下
directory.contains.no.php.files=目录 ''{0}'' 不包含 php 文件
test.class.is.empty=未指定测试类
php.not.test.class.or.suite=类 ''{0}'' 不是测试类或套件
php.not.test.class=类 ''{0}'' 不是测试类
file.name.is.not.specified=未指定文件名
no.class.found=在文件 ''{0}'' 中未找到 php 类
no.class.with.name.found=在文件 ''{1}'' 中未找到 ''{0}'' 类

php.unit.run.configuration.page=PHPUnit 运行配置页面
configuration.file.is.not.specified=未指定配置文件
configuration.file.not.found=未找到配置文件 {0}

file.not.specified=未指定文件
file.invalid=文件 ''{0}'' 不存在
choose.file=选择 PHP 文件
choose.path=选择路径
wrong.file.type=文件 ''{0}'' 不是 PHP 文件
failed.to.run=无法启动 PHP 进程\: {0}
choose.php.home=选择 PHP 可执行文件
php.unit.remote.run.display.name=PHPUnit (HTTP)
php.unit.remote.run.description=通过向 Web 应用程序发起 HTTP 请求执行 PHPUnit 测试
no.valid.mapping.found.for=未找到 ''{0}'' 的有效映射
remote.path.for.0.is.excluded.from.mappings.1=''{0}'' 的远程路径已被从映射中排除\: ''{1}''
failed.to.retrieve.test.data=无法在 ''{0}'' 从服务器检索测试结果。
executing.tests=正在执行测试
cleaning.up=正在清理…
this.reassignment.is.not.allowed=不能重新分配 $this
cant.use.temporary.expression.in.write.context=在写上下文中不能使用临时表达式
parsing.error.statement.expected=应为语句
smarty.configurable.title=Smarty
analyzing.php.sdk=正在检查 PHP 安装…
include.path.column.info=路径
failed.to.read.php.sdk.info.0=无法检查 PHP 安装\: {0}
php.sdk.version.local=PHP 版本\: {0}
php.sdk.version.server=服务器上的 PHP 版本\: {0}
overwrite.include.paths.dialog.text=PHP 安装 include 路径不同于当前。\n\
覆盖当前路径还是将它们合并在一起?
overwrite.include.paths.dialog.title=更新 Include 路径
overwrite.include.paths.dialog.overwrite=&覆盖
overwrite.include.paths.dialog.merge=&合并
review.php.sdk.settings=检查 PHP 设置
php.sdk.step.title=PHP 设置
php.sdk.autodetect.failed=无法确定服务器 ''{0}'' 上的 PHP 安装。
include.paths.label.local=Include 路径\:
include.paths.label.server=服务器上的 Include 路径\:
local.path.empty=未指定本地路径
server.label.text=服务器(&E)：
include.path.is.empty=未指定 Include 路径。
include.path.is.not.found=找不到本地项目 ''{0}''。
failed.to.parse.script.output=执行诊断脚本时出错
working.directory.invalid=找不到工作文件夹 ''{0}''
custom.working.directory.label=自定义工作目录(&W)\:

#control flow
control.flow.access.description=(访问\: ''{0}'' 名称\: ''{1}'')

#validation common
validation.file.already.exists.in.dir=名称为“{0}”的文件已存在于“{1}”中
validation.file.already.exists=文件"{0}" 已存在
validation.file.not.valid.name=“{0}”不是有效的文件名
validation.class.not.valid.name=“{0}”不是有效的类名
validation.namespace.not.valid.name=“{0}”不是有效的命名空间名称
validation.invalid.identifier=“{0}”不是有效的标识符
validation.invalid.identifier.with.no.identifier=插入的标识符无效
validation.invalid.alias=“{0}”不是有效的别名
validation.value.is.not.specified.or.invalid={0} 未指定或无效。
validation.value.path.to.value.should.be.specified={0} 的路径应在 {1} 中指定
validation.value.path.to.value.is.invalid=无法通过 {1} 中提供的路径找到 {0}
validation.value.path.to.value.is.invalid.press.fix.project.configuration=无法通过 {1} 中提供的路径找到 {0}。按“修复”以编辑 {2} 配置。
validation.value.is.not.specified.or.invalid.press.fix.project.configuration={0} 未指定或无效。按“修复”编辑您的项目配置。
validation.value.is.not.specified.press.fix.project.configuration={1} 配置中未指定 {0}。按“修复”以编辑 {1} 配置。
validation.press.fix.to.edit.project.configuration=按“修复”编辑您的项目配置。
validation.value.is.invalid={0} 无效
validation.0.not.found.at.1=在 ''{1}'' 中找不到 ''{0}''
validation.0.is.not.a.directory=''{0}''不是一个目录。
validation.0.extension.is.not.installed=未安装 ''{0}'' 扩展
validation.debug.extension.is.updated=调试扩展设置已更新。请重新运行当前配置以使用新值。
validation.0.extension.is.installed.check.configuration.options=已安装 ''{0}'' 扩展。检查配置选项。
validation.no.debug.extension.is.installed=未安装调试扩展。
validation.0.is.only.available.since.1={0} 仅自 {1} 起可用
validation.cannot.parse.value.of.0=无法解析 ''{0}'' 的值
validation.connection.was.not.established=未建立连接。
validation.connection.was.not.established.0=无法使用 ''{0}'' 启动调试器会话
validation.connection.was.not.established.no.debug=未安装调试扩展
validation.connection.was.not.established.update.info=更新解释器信息
validation.connection.was.not.established.validate.installation=验证安装
validation.function.already.exists = 当前命名空间中已定义具有相同名称的函数
validation.namespace.already.exists = {1}中已定义名称为 ''{0}'' 的命名空间
validation.class.already.exists = {0}中已经存在具有相同名称的类
validation.class.cannot.be.overridden = 类“{0}”不能被重写
validation.interface.cannot.be.overridden = 无法实现接口“{0}”
validation.test.no.test.patterns = 未添加任何模式

validation.ssh.remote.debug.support=''{0}'' 扩展不支持通过 ssh 进行远程调试。
validation.ssh.remote.code.coverage.support={0} 扩展不支持通过 ssh 进行代码覆盖
remote.interpreter.path.mappings.validation.title=没有为所选解释器配置路径映射。
remote.interpreter.path.mappings.validation.message=请检查映射是否在 {0} 下正确配置。
remote.interpreter.path.mappings.validation.php.section=<b><i><a href\="php_mappings">设置|PHP</a></i></b>
remote.interpreter.docker.is.not.supported=不支持基于 Docker 的 PHP 解释器

docker.compose.coverage.file.is.not.found=找不到覆盖率文件
docker.compose.coverage.file.failed.to.copy=无法从 Docker 容器复制覆盖率结果
docker.compose.coverage.file.failed.to.extract=无法提取覆盖率结果
docker.compose.radio.button.always.start.a.new.container.docker.compose.run=始终启动一个新容器('Docker-compose run')
docker.compose.radio.button.connect.to.existing.container.docker.compose.exec=连接到现有容器('Docker-compose exec')

#errors common
error.template.unable.parse.internal.template=无法解析内部模板 {0}
error.template.unable.create.from.internal.template=无法从内部模板 {0} 创建文件
error.template.invalid.internal.template=内部模板 {0} 无效
error.file.unable.create.selected.directory=无法在所选目录中创建文件 {0}
error.cannot.connect.to.0.1=无法连接到 ''{0}''\: {1}
error.cannot.connect.to.0=无法连接到 ''{0}''

#messages common
0.completion.shortcut=使用{1}进行{0}补全

#completion
completion.press.again.to.see.more.variants=再次按 {0} 以查看更多变体
completion.press.again.to.see.global.variants=再次按 {0} 以查看全局变体
completion.press.again.to.see.all.classes=再次按 {0} 以查看所有类

#unwrap
unwrap.if=解开 if...
unwrap.while=解开 while...
unwrap.for=解开 for...
unwrap.with=解开 with...
unwrap.try=解开 try...
unwrap.else=解开 else...
unwrap.elseif=解开 elseif…
unwrap.dowhile=解开 do-while…
unwrap.foreach=解开 foreach…
unwrap.method=开启 ''{0}''
remove.else=移除 else...


#refactoring
refactoring.common.not.supported.expression.in.scope=当前范围不支持此类表达式的{0}
refactoring.common.not.supported.context=当前上下文不支持{0}
refactoring.common.not.extractable.expression=不支持此类表达式
refactoring.common.fail.to.extract.expression=无法从所选代码片段中提取表达式

refactoring.common.ui.target.namespace.label=&命名空间\:
refactoring.common.ui.target.directory.label=目标目录\: (&D)
refactoring.common.ui.target.directory.edit = 按 F2 编辑目标目录

refactoring.common.validation.namespace.name=“{0}”不是有效的命名空间名称
refactoring.common.validation.class.psi=无法执行重构\: 目标类“{0}”无效
refactoring.common.validation.target.directory.is.not.valid=目录“{0}”的路径无效
refactoring.common.validation.target.directory.not.inside.project=目录“{0}”不在项目内部

refactoring.parameter.reserved.name = 参数名称“{0}”已保留
refactoring.parameter.validation = 参数 {0} 无效
refactoring.parameter.validation.duplicate.parameter=重复的参数名称：{0}
refactoring.parameter.validation.initializer.last=必选参数不能位于可选参数后
refactoring.parameter.validation.variadic.last=只有最后一个参数可以是可变参数
refactoring.parameter.validation.variadic.can.have.default.value=可变参数不能具有默认值
refactoring.parameter.validation.initializer.type=具有类类型提示的参数的默认值只能为 NULL
refactoring.parameter.validation.pass.by.reference=仅变量可通过引用传递
refactoring.parameter.validation.type=参数类型 ''{0}'' 无效
refactoring.parameter.validation.default.value=默认值表达式 ''{0}'' 无效
refactoring.parameter.validation.initializer=初始值设定项 ''{0}'' 无效
refactoring.parameter.validation.no.default.value=应该为参数 ''{0}'' 提供初始值设定项或默认值
refactoring.parameter.validation.name.collision.with.use.list=参数名称 ''{0}'' 无效。''{0}'' 已导入 use 列表
refactoring.returnType.validation.type=返回类型 ''{0}'' 无效

#refactoring - > extract base
refactoring.extract.base.validator.not.valid.identifier=“{0}”不是有效的 PHP 标识符。
refactoring.extract.base.validator.reserved.keyword=“{0}”是保留的 PHP 关键字。
refactoring.extract.base.handler.no.expression.selected=选择不构成正确的表达式
refactoring.extract.base.handler.not.supported.expression=此类表达式不支持{0}
refactoring.extract.base.handler.not.supported.scope=当前范围不支持{0}
refactoring.extract.base.dialog.replace.all.occurrences=替换所有匹配项(找到 {0} 个匹配项) (&A)

#refactoring -> extract variable
refactoring.extract.variable.name=提取变量
refactoring.extract.variable.conflict.already.exists=范围中已经存在名称为“{0}”的变量。
refactoring.extract.variable.conflict.superglobal.name=名称为“{0}”的变量将与超全局变量 ${1} 冲突。

#refactoring -> extract constant
refactoring.extract.constant.name=提取常量
refactoring.extract.constant.conflict.already.exists=范围中已经存在名称为“{0}”的常量。
refactoring.extract.constant.conflict.exists.in.subclass.with.weaker.access=“{0}”的访问级别必须为“{1}”(如在类“{2}”中)或更弱
refactoring.extract.constant.conflict.exists.in.subclass=“{0}\:\:{1}”将被此常量重写
refactoring.extract.constant.conflict.cannot.override.interface.constant=无法重写接口“{1}”的常量“{0}”
refactoring.extract.constant.unable.to.add.constant.declaration="无法添加常量声明"

#refactoring -> extract field
refactoring.extract.field.name=提取属性
refactoring.extract.field.validator.reserved.field.name=“{0}”是保留的属性名称
refactoring.extract.field.conflict.already.exists=该类中已经存在名称为“{0}”的属性。
refactoring.extract.field.visibility=可见性
refactoring.extract.field.visibility.public=public(&U)
refactoring.extract.field.visibility.protected=protected(&O)
refactoring.extract.field.visibility.private=private(&I)

#refactoring -> extract parameter
refactoring.extract.parameter.name=提取参数

#refactoring -> rename - > element processor
conflict.method.with.same.name.already.exists=此类中已经定义了具有相同名称的方法
conflict.field.with.same.name.already.exists=此类中已经定义了具有相同名称的属性
conflict.class.constant.with.same.name.already.exists=此类中已经定义了具有相同名称的常量
conflict.variable.with.same.name.already.exists=已经定义了具有相同名称的变量
conflict.parameter.with.same.name.already.exists=已经定义了具有相同名称的参数
conflict.tag.name.contains.close.tag=文本包含“{0}”
conflict.use.with.same.name.already.exists=已经定义了具有相同名称的 use 语句
conflict.class.with.same.name.already.exists=已经定义了具有相同名称的类
conflict.function.with.same.name.already.exists=已经定义了具有相同名称的函数
conflict.constant.with.same.name.already.exists=已经定义了具有相同名称的常量
refactoring.rename.search.in.global.scope=在全局范围中搜索

#refactoring -> rename - > automatic renamers
refactoring.rename.automatic.renamer.accessors.name=重命名访问器(&C)
refactoring.rename.automatic.renamer.field.accessors.dialog.title=重命名访问器
refactoring.rename.automatic.renamer.field.accessors.dialog.description=将具有以下名称的属性访问器重命名为\:
refactoring.rename.automatic.renamer.field.accessors.entity.name=访问器


refactoring.rename.automatic.renamer.class.name=重命名类(&C)
refactoring.rename.automatic.renamer.class.dialog.title=重命名类
refactoring.rename.automatic.renamer.class.dialog.description=将具有以下名称的类重命名为\:
refactoring.rename.automatic.renamer.class.entity.name=类

refactoring.rename.entity.name.inheritor=继承者/文件
refactoring.rename.inheritors.and.related.files.with.the.following.names.to=将具有以下名称的继承者和相关文件重命名为\:


#refactoring->inline variable
refactoring.inline.variable.cannot.extract.value=无法提取变量 ''${0}'' 的值
refactoring.inline.cannot.find.variable.to.inline=无法找到要内联的变量
refactoring.inline.variable.no.occurrences=没有匹配项可以被安全地内联

#refactoring->inline function
refactoring.inline.function.title=内联{0}重构
refactoring.inline.function.all.invocations.and.remove.the.method=全部内联并移除{0}(&A)
refactoring.inline.function.all.invocations.keep.the.method=全部内联并保留{0}(&E)
refactoring.inline.function.this.invocation.only.and.keep.the.method=仅内联此调用并保留{0}(&K)
refactoring.inline.function.command=正在内联{0}
refactoring.inline.function.undefined=未定义的函数
refactoring.inline.function.cannot.inline.function.with.global.usage=无法内联{0}和 <code>global</code> 用法
refactoring.inline.function.not.accessible.from.caller.site=无法从调用者站点访问成员引用 <code>{0}</code>
refactoring.inline.function.cannot.parse.function.body=无法解析函数体
refactoring.inline.function.cannot.inline.library.function=无法内联库函数
refactoring.inline.function.reference.is.ambiguous=函数引用不明确
refactoring.inline.function.only.static.method.is.supported=仅支持静态方法
refactoring.inline.function.reference.is.recursive=不支持递归调用
refactoring.inline.function.inline.function.refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=当返回语句中断执行流程时，不支持内联函数重构
refactoring.inline.function.parent.reference.unresolved=<code>parent</code> 类引用在 {0} 中未解析
refactoring.inline.function.yield.found.in.function.body=在函数体中找到 <code>yield</code> 用法

#refactoring->inline constant
refactoring.inline.constant.name=内联常量
refactoring.inline.constant.command=内联常量
refactoring.inline.constant.this.reference.only=仅内联此引用并保留常量
refactoring.inline.constant.all.references.and.remove=全部内联并移除常量
refactoring.inline.constant.all.references.and.keep=全部内联并保留常量
refactoring.inline.constant.cannot.extract.value=无法提取常量的值
refactoring.inline.constant.is.never.used=常量 {0} 从未使用
refactoring.inline.constant.multiple.declarations=还有其他具有相同名称的常量声明。

#refactoring -> extact method/function
refactoring.extract.method.name=提取函数/方法
refactoring.extract.method.error.can.not.extract.statements=无法从所选块中提取语句
refactoring.extract.method.error.selected.block.should.represent.a.set.of.statement.or.an.expression=选块应该代表一组语句或表达式.
refactoring.extract.method.error.a.set.of.statements.should.be.from.the.same.code.block=一组语句应来自同一代码块。
refactoring.extract.method.error.there.are.break.continue.operators.which.can.interrupt.execution=存在会中断执行的 break/continue 运算符。
refactoring.extract.method.error.inconsistent.return.points.in.selected.code.fragment=所选代码片段中的返回点不一致。
refactoring.extract.method.tooltip=输入 $name \= 'init'
PhpExtractMethodDialog.extract.method=提取方法
PhpExtractMethodDialog.extract.function=提取函数
PhpExtractMethodDialog.visibility=可见性\:
PhpExtractMethodDialog.public=public(&B)
PhpExtractMethodDialog.protected=protected(&T)
PhpExtractMethodDialog.private=private(&V)
PhpExtractMethodDialog.method=方法\:
PhpExtractMethodDialog.function=函数\:
PhpExtractMethodDialog.name=名称(&A)\:
PhpExtractMethodDialog.declare.static=声明静态 (&S)
PhpExtractMethodDialog.generate.php.doc=生成 PhpDoc(&G)
PhpExtractMethodDialog.parameters=参数
PhpExtractMethodDialog.signature.preview=签名预览
PhpExtractMethodDialog.replace.tail.break.continue.with.return=将尾“break/continue”语句替换为“return”语句(&T)
PhpExtractMethodDialog.return.output.through=通过以下方式返回输出变量\:
PhpExtractMethodDialog.return.output.through.return=返回语句(&E)
PhpExtractMethodDialog.return.output.through.ref.parameters=通过引用传递的参数(&P)
PhpExtractMethodDialog.transformation.options=转换选项
PhpExtractMethodDialog.output.variables=输出变量
PhpExtractMethodDialog.duplicates.count=检查并替换重复项(找到 {0} 个)
PhpExtractMethodDialog.duplicates.pending=搜索副本...

#find usages
find.options.include.child.methods.checkbox=包括重写/实现方法(&V)
find.field.accessors.title=搜索访问器
find.field.accessors.text=要搜索 ''{0}'' 的访问器吗?
usages.show.this.self.references=显示 $this/自引用

#refactoring -> change signature
change.signature.find.usages.of.base.interface=类 {1} 的方法 {0}\n\
实现了接口 {2} 的方法。\n\
要{3}基方法吗?
change.signature.find.usages.of.base.class=类 {1} 的方法 {0}\n\
重写了类 {2} 的方法。\n\
要{3}基方法吗?
change.signature.tooltip=输入 $name \= 'init' // 默认值
change.signature.tooltip.parameter=$name \= 'init' 或 &...$array \= 'init'
change.signature.tooltip.default.value=要在此方法的所有现有调用中使用的值
change.signature.error.wrong.caret.position=脱字符号应置于要重构的函数的名称处。
change.signature.usage.view.declarations.header=要重构的函数
change.signature.column.name.parameter=参数\:
change.signature.column.type.parameter=按类型分组\:
change.signature.column.default=默认\:
change.signature.initialize.new.parameters=创建并初始化类属性(&I)
change.signature.parameter.may.have.side.effect=用作参数“{1}”的表达式“{0}”可能会有副作用
change.signature.visibility.not.accessible=可见性为 {1} 的{0}将无法从{2}访问

#refactoring -> pull up/push down
refactoring.pull.up.class.does.not.have.base.classes.interfaces.in.project.files={0}在项目文件中没有基类/接口
refactoring.pull.up.implement.method = 在实现接口的类中创建方法存根(&S)
refactoring.pull.up.validation.field.into.interface = 无法将属性拉入接口
refactoring.pull.up.validation.static.method.into.interface = {0} 为静态，不能为抽象。
refactoring.pull.up.private.access = {0} 访问权限将更改为 {1}
refactoring.pull.up.abstract.method = 类 {0} 将被标记为抽象
refactoring.pull.up.conflict.duplicate.constant = {0} 将与 {1} 中的常量冲突。
refactoring.pull.up.will.not.be.accessible.in.the.target.class={0} 在目标类中将无法访问。
refactoring.pull.up.static.reference.is.not.accessible.in.the.target.class=非静态方法 {0} 不应在外部类中静态调用
refactoring.pull.up.may.not.be.accessible.in.the.target.class={0} 在目标类中可能无法访问。
refactoring.pull.up.is.1.and.will.not.be.accessible.in.the.target.class={0} 为 private，在目标类中将无法访问。
refactoring.push.down.method.implemented.in.interface={0} 必须被声明为 abstract 或实现 {1}
refactoring.push.down.validation.magic.method=移动魔术方法会产生副作用

#refactoring -> move class
refactoring.move.class.name = 移动类
refactoring.move.class.title = 将类 {0} 移至命名空间(&C)\:
refactoring.move.class.new.file = 将类提取到单独的文件(&E)
refactoring.move.class.in.non.code.message=注释和字符串中的类引用
refactoring.move.class.cannot.move.anonymous.class=无法移动匿名类

#refactoring -> move namespace
refactoring.move.namespace.name=移动命名空间
refactoring.move.namespace.title=移动命名空间 {0}
refactoring.move.namespace.new.namespace=新命名空间名称(&N)\:
refactoring.move.related.namespace.description=将具有相关命名空间的文件移至新目录\:
refactoring.move.related.namespace.title=移动具有相关命名空间的文件
refactoring.move.related.namespace.name.column=新命名空间名称
refactoring.move.related.namespace.directory.column=新建目录
refactoring.move.related.namespace.collect.title=收集子命名空间
refactoring.move.namespace.header.message=移动命名空间
refactoring.move.namespace.message=要移动的命名空间
refactoring.move.namespace.in.non.code.message=注释和字符串中的命名空间引用

#refactoring -> move member
refactoring.move.method.label.text.field=将成员移至类(&C)
refactoring.move.member.method.is.overridden.in.a.sublclass={0} 在子类 {1} 中被重写
refactoring.move.members.there.are.several.classes.with.specified.name=存在多个具有指定名称 {0} 的类
refactoring.move.members.is.not.a.valid.class.name=“{0}”不是有效的类名
refactoring.move.member.title=Move Static Member
refactoring.move.member.action.name=移动成员…
refactoring.move.method.message=将静态成员移至另一个类
refactoring.move.members.to.be.moved=要移至另一个类的成员(&B)
refactoring.move.members.preview.header=要移至另一个类的成员
refactoring.move.members.unable.to.move.method=无法移动成员
refactoring.move.members.unable.to.resolve.usage.callback.found=无法解析用法\: 发现回调\: {0}
refactoring.move.members.unable.to.resolve.usage.late.static.binding.detected=无法解析用法\: 检测到后期静态绑定\: {0}
refactoring.move.members.late.static.binding.detected=检测到延迟静态绑定\: {0}
refactoring.move.members.self.from.anonymous.class=无法处理对匿名类的自引用
refactoring.move.members.late.static.binding.detected.in.doc=在文档中检测到延迟静态绑定
refactoring.move.members.unable.to.resolve=无法解析 {0}
refactoring.move.members.is.not.accessible={0} 在 {1} 中无法访问
refactoring.move.members.cannot.move.nonstatic.method=不支持移动非静态方法
refactoring.move.members.refactoring.method.declaration.is.not.correct=方法声明不正确
refactoring.move.members.cannot.find.target.class=无法找到类 {0}
refactoring.move.members.member.will.change.visibility.to.public=成员 {0} 会将可见性更改为 public
refactoring.move.members.method.implements.abstract.method={0} 在 {1} 中实现抽象方法
refactoring.move.members.method.implements.method.in={0} 在 {1} 中实现方法
refactoring.move.members.0.will.be.hidden.in.1=成员 {0} 将在 {1} 中被隐藏
refactoring.move.members.only.constants.can.be.moved.to.interface = 只有常量可以移至接口

#refactoring -> move file constant
refactoring.move.constant.title=移动常量
refactoring.move.constant.label.text.field=将常量 {0} 移至类(&C)
refactoring.move.multiple.constant.label.text.field=将 {0} 个常量移至类(&C)
refactoring.move.constant.unable.to.resolve=无法解析 {0}
refactoring.move.constant.class.already.contains.constant=类 {0} 已包含常量 {1}

#refactoring -> move function
refactoring.move.function.title=移动函数
refactoring.move.function.label.text.field=将函数 {0} 移至类(&C)
refactoring.move.multiple.functions.label.text.field=将 {0} 个函数移至类(&C)
refactoring.move.constant.class.already.contains.method=类 {0} 已包含方法 {1}
refactoring.move.function.interface.cant.contain.method=接口中不允许带有主体的方法

#refactoring -> move instance
refactoring.move.method.no.candidates.found=找不到合适的参数/属性
refactoring.move.method.cannot.move.constructor=无法移动构造函数
refactoring.move.method.cannot.move.magic.method=无法移动魔术方法
refactoring.move.instance.method=移动实例方法
refactoring.move.instance.method.action.name=移动实例方法...
refactoring.move.instance.method.preview.header=要移至另一个类的方法
refactoring.move.instance.method.this.parameter.label=将替换类 {0} 的 $this 引用的参数名称
refactoring.move.instance.method.usage.will.not.be.accessible=用法 {0} 将无法访问。应提高方法可见性

#refactoring -> make static then move method
refactoring.make.static.then.move.method.select=将方法 ''{0}'' 移至类
refactoring.make.static.then.move.method.message=方法 ''{0}'' 将被设为 ''public static''

#refactoring -> extract interface
refactoring.extract.interface.name=提取接口
refactoring.extract.interface.title=从类 ''{0}'' 提取接口
refactoring.extract.interface.invalid.caret.location=脱字符号应置于要重构的类名处。
refactoring.extract.interface.invalide.extract.from.trait=无法从特征提取接口。
refactoring.extract.interface.no.methods=没有要提取到接口的方法。
refactoring.extract.interface.field=接口名称(&I)\:
refactoring.extract.replace.class.reference=尽可能将类引用替换为接口(&F)
refactoring.extract.interface.members.title=成员形成接口(&B)
refactoring.extract.interface.phpdoc.title=PhpDoc
refactoring.extract.interface.phpdoc.do.nothing=保留原样(&A)
refactoring.extract.interface.phpdoc.copy=复制 (&C)
refactoring.extract.interface.phpdoc.move=移动 (&M)
refactoring.extract.interface.validation.members.modifier=对于每个提取的方法，修饰符将更改为 public。
refactoring.extract.interface.fail.to.create.file=无法创建文件 ''{0}''。

#refactoring -> make method static
refactoring.make.method.static=把方法静态化
refactoring.make.method.static.method.calls.found.in.static.context=在静态上下文中找到方法调用
refactoring.make.method.static.method.converts.method.to.static=将方法转换为静态
refactoring.make.method.static.dynamic.method.call.found=实例对象应作为参数传递，找到动态方法调用\: {0}
refactoring.make.method.static.this.found=实例对象应作为参数传递，找到 $this
refactoring.make.method.static.references.to.be.changed=引用是改变了{0}
refactoring.make.method.static.doc.method.is.not.supported=不支持文档方法
refactoring.make.method.static.method.is.overridden=方法 {0} 被重写
refactoring.make.method.static.object.is.needed=方法 {0} 使用未作为参数传递的属性 {1}
refactoring.make.method.static.private.field.is.not.accessible=private 属性 {0} 无法从类外部访问
refactoring.make.method.static.protected.field.is.not.accessible=protected 属性 {0} 无法从类及其继承者外部访问
refactoring.make.method.static.writeAccess=检测到 {0} 写入访问，实例对象应作为参数传递。
refactoring.make.method.static.magic.method=魔术方法不能设为静态
refactoring.make.method.static.add.parameters.for.fields=为属性添加参数(&P)\:

#actions
#action -> detect namespace roots
actions.detect.namespace.roots.notification.id=PHP PSR-0 命名空间根检测
actions.detect.namespace.roots.notification.title=检测 PSR-0 命名空间根
actions.detect.namespace.roots.title=正在检测 PSR-0 命名空间根…
actions.detect.namespace.roots.finished=已完成 PSR-0 命名空间根检测。
actions.detect.namespace.roots.no.new.roots.detected=未检测到新的 PSR-0 命名空间根。
actions.detect.namespace.roots.view.configuration=视图配置
actions.detect.namespace.roots.manual.configuration=手动配置
actions.detect.namespace.roots.idea.view.configuration=您可以在 '项目结构 | 模块' 中修改设置。
actions.detect.namespace.roots.from.composer.title=PSR-0/PSR-4 根
actions.detect.namespace.roots.from.composer.idea.title=源根

#action -> detect language level
actions.detect.language.level.loaded.from.composer.title=PHP 语言级别
actions.detect.language.level.loaded.from.composer.idea.title=语言级别

#action --> common settings
actions.detect.common.setting.from.composer.suggest.title=将设置与 Composer 同步?
actions.detect.common.setting.from.composer.enable=启用同步
actions.detect.common.setting.from.composer.disable=不同步
actions.detect.common.settings.updated.from.composer.title={0} 设置已更新
actions.detect.common.settings.composer.sync.state.title=与 composer.json 的同步{0}
actions.detect.common.settings.composer.sync.state.message=您可以在“PHP|Composer”设置中{0}与 composer.json 的同步。
actions.detect.common.setting.from.composer.show.settings=显示设置

actions.detect.common.setting.link.wrapper=<a href\="{0}">{1}</a>
action.detect.user.settings.state.overwritten=如果打开同步，IDE 设置(PHP 语言级别，PSR-0/PSR-4 根)可能会被覆盖
action.detect.user.settings.state.supported=支持 PSR-0/PSR-4 根和 PHP 语言级别的同步
action.detect.user.settings.state.overwritten.short=设置可能会被覆盖\: PSR-0/PSR-4 根和 PHP 语言级别。
action.detect.php.language.level.is=PHP 语言级别为
action.detect.settings.sync.turned.on.title=已与 composer.json 同步
action.detect.settings.sync.turned.on=PHP 语言级别已与 composer.json 同步
action.detect.composer.json.not.found.title=找不到 composer.json
action.detect.composer.json.not.found=在路径 {0} 下找不到 composer.json
action.detect.composer.json.open=在编辑器中打开

#action -> mark directory as namespace root
actions.mark.directory.as.psr.0.root.title=要将文件夹标记为 {0} 根吗?
actions.mark.directory.as.psr.0.root=<i>{0}</i>
actions.mark.directory.as.psr.0.root.with.prefix=<i>{0}</i>为前缀“{1}”?
actions.mark.directory.as.psr.0.root.mark.psr=标记为 {0} 根

#action - > new php base
actions.new.php.base.dialog.label.file.name=文件名称\:
actions.new.php.base.dialog.label.extension=文件扩展名\:
actions.new.php.base.arrows.extension.tooltip=在编辑器中按向上或向下箭头可更改文件扩展名
actions.new.php.base.arrows.template.tooltip=在编辑器中按向上或向下箭头可更改模板

#action -> new php file
actions.new.php.file.action.name=PHP 文件
actions.new.php.file.action.description=创建新的 PHP 文件
actions.new.php.file.dialog.title=创建新的 PHP 文件

#action -> new php class
actions.new.php.class.action.name=PHP 类
actions.new.php.class.action.description=创建新的 PHP 类
actions.new.php.class.dialog.title=创建新的 PHP 类
actions.new.php.class.dialog.label.class.name=名称\:
actions.new.php.class.dialog.label.namespace=命名空间\:
actions.new.php.class.dialog.label.directory=目录\:
actions.new.php.class.dialog.label.template=模板\:
actions.new.php.class.dialog.label.superclasses.container=父类
actions.new.php.class.dialog.label.superclasses.super.fqn=扩展\:
actions.new.php.class.dialog.label.superinterfaces.add.interface=添加接口…
actions.new.php.class.dialog.label.superinterfaces.to.implement=实现\:
actions.new.php.class.dialog.label.superinterfaces.to.implement.empty=选择要实现的接口
actions.new.php.class.dialog.label.superinterfaces.to.extend.empty=选择要扩展的接口
actions.new.php.class.dialog.border.title.class=类

#action -> new php test
actions.new.test.class.action.name=新建 PHP 测试
actions.new.test.class.action.description=创建新的 PHP 测试
actions.new.test.class.dialog.title=创建新的 PHP 测试
actions.new.test.class.dialog.title.named=为 {0} 创建新的 PHP 测试
actions.new.test.class.dialog.label.name=名称\:
actions.new.test.class.dialog.label.namespace=命名空间\:
actions.new.test.class.dialog.label.file.name=文件名称\:
actions.new.test.class.dialog.label.directory=目录\:
actions.new.test.class.dialog.label.fqn=完全限定名称\:
actions.new.test.class.dialog.border.title.class.to.test=要测试的类(可选)
actions.new.test.class.dialog.border.title.test.class=测试类
actions.new.test.class.dialog.border.title.target.class.file.path=文件路径\:
actions.new.test.class.dialog.arrows.libraries.hint=在编辑器中按向上或向下箭头可更改测试库
actions.new.test.class.dialog.select.methods=生成的测试方法\:
actions.new.test.class.dialog.select.methods.show.inherited.methods=显示继承的方法

#action -> new PHPUnit test
actions.new.phpunit.class.action.name=PHPUnit 测试
actions.new.phpunit.class.action.description=创建新的 PHPUnit 测试

#action -> generate php doc
actions.generate.php.doc.is.not.available=PHPDoc 生成在索引更新期间不可用

unnamed.variable=(未命名)
create.web.project.php.sdk.step.summary=检查新项目的 PHP 配置。
server=服务器
executing.script=正在服务器上执行脚本…

#Connection -> Server Connection
connection.port.is.busy=端口 {0} 正忙

#Server configuration
debug.server.import.configuration.dialog.title=从部署配置导入
debug.server.import.configuration.preview.border.title=预览
debug.server.import.configuration.path.to.remote.root=部署根的绝对路径(&R)\:
debug.server.import.configuration.path.to.remote.root.sftp=绝对远程根\: ''{0}''
debug.server.import.configuration.path.to.remote.root.sftp.tooltip=远程文件的绝对路径\:<br>"远程根的绝对路径" . "根路径" (来自部署设置) . "服务器上的相对部署路径" (来自部署路径映射)
debug.server.import.configuration.path.to.remote.root.mounted=本地\: ''{0}'' -> 远程\: ''{1}''
debug.server.import.configuration.path.to.remote.root.mounted.label=已挂载文件夹的远程路径(&R)\:
debug.server.import.configuration.path.to.remote.root.mounted.tooltip=远程文件的绝对路径\:<br>"已挂载文件夹的远程路径" . "服务器上的相对部署路径" (来自部署路径映射)
debug.server.import.configuration.deployment=&部署\:
debug.server.import.configuration.local=&本地
debug.server.import.configuration.mounted=已挂载(&M)

debug.server.import.configuration.local.file.path=本地文件路径\:
debug.server.import.configuration.project=&项目\:
debug.server.import.from.deployment.single.deployment.message=选择部署配置以导入路径映射。
debug.server.import.from.deployment.multi.deployment.message=选择项目和部署配置以导入路径映射。
debug.server.import.from.deployment.deployment.configurations.message=找到具有相关路径映射的部署配置。
debug.server.import.from.deployment.no.deployment.configurations.message=找不到合适的部署配置
debug.server.import.from.deployment.no.deployment.configurations.tooltip=配置部署根(如果不为空)
debug.server.import.from.deployment.deployment.root.label=部署根(&R)\:
debug.server.import.from.deployment.import.button=导入路径映射(&I)
debug.server.import.from.deployment.radio=从部署导入映射(&I)
debug.server.manually.select.file.or.project=手动选择本地文件或项目(&M)
debug.server.manually.select.file.message=选择一个项目或文件进行调试
debug.server.select.file.mapping=配置本地文件路径
debug.server.detect.path.mappings.from.deployment.progress=正在为 ''{0}'' 项目分析路径映射
debug.server.detect.path.mappings.from.deployment=正在检测现有路径映射…
debug.server.can.not.detect.path.mappings.from.deployment=无法评估路径映射\: 未选择目标部署服务器

#Debug
debug.accept.connection=应用更改
debug.ignore.connection=忽略更改
debug.incoming.connection.title.0=来自 {0} 的传入连接
debug.path.on.server=服务器上的绝对路径
debug.error.cannot.modify.value=无法修改值
debug.error.cannot.evaluate.variables=无法评估变量
debug.error.cannot.evaluate.expression0=无法评估表达式 ''{0}''
debug.error.cannot.evaluate.expression=无法评估表达式
debug.process.cannot.find.file.in.project=在项目中找不到路径为 ''{0}'' 的文件
debug.process.cannot.find.server.name=找不到源位置。名称为 ''{0}'' 的服务器不存在。
debug.process.status.disconnected=已断开
debug.process.status.wait=正在等待与{0} ''{1}'' 的传入连接
debug.process.status.connected=已连接
debug.process.console.error.format={0}\: {1}，{2} 中的第 {3} 行\n\

debug.mapping.resolve.dialog.stop.debugger=停止调试器
debug.zend.error.title.cannot.accept.external.xdebug.connection=无法接受外部 Xdebug 连接
debug.zend.required.protocol.version.0.or.higher=所需协议版本为 ''{0}'' 或更高版本
debug.error.title.cannot.accept.external.0.connection=无法接受外部 {0} 连接
debug.zend.cannot.accept.incoming.connection=无法接受来自 Zend Debugger 的传入连接
debug.zend.debugger.settings.broadcasting=Zend Debugger 设置广播
debug.zend.debugger=Zend 调试器
debug.xdebug=Xdebug
debug.not.installed=<未安装>
debug.process.cannot.find.file.link=更多信息
debug.process.cannot.find.file=在本地找不到文件 ''{0}''。\n\
要修复，请通过环境变量 PHP_IDE_CONFIG 设置服务器名称，然后重新启动调试会话。
debug.process.cannot.find.local.file=在服务器 {0} 上找不到文件的本地副本\n\
本地路径为 {1}
debug.process.cannot.find.path.mapping=远程文件路径 ''{0}'' 未映射到项目中的任何文件路径
debug.process.script.outside.project=脚本 ''{0}'' 在项目外部。
debug.process.cant.compute.source.position=无法计算源位置。脚本 ''{0}'' 未与任何文本文件类型关联。
debug.edit.path.mappings=点击以设置路径映射
debug.configure.servers=配置服务器
debug.settings.broadcasting.port=设置广播端口：
debug.settings.auto.detect.ide.host=自动检测 IDE IP\:
debug.debug.port=调试端口：
debug.error=错误
debug.process.cannot.find.remote.copy.local.file=项目 ''{0}'' 中的文件路径未映射到服务器上的任何文件路径
debug.cannot.map.local.file=文件路径未映射到服务器上的任何文件路径。编辑路径映射以解决此问题。
debug.resolve.mapping.problem=解决路径映射问题
debug.cannot.start.listening.for.connections.from.0=无法开始侦听来自 ''{0}'' 的连接
debug.cannot.start=无法启动 ''{0}''
debug.stop.listen.debug.connections=停止侦听 PHP 调试连接
debug.start.listen.debug.connections=开始侦听 PHP 调试连接
debug.breakpoint.was.resolved=此处的调试会话已暂停，因为 ''{0}'' 处的断点已被解析到此位置。<br/>您可以<a href\="disable">禁用</a>断点解析或<a href\="more">了解详情</a>。<a href\="dontshow">不再显示</a>
debug.breakpoint.resolved.disabled=断点解析已被禁用，从下一个调试会话开始将不会解析断点。 您可以稍后在 <a href\="open">PHP|调试</a>下将其启用。
debug.breakpoint.resolved.notify.disabled=断点解析通知已被禁用。您可以在 <a href\="open">PHP|调试|高级设置</a>下将其启用。
debug.log.invalid.xdebug.message=由于 Xdebug 消息无效，无法在断点处停止。\n\
要解决此问题，请切换到稳定版本的 Xdebug 或使用 'xdebug.remote_log' 选项收集日志并创建错误报告。 
debug.log.stop=停止于 (''{0}''\:{1})
debug.log.path.mapping.remote.local=远程\: ''{0}'' <-> 本地\: ''{1}''
debug.log.path.mapping.remote.extracted=远程\: ''{0}'' <-> 提取\: ''{1}''
debug.log.stack.frame=框架\: {0}\:{1}，{2}
debug.log.connection.was.terminated=调试连接在 ''{0}''\:''{1}'' 上意外终止
debug.log.cant.register.breakpoint.no.remote=无法注册断点。没有本地路径 ''{0}'' 的路径映射
debug.log.cant.register.breakpoint.no.template.mapping=无法注册断点。没有到 PHP 行 ''{0}'' 的映射
debug.log.exception.break=异常中断\: {0} ({1})
debug.validation.connection.was.not.established=与 {0} 的调试连接未建立
debug.file.is.ignored=文件 ''{0}'' 被跳过。
debug.edit.ignored.paths.list=<a href\="\#a">编辑</a>跳过的路径。
debug.composite.value.presentation=[{0}]
debug.error.unknown.debugger.id=未检测到调试器扩展
debug.error.wrong.debugger.id=不支持 {0}
debug.type.array=数组
debug.type.resource=资源
debug.type.int=int
debug.type.float=浮点数
debug.xdebug.error.unsupported.protocol.version=不支持的 Xdebug 协议版本
debug.php.line.breakpoint.title=PHP 行断点
debug.php.exception.breakpoint.title=PHP 异常断点
debug.php.exception.breakpoint.not.supported=加载的调试扩展不支持异常断点
debug.php.exception.breakpoint.zend.not.supported=Zend Debugger 不支持异常断点
debug.php.exception.breakpoint.dialog.title=添加异常断点
debug.php.exception.breakpoint.exception.name=异常名称\:
debug.php.method.breakpoint.title=PHP 方法断点
debug.php.method.breakpoint.dialog.title=添加方法断点
debug.php.method.breakpoint.method.name=方法名称\:
debug.php.method.breakpoint.zend.not.supported=Zend Debugger 不支持方法断点
debug.php.breakpoint.failed.to.register=无法注册断点，请尝试将其禁用并重新启用。
debug.error.cannot.parse.ssh.connection=无法从 $_SERVER[''SSH_CONNECTION''] 解析端口\: ''{0}''
debug.error.cannot.parse.server.name.for.external.connection=无法为外部 {0} 连接解析服务器名称。
debug.error.cannot.parse.server.name=要修复，请在远程服务器上创建环境变量 <i><b>PHP_IDE_CONFIG</b></i>。<br/><br/><i>Windows\:</i> 设置 PHP_IDE_CONFIG\="serverName\=SomeName"<br/> <i>Linux / Mac OS X\:</i> 导出 PHP_IDE_CONFIG\="serverName\=SomeName"。
debug.error.server.name.is.empty=<i><b>$_SERVER["SERVER_NAME"]</i></b> 为空，这可能是 Web 服务器配置错误所致。<br/><br/><i>Nginx\:</i> 将 fastcgi 参数添加至 nginx 配置，<a href\="http\://wiki.nginx.org/PHPFcgiExample">更多</a><br/><i>Apache\:</i> 为当前 VirtualHost 配置 ServerName，<a href\="https\://httpd.apache.org/docs/2.4/vhosts/name-based.html">更多</a>

debug.php.external.connection.finished.warning.title=调试会话已完成且未暂停
debug.php.external.connection.finished.warning=这可能是由于路径映射配置错误或本地和远程项目未同步。<br/><br/>要找出问题，请在 <b><i><a href\="servers">PHP|服务器</a></i></b>下检查 ''{0}'' 服务器的路径映射配置，或启用 <b><i><a href\="break">''在 PHP 脚本中的第一行中断''</a></i></b> 选项(位于<i>运行</i>菜单下)。<br/><a href\="ignore">不再显示</a>
debug.php.external.connection.finished.break.at.first.line.title=PHP 调试配置
debug.php.external.connection.finished.break.at.first.line=<b><i>'在第一行中断'</i></b> 选项已启用

debug.process.smart.step.into.popup=单步进入函数
debug.process.smart.step.into.function.evaluation.error =无法评估目标函数。将执行“单步跳入”。
debug.process.smart.step.into.function.was.not.executed=尚未调用所选函数。

#rest client
debug.rest.client.submit.request.in.debug.mode=在调试模式下提交请求
debug.rest.client.runs.request.in.debug.mode=在调试模式下运行请求
debug.rest.client.can.not.resolve.host.name=无法解析 URL 的主机名\: {0}
debug.rest.client.can.not.resolve.host.name.title=Rest 客户端中的 PHP 调试
debug.rest.client.debugger.is.not.supported=尚不支持所选调试器类型 ''{0}''
debug.rest.client.error.cannot.evaluate.server.name.title=无法通过服务器名称找到对应的“PHP|服务器”
debug.rest.client.error.cannot.evaluate.server.name=无法评估 '$_SERVER['SERVER_NAME']'。请确保为您的 Web 服务器配置了正确的服务器名称。<br>点击此<a href\="help">链接</a>获取更多信息。

# custom actions
debug.function.was.added.to.skip.list=''{0}'' 已添加到跳过列表。
debug.action.copy.as.title=将变量复制为 ''{0}''
debug.action.copy.as.was.fail.can.not.get.full.name=无法将变量复制为 ''{0}''，无法评估完整的变量名
debug.action.copy.value.as.text=将值复制为...

debug.label.select.a.project.or.a.file.to.debug=选择一个项目或文件进行调试
debug.label.select.a.project.to.debug=选择一个项目进行调试
debug.label.file.path.on.server=服务器上的文件路径\:
debug.label.file.path.in.project=项目中的文件路径\:
debug.checkbox.can.accept.external.connections=可以接受外部连接
debug.checkbox.ignore.z.ray.system.requests=忽略 Z-Ray 系统请求
debug.label.max.simultaneous.connections=最大同时连接数\:

# templates
template.debug.path.to.output.folder.descr=指定缓存目录路径
template.debug.path.to.output.folder=缓存目录路径
template.debug.cache.path=缓存路径\:
template.debug.cache.dir.is.incorrect=模板调试\: 在设置中指定的缓存目录路径无效
template.debug.cache.dir.is.not.specified=模板调试\: 未在设置中指定缓存目录路径
template.debug.php.file.not.found=模板调试\: 未找到 {0} 的相应 PHP 文件

debug.expression.evaluation.fail=由于返回值未知，无法评估表达式

dbgp.proxy=Xdebug 代理
dbgp.proxy.port=代理端口
dbgp.proxy.host=代理主机
dbgp.proxy.ide.key=IDE 键
dbgp.proxy.ide.register.success=IDE 已成功使用 IDE 键 ''{0}'' 注册
dbgp.proxy.ide.unregister.success=IDE 已成功注销
dbgp.proxy.ide.register.error=无法使用 IDE 键 ''{0}'' 注册 IDE
dbgp.proxy.cannot.connect.to.host=无法连接到主机 ''{0}''
dbgp.proxy.cannot.connect.to.xdebug.proxy=无法连接到 ''{0}\:{1}'' 上的 Xdebug 代理
dbgp.proxy.sending.request.to.xdebug.proxy=正在将请求发送到 Xdebug 代理…

profiler.xdebug.task.title=分析 Xdebug 分析器快照
profiler.xdebug.task.parsing=正在解析 ''{0}''
profiler.xdebug.file.chooser.title=选择 Xdebug 分析器快照

profiler.view.execution.statistics.title=执行统计
profiler.view.call.tree.title=调用树
profiler.view.callees.title=被调用方
profiler.view.callers.title=调用方
profiler.column.time.title=时间
profiler.column.memory.title=内存(B)
profiler.column.own.memory.title=自身内存(B)
profiler.column.own.time.title=自身时间
profiler.column.invocation.count.title=调用
profiler.column.invocation.callable=可调用
profiler.column.script=脚本

profiler.measurement.unit.second=秒
profiler.measurement.unit.second.short=秒
profiler.measurement.unit.millisecond=毫秒
profiler.measurement.unit.millisecond.short=毫秒
profiler.measurement.unit.microsecond=微秒
profiler.measurement.unit.microsecond.short=µs
profiler.button.refresh=刷新
profiler.label.time=时间：

#phpunit
php.uml.provider.presentable.name=PHP 类图

#coverage
coverage.is.not.supported.for.selected.run.profile=代码覆盖率与所选运行配置文件不兼容

#UI

#run configurations -> components -> command line
PhpCommandLineConfigurationEditor.interpreter.options.editor.dialog.caption=解释器选项
PhpCommandLineConfigurationEditor.command.line=命令行
PhpCommandLineConfigurationEditor.field.interpreter.options=解释器选项：
PhpCommandLineConfigurationEditor.field.custom.working.directory=自定义工作目录\:
PhpCommandLineConfigurationEditor.field.environment.variables=环境变量：

#run configurations -> components -> test runner
PhpUnitTestRunnerConfigurationEditor.test.runner=测试运行程序
PhpUnitTestRunnerConfigurationEditor.scope=测试范围\:
PhpUnitTestRunnerConfigurationEditor.scope.directory=目录
PhpUnitTestRunnerConfigurationEditor.scope.class=类
PhpUnitTestRunnerConfigurationEditor.scope.method=方法
PhpUnitTestRunnerConfigurationEditor.scope.xml=在配置文件中定义
PhpUnitTestRunnerConfigurationEditor.field.directory=目录\:
PhpUnitTestRunnerConfigurationEditor.field.method=方法\:
PhpUnitTestRunnerConfigurationEditor.field.class=类\:
PhpUnitTestRunnerConfigurationEditor.field.file=文件\:
PhpUnitTestRunnerConfigurationEditor.use.alt.configuration.file=使用替代配置文件(&U)\:
PhpUnitTestRunnerConfigurationEditor.use.alt.bootstrap.file=使用替代启动文件(&U)\:
PhpUnitTestRunnerConfigurationEditor.field.test.runner.options=测试运行程序选项(&O)\:
PhpUnitTestRunnerConfigurationEditor.field.test.runner.coverage.engine=首选覆盖率引擎\:
PhpUnitTestRunnerConfigurationEditor.dialog.caption.test.runner.options=测试运行程序选项

# run configurations
PhpScripRunConfigurationEditor.configuration.display.name=PHP 脚本
PhpScripRunConfigurationEditor.configuration.description=PHP 脚本配置
PhpScripRunConfigurationEditor.file=文件\:
PhpScripRunConfigurationEditor.arguments=参数\:
PhpScripRunConfigurationEditor.arguments.caption=参数

PhpHttpRequestRunConfiguration.configuration.display.name=PHP HTTP 请求
PhpHttpRequestRunConfiguration.configuration.description=HTTP 请求配置
PhpHttpRequestRunConfiguration.error.fetch.result=响应正文不可用
PhpHttpRequestRunConfiguration.error.server.is.not.specified=找不到名称为 ''{0}'' 的远程服务器
PhpHttpRequestRunConfiguration.error.host.is.not.specified=服务器 ''{0}'' 的主机未指定或无效
PhpHttpRequestRunConfiguration.error.url.is.not.specified=URL 未指定或无效\: ''{0}''。
PhpHttpRequestRunConfiguration.error.server.configuration=无法执行 HTTP 请求\: ''{0}''。请在“PHP|服务器”下检查服务器配置。

RunConfigurationEditor.configuration=配置
RunConfigurationEditor.server=&服务器\:
RunConfigurationEditor.error.server.is.not.selected=未选择服务器
RunConfigurationEditor.error.server.is.not.exist=名称为 ''{0}'' 的服务器不存在

PhpWebAppRunConfigurationEditor.configuration.display.name=PHP Web 页面
PhpWebAppRunConfigurationEditor.configuration.description=PHP Web 页面配置
PhpWebAppRunConfigurationEditor.startUrl=起始 URL(&U)\:
PhpWebAppRunConfigurationEditor.browser=&浏览器\:
PhpWebAppRunConfigurationEditor.malformed.start.url=起始 URL 的格式错误 - {0}

PhpRemoteDebugRunConfigurationEditor.configuration.display.name=PHP 远程调试
PhpRemoteDebugRunConfigurationEditor.configuration.description=PHP 调试配置
PhpRemoteDebugRunConfigurationEditor.server.label=服务器(&E)：
PhpRemoteDebugRunConfigurationEditor.session.id.label=IDE 键(会话 ID)(&K)\:
PhpRemoteDebugRunConfigurationEditor.auto.config=通过 IDE 键筛选调试连接
PhpRemoteDebugRunConfigurationEditor.session.id.cannot.be.empty=IDE 键(会话 ID)不能为空
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used.title=已开始侦听传入 PHP 调试连接
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.title=高级选项
PhpRemoteDebugRunConfigurationEditor.filter.connections.help=适用于复杂服务器设置，例如同一主机端口上有多个应用程序。<p/>保持未选中状态以自动检测配置，或使用<i>“侦听调试连接”</i>操作。
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.link=阅读更多
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used=没有为 <i>''{0}''</i> 运行配置指定<i>服务器</i>，因此 PhpStorm 将侦听所有传入调试连接。<br/>查看<a href\="zero_config">零配置调试</a>获取更多信息。<br/><br/>要停止侦听调试连接，请使用<a href\="stop">运行|停止侦听 PHP 调试连接</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.is.already.used=“侦听传入调试连接”已启用，不会发生任何变化。<br/>查看<a href\="zero_config">零配置调试</a>获取更多信息。<br/><br/>要停止侦听调试连接，请使用<a href\="stop">运行|停止侦听 PHP 调试连接</a>。
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration.title=已停止侦听传入 PHP 调试连接
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration=PhpStorm 已停止侦听传入调试连接。

PhpBuiltInWebServerRunConfigurationEditor.configuration.display.name=PHP 内置 Web 服务器
PhpBuiltInWebServerRunConfigurationEditor.configuration.description=PHP 内置 Web 服务器配置
PhpBuiltInWebServerRunConfigurationEditor.title=服务器配置
PhpBuiltInWebServerRunConfigurationEditor.host=主机
PhpBuiltInWebServerRunConfigurationEditor.port=端口
PhpBuiltInWebServerRunConfigurationEditor.document.root=文档根\:
PhpBuiltInWebServerRunConfigurationEditor.use.router.script=使用 router 脚本\:

PhpDebugConfigurable.ignore.external.connections.through.unregistered.server.configurations.label=通过未注册的服务器配置忽略外部连接
PhpDebugConfigurable.xdebug.resolve.breakpoints=如果断点在当前行不可用，则解析断点(Xdebug 2.8+)
PhpDebugConfigurable.xdebug.force.break.no.path.mapping=未指定路径映射时，在第一行强制中断
PhpDebugConfigurable.xdebug.force.break.when.outside.project=当脚本在项目外部时，在第一行强制中断
PhpDebugConfigurable.xdebug.debug.port=Xdebug 调试端口
PhpDebugConfigurable.zend.debug.port=Zend Debugger 调试端口
PhpDebugConfigurable.zend.settings.broadcasting.port=Zend Debugger 设置广播端口
PhpDebugConfigurable.zend.settings.ide.hosts=Zend Debugger IDE 主机
PhpDebugConfigurable.zend.settings.ide.hosts.detect=正在检测…
PhpDebugConfigurable.zend.settings.ide.hosts.detect.progress=正在检测 Zend Debugger 的 IP…
PhpDebugConfigurable.xdebug=Xdebug
PhpDebugConfigurable.zend.debugger=Zend 调试器
PhpDebugConfigurable.safe.evaluation.mode=值提示和监视框架下的安全评估模式
PhpDebugConfigurable.import.use.statements=导入命名空间并使用评估上下文中的语句
PhpDebugConfigurable.show.array.children.in.repl=在调试控制台中显示数组和对象子级
PhpDebugConfigurable.external.connections=外部连接
PhpDebugConfigurable.pass.required.configuration.options=通过命令行传递所需的配置选项（仍需手动启用调试扩展）
PhpDebugConfigurable.advanced.settings=高级设置
PhpDebugConfigurable.notify.session.stopped.without.pause=调试会话结束时通知，但不暂停
PhpDebugConfigurable.notify.resolved.breakpoint=通知是否将断点解析为另一行(Xdebug 2.8+)
PhpDebugConfigurable.detect.path.mappings.from.deployment=检测部署配置的路径映射
PhpDebugConfigurable.break.at.first.line=在 PHP 脚本中的第一行中断
PhpDebugConfigurable.evaluation=评估
PhpDebugConfigurable.zero.configuration=预配置
PhpDebugConfigurable.zero.configuration.install.debugger.php.instruction=1. 安装
PhpDebugConfigurable.zero.configuration.install.xdebug.php.instruction=Xdebug
PhpDebugConfigurable.zero.configuration.install.php.instruction=或
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.action=Zend 调试器
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.instruction=在 Web 服务器上。
PhpDebugConfigurable.zero.configuration.install.php.validate.action=验证
PhpDebugConfigurable.zero.configuration.install.php.validate=Web 服务器上的调试器配置。
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction.label=2. 安装
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction=浏览器工具栏或小书签。
PhpDebugConfigurable.zero.configuration.listen.for.connections=3. 启用 PHP 调试连接侦听\:
PhpDebugConfigurable.zero.configuration.start.session=4. 使用工具栏或小书签在浏览器中启动调试会话。
PhpDebugConfigurable.zero.configuration.tutorial=有关更多信息，请参见
PhpDebugConfigurable.zero.configuration.tutorial.action=“零配置调试”教程

PhpDebugConfigurable.zero.configuration.listen.for.connections.action=开始侦听
PhpDebugConfigurable.zero.configuration.stop.listen.for.connections.action=停止侦听
PhpDebugConfigurable.remote.debug.listen.for.connections=3. 启动“PHP 远程调试”运行配置。
PhpDebugConfigurable.web.page.pre.config.title=调试预配置
PhpDebugConfigurable.web.page.listen.for.connections=2. 启动“PHP Web 页面”运行配置。

PhpDebugSkippedPathsConfigurable.display.name=跳过的路径
PhpDebugSkippedPathsConfigurable.notify.about.skipped.files=通知跳过的文件
PhpDebugSkippedPathsConfigurable.column.title=跳过的路径

PhpFrameworksCommonConfigurable.display.name=框架

PhpStepFiltersConfigurable.title.methods=方法
PhpStepFiltersConfigurable.specify.method.name=指定方法名称
PhpStepFiltersConfigurable.add.method=添加方法
PhpStepFiltersConfigurable.skip.magic.methods=跳过魔术方法
PhpStepFiltersConfigurable.skip.constructors=跳过构造函数
PhpStepFiltersConfigurable.skipped.methods=跳过的方法
PhpStepFiltersConfigurable.title.files=模板
PhpStepFiltersConfigurable.skipped.files=跳过的文件
PhpStepFilters.log.frame=框架已被跳过。函数名称\: {0}。远程文件 URL\: {1}

PhpServerConfigurable.shared=&共享
PhpServerConfigurable.host=主机
PhpServerConfigurable.host.label=&主机
PhpServerConfigurable.port=端口
PhpServerConfigurable.port.label=&端口
PhpServerConfigurable.debugger.label=&调试器

# web server validation for debug
php.web.server.validation.title=验证 Web 服务器上的调试器配置
php.web.server.validation.action.text=Web 服务器调试验证
php.web.server.validation.local.web.server.radio=本地 Web 服务器或共享文件夹(&L)
php.web.server.validation.remote.web.server.radio=远程 Web 服务器(&R)
php.web.server.validation.local.path.to.script=创建验证脚本的路径(&P)\:
php.web.server.validation.local.path.to.script.tooltip=所选路径应可通过 Web 服务器访问
php.web.server.validation.url.to.validation.script=验证脚本的 URL(&U)\:
php.web.server.validation.url.to.validation.script.tooltip=所选 Web 路径将用于运行验证脚本
php.web.server.validation.deployment.server=部署服务器(&D)\:
php.web.server.validation.deployment.server.tooltip=所选服务器会用于将验证脚本部署到远程服务器
php.web.server.validation.process.title=验证 Web 服务器
php.web.server.validation.dialog.validate.button=&验证
php.web.server.validation.chose.path.to.script=选择验证脚本的路径
php.web.server.validation.chose.path.to.script.description=选择本地文件夹以创建验证脚本
php.web.server.validation.invalid.path.to.script=验证目录的路径无效
php.web.server.validation.configure.local=请配置验证脚本的本地和 Web 路径
php.web.server.validation.configure.remote=请配置验证脚本的路径并选择部署服务器
php.web.server.validation.failed.to.find.web.path=请配置验证脚本的 Web 路径
php.web.server.validation.failed.to.find.deployment.settings=无法找到服务器的部署设置
php.web.server.validation.failed.to.map.deployment.folder=请为验证目录配置远程路径映射
php.web.server.validation.failed.to.map.deployment.folder.to.web=请为验证目录配置 Web 路径映射
php.web.server.validation.uploading.validation.script=正在将验证脚本上传至 {0}
php.web.server.validation.failed.to.deploy.validation.script=无法将验证脚本部署到服务器
php.web.server.validation.failed.to.fetch.script.result=无法获取验证脚本的结果
php.web.server.validation.script.result.is.empty=验证脚本的结果为空
php.web.server.validation.script.result.wrong.format=验证脚本的结果具有意外格式
php.web.server.validation.script.local.result.path.mapping.check=请检查是否为 <b>''{0}''</b> 目录正确配置了验证脚本的 Web 路径
php.web.server.validation.script.result.path.mapping.check=请检查是否在部署设置中为 <b>''{0}''</b> 目录正确配置了远程和 Web 路径映射
php.web.server.validation.failed.to.execute.script=指定的 URL 不可到达，原因是\: ''{0}''
php.web.server.validation.configuration.files=<b>已加载的 php.ini\:</b> {0}
php.web.server.validation.additional.configuration.files=<b>已解析的其他 .ini 文件\:</b> {0}
php.web.server.validation.no.configuration.files=找不到 php.ini 文件
php.web.server.validation.server.name=<b>服务器名称\:</b> {0}
php.web.server.validation.server.name.is.empty=服务器名称为空
php.web.server.validation.server.name.is.empty.description=服务器名称对于 PhpStorm 中的标识是必要的。<br>请在 Web 服务器配置文件中进行配置。
php.web.server.validation.no.debugger.extension=未加载调试扩展
php.web.server.validation.multi.debugger.extension=Xdebug 和 Zend Debugger 扩展均已加载
php.web.server.validation.multi.debugger.extension.description=只有一个调试器扩展可在 php.ini 中加载。
php.web.server.validation.loaded.debugger.extension=<b>调试器扩展\:</b> {0}
php.web.server.validation.xdebug.debugger.host=<b>远程主机\:</b> {0}
php.web.server.validation.xdebug.debugger.localhost=尽管服务器主机可能不在本地，但远程主机仍配置为 ''{0}''
php.web.server.validation.xdebug.debugger.host.remote.addr=<br/><br/>在 php.ini 文件中，将 <b>''xdebug.remote_host''</b> 设为 <i>''{0}''</i> 或自 Web 服务器可见的本地机器 IP 地址。
php.web.server.validation.xdebug.debugger.host.description=正在运行调试器<b>客户端</b>的主机。
php.web.server.validation.xdebug.zend.extension.load=Xdebug 必须通过 'zend_extension' 而不是 'extension' 加载
php.web.server.validation.xdebug.zend.extension.load.description=在 php.ini 文件中使用 <b>'zend_extension\=path_to_xdebug.so'</b> 行以加载 Xdebug 扩展。
php.web.server.validation.xdebug.port=<b>远程端口\:</b> {0}
php.web.server.validation.xdebug.port.require.sudo=<b>远程端口\:</b> {0}，需要根权限才能使用
php.web.server.validation.xdebug.port.require.sudo.description=要在 Linux 和 Mac 上使用小于 1024 的端口，必须具有根权限。
php.web.server.validation.xdebug.wrong.port.format=<b>Xdebug 端口无效\:</b> ''{0}''
php.web.server.validation.xdebug.wrong.port=Xdebug 端口(''{0}'')与“PHP->调试 IDE”设置(''{1}'')不同
php.web.server.validation.xdebug.wrong.port.description=来自 php.ini (<b>xdebug.remote_port</b>) 的 Xdebug 端口应与在 IDE 内(在 <b>PHP->调试</b>下)配置的端口相同。
php.web.server.validation.xdebug.remote.is.not.enable=远程调试未启用
php.web.server.validation.xdebug.remote.is.not.enable.description=将 <b>'xdebug.remote_enable\=1'</b> 行添加至 php.ini 文件。
php.web.server.validation.xdebug.remote.autostart=<b>远程自动开始</b>选项已启用
php.web.server.validation.xdebug.remote.autostart.description=调试会话将尝试为每个请求启动。
php.web.server.validation.xdebug.remote.connect.back=<b>远程回连</b>选项已启用
php.web.server.validation.xdebug.remote.connect.back.description=<b>xdebug.remote_host</b> 选项将被忽略。
php.web.server.validation.xdebug.remote.mode.jit=<b>远程模式\:</b> 'jit'
php.web.server.validation.xdebug.remote.mode.jit.description=调试会话将仅在出现错误后初始化。
php.web.server.validation.xdebug.remote.mode.req=<b>远程模式\:</b> 'req'
php.web.server.validation.xdebug.remote.mode.req.description=调试会话将在脚本启动时初始化。
php.web.server.validation.xdebug.mode.is.not.supported=不支持远程模式 ''{0}''
php.web.server.validation.xdebug.remote.log=<b>远程日志\:</b> {0}
php.web.server.validation.xdebug.protocol.is.not.supported=不支持调试协议 ''{0}''
php.web.server.validation.zend.debugger.host=<b>远程主机\:</b> {0}
php.web.server.validation.zend.debugger.localhost=尽管服务器不在本地，但调试会话仅适用于本地主机。
php.web.server.validation.zend.debugger.localhost.description=将正在运行调试器<b>客户端</b>的主机添加至 <b>'zend_debugger.allow_hosts'</b> 选项。
php.web.server.validation.zend.debugger.deny.host=<b>拒绝主机\:</b> {0}
php.web.server.validation.zend.debugger.deny.host.description=无法使用拒绝主机从客户端进行调试。
php.web.server.validation.zend.expose.remotely=<b>属性 ''expose_remotely''</b> 设为 ''{0}''
php.web.server.validation.zend.expose.remotely.allowed.hosts.description=调试器会话将尝试从 <b>'zend_debugger.allow_hosts'</b> 选项为主机启动。
php.web.server.validation.zend.expose.remotely.always.description=调试器会话将尝试为每个客户端启动。
php.web.server.validation.zend.expose.remotely.never.description=调试器会话将不会进行初始化，<b>'zend_debugger.allow_hosts'</b> 选项将被忽略。<br>将选项 <b>'zend_debugger.expose_remotely'</b> 设置为 'allowed_hosts' 或 'always' 以启用 Web 服务器调试。
php.web.server.validation.reference.to.documentation=请参阅<a href\="{0}">{0}</a>获取更多信息。

PhpPathMappingsConfigurable.use.path.mappings.label=使用路径映射(选择服务器是远程服务器还是使用符号链接)

PhpMappingSimpleResolveDialog.title=为服务器上的文件路径选择本地文件

PhpSdkForm.debugger.label=&调试器
PhpSdkForm.include.paths.label=Include 路径(&I)

DBGPProxyConfigurable.display.name=DBGp 代理
DBGPProxyConfigurable.ide.key=IDE 键：
DBGPProxyConfigurable.host=主机
DBGPProxyConfigurable.port=端口

PhpIncomingLocalConnectionDialog.file.path=文件路径\:

PhpIncomingConnectionDialog.server.name=服务器名称：
PhpIncomingConnectionDialog.server.port=服务器端口：
PhpIncomingConnectionDialog.request.uri=请求 URI\:
PhpIncomingConnectionDialog.file.path.on.server=服务器上的文件路径\:

PhpInterpreter.php.sdk.type=PHP 解释器
PhpInterpreter.php.dependent.configuration.exists.title=PHP 解释器依赖配置
PhpInterpreter.php.dependent.configuration.exists=所选 PHP 解释器有{0}配置。确定要删除此解释器吗?
PhpInterpreter.php.home.path.label=PHP 可执行文件\:
PhpInterpreter.php.debugger.label=调试器\:
PhpInterpreter.php.general.title=常规
PhpInterpreter.configuration.in.project.settings.title=PHP 解释器配置
PhpInterpreter.configuration.in.project.settings.message=无法将 PHP 解释器指定为默认 SDK。您可以在“设置| PHP”中为当前项目配置
PhpInterpreter.configuration.duplicate.interpreter.name=找到了具有非唯一名称 ''{0}'' 的 PHP 解释器。
PhpInterpreter.configuration.selection.list.title=选择 CLI 解释器
PhpInterpreterConfigurable.configuration.title=其他
PhpInterpreterConfigurable.reload.phpinfo=重新加载 phpinfo
PhpInterpreterConfigurable.show.phpinfo=显示 phpinfo
PhpInterpreterConfigurable.updated.phpinfo=已成功更新 phpinfo
PhpInterpreterConfigurable.can.not.updated.phpinfo=无法更新 phpinfo
PhpInterpreterConfigurable.php.version=PHP 版本\: {0}
PhpInterpreterConfigurable.not.installed=未安装
PhpInterpreterConfigurable.configuration.project.level=仅对此项目可见
PhpInterpreterConfigurable.configuration.project.tooltip=检查是否不想在项目之间共享解释器
PhpInterpreterConfigurable.configuration.default.project.tooltip=无法仅为默认项目保存解释器。
PhpInterpreterConfigurable.debugger.extension.label=调试器扩展\:
PhpInterpreterConfigurable.debugger.extension.title=选择调试器扩展路径
PhpInterpreterConfigurable.debugger.extension.description=将仅为从 CLI 运行配置启动的调试会话加载调试器扩展
PhpInterpreterConfigurable.configuration.options.table.empty.text=为 php.ini 中允许的任何配置指令设置自定义值
PhpInterpreterConfigurable.configuration.options.with.empty.name.are.not.allowed=不允许名称为空的配置选项
PhpInterpreterConfigurable.configuration.options.dialog.caption=配置选项
PhpInterpreterConfigurable.configuration.options.label=配置选项\:
PhpInterpreterConfigurable.configuration.options.table.name=配置指令
PhpInterpreterConfigurable.configuration.options.table.value=值
PhpInterpreterConfigurable.configuration.options.description=这些选项将使用 '-d' 命令行选项传递
PhpInterpreterConfigurable.configuration.file.path=配置文件\: {0}
PhpInterpreterConfigurable.configuration.file.path.not.found=配置 php.ini 文件不存在
PhpInterpreterConfigurable.configuration.additional.files=其他 .ini\:<br> {0}
PhpInterpreterConfigurable.configuration.file.evaluate.dir=正在评估配置文件目录…
PhpInterpreterConfigurable.configuration.file.fix.title=配置 php.ini 文件不存在
PhpInterpreterConfigurable.configuration.file.hhvm.fix=在 <b>/etc/hhvm</b> 目录中创建 php.ini 文件，<br><br>点击此<a href\="http\://docs.hhvm.com/manual/en/configuration.file.php">>链接</a>获取更多信息。
PhpInterpreterConfigurable.configuration.file.fix=在 {0} 目录中创建 php.ini 文件，<br><br>配置文件模板可在 php 根文件夹中找到\:<br>“php.ini-development”- 默认设置<br>“php.ini-production”- 推荐设置。<br>
PhpInterpreterConfigurable.configuration.file.fix.failed.to.detect=使用“{0} --ini”命令确定配置文件目录。<br>
PhpInterpreterConfigurable.configuration.file.fix.link=<br>点击此<a href\="http\://php.net/manual/en/configuration.file.php">链接</a>获取更多信息。
PhpInterpreterConfigurable.configuration.file.can.not.find.title=无法找到配置文件
PhpInterpreterConfigurable.configuration.file.can.not.find=无法通过路径找到文件\: ''{0}''
php.info.parse.exception=无法解析 php 信息\: {0} 是空的
PhpInterpreterConfigurable.update.helpers.title=正在更新帮助程序目录…
php.info.parse.exception.configuration.option=无法解析 php 信息\: {0} 是空的
PhpInterpreter.php.interpreter.name.conflict.title=解释器名称冲突
PhpInterpreter.php.interpreter.name.conflict=发现项目级和应用程序级解释程序名称存在冲突。为解决该问题，以下项目级解释器被重命名\:
remote.interpreter.browse.action.is.not.supported.for.docker=基于 Docker 的远程解释器不支持浏览操作
php.interpreter.info.failed.to.parse.validation.script=无法解析验证脚本输出

php.interpreter.base.configuration.interpreter.is.invalid.title=无法运行 {0}
php.interpreter.base.configuration.interpreter.is.invalid=无法运行 {0}，因为 {1} 配置的解释器无效。
php.interpreter.base.configuration.is.not.provided.or.empty={1} 的 {0} 路径未配置。您可以在“PHP|{0}”下进行修复
php.interpreter.base.configuration.working.directory=无法检测工作目录，请在运行配置中进行配置。
php.interpreter.base.configuration.fix.interpreter={0}。要修复，请<a href\=''{1}''>更改</a>项目解释器或<a href\=''{2}''>检查</a>设置。

PhpProjectConfigurable.language.level=PHP 语言级别：
PhpProjectConfigurable.interpreter=CLI 解释器：
PhpProjectConfigurable.include.path=Include 路径
PhpProjectConfigurable.0.interpreter.include.path=''{0}'' 解释器 include 路径
PhpProjectConfigurable.specify.other=指定其他…
PhpProjectConfigurable.all=所有
PhpProjectConfigurable.provide.include.path=提供 include 路径
PhpProjectConfigurable.docker.default.project.error.tooltip=打开或创建项目以配置 Docker 容器
PhpProjectConfigurable.php.runtime=PHP 运行时
PhpProjectConfigurable.advanced.settings=高级设置(&V)
PhpProjectConfigurable.default.stubs.path=默认存根路径(&D)\:
PhpProjectConfigurable.select.default.stubs.path.title=选择默认存根路径
PhpProjectConfigurable.select.default.stubs.path.description=选择默认存根路径
PhpProjectConfigurable.analysis=分析
PhpProjectConfigurable.exception.analysis=异常分析
PhpProjectConfigurable.exception.analysis.depth=调用树分析路径\:
PhpProjectConfigurable.exception.analysis.unchecked.exceptions=未检查的异常
PhpProjectConfigurable.analysis.custom.format.functions=自定义格式函数
PhpProjectConfigurable.include.analysis=Include 分析
PhpProjectConfigurable.select.document.root.path.title=选择 $_SERVER['DOCUMENT_ROOT'] 路径
PhpProjectConfigurable.select.document.root.path.description=选择 $_SERVER['DOCUMENT_ROOT'] 路径

custom.format.functions.dialog.validation.class.not.found=类{0}未找到
custom.format.functions.dialog.validation.function.not.found=找不到函数 {0}
custom.format.functions.dialog.validation.method.not.found=在 {1} 中找不到方法 {0}
custom.format.functions.dialog.validation.format.index=索引必须为非负数
custom.format.functions.dialog.format.index.title=格式字符串模板的索引
custom.format.functions.dialog.class.placeholder=留空以添加纯函数

PhpUnitConfigurableForm.phpunit.library=PHPUnit 库
PhpUnitConfigurableForm.use.custom.loader=使用 Composer 自动加载器
PhpUnitConfigurableForm.custom.loader.is.empty=自动加载器文件的路径为空
PhpUnitConfigurableForm.can.not.find.custom.loader=在 ''{0}'' 下找不到自动加载器脚本
PhpUnitConfigurableForm.phpunit.phar.is.empty=phpunit.phar 路径为空
PhpUnitConfigurableForm.can.not.find.phpunit.phar=在 ''{0}'' 下找不到 phpunit.phar
PhpUnitConfigurableForm.custom.loader.is.directory=自动加载器不应为目录，对于默认 Composer 配置，将路径设置为“vendor/autoload.php”
PhpUnitConfigurableForm.download.phpunit.phar.link.text=从 {0} 下载 phpunit.phar
PhpUnitConfigurableForm.path.to.script=脚本路径\:
PhpUnitConfigurableForm.path.to.phpunit.phar=phpunit.phar 路径
PhpUnitConfigurableForm.test.runner=测试运行程序
PhpUnitConfigurableForm.use.configuration.file=默认配置文件\:
PhpUnitConfigurableForm.use.bootstrap.file=默认启动文件\:
PhpUnitConfigurableForm.use.configuration.file.validation.warning=为 ''{0}'' 提供配置文件的路径，或禁用“默认配置文件”选项
PhpUnitConfigurableForm.use.bootstrap.file.validation.warning=为 ''{0}'' 提供启动文件的路径，或禁用“默认启动文件”选项

phpunit.config.label=测试根
phpunit.config.directory.label=目录\:
phpunit.getting.phpunit.version=正在更新 PhpUnit 版本…
phpunit.not.tests.was.executed.title=未配置 PHPUnit
phpunit.not.tests.was.executed.message=要修复，为 <i>{0}</i> <a href\="config">配置</a>自动加载文件或 PHPUnit phar 路径。
phpunit.can.not.rerun.failed.tests.title=无法执行失败的 PHPUnit 测试。
frameworks.settings.none.installed=<html>没有可用的框架设置提供程序。<br/>考虑安装 Drupal Support、Joomla\! Support 或 WordPress Support 插件。</html>
framework.composer.packages.were.changed.0.test.config.title=Composer 包已被更改
framework.composer.packages.were.changed.0.test.config.popup={0} 配置已根据 composer.json 更新

PhpUnitConfiguration.interpreter.conflict=发现应用程序级 PHPUnit 配置冲突。为解决该问题，创建了以下配置的项目级副本\:
PhpUnitConfiguration.interpreter.conflict.title=PHPUnit 配置冲突

# php test framework
php.test.framework.select.type.of.settings.popup.title=选择配置类型
php.test.framework.configuration.ui.library={0}库
php.test.framework.configuration.ui.test.runner=测试运行程序
php.test.framework.configuration.ui.path.to.exe={0} 可执行文件路径\:
php.test.framework.configuration.ui.use.configuration.file=默认配置文件\:
php.test.framework.download.hyperlink={0} 版本\: <a href\={1}>{1}</a>
php.test.framework.configuration.ui.version={0} 版本\: {1}
php.test.framework.configuration.ui.not.installed=未安装
php.test.framework.configuration.ui.can.not.detect.version.title=无法检测版本
php.test.framework.configuration.ui.can.not.detect.version.default.message=无法检测 {0} 版本
php.test.framework.configuration.ui.select.interpreter=请选择 PHP 解释器以加载 {0} 版本
php.test.framework.configuration.ui.select.local.interpreter=请选择本地 PHP 解释器以加载 {0} 版本
php.test.framework.configuration.updated.version=已成功更新 {0} 版本
php.test.framework.configuration.can.not.update=无法更新 {0} 版本
php.test.framework.default.interpreter.is.not.local=无法检测到 {0} 版本。默认 PHP 解释器不是本地解释器

php.test.framework.version.getting.version.title=正在获取 {0} 版本…
php.test.framework.version.path.to.exe.is.invalid={0} 可执行文件的路径为空或无效。
php.test.framework.version.detector.empty.output=''{0}'' 命令输出为空。
php.test.framework.version.configuration.ui.can.not.parse.version=无法解析版本命令输出。\n\
{0}

php.test.framework.by.sdk.new.settings.dialog.title=通过远程解释器{0}
php.test.framework.by.sdk.dialog.label=解释器(&I)\:
php.test.framework.by.sdk.settings.select.server=选择远程解释器以配置远程{0}
php.test.framework.by.sdk.settings.already.exist=所选解释器的 {0} 设置已存在
php.test.framework.by.sdk.settings.remote.path.title=选择服务器上的路径

php.test.framework.run.configuration.ui.scope=测试范围\:
php.test.framework.run.configuration.ui.type.radio.button=&按类型分组
php.test.framework.run.configuration.ui.directory.radio.button=目录 (&D)
php.test.framework.run.configuration.ui.file.radio.button=&文件
php.test.framework.run.configuration.ui.scenario.radio.button=&方法
php.test.framework.run.configuration.ui.configuration.radio.button=在配置文件中定义(&C)
php.test.framework.run.configuration.ui.type.combo.box=按类型分组\:
php.test.framework.run.configuration.ui.directory.text.field=目录\:
php.test.framework.run.configuration.ui.file.text.field=文件\:
php.test.framework.run.configuration.ui.scenario.text.field=方法\:
php.test.framework.run.configuration.ui.alternative.configuration.file=使用替代配置文件(&U)\:
php.test.framework.run.confuguration.ui.dialog.caption.test.runner.options=测试运行程序选项
php.test.framework.field.test.runner.options=测试运行程序选项(&O)\:
php.test.framework.run.configuration.ui.custom.file.radio.button=在 {0} 中定义
php.test.framework.run.configuration.ui.alternative.custom.file=使用替代 {0}(&U)
php.test.framework.run.configuration.select.interpreter=未选择解释器。
php.test.framework.settings.is.not.provided.or.empty={1} 的 {0} 路径未配置。按“修复”以编辑您的 {0} 配置。

php.test.framework.interpreter.conflict=发现应用程序级 {0} 配置冲突。为解决该问题，创建了以下配置的项目级副本\:
php.test.framework.interpreter.conflict.title={0} 配置冲突
php.test.framework.project.level=(当前项目)
php.test.framework.no.configuration.types.are.available=没有可用的其他配置类型

# validation
php.test.framework.validation.run.configuration.no.type=如果未选择类型则无法运行测试。
php.test.framework.validation.run.configuration.unsupported.type=无法通过 ''{0}'' 命令运行测试。
php.test.framework.validation.run.configuration.working.directory=目录应该是工作目录的子文件夹\: ''{0}''
php.test.framework.validation.run.configuration.file.working.directory=文件应该是工作目录的子项\: ''{0}''
php.test.framework.validation.run.configuration.method=在 ''{1}'' 中找不到 ''{0}''

php.executable.macro.description=项目设置中配置的 Php 可执行文件
inspection.undefined.class.dont.report.multiresolve=不报告多个类声明潜在问题
inspection.undefined.class.ignore.phpdoc=忽略 PHPDoc

inspection.missing.ext.composer.json=composer.json 中缺少 ''{0}''
inspection.missing.ext.require.bundled=需要 PHP 捆绑的扩展
add.to.composer.json.quick.fix=向 composer.json 中添加 ''{0}''

configure.php.include.paths=配置 PHP Include 路径(&O)…

interpreter=解释器

XdebugShowUserDefinedConstantsToggleAction.text=显示用户定义的常量
XdebugShowUserDefinedConstantsToggleAction.description=将其禁用会停止获取用户定义的常量信息并提高调试器性能
XdebugShowValuesAddressesToggleAction.text=显示值地址
XdebugAddMethodToSkipListToggleAction.text=将方法添加到跳过列表
PhpDebugHideEmptySuperGlobalsToggleAction.text=显示空的超全局变量
PhpDebugBreakAtFirstLineToggleAction.text=在 PHP 脚本中的第一行中断
PhpUserDefinedConstantsGroup.name=常量

PhpLanguageLevel.5.3.0.presentable.name=5.3
PhpLanguageLevel.5.3.0.short.description=命名空间，闭包
PhpLanguageLevel.5.4.0.presentable.name=5.4
PhpLanguageLevel.5.4.0.short.description=特征，短数组语法
PhpLanguageLevel.5.5.0.presentable.name=5.5
PhpLanguageLevel.5.5.0.short.description=finally，生成器
PhpLanguageLevel.5.6.0.presentable.name=5.6
PhpLanguageLevel.5.6.0.short.description=可变函数，参数解压缩
PhpLanguageLevel.7.0.0.presentable.name=7.0
PhpLanguageLevel.7.0.0.short.description=返回类型，标量类型提示
PhpLanguageLevel.7.1.0.presentable.name=7.1
PhpLanguageLevel.7.1.0.short.description=常量可见性，可为 null，多个异常
PhpLanguageLevel.7.2.0.presentable.name=7.2
PhpLanguageLevel.7.2.0.short.description=对象类型提示，抽象函数重写
PhpLanguageLevel.7.3.0.presentable.name=7.3
PhpLanguageLevel.7.3.0.short.description=列表赋值中的引用，灵活的 heredoc
PhpLanguageLevel.7.4.0.presentable.name=7.4
PhpLanguageLevel.7.4.0.short.description=类型属性，短闭包，null 合并运算符

PhpLanguageFeature.traits.not.supported=仅 PHP 5.4 允许特征 use
PhpLanguageFeature.short.array.syntax.not.supported=仅 PHP 5.4 允许短数组语法
PhpLanguageFeature.array.dereferencing.not.supported=仅 PHP 5.4 允许调用时取消数组引用
PhpLanguageFeature.class.member.access.on.instantiation.not.supported=仅 PHP 5.4 允许在实例化时访问类成员
PhpLanguageFeature.this.in.closure.not.supported=仅 PHP 5.4 允许在闭包中使用 $this
PhpLanguageFeature.self.in.closure.not.supported=仅 PHP 5.4 允许在闭包中使用 self
PhpLanguageFeature.parent.in.closure.not.supported=仅 PHP 5.4 允许在闭包中使用 parent
PhpLanguageFeature.static.in.closure.not.supported=仅 PHP 5.4 允许在闭包中使用 static
PhpLanguageFeature.binary.literal.not.supported=仅 PHP 5.4 允许二进制文字
PhpLanguageFeature.literal.in.static.call.not.supported=仅 PHP 5.4 允许在静态调用中使用文字
PhpLanguageFeature.built.in.web.server=内置 Web 服务器仅自 PHP 5.4 起可用
PhpLanguageFeature.var.break.argument.not.supported=PHP 5.4 不再支持具有非常量操作数的 'break' 运算符
PhpLanguageFeature.var.break.zero.argument.not.supported=自 PHP 5.4 起，'break' 运算符仅接受正数
PhpLanguageFeature.var.continue.not.supported=PHP 5.4 不再支持具有非常量操作数的 'continue' 运算符
PhpLanguageFeature.var.continue.zero.not.supported=自 PHP 5.4 起，'continue' 运算符仅接受正数
PhpLanguageFeature.call.time.pass.by.reference.not.supported=调用时通过引用传递在 PHP 5.4 中已被移除

PhpLanguageFeature.finally.not.supported=仅 PHP 5.5 允许 finally 子句
PhpLanguageFeature.generators.not.supported=仅 PHP 5.5 允许生成器
PhpLanguageFeature.foreach.list.not.supported=仅 PHP 5.5 允许 foreach 中的列表
PhpLanguageFeature.empty.any.expression.not.supported=仅 PHP 5.5 允许在 empty 中使用任意表达式
PhpLanguageFeature.immediate.dereferencing.not.supported=仅 PHP 5.5 允许立即取消引用
PhpLanguageFeature.class.name.const.not.supported=类名常量仅在 PHP 5.5 中可用

PhpLanguageFeature.constant.scalar.expressions=常量标量表达式仅在 PHP 5.6 中可用
PhpLanguageFeature.variadic.functions=可变函数仅在 PHP 5.6 中可用
PhpLanguageFeature.argument.unpacking=参数解压缩仅在 PHP 5.6 中可用
PhpLanguageFeature.exponentiation=求幂仅在 PHP 5.6 中可用
PhpLanguageFeature.use.function.and.const=use 函数和 const 仅在 PHP 5.6 中可用

PhpLanguageFeature.return.types=返回类型声明仅在 PHP 7 中可用
PhpLanguageFeature.scalar.type.hints=标量类型提示仅在 PHP 7 中可用
PhpLanguageFeature.spaceship.operator=太空船运算符仅在 PHP 7 中可用
PhpLanguageFeature.coalesce.operator=合并运算符仅在 PHP 7 中可用
PhpLanguageFeature.grouped.use=分组的使用声明仅在 PHP 7 中可用
PhpLanguageFeature.keyword.names=关键字只能在 PHP 7 中用作名称
PhpLanguageFeature.uniform.variable.syntax=统一变量语法仅在 PHP 7 中可用
PhpLanguageFeature.anonymous.classes=匿名类仅在 PHP 7 中可用

PhpLanguageFeature.return.void=返回 void 只能在 PHP 7.1 中使用
PhpLanguageFeature.nullables=可为 null 只能在 PHP 7.1 中使用
PhpLanguageFeature.iterable.type.hint=可迭代类型提示仅在 PHP 7.1 中可用
PhpLanguageFeature.catch.multiple=捕获多个语句只能在 PHP 7.1 中使用
PhpLanguageFeature.class.constant.visibility=类常量可见性只能在 PHP 7.1 中使用
PhpLanguageFeature.list.keys=列表解压缩中的键只能在 PHP 7.1 中使用
PhpLanguageFeature.list.assign=列表解压缩中的 [] 只能在 PHP 7.1 中使用
PhpLanguageFeature.negative.numeric.indices=负数值索引只能在 PHP 7.1 中使用

PhpLanguageFeature.object.type.hint=对象类型提示仅在 PHP 7.2 中可用
PhpLanguageFeature.abstract.function.override=仅 PHP 7.2 允许抽象函数重写

PhpLanguageFeature.literal.in.instanceof=文字作为第一个操作数仅在 PHP 7.3 中可用
PhpLanguageFeature.references.in.list=[] 和 list() 赋值中的引用仅在 PHP 7.3 中可用
PhpLanguageFeature.trailing.comma.in.function.calls=函数调用中的尾随逗号
PhpLanguageFeature.flexible.heredocs=灵活的 heredoc/nowdoc 语法

PhpLanguageFeature.typed.properties=类型属性仅在 PHP 7.4 中可用
PhpLanguageFeature.spread.operator.in.array=数组中的延展操作符仅在 PHP 7.4 中可用
PhpLanguageFeature.coalesce.assign=??\= 仅在 PHP 7.4 中可用
PhpLanguageFeature.arrow.function=箭头函数语法仅在 PHP 7.4 中可用
PhpLanguageFeature.numeric.literals.separators=数字文字分隔符仅在 PHP 7.4 中可用
PhpLanguageFeature.exception.throw.from.toString=自 PHP 7.4 起，才可以从 '__toString' 抛出异常

#Empty project generation
php.empty.project.generator.name=PHP 空项目
php.empty.project.generator.description=为 PHP 创建空项目

#UML
error.cant.create.edge=无法创建关系链接
relationship.already.exists={0}和{1}之间的关系已存在
this.will.remove.relationship.link.between.classes=这将移除类之间的关系链接并修改类 {0}。继续？
remove.relationship.link=移除关系链接
final.class.cant.be.inherited=类 {0} 是 final
node.is.interface=接口只能继承一个接口
inspection.undefined.member.downgrade=如果类中存在 __magic 方法则降级严重性(&D)

#Phar
phar.include.into.project.action.title=将 phar 包含到项目中
phar.exclude.from.project.action.title=从项目中排除 phar
phar.exclude.or.include.into.project.action.title=在项目中包含 Phar 或从项目中排除 Phar
phar.failed.to.parse=无法解析
phar.file.type.description=Php Phar

#Composer

framework.composer.name.composer=Composer
framework.composer.path.dialog.path.to.composer=Composer 路径
framework.composer.path.dialog.path.to.composer.json=composer.json 路径
framework.composer.path.dialog.specify.composer.phar=指定 Composer phar\:
framework.composer.path.dialog.specify.composer.executable=指定 Composer 可执行文件\:
framework.composer.path.dialog.specify.composer.json=指定 composer.json\:
framework.composer.configurable.title=Composer
framework.composer.init.dialog.title.composer.settings=Composer 设置
framework.composer.path.form.path.label=composer.phar 路径(&P)\:
framework.composer.path.form.download.label=点击此处从 getcomposer.org 下载
framework.composer.comment.old.config.command.title=初始化 composer.json
framework.composer.file.0.is.not.found=找不到文件 ''{0}''。

framework.composer.add.dependency.task.title=添加依赖项
framework.composer.add.dependency.install.button=安装
framework.composer.add.dependency.update.button=更新
framework.composer.add.dependency.close.button=关闭
framework.composer.failed.to.0=无法{0}。
framework.composer.0.1.version.2={0} {1}，版本 {2}
framework.composer.add.dependency.show.output=显示输出
framework.composer.add.dependency.hide.tooltip=隐藏
framework.composer.add.dependency.successfully.installed.0.version.1=已成功安装 {0}，版本 {1}。
framework.composer.add.dependency.running=运行中...
framework.composer.add.composer.dependency.title=管理 Composer 依赖项
framework.composer.failed.to.connect.to.0.1.please.check.your.internet.connection=无法连接到 {0}\: {1}。请检查您的网络连接。
frameworks.composer.could.not.get.packages.info.0=无法获取包信息。{0}
frameworks.composer.could.not.get.package.info=无法获取包信息。
framework.composer.package.description.title=描述
framework.composer.label.version.to.install=要安装的版本(&V)\:
framework.composer.empty.package.name.in.0={0} 中的包名称为空
framework.composer.no.package.versions.in.0={0} 中没有包版本
framework.composer.expected.name.0.versions.0.description.got.1=应为 <name> {0} <versions> {0} <description>，获得的是 {1}
framework.composer.add.dependency.available.packages.label=可用包
framework.composer.package.default.version=<默认>
framework.composer.add.dependency.no.package.selected=未选择包
framework.composer.path.form.execution.validation.wrapper=<html>执行未设置。<br/>{0}</html>
framework.composer.path.form.empty.path.to.composer.phar=composer.phar 路径为空
framework.composer.path.form.empty.path.to.composer.executable=Composer 可执行文件路径为空
framework.composer.project.generator.name=Composer 项目
framework.composer.project.generator.description=通过 Composer 命令创建项目。
framework.composer.failed.to.download.composer.phar=无法下载 composer.phar
framework.composer.project.generator.failed.to.copy.temp.directory.0.content.to.project.root=无法将临时目录 ''{0}'' 内容复制到项目根
framework.composer.project.generation.error.title=无法创建 Composer 项目
framework.composer=Composer
framework.composer.failed.to.run.create.project.command.more=无法运行 'create-project' 命令。<a href\=\"\">更多…</a>
framework.composer.create.project.progress.title=创建项目
framework.composer.create.project.from=自以下创建项目
framework.composer.install.action.name=安装
framework.composer.path.validation.0.is.a.directory={0} 是目录
framework.composer.command.create.project.was.cancelled.check.its.output=命令 'create-project' 已被取消。<a href\=\"\">检查</a>其输出。
framework.composer.path.form.empty.path.to.composer.json=composer.json 路径为空
framework.composer.vendors.library.name=Composer 供应商
framework.composer.selected.file.is.not.composer.json=所选文件不是 composer.json
framework.composer.notification.title.init.composer=初始化 Composer
framework.composer.file.0.set.as.composer.config.change.setting.a.href.here.a=文件 ''{0}'' 设置为 Composer 配置。
framework.composer.failed.to.parse.package.names=无法解析包名称。
framework.composer.failed.to.load.package.names=无法加载包名称。
framework.composer.invalid.composer.json.format=composer.json 格式无效
framework.composer.failed.to.parse.package.description=无法解析包描述。
framework.composer.add.dependency.no.version.selected=未选择版本
framework.composer.add.dependency.settings.cl.dialog.title=参数
framework.composer.add.dependency.settings.cl.label=命令行参数(&P)\:
framework.composer.add.dependency.settings.interpreter.label=PHP 解释器\:
framework.composer.add.dependency.settings.title=&设置
framework.composer.no.description.available=无可用描述。
framework.composer.packages.were.moved.to.0.php.include.paths.popup=Composer 包已从 Composer 外部库移至 PHP include 路径。
framework.composer.packages.were.changed.0.excluded.folders.popup=Composer 包已更改，因此更新了排除的文件夹。
framework.composer.packages.were.changed.0.php.include.paths.popup=Composer 包已更改，因此更新了 PHP include 路径。
framework.composer.packages.were.removed.0.excluded.folders.popup=Composer 包已从排除的文件夹中移除。
framework.composer.packages.were.removed.0.php.include.paths.popup=Composer 包已从 PHP include 路径中移除。
framework.composer.packages.were.added.0.excluded.folders.popup=Composer 包已被添加到排除的文件夹中。
framework.composer.packages.were.added.0.php.include.paths.popup=Composer 包已被添加到 PHP include 路径中。
framework.composer.failed.to.0.1.script.was.cancelled=无法{0} {1}。脚本已被取消。
framework.composer.add.dependency.successfully.updated.0=已成功更新 {0}。
framework.composer.add.dependency.no.new.version.found.for.0=找不到 {0} 的新版本。
framework.composer.add.dependency.successfully.removed.0=已成功移除 {0}。
framework.composer.updating.package.task.title=更新包
framework.composer.removing.package.task.title=移除包
framework.composer.update.action.name=更新
framework.composer.remove.action.name=移除
framework.composer.self.update.action.name=自我更新
framework.composer.label.installed.version=已安装的版本\:
framework.composer.path.to.php.executable.titled=PHP 可执行文件的路径
framework.composer.specify.php.executable.0=指定 PHP 可执行文件 {0}
framework.composer.empty.path.to.0={0} 的路径为空
framework.composer.default.project.interpreter=默认项目解释器
framework.composer.default.interpreter.is.not.configured=尚未为此项目配置默认解释器。
framework.composer.default.interpreter.for.this.project.is.remote=此项目的默认解释器是远程解释器，无法使用。
framework.composer.default.composer.interpreter.name=Composer 的解释器
framework.composer.interpreters.combo.default.interpreter=< 默认解释器 >
framework.composer.interpreters.combo.default.project.interpreter=< 默认项目解释器 >
framework.composer.interpreters.combo.no.default.interpreter=默认设置中没有默认解释器
framework.composer.interpreters.combo.no.default.interpreter.in.project=此项目中没有默认解释器
framework.composer.interpreters.combo.remote.default.interpreter=默认解释器是远程解释器；目前尚不受支持
framework.composer.interpreters.combo.default.interpreter.no.php.path=默认解释器未提供 PHP 路径
framework.composer.initialize.popup=找到了 Composer 配置文件 {0}。项目设置与其同步。
framework.composer.install.task.title=正在安装包
framework.composer.update.task.title=更新包
framework.composer.self.update.task.title=更新 Composer
framework.composer.script.run.configuration.name=Composer 脚本
framework.composer.script.run.configuration.description=Composer 脚本运行配置
framework.composer.run.path.to.composer.json=composer.json 路径：
framework.composer.run.script=脚本\:
framework.composer.run.script.missing=未指定 Composer 脚本
framework.composer.available.version=可用版本\:
framework.composer.package.version.available.0={0}的更新
framework.composer.failed.check.for.update=无法运行 'update --dry-run' 命令。
framework.composer.checking.for.update=正在检查更新…
framework.composer.loading.packages=正在加载 Composer 包
framework.composer.loading.package.description=正在加载包描述


php.interpreter.not.configured.title=未配置 PHP 解释器
php.interpreter.not.configured=请<a href\="">配置 PHP 解释器</a>以使用内置 Web 服务器
php.interpreter.is.remote.title=已配置远程 PHP 解释器
php.interpreter.is.remote.message=请<a href\="">选择本地 PHP 解释器</a>以使用内置 Web 服务器

php.cgi.not.found.title={0}未找到
php.cgi.not.found=请确保<a href\="">配置的 PHP 解释器</a>作为 CGI 程序构建(指定了 --enable-fastcgi)
inspection.missing.doc.comment.check.functions.without.params.and.return=忽略没有 @param/@return 的 PHPDoc

php.smart.indent.codestyle.indent.in.php=缩进 PHP 标签中的代码

phpdoc.code.style.title=PHPDoc

phpdoc.code.style.generated.doc.blocks=生成的 PHPDoc 标签
phpdoc.code.style.sort.doc.blocks=PHPDoc 标签顺序

phpdoc.code.style.force.null.position=将 ‘null’ 置于以下类型中\:
phpdoc.code.style.in.beginning.position=在开头
phpdoc.code.style.in.end.position=在末尾

phpdoc.code.style.convert.true.false.to=将 True/False 常量转换为：
phpdoc.code.style.convert.null.to=将 Null 常量转换为：
php.code.style.convert.keyword.to.lowercase=将关键字转换为小写
php.code.style.convert.lower.case=小写
php.code.style.convert.upper.case=大写
php.code.style.sort.use.stmt=对语句进行使用排序：
php.code.style.sort.alphabetically=按字母顺序
php.code.style.sort.by.length=按长度

phpdoc.code.style.convert.else.if.to=将 else if/elseif 转换为：
phpdoc.code.style.convert.else.if.separate=else if
phpdoc.code.style.convert.else.if.combine=elseif

phpdoc.code.style.throws.analysis.depth.performance.note.title=性能注释
phpdoc.code.style.throws.analysis.depth.performance.note.message=不建议深入分析多个级别，因为这可能会影响 IDE 性能。要继续吗?

phpdoc.code.style.param.spaces.panel=PHPDoc '@param' 空间
phpdoc.code.style.param.spaces.between.tag.and.type=在标签和类型之间：
phpdoc.code.style.param.spaces.between.type.and.name=类型和名称之间：
phpdoc.code.style.param.spaces.between.name.and.description=在名称和描述之间：

php.conversion.code.style.title=代码转换

php.generation.code.style.title=代码生成

array.declaration.style=数组/列表声明样式

variable.naming.style.panel=变量命名样式
variable.naming.style.mixed=混合
variable.naming.style.camel.case=骆驼拼写法
variable.naming.style.snake.case=蛇形拼写法

php.prefdefined.codestyle.psr12.chosen.title=PSR-12 代码样式
php.prefdefined.codestyle.psr12.chosen.message=您可以启用其他 PSR-12 检查，这些检查当前已禁用。
php.prefdefined.codestyle.psr12.enabled.message=PSR-12 检查已启用。

fields.default.visibility.panel=属性默认可见性
fields.default.visibility.private=private
fields.default.visibility.protected=protected
fields.default.visibility.public=public

php.embedded.stubs.incorrect.path.warning.title=默认存根路径不正确
php.embedded.stubs.incorrect.path.warning.message=配置的默认存根路径 ''{0}'' 不存在，改为使用嵌入式存根。
php.embedded.stubs.notification.provider.notification=您正在查看不可变的嵌入式存根。为了能够编辑它们，您需要克隆一个存根项目，然后通过“语言和框架 / PHP / 高级设置”提供默认存根路径。
php.embedded.stubs.notification.provider.clone=在 GitHub 上克隆
php.embedded.stubs.notification.provider.provide=提供默认存根路径
php.embedded.stubs.notification.provider.do.not.show.again=不要再显示

auto.import.in.file.scope=在文件范围内启用自动导入
auto.import.in.namespace.scope=在命名空间范围内启用自动导入
auto.import.from.global.space=处理来自全局空间的符号
auto.import.from.global.space.class=类
auto.import.from.global.space.function=函数
auto.import.from.global.space.constant=常量
auto.import.from.global.space.prefer.fallback=回退优先
auto.import.from.global.space.prefer.import=导入优先
auto.import.from.global.space.prefer.fqn=FQN 优先
# non-strict
quickfix.non.strict.object.equality=非严格对象相等比较
inspection.non.strict.object.equality=非严格对象相等比较

exception.analysis.settings.path=语言和框架 / PHP / 分析
inspection.severity.with.magic=当 __magic 存在时显示

import.references.on.paste.dialog.title=选择要导入的{0}
import.references.on.paste.dialog.message=<html>粘贴的代码片段使用 {0}，后者在目标范围中不能通过导入访问。<br/>选择您想要导入到范围中的{0}。</html>
skip.constant.params=使用常量参数跳过调用
inspection.unused.declaration.option.test.entry_points=假定测试声明为入口点
inspection.unused.declaration.option.show.unused_from_entries=显示所有声明
inspection.unused.declaration.option.show_strictly_unused=仅显示未使用项
inspection.unused.declaration.option.test.suppressGettersAndSetters=抑制 getter/setter
inspection.code.patterns.panel.errors.class = 模式必须是有效的 php fqn，仅接受 '*' 作为占位符
inspection.code.patterns.panel.errors.member = 方法模式 {0} 必须是有效的 php 标识符，仅接受 ''*'' 作为占位符
inspection.code.patterns.panel.description.label = 如果 fqn 名称匹配，则将代码标记为入口点
inspection.code.patterns.panel.description.text = 将方法留空以表示构造函数 \n\
 任何 * 都将与 fqn 名称中的一个或多个字符匹配
inspection.unusedd.description.code.patterns.button.label=代码模式
inspection.unused.description.code.suppressed.annotations=已抑制的注解
inspection.undefined.member.warnOnMixed=出现混合、对象、stdClass、未定义类型、null 的访问成员时通知
configurable.PhpServerConfigurable.display.name=服务器
configurable.PhpStanConfigurable.display.name=PHPStan
configurable.PhpStanConfigurableForm.display.name=PHPStan
configurable.PhpDebugConfigurable.display.name=调试
configurable.PhpProjectConfigurable.display.name=PHP
configurable.PhpSmartKeysConfigurable.display.name=PHP
configurable.QualityToolCommonConfigurable.display.name=质量工具
phpstan.checkbox.full.project.run=完整项目运行
phpstan.label.options=选项\:
class.implements.solely.traversable=类 ''{0}'' 必须将接口 Traversable 作为 Iterator 或 IteratorAggregate 的一部分来实现
configurable.PhpServersConfigurable.display.name=服务器
configurable.PhpTestFrameworksConfigurable.display.name=测试框架
configurable.PhpTemplatesCommonConfigurable.display.name=模板
PhpStepFiltersConfigurable.display.name=步进筛选器
settings.default.remote.interpreter=默认远程解释器
php.element.is.available.starting.with.php.version=''{0}'' 从 PHP 版本 {1} 开始可用
php.element.was.removed.in.php.version=''{0}'' 已在 PHP {1} 版本中被移除
settings.smart.keys.title=PHP
settings.smart.keys.enable.smart.function.parameters.completion=启用智能函数参数补全
settings.smart.keys.select.variable.name.without.dollar.sign.on.double.click=双击时选择不含 '$' 符号的变量名称
settings.smart.keys.remove.php.open.close.tags.while.pasting.in.php.context=在 PHP 上下文中粘贴时移除 PHP 开始/结束标记
settings.smart.keys.auto.insert.tag.after.typing=输入 '<?' 后自动插入 '<?php' 标记
settings.smart.keys.find.usages.of.base.method.prompt=搜索方法用法时显示其他选项
php.exception.is.never.thrown=函数中从未抛出异常 ''{0}''
php.remove.exception.from.throws=从 @throws 标记中移除 ''{0}''
php.remove.throws.tag=从 @throws 标记移除
php.add.exception=将 ''{0}'' 添加到现有 @throws 标记
ternary.condition.can.be.replaced.with.condition.expression=表达式可以安全地替换为 ''{0}''
php.replace.with=替换为''{0}''
php.tag.is.deprecated={0} 已弃用，将在 PHPUnit 9 中移除
potentially.polymorphic.call.multiple.subclasses=潜在的多态调用。该代码可能无法操作，具体取决于作为参数传递的实际类实例。
trait.already.contains.method=特征 {0} 已包含方法 {1}
potentially.polymorphic.call.single.subclass=潜在的多态调用。{0} 的层次结构中没有成员
navigate.to.meta.declaration=导航到 ''{0}''
meta.declaration.exists=''{1}'' 存在元声明 ''{0}''
meta.multiple.declaration.exists=''{0}'' 存在多个元声明
meta.declaration.line.marker.name=存在元声明
unnecessary.local.variable=不必要的局部变量
phpunit.10.won.t.support.classname.annotations=PHPUnit 10 将不支持 ClassName\:\:<*> 注解
returned.by.iterator.aggregate.should.be.traversable=\\IteratorAggregate\:\:getIterator() 返回的对象必须为 Traversable 或实现接口 Iterator
inspection.probably.undefined.property=属性 '\#ref' 已动态声明，可能未定义
find.classes.without.member=查找没有成员的类
classes.without.member=层次结构中不带 ''{0}'' 的类
remove.pass.by.ref=移除 '\\&'
pass.by.ref.is.not.effectively.used.inside.body=通过引用传递未在主体内有效使用
suppress.if.annotated.by.tag=如果用 ''{0}'' 注解，则抑制
configure.suppressed.annotations=配置抑制的注解
enter.annotation=输入注解
suppressed.annotation.title=已抑制的注解
type.primitive.hints.names.are.forbidden=禁止名为 'true'、'false' 和 'null' 的类型提示
primitive.hints.name.are.forbidden.in.php.7=PHP 7 中禁止名为 'int'、'string'、'float'、'bool'、'true'、'false' 和 'null' 的类
classes.named.void.and.iterable.are.forbidden.in.php.7.1=PHP 7.1 中禁止名为 'void' 和 'iterable' 的类
classes.named.object.are.forbidden.in.php.7.2=PHP 7.2 中禁止名为 'object' 的类
switch.statements.may.only.contain.one.default.clause.in.php.7=在 PHP 7 中，switch 语句只能包含一个 'default' 子句
show.composer.settings.action.name=显示 Composer 设置
composer.change.setting.action.name=更改设置
composer.diagnose.task.title=诊断
composer.simulating.update.task.title=模拟更新
composer.generating.autoloader.task.title=生成自动加载器
composer.autoloader.generation.settings.name=自动加载器生成设置
composer.generate.list.popup.title=生成
install.composer.packages.task.title=安装 Composer 包
composer.listing.licenses.task.title=列出许可证
composer.update.composer.task.title=更新 Composer
composer.checking.for.changes.in.code.of.dependencies.task.title=检查依赖项代码中的变更
composer.update.composer.packages.task.title=更新 Composer 包
composer.validating.task.title=验证
composer.validation.settings.name=验证设置
composer.validate.dialog.action.button.title=验证
composer.revert.action.name=还原
composer.clearing.cache.action.name=清除缓存
composer.remove.action.name=移除 (&R)
composer.checkbox.download.composer.phar.from.getcomposer.org=从 getcomposer.org 下载 composer.phar
composer.label.phar=composer.phar
composer.label.executable='composer' 可执行文件
composer.checkbox.check.if.composer.lock.is.up.to.date=检查 composer.lock 是否为最新
composer.checkbox.autoload.classes.from.the.classmap.only=仅从类映射自动加载类
composer.label.can.be.time.consuming=可能较为耗时
composer.checkbox.disable.autoload.dev.dependencies=禁用 autoload-dev 依赖项
composer.checkbox.optimize.autoloader.convert.psr.0.4.rules.to.a.classmap=优化自动加载器(将 PSR-0/4 规则转换为类映射)
composer.checkbox.skip.scripts.execution=跳过脚本执行
composer.checkbox.use.apcu.to.cache.found.not.found.classes=使用 APCu 缓存找到/未找到的类
composer.checkbox.allow.unbound.version.constraints=允许未绑定的版本约束
composer.checkbox.check.if.the.package.is.packagist.ready=检查包是否为 Packagist 就绪
composer.checkbox.validate.package.dependencies=验证包依赖关系
composer.checkbox.synchronize.ide.settings.with.composer.json=将 IDE 设置与 composer.json 同步(&S)
composer.label.path.to.composer.json=composer.json 路径(&C)\:
composer.label.the.settings.php.language.level.directories.may.be.updated=设置(Php 语言级别，目录)可能会更新
composer.border.title.package=包
composer.label.package=包\:
composer.label.version.to.install=要安装的版本\:
composer.label.filter.packages=筛选包(&F)\:
composer.label.label=标签
composer.border.title.execution=执行
php.run.label.server=服务器\:
php.run.label.url=URL\:
php.run.label.query.string=查询字符串\:
php.run.label.request.body=请求正文\:
php.run.label.request.method=请求方法\:
php.run.label.send.request.body.as=将请求正文发送为\:
php.run.radio.button.key.value=键值
php.run.http.border.title.configuration=配置
php.run.label.interpreter=解释器：
php.run.radio.button.text=文本文件
replace.with.alias.from.target.scope=替换为目标范围中的别名
php.information.dialog.title=PHP 信息
extract.method.parameter.name.column.title=参数
constant.with.same.name.already.exists.in.0={0}中已经存在具有相同名称的常量
path.0.is.invalid=路径''{0}''无效
rename.parameters.dialog.title=重命名参数
rename.parameter.dialog.description=以层次结构重命名参数\:
quality.tools.custom.coding.standard=自定义编码标准
quality.tools.0.added.to.ignored.files.list={0}已添加到忽略的文件列表。
create.new.field.dialog.title=创建新字段
uml.wrong.name=错误的名称
uml.0.already.exists.in.class.1=类 {1} 中已经存在 ''{0}''

checkbox.add.packages.as.libraries=作为库添加包(&A)
phpunit.label.data.set=数据集\:
label.insert.imports.on.paste=粘贴时插入导入\:
border.title.php=PHP
label.class.fqn=类 FQN
label.method.name=方法名称
checkbox.move.to.another.class=&移动到另一个类
label.visibility=可见性(&V)
label.initialize.in=&初始化在
radio.button.const=const(&C)
radio.button.define=&定义
border.title.constant.syntax=常量语法
border.title.visibility=可见性
radio.button.default=默认(&F)
radio.button.public=public(&U)
radio.button.private=private(&I)
radio.button.protected=protected(&O)
radio.button.by.concatenation=通过串联(&C)
radio.button.by.embeding=通过嵌入(&E)
radio.button.class.constructor=类构造函数(&S)
radio.button.current.method=当前方法(&T)
radio.button.field.declaration=字段声明 (&D)
border.title.initialize.in=初始化在
border.title.introduce.field=引入字段
radio.button.setup=设置(&U)
border.title.introduce.variable=引入变量
label.name=名称\:
label.visibility2=可见性\:
checkbox.static=静态
checkbox.check.clone.method=检查 __clone 方法
checkbox.check.destruct.method=检查 __destruct 方法
checkbox.check.sleep.method=检查 __sleep 方法
checkbox.check.wakeup.method=检查 __wakeup 方法
checkbox.align.parameter.property.names=对齐参数/属性名称
checkbox.align.tag.comments=对齐标记注释
checkbox.blank.line.before.the.first.tag=在第一个标记前使用空行
checkbox.blank.lines.around.parameters=在参数周围使用空行
checkbox.keep.blank.lines=保持空行
checkbox.sort.phpdoc.tags=对 PHPDoc 标记排序
checkbox.use.fully.qualified.class.names=使用完全限定类名
checkbox.wrap.long.lines=长行换行
checkbox.use.as.a.default.template=用作默认模板
label.server.document.root=$_SERVER['DOCUMENT_ROOT']
tooltip.defaults.to.project.folder=默认为项目文件夹
border.title.include.analysis=Include 分析
button.sync.extensions.with.interpreter=将扩展与解释器同步
checkbox.add.a.comma.after.last.element.in.multiline.array=在多行数组中的最后一个元素之后添加逗号
checkbox.force.short.declaration.style=强制短声明样式
checkbox.add.phpdoc=添加 PHPDoc(&D)\:
radio.button.copy.from.base.class=从基类复制(&P)
radio.button.default.empty.template=默认/空模板(&E)
radio.button.with.inheritdoc.tag=带有 @inheritDoc 标记(&I)
label.constant.syntax=常量语法(&C)
php.interpreter.label.label=标签
no.expression.found=未找到表达式
empty.type=空类型
find.usages.button.base.method=基方法
find.usages.button.current.method=当前方法
find.usages.prompt.dialog.implements=类 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中实现了{3,choice,0\#方法|1\#方法}\n\
要查找基{3,choice,0\#方法|1\#方法}的用法吗?
find.usages.prompt.dialog.overrides=类 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中重写了{3,choice,0\#方法|1\#方法}\n\
要查找基{3,choice,0\#方法|1\#方法}的用法吗?