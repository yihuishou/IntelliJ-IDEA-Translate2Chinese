action.invalid.for.selection=操作对当前选择无效
action.create.new.file=新建{0}
action.new.file.creation=创建新文件
annotator.type.literals.are.not.supported=编译器不支持 {0} 文字
extract.category.dialog=提取类别
extract.category.unable.create.file=无法创建文件
extract.unavailable.for.protocols=此操作不适用于协议
extract.method.selected.block.hint=选块应该代表一组语句或表达式
extract.method.cannot.determine.hint=无法确定所选表达式的类型
extract.class.use.protocol.instead=改用“提取超级协议”
extract.class.element.not.located.hint=所选元素是一个不在项目内部的类上的类别
extract.subclass.dialog.title=提取子类
extract.symbol.already.exist={0}已存在
create.file.title=文件
create.file.description=创建新文件
create.field.name=名称\:
create.field.name.category=类别名称(&N)\:
create.field.location=文件夹(&F)\:
create.field.language=&语言\:
create.field.class=类\:
create.field.type=类型(&P)\:
create.checkbox.targets=添加到目标(&A)
create.tooltip.no.targets=没有合适的目标
create.error.invalid.name=名称 ''{0}'' 无效
create.error.missing.target.dir=找不到目标目录
create.error.dir.exists=名称为 ''{0}'' 的目录已存在
create.error.file.exists=名称为 ''{0}'' 的文件已存在
create.error.files.in.directory=无法在目录 ''{1}'' 中创建文件 ''{0}''
create.folder.dialog.title=选择目标文件夹
create.folder.dialog.description=选择目标文件夹
create.tooltip.arrows.type=在编辑器中按向上或向下箭头可更改类型
create.class.title=类
create.class.dialog.title=新建 Objective-C 类
create.cpp.class.title=C++ 类
create.cpp.class.description=创建新的 C++ 类
create.cpp.class.dialog.title=新建 C++ 类
create.checkbox.cpp.class.header=仅创建头(&H)
create.cpp.source.title=C/C++ 源文件
create.cpp.header.title=C/C++ 头文件
create.checkbox.source.associated.header=创建关联头(&H)
create.class.description=创建新的 Objective-C 类和头文件
create.protocol.title=协议
create.protocol.description=创建新的 Objective-C 协议
create.protocol.dialog.title=新建 Objective-C 协议
create.category.title=分类
create.category.description=创建新的 Objective-C 类别
create.category.dialog.title=新建 Objective-C 类别
create.checkbox.category.interface=创建接口文件(&I)
create.category.no.class.dialog=找不到类 ''{0}''。\n要创建类别吗?
create.category.no.class.dialog.title=类无效
create.implementation.title=实现
create.implementation.description=创建新的实现
create.interface.title=接口
create.interface.description=创建新的接口
create.class.error=无法创建新的 Objective-C 类
create.protocol.error=无法创建新的 Objective-C 协议
create.category.error=无法创建新的 Objective-C 类别
create.class.file.exist.error.title=无法创建文件
create.class.file.exist.error.message=所选位置中已存在文件 ''{0}''，请选择其他名称。
create.directory.failed=无法创建目录
create.directory.failed.message=无法创建目录 ''{0}''\!
create.strings.title=字符串文件
create.strings.description=创建新的字符串文件
create.strings.dialog.title=新建字符串文件
codeassists.quickFix=快速修复
codeassists.altInsert=生成代码
codeassists.parameterInfo=参数信息
codeassists.liveTemplates=活动模板
codeassists.surroundwith.expression=环绕用
copy.files.handler.fail=无法将文件复制到 ''{0}''
code.style.remember.choice=记住选择
refactoring.localize=本地化字符串
refactoring.categoryElement.not.in.project=所选元素位于不在项目内部的类上的类别中
refactoring.category.not.in.project=所选元素是一个不在项目内部的类上的类别
navigation.class.hierarchy=类层次结构
navigation.import.hierarchy.including.title=包含 {0} 的文件
navigation.import.hierarchy.including.action=包含层次结构
navigation.import.hierarchy.including.action.description=切换到包含层次结构
navigation.import.hierarchy.included.title={0} 包含的文件
navigation.import.hierarchy.included.action=已包含的层次结构
navigation.import.hierarchy.included.action.description=切换到已包含的层次结构
navigation.import.hierarchy.next.occurence=转到下一个文件
navigation.import.hierarchy.previous.occurence=转到上一个文件
navigation.goto.please.wait=请稍候…
navigation.goto.resolving.target=解析目标…
naming.convention.title=命名惯例
naming.convention.header.guard.style.help=您可以使用预定义变量，例如\:<br><b>${PROJECT_NAME}</b>、 <b>${PROJECT_REL_PATH}</b>、 <b>${FILE_NAME}</b>、 <b>${EXT}</b> 和 <b>${UUID}</b>。<br>所有来自<i>编辑器/文件和代码模板</i> (<i>“文件”选项卡</i>)<br>的预定义变量也可用(例如 <b>${USER}</b>、<b>${DATE}</b> 等)
naming.convention.entity.kind=实体种类
naming.convention.visibility=可见性
naming.convention.specifier=说明符
naming.convention.entity.any=任意
naming.convention.entity.namespace=命名空间
naming.convention.entity.macro=宏
naming.convention.entity.class=类
naming.convention.entity.struct=结构
naming.convention.entity.enumeration=枚举
naming.convention.entity.union=联合
naming.convention.entity.typedef=Typedef
naming.convention.entity.global.function=全局函数
naming.convention.entity.global.variable=全局变量
naming.convention.entity.class.member.function=类成员函数
naming.convention.entity.struct.member.function=结构成员函数
naming.convention.entity.class.member.field=类成员字段
naming.convention.entity.struct.member.field=结构成员字段
naming.convention.entity.enumerator=枚举器
naming.convention.entity.parameter=参数
naming.convention.entity.local.variable=局部变量
naming.convention.prefix=前缀
naming.convention.suffix=后缀
refactoring.changeSignature=更改签名
refactoring.inlineConst=内联常量
refactoring.inlineLocalVar=内联变量
refactoring.inlineMacro=内联宏
refactoring.inlineMethod=内联方法
refactoring.inlineParameter=内联参数
refactoring.inlineTypedef=内联 Typedef
refactoring.introduceDefine=引入定义
refactoring.introduceConstant=引入常量
refactoring.introduceIvar=引入 Ivar
refactoring.introduceParameter=引入参数
refactoring.introduceProperty=引入属性
refactoring.introduceTypedef=引入 Typedef
refactoring.appCodeIntroduceVariable=引入变量
refactoring.convertToProperty=转换为属性
refactoring.convertToIvar=转换为 Ivar
refactoring.convertToMethod=转换为方法/函数
refactoring.convertIvarUsagesToProperties=将 ivar 用法转换为属性(&C)
refactoring.convertToLiteral=引入 Objective-C 文字
refactoring.extractSubclass=提取子类
refactoring.extractSuperclass=提取超类
refactoring.extractSuperProtocol=提取协议
refactoring.extractCategory=提取类别
refactoring.extractMethod=提取方法/函数
refactoring.extractBlockParameter=提取块参数
refactoring.moveMembers=移动成员
refactoring.moveTopLevel=移动顶层声明
refactoring.pullUp=把成员向上移动
refactoring.pushDown=向下移动成员
refactoring.ambiguous=不明确的函数无法被重构
title.function.return.type.group=函数返回类型之后
title.function.top.return.type=在全局和命名空间范围中
title.function.nontop.return.type=在类范围中
title.function.parameters.group=函数声明参数
title.function.call.arguments.group=函数调用参数
title.template.decl.class.group=模板类声明
title.template.decl.func.group=模板函数声明
title.template.parameters.group=模板声明参数
title.template.call.arguments.group=模板实例化参数
title.ctor.init.list.group=构造函数初始化列表
title.superclass.list.group=基类列表
title.shift.operators.group='<<', '>>' 运算符
title.capture.list.group=Lambda 捕获列表
wrapping.new.line.after.lt=新行后 '<'
wrapping.gt.on.new.line=将 '>' 置于新行
wrapping.align.multiline.parentheses=对齐多行括号
wrapping.align.multiline.brackets=对齐多行中括号
wrapping.align.multiline.lt.gt=对齐多行 '<','>'
wrapping.keep.simple.case.inline=将简单 case 保持在同一行
wrapping.keep.simple.methods.in.one.line=简单函数在同一行
wrapping.keep.simple.methods.in.one.line.oc=简单方法和函数在同一行
wrapping.keep.simple.blocks.in.one.line=简单的lambdas表达式在同一行
wrapping.keep.simple.blocks.in.one.line.oc=简单块和 lambda 在同一行
wrapping.keep.nested.namespaces.in.one.line=将嵌套命名空间保持在同一行
wrapping.keep.directive.at.first.column=指令在第一列
wrapping.brace.placement.class.declaration=在类和结构中
wrapping.property.declaration.oc=@property 声明
wrapping.try.statement='try'语句
wrapping.catch.on.new.line='catch'在新行
wrapping.array.initializer=初始值设定项列表
wrapping.array.initializer.oc=集合文字和初始值设定项列表
wrapping.align.multiline.fields.groups=变量组
wrapping.align.in.columns=列中对齐
wrapping.structures.in.one.line=类和结构在同一行
wrapping.before.brace.namespace=在命名空间中
wrapping.ternary.short.inline='a ?\: b' 中的 '?\:' 不换行
wrapping.try.statement.oc='@try'语句
wrapping.catch.on.new.line.oc='@catch'在新行
wrapping.finally.on.new.line.oc='@finally' 在新行
wrapping.array.initializer.lbrace.on.next.line.oc=新行后 '{', '['
wrapping.array.initializer.rbrace.on.next.line.oc=将 '}'、']' 置于新行
wrapping.method.brace.placement=在方法中
wrapping.function.brace.placement=在函数中
wrapping.block.brace.placement=在 lambda 中
wrapping.block.brace.placement.oc=在块和 lambda 中
wrapping.method.parameters.align.by.colons=通过冒号对齐
wrapping.method.call.arguments.special.dictionary.pairs.treatment=特殊 NSDictionary 初始化处理
wrapping.indent.template.body.if.wrapped=若换行则缩进模板主体
wrapping.new.line.after.colon=新行后 '\:'
wrapping.new.line.before.colon=将 '\:' 置于新行
wrapping.new.line.never=从不
wrapping.new.line.always=始终
wrapping.new.line.if.long=如果过长
align.dictionary.values=对齐列中的字典值
align.init.list.values=对齐列中的初始值设定项列表值
space.within.empty.code.blocks=空代码大括号
space.within.template=内部 <...>
space.within.empty.diamond=在空 <> 内
space.within.template.double.gt=在模板中防止 >> 串联
space.within.bracket=数组中括号
space.within.array.initializer.braces=初始值设定项列表大括号
space.within.array.empty.initializer.braces=空初始值设定项列表大括号
space.within.array.initializer.braces.oc=集合文字和初始值设定项列表大括号
space.within.array.empty.initializer.braces.oc=空集合文字和初始值设定项列表大括号
space.within.function.declaration.parentheses=函数声明括号
space.within.empty.function.declaration.parentheses=空函数声明括号
space.within.function.call.parentheses=函数调用括号
space.within.empty.function.call.parentheses=空函数调用括号
space.within.lambda.capture.list.brackets=Lambda 捕获列表中括号
space.within.empty.lambda.capture.list.brackets=空 lambda 捕获列表中括号
space.within.catch.parentheses.oc='@catch'括号
space.within.synchronized.parentheses.oc='@synchronized' 括号
space.within.protocols.brackets.oc=协议列表中括号
space.within.property.attributes.parentheses.oc='@property' 特性括号
space.within.method.return.type.parentheses.oc=方法返回类型括号
space.within.method.parameter.type.parentheses.oc=方法参数类型括号
space.within.send.message.brackets.oc=发送消息中括号
space.within.template.declaration=在模板声明中
space.within.template.inst=在模板实例化中
space.within.class=在类/结构中
space.before.initialization.lists.colon=构造函数初始化列表冒号之前
space.after.initialization.lists.colon=构造函数初始化列表冒号之后
space.before.lt.template=之前 '<'
space.before.function.call.parentheses=函数调用括号
space.before.function.parentheses=函数声明括号
space.before.class.lbrace=类/结构左大括号
space.before.method.lbrace=函数左大括号
space.before.method.lbrace.oc=方法/函数左大括号
space.before.namespace.lbrace=命名空间左大括号
space.before.init.list.lbrace=初始值设定项列表左大括号
space.before.superclass.colon=基类冒号之前
space.before.pointer.in.declaration=声明中的 '*' 之前
space.before.reference.in.declaration=声明中的 '\\&' 之前
space.before.catch.parentheses.oc='@catch'括号
space.before.try.lbrace.oc='@try'左大括号
space.before.catch.lbrace.oc='@catch'左大括号
space.before.finally.lbrace.oc='@finally' 左大括号
space.before.synchronized.lbrace.oc='@synchronized' 左大括号
space.before.catch.keyword.oc='@catch' 关键字
space.before.finally.keyword.oc='@finally' 关键字
space.before.synchronized.parentheses.oc='@synchronized' 括号
space.before.autorelease.pool.lbrace.oc='@autoreleasepool' 左大括号
space.before.category.parentheses.oc=类别括号之前
space.before.protocols.brackets.oc=协议列表中括号之前
space.before.chained.send.message.oc=链式消息发送之前
space.before.property.attributes.parentheses.oc='@property' 特性括号
space.before.dictionary.literal.colon=位字段中的冒号之前
space.before.dictionary.literal.colon.oc=字典文字 'key\:value' 对中的冒号和位字段之前
space.after.superclass.colon=基类冒号之后
space.after.structures.rbrace=结构中的右大括号之后
space.after.pointer.in.declaration=声明中的 '*' 之后
space.after.reference.in.declaration=声明中的 '\\&' 之后
space.after.reference.in.rvalue=取消引用和 address-of 之后
space.after.method.return.type.parentheses.oc=方法返回类型括号之后
space.after.method.parameter.type.parentheses.oc=方法参数类型括号之后
space.after.visibility.sign.in.method.declaration.oc=方法声明中的 +/- 之后
space.after.colon.in.selector.oc=选择器中的冒号之后
space.after.cup.in.blocks.oc=块中的 '^' 之后
space.after.dictionary.literal.colon=位字段中的冒号之后
space.after.dictionary.literal.colon.oc=字典文字 'key\:value' 对中的冒号和位字段之后
space.between.adjacent.brackets=在相同类型的中括号之间保持空格
space.between.operator.punctuator='operator' 关键字和标点符号之间
space.discharged.short.ternary.operator='?' 与 'a ? \: b' 中的 '\:' 之间空格
space.around.relational.operators=关系运算符 (<, >, <\=, >\=, <\=>)
space.around.shift.operators=移位运算符 (<<, >>)
space.around.lambda.arrow='->' 在返回类型中
space.around.pm.operators=指针成员运算符(->、 .、->*、.*)
blank.lines.before.includes=包含之前\:
blank.lines.after.includes=包含之后\:
blank.lines.around.classes=类/结构周围\:
blank.lines.after.class.header=类/结构头之后\:
blank.lines.around.member.variable=环绕字段\:
blank.lines.around.member.variable.oc=实例变量/字段周围\:
blank.lines.around.global.variable=全局变量周围\:
blank.lines.around.function.declaration=函数声明周围\:
blank.lines.around.function.declaration.oc=方法/函数声明周围\:
blank.lines.around.function.definition=函数定义周围\:
blank.lines.around.function.definition.oc=方法/函数定义周围\:
blank.lines.before.function.body=函数主体之前\:
blank.lines.before.function.body.oc=方法/函数主体之前\:
completion.press.keyboard.shortcut.for.all.methods.selectors=为所有方法选择器再次按 {0}
completion.press.keyboard.shortcut.to.filter.results.by.type=按 {0} 按类型筛选结果
completion.press.keyboard.shortcut.for.non.imported.symbols=为未导入的符号再次按 {0}
completion.press.keyboard.shortcut.for.global.symbols=为全局符号再次按 {0}
collapse.ivars=实例变量
collapse.synthesizes=合成语句
collapse.localized.strings=已本地化的字符串
collapse.multiline.comments=多行注释
collapse.block.expressions.oc=块和 lambda
collapse.block.expressions=Lambdas
collapse.conditionally.non-compiled=有条件的未编译代码
collapse.template.param.list=模板参数
collapse.new.line.before.lbrace=如果收起，则在 '{' 之前用空格代替换行
color.this.keywords='this' 关键字
color.preprocessor.directive=预处理程序//指令
color.preprocessor.path=预处理程序//头路径
color.format.string.token=字符串参数中的格式说明符
color.conditionally.non-compiled=有条件的未编译代码
color.macro.name=宏名称
color.macro.parameter=宏参数
color.global.variable=全局变量
color.extern.variable=extern 变量
color.struct.union.oc=结构/枚举/联合
color.struct.union=类/结构/枚举/联合
color.struct.field=结构字段
color.concept=概念
color.template.type=模板类型
color.template.value=模板值
color.namespace=命名空间
color.enum.const=枚举常量
color.function.declaration=函数声明
color.function.call=函数调用
color.overloaded.operator=重载运算符
color.typedef=Typedef
color.label=标签
color.dependent_code=依赖代码
color.this.keywords.oc='self'、'super'、'this' 关键字
color.instance.variable.oc=实例变量
color.method.declaration.oc=方法声明
color.method.call.oc=方法调用 
color.property.oc=特性
color.property.attribute.oc=属性特性
color.class.reference.oc=类
color.protocol.reference.oc=协议
color.generic.parameter.oc=泛型参数
indent.namespace=缩进命名空间成员
indent.interface.protocol=缩进 '@interface' 和 '@protocol' 成员
indent.not.ivar=实例变量列表除外
indent.implementation=缩进 '@implementation' 成员
indent.visibility.keywords=缩进类/结构中的可见性关键字
indent.block=在 lambda 中缩进
indent.block.oc=在块和 lambda 中缩进
indent.c.struct=缩进纯结构成员
indent.class=缩进类成员
indent.class.oc=缩进 C++ 类成员
indent.preprocessor.directive=预处理程序指令缩进
indent.preprocessor.directive.as.code=遵循代码缩进
indent.preprocessor.directive.after.hash=在 \# 之后缩进
inline.handler.check.for.validness=正在检查有效性
checkbox.block.comment.indent=在块注释中缩进新行
fileExtensions.tabName=新文件扩展名
fileExtensions.extensionPair=扩展名对
fileExtensions.error=错误
fileExtensions.noExtensionsError=请定义至少一对扩展名对
fileExtensions.sourceExtension=源扩展名\:
fileExtensions.headerExtension=头扩展名\:
fileExtensions.fileNamingConvention=文件命名惯例\:
fileExtensions.editFileTypesTooltip=编辑文件类型
fileExtensions.no.extensions=无扩展名
fileExtensions.noCompatibleTypes=找不到兼容的文件类型
override.implement.show.optional.members=显示可选成员(&O)
override.implement.show.no.optional.members=显示可选成员(无可选项)
override.implement.show.only.optional.members=显示可选成员(仅可选项)
override.implement.show.synthesized.accessors=显示合成访问器
override.implement.show.no.synthesized.accessors=显示合成访问器(无访问器)
override.implement.show.only.synthesized.accessors=显示合成访问器(仅访问器)
override.implement.cpp.action.title=重写/实现函数
override.implement.cpp.action.name=重写函数…
override.implement.cpp.action.memberChooserTitle=选择要重写/实现的函数
override.implement.cpp.action.noMember={0} 没有要重写/实现的函数
override.implement.cpp.action.noParent=没有要重写/实现的函数
override.implement.cpp.action.insertOverride=插入“override”特性
override.implement.cpp.action.showNonVirtual=显示非虚拟函数
override.implement.cpp.action.insertVirtualWithOverride=将“virtual”特性与“override”一起插入
implement.cpp.action.name=实现函数…
implement.cpp.action.memberChooserTitle=选择要实现的函数
implement.cpp.action.noMember={0} 没有要实现的函数
implement.cpp.action.noParent=没有要实现的函数
changeSignature.usages.cantBeUnnamed=参数 {0} 已被使用，不能取消命名
changeSignature.usages.cantBeRemoved=参数 {0} 已被使用，不能移除
changeSignature.usages.cantConvertSelectorToFuncBlock=无法将选择器表达式转换为函数/块
changeSignature.usages.cantConvertToBlock=无法转换为块\:
changeSignature.usages.cantConvertLanguage=无法转换 {0} 代码中的用法
changeSignature.usages.ambiguousReference=函数 {0} 被模糊引用
changeSignature.usages.noUsagesFound=找不到用法
changeSignature.usages.moreThan1Found=找到超过 1 个用法
changeSignature.usages.usageInsideFunction=用法在函数/方法内部
changeSignature.usages.functionHasSeveralDefinitions=函数 ''{0}'' 具有多个定义
changeSignature.usages.atLeasTwoParams=至少两个参数的名称为 ''{0}''
changeSignature.usages.conflictsWithNewParameter={0} 与新参数冲突
changeSignature.usages.unrelatedSelector=可能不相关的同名选择器将被重命名
changeSignature.usages.willConflictWith={0} 将与 {1} 冲突
changeSignature.usages.willConflictWithMethod={0} 将与 {1} 中的方法冲突
changeSignature.targetNotFound=脱字符号应置于函数、方法或块处
changeSignature.dialog.containing.class=包含类\:
changeSignature.parameter.selector.part=选择器部分\:
rename.renameAssociatedFiles=同时重命名关联的文件?
rename.renameAssociatedClass=同时重命名关联的类/结构
find.existing.operators.progress.title=正在搜索现有的运算符
generate.inplace.option=就地生成(&P)
generate.cpp.progress.title=正在生成
generate.cpp.replace.button=替换现有(&R)
generate.cpp.add.missing.button=添加缺失(&A)
generate.cpp.show.existing.button=显示现有(&S)
generate.cpp.usages.string=匹配项
generate.cpp.usages.word=匹配项
generate.cpp.usages.cannot.make=无法完成生成\: 部分文件已更改
generate.definitions=生成定义
generate.definitions.commandName=生成定义
generate.definitions.intention.familyName=生成定义
generate.definitions.intention.outsideText=生成定义
generate.definitions.intention.inlineText=就地生成定义
generate.definitions.action.name=生成定义...
generate.definitions.action.title=生成定义
generate.definitions.action.memberChooserTitle=选择要为其生成定义的函数
generate.definitions.action.noParent=没有要为其生成定义的函数
generate.definitions.action.noMembers={0} 没有要为其生成定义的函数
generate.definitions.quickfix.inlineText=就地为 {0} 生成定义
generate.definitions.quickfix.outsideText=为 {0} 生成定义
generate.definitions.progress.text=正在查找现有定义…
generate.comparison.operators.action.title=生成比较运算符
generate.comparison.operators.action.title.eq=生成相等运算符
generate.comparison.operators.action.title.rel=生成关系运算符
generate.comparison.operators.member.chooser.title=选择要使用的字段
generate.comparison.operators.as.member.option=作为类成员生成(&M)
generate.comparison.operators.use.std.tie=使用 std\:\:&tie
generate.comparison.operators.as.member.option.desc=作为类成员生成运算符
generate.comparison.operators.additional.eq.option=将 \!\= 与 \=\= 一起生成(&W)
generate.comparison.operators.additional.eq.option.desc=将 \!\= 与 \=\= 一起生成
generate.comparison.operators.additional.rel.option=将 >、<\=、>\= 与 < 一起生成(&W)
generate.comparison.operators.additional.rel.option.desc=将 >、<\=、>\= 与 < 一起生成
generate.comparison.operators.usages.all.defined=所有运算符均已定义。
generate.comparison.operators.usages.some.defined=部分运算符已定义。
generate.comparison.operators.usages.existing.text=现有运算符
generate.getter.add.prefix=将 get/is 前缀添加到 getter
generate.setter.add.prefix=将 set 前缀添加到 setter
generate.stream.output.action.title=生成流输出运算符
generate.stream.output.member.chooser.title=选择要使用的字段
generate.stream.output.usages.all.defined=流输出运算符已定义
generate.stream.output.usages.existing.text=现有运算符
generate.configurable.retain.parameters=在 initWith 中保留对象参数…
generate.configurable.use.property.setters=在 initWith 中使用属性 setter…
generate.configurable.put.ivars=尽可能将 ivars 放入实现
generate.configurable.semicolon.after.method=实现中方法签名后的分号
generate.configurable.use.nsinteger.and.cgfloat=在引入变量中使用 NSInteger 和 CGFloat
generate.configurable.instance.variable.prefix=实例变量的前缀\:
generate.configurable.instance.variable.suffix=实例变量的后缀\:
generate.configurable.add.brief.tag=添加 @brief 标记
generate.configurable.const.volatile.placement=const/volatile 限定符位置
generate.configurable.top.level.declarations.order=顶层声明顺序
generate.configurable.ivars.release.style=Ivars 释放样式(对于 'dealloc')
generate.configurable.ivars.generation=为属性生成 ivar 声明
generate.configurable.ivars.generation.always=始终生成
generate.configurable.ivars.generation.never=从不生成
generate.configurable.ivars.generation.ask=问
generate.configurable.tag.prefix.comments=行注释中的标记前缀
generate.configuralble.tag.prefix.block.comments=块注释中的标记前缀
generate.choose.base.class.constructor=选择基类构造函数
generate.configurable.documentation.title=文档注释
inspections.templateArguments.tooFew=模板参数过少，应为 {0} 个
inspections.templateArguments.tooFewAtLeast=模板参数过少，应为至少 {0} 个
inspections.templateArguments.tooMany=模板参数过多，应为 {0} 个
inspections.templateArguments.tooManyAtMost=模板参数过多，应为至多 {0} 个
inspections.templateArguments.valueInsteadOfType=应为值而不是类型
inspections.templateArguments.typeInsteadOfValue=应为类型而不是值
inspections.typeChecks.volatileConflict=正在将非 volatile 结构分配至 volatile 结构
inspections.duplicate.explicitInstantiation=重复的显式实例化
inspections.typeChecks.neitherNumericNorPointer=类型 ''{0}'' 的表达式既不是数字也不是指针
inspections.typeChecks.notNumeric=类型 ''{0}'' 的表达式不是数字
inspections.fileChecks.outOfProject=此文件不属于任何项目目标，代码洞察功能可能无法正常工作。
inspections.fileChecks.allContextsUnloaded=索引已对此目标的 {0} 禁用，代码洞察功能可能无法正常工作。
inspections.fileChecks.sourceTooLarge=文件大小({0})超出了为 {1} 配置的限制({2})。代码洞察功能不可用。
inspections.fileChecks.headerTooLarge=文件包含长度({0})超出为 {1} 配置的限制({2})的内联头({3})。头未解析。
inspections.fileChecks.headerTooLargePlatform=文件包含长度({0})超出配置限制({1})的内联头({2})。头未解析。
checkbox.allow.import.in.completion=在补全中自动导入
progressbar.long.resolve.description=解析操作需要更多时间…\n如果您取消，则依赖于解析的编辑器操作将不可用
intentions.add.constructor.initializer.for.field=为字段添加构造函数初始值设定项
intentions.add.initializer=添加初始值设定项
intentions.add.parameters.to.constructor=将 {0} 作为参数添加到构造函数
intentions.add.parameter.initWith=作为参数添加到 'initWith...'
intentions.check.raw.string=检查原始字符串
intentions.add.super.constructor.call=添加缺少的基本构造函数调用
intentions.add.super.protocol.by.class=按类采用协议
intentions.add.super.protocol.by.private.category=按私有类别采用协议
intentions.add.mofifier=添加 ''{0}''
intentions.change.arc.attribute=更改 ARC 特性
intentions.change.function.signature=更改函数签名
intentions.change.type.capitalized=更改类型
intentions.change.type=更改类型
intentions.change.visibility=更改可见性
intentions.convert.id.to.instance=将 'id' 返回类型替换为 'instancetype'
intentions.replace.if.else.with.ternary=将 'if else' 替换为 '?\:'
intentions.replace.ternary.with.if.else=将 '?\:' 替换为 'if else'
intentions.convert.objc.literal=切换至 Objective-C 文字
intentions.convert.to.instance.variable=转换为实例变量
intentions.convert.to.property=转换为属性
intentions.convert.type=转换类型
intentions.create.matching.constructor=创建与基类匹配的构造函数
intentions.create.matching.constructor.in=在 {0} 中创建默认构造函数
intentions.create.new.matching.constructor=在 {0} 个匹配基类中创建新的构造函数
intentions.create.new.constructor=创建新的构造函数 ''{0}()''
intentions.predeclare.function=预声明 {0}
intentions.create.interface=为 {0} 创建接口
action.invalid.title=无效
intentions.create.missing.default.switch.case=创建缺少的默认 case
intentions.create.missing.switch.cases=创建缺少的 switch case
intentions.declare.method.in.interface=在接口中声明方法
intentions.declare.method.in.private.category=在私有类别中声明方法
intentions.declare.method.in=在 {0} 中声明方法
intentions.declare.property.as.readwrite=在私有类别中将属性声明为 'readwrite'
intentions.replace.and.with.or=将 '\\&\\&' 替换为 '||'
intentions.replace.or.with.and=将 '||' 替换为 '\\&\\&'
intentions.deMorgan.law=德摩根定律 
intentions.declare.member.in=声明位置\:
intentions.remove.private.category.message=要移除空的私有类别吗?
intentions.remove.private.category.title=移除私有类别
intentions.extract.category=提取此类的类别
intentions.extract.if=提取 'if'
intentions.extract.if.with.text=提取 ''if ({0})''
intentions.extract.private.category=提取此类的私有类别
intentions.extract.protocol=提取此类的协议
intentions.extract.super.class=提取超类
intentions.extract.super.protocol=提取超级协议
intentions.flip.operator=翻转 {0}
intentions.flip.operator.to=将 {0} 翻转为 {1}
intentions.flip.binary.operation=翻转二元运算
intentions.generate.property=生成属性
intentions.implement.required.methods=实现接口 ''{0}'' 的必需方法
intentions.create.implementation=创建 {0} 的实现
intentions.implement.method=实现{0}
intentions.implement.accessor.methods=实现访问器方法
intentions.implement.accessor.methods.for=为 {0} 实现访问器方法
intentions.cast.expression=强制转换表达式
intentions.introduce.typedef=引入 typedef
intentions.introduce.typedef.for.type=为类型 {0} 引入 typedef
intentions.invert.if.condition=转化如果条件
intentions.merge.if.else=合并 If else
intentions.merge.nested.ifs=合并嵌套的 if
intentions.migrate.to.arc=迁移到 ARC
intentions.move.instance.variables=将实例变量移至实现
intentions.move.to.interface=移至接口
intentions.move.to.private.category=移至私有类别
intentions.import.predeclare.symbol=导入/预声明符号
intentions.provide.localization=提供本地化
intentions.release.variables=释放变量
intentions.remove.suppression=移除抑制
intentions.remove.type.modifier=移除 ''{0}''
intentions.remove.unnecessary.parentheses=移除不必要的括号
intentions.rename.reference=重命名引用
intentions.rename.symbol=重命名符号
intentions.replace.type.with.auto=将类型替换为 'auto'
intentions.reuse.declaration=重用声明
intentions.change.superclass=更改超类
intentions.split.declaration=拆分为声明和赋值
intentions.split.function=将函数分为声明和定义
intentions.split.into.separate.declarations=拆分为单独的声明
intentions.suppress.for=对{0}禁止
intentions.suppress.option.for=禁止{1}的“{0}”
intentions.suppress.for.statement=对语句禁止
intentions.suppress.for.method=对方法/函数禁止
intentions.suppress.for.file=对文件禁止
intentions.surround.with.if.responds=用“if ([ respondsToSelector\: ])”环绕
intentions.switch.property.dot.method=切换 '.' 和方法表示法
intentions.switch.to.getter.notation=切换至 getter 方法表示法
intentions.switch.to.setter.notation=切换至 setter 方法表示法
intentions.switch.to.dot.notation=切换至 '.' 表示法
intentions.synthesize.property=合成属性
intentions.wrap.with.stringFormat=用 stringWithFormat 环绕
change.function.const.action=更改 const 限定符
change.function.volatile.action=更改 volatile 限定符
change.gcc.attribute.action=更改特性 ''{0}''
change.method.signature.add.parameters=添加参数
change.method.staticness.action=使方法成为实例/类
change.property.attribute.action=更改属性特性
change.signature.convert.action=选择要转换为{0}的实现
intentions.insert.cast.use.modern=使用 C++ 转换运算符
intentions.split.function.progress.text=正在确定定义位置…
header.source.looking.for.the.best.file=正在查找关联文件
collect.compiler.info.error.message=无法获取编译器信息
collect.compiler.info.cancelled.message=已取消编译器信息收集
collect.compiler.info.warning.message=收集编译器信息时遇到问题
resolve.contexts.select.automatically=自动选择
oc.inlay.hints.blacklist.pattern.explanation=<html> 要禁用方法的提示，请使用合适的模式\: <p> <code><b>(*info)<b></code> - 单参数方法，其中参数名称以 info 结尾<br> <code><b>(key, value)<b></code> - 具有参数键和值的方法<br> <code><b>*\:\:put(key, value)<b></code> - 具有键和值参数的 put 方法<br> </p> </html>
include.cpp.message='\#include <C++>' 一个面向对 C++ 感兴趣的开发者的全球性、包容性和多元化社区
include.cpp.url=https\://www.includecpp.org/
include.cpp.intention.text=了解更多
usage.superclass=超类引用
usage.protocol=协议引用
usage.message.receiver=消息接收器
usage.qualifier=限定符
usage.member.access=成员访问
usage.variable.declaration=变量声明
usage.parameter.declaration=参数声明
usage.method.call=方法调用 
usage.in.property.attribute=属性特性中的用法
usage.selector.expression=选择器表达式
usage.in.synthesize.statement=合成语句中的用法
usage.class.predeclaration=类预声明
usage.protocol.predeclaration=协议预声明
usage.namespace.qualifier=命名空间限定符
usage.in.using.statement=using 语句中的用法
usage.in.macro.substitution=宏替换中的用法
usage.in.macro.arguments.list=宏参数列表中的用法
usage.in.expression=表达式中的用法
usage.in.declaration=声明或预声明中的用法
usage.in.template.argument.list=模板参数列表中的用法
usage.properties.search.message=要同时{0}{1}吗?
usage.properties.search.title=属性搜索
usage.instance.variables.search.message=要同时{0}{1}吗?
usage.instance.variables.search.title=实例变量搜索
usage.method.search.title=方法搜索
usage.method.search.message={0}\n\n要{1}基{2}吗?
usage.delete.out.of.project.title=警告
usage.delete.out.of.project.message={0} 要继续执行重构吗?
usage.overrides.message={0} 重写 {2} 中的 {1}。
usage.overrides.out.of.project.message={0} 重写项目外的 {2} 中的 {1}。
usage.include.property.checkbox.text=包含 {0}
usage.include.ivar.checkbox.text=包含 {0}
usage.include.derived.classes.checkbox.text=包含派生类
switch.header.source.popup.title=Go to Header/Source
switch.header.source.no.results=无相关文件
switch.header.source.new.scheme.name={0} 重新映射“转到头/源”
switch.header.source.new.scheme.yes=重新映射
switch.header.source.new.scheme.no=保持原样
switch.header.source.new.scheme.explanation.title=“转到头/源”的快捷键
switch.header.source.new.scheme.explanation.text=有专门的操作可在头和源之间切换({0})。\n\n将此快捷键({1})从“转到相关符号”操作重新映射到新的操作吗?
command.line.parser.unknown.exception=命令行解析期间出错
command.line.parser.cancellation.exception=命令行解析被中断
command.line.parser.invalid.exception=无法解析命令行\:\n{0}\n选项 \#{1} 中出错\: ''{2}''
configurable.ClangdConfigurable.display.name=Clangd
configurable.OCGenerateCodeConfigurable.display.name=代码生成
abstract.extract.dialog.class.name={0}的名字\:
abstract.extract.dialog.unable.create.file=无法创建文件
browse.include.hierarchy.action=导入层次结构
chrome.trace.title=JSON 跟踪
escalate.visibility=升级可见性
escalate.visibility.description=是否要升级以下成员的可见性?
dump.file.symbol.stats=文件符号统计信息
dump.symbol.stats=符号统计信息
highlighter.change.file.length.limit=更改最大文件长度
highlighter.change.file.length.limit.input=以字符为单位输入 {0} 文件的新最大长度
highlighter.max.file.length.title=最大文件长度
if.responds.to.surround.error.hint=所选代码中没有发送消息表达式
quickfixes.implement.missing.getter=实现缺少的 getter 方法
quickfixes.implement.missing.setter=实现缺少的 setter 方法
quickfixes.import.symbol=导入符号
quickfixes.make.function.virtual=使函数为虚拟
quickfixes.make.property.dynamic=使 {0} 为 @dynamic
quickfixes.synthesize=合成{0}
move.dialog.move.members.to.class=将成员移至类(现有或新的)\:
move.dialog.move.declarations.to.file=将声明移至文件(现有或新的)\:
move.dialog.put.to.namespace=置于命名空间(现有或新的)\:
move.dialog.move.declarations=移动声明
move.dialog.destination=目标\:
move.dialog.target.file.does.not.exist=目标文件 ''{0}'' 尚不存在。
move.dialog.create.new.file=创建新文件
move.dialog.create.new.class=创建新类
move.processor.skip=跳过
push.down.members.dialog=将{0}的成员下推至\:
push.down.dialog.searching.inheritors=搜索继承者
resolve.show.related.contexts=仅显示相关上下文
resolve.show.all.contexts=显示所有上下文…
symbol.table.activity.building.symbols=正在构建符号…
symbol.table.activity.loading.symbols=正在加载符号…
symbol.table.activity.updating.symbols=正在更新符号…
symbol.table.dump.stats.action=统计信息写入{0}
symbol.is.never.used=从未使用 {0}
roots.synchronizer.ignoring.directory=忽略目录
roots.synchronizer.ignoring.directory.description=正在拒绝为索引编制注册文件系统根 {0}，因为这样可能会导致性能下降。
# action names
action.CIDR.DebugDumpBuildingSymbols.text=C/C++：转储符号构建状态
action.CIDR.ShowTestList.text=显示测试列表
action.CIDR.ShowCompilerInfo.text=显示编译器信息
action.CIDR.DumpTracedEvents.text=C/C++：转储跟踪的事件
action.CIDR.StopEventTracing.text=C/C++：停止事件跟踪
action.CIDR.StartEventTracing.text=C/C++：启动事件跟踪
action.CIDR.Lang.Format.Extractor.text=提取代码格式
action.CIDR.Lang.DropPsiForOpenedFiles.text=删除打开的文件的 PSI
action.CIDR.Lang.RemoveBodiesAndComments.text=移除函数主体和注释
action.CIDR.Lang.DumpFileSymbolStats.text=转储文件符号统计信息
action.CIDR.Lang.DumpSymbolStats.text=转储一般符号统计信息
action.CIDR.Lang.CompactSymbols.text=更新/压缩符号
action.CIDR.Lang.ImportsHierarchy.text=导入层次结构
action.CIDR.Lang.ObjC.GenerateSharedInstance.text=+sharedInstance
action.CIDR.Lang.ObjC.GenerateSharedInstance.description=生成共享实例
action.CIDR.Lang.ObjC.GenerateDescription.text=-描述...
action.CIDR.Lang.ObjC.GenerateDescription.description=从类成员生成 -description
action.CIDR.Lang.ObjC.GenerateIsEqualAndHash.text=-isEqual\: 和 -hash...
action.CIDR.Lang.ObjC.GenerateIsEqualAndHash.description=从类成员生成 -isEqual\: 和 -hash
action.CIDR.Lang.ObjC.GenerateCopy.text=-copyWithZone\:...
action.CIDR.Lang.ObjC.GenerateCopy.description=从类成员生成 -copyWithZone\:
action.CIDR.Lang.ObjC.GenerateEncode.text=-init/encodeWithCoder\:...
action.CIDR.Lang.ObjC.GenerateEncode.description=从类成员生成 -encodeWithCoder\: 和 initWithCoder\:
action.CIDR.Lang.ObjC.GenerateInitWith.text=-initWith...
action.CIDR.Lang.ObjC.GenerateInitWith.description=从类成员生成 -initWith...
action.CIDR.Lang.Cpp.GenerateDefinitions.text=生成定义...
action.CIDR.Lang.Cpp.GenerateDefinitions.description=生成定义
action.CIDR.Lang.Cpp.GenerateStreamOutputOperator.text=流输出运算符
action.CIDR.Lang.Cpp.GenerateStreamOutputOperator.description=生成流输出运算符
action.CIDR.Lang.Cpp.GenerateRelationalOperators.text=关系运算符
action.CIDR.Lang.Cpp.GenerateRelationalOperators.description=生成关系运算符
action.CIDR.Lang.Cpp.GenerateEqualityOperators.text=相等运算符
action.CIDR.Lang.Cpp.GenerateEqualityOperators.description=生成相等运算符
action.CIDR.Lang.Cpp.GenerateGetterAndSetter.text=Getter 和 Setter
action.CIDR.Lang.Cpp.GenerateGetterAndSetter.description=为字段生成 getter 和 setter 函数
action.CIDR.Lang.Cpp.GenerateSetter.text=Setter
action.CIDR.Lang.Cpp.GenerateSetter.description=为字段生成 setter 函数
action.CIDR.Lang.Cpp.GenerateGetter.text=Getter
action.CIDR.Lang.Cpp.GenerateGetter.description=为字段生成 getter 函数
action.CIDR.Lang.Cpp.GenerateDestructor.text=析构函数
action.CIDR.Lang.Cpp.GenerateDestructor.description=生成解造函数
action.CIDR.Lang.Cpp.GenerateConstructor.text=构造函数
action.CIDR.Lang.Cpp.GenerateConstructor.description=从类成员生成构造函数
action.CIDR.Lang.ObjC.Synthesize.text=@synthesize...
action.CIDR.Lang.ObjC.Synthesize.description=生成合成变量和实例变量（可选）
action.CIDR.Lang.ObjC.DeclareMembers.text=声明成员...
action.CIDR.Lang.ObjC.DeclareMembers.description=声明接口或私有类别中的类成员
action.CIDR.Lang.ObjC.ConvertToIvar.text=转换为实例变量...
action.CIDR.Lang.ObjC.ConvertToIvar.description=将属性转换为实例变量
action.CIDR.Lang.ObjC.ConvertToProperty.text=转换为属性...
action.CIDR.Lang.ObjC.ConvertToProperty.description=将实例变量转换为属性
action.CIDR.Lang.ObjC.ConvertToBlock.text=转换为块...
action.CIDR.Lang.ObjC.ConvertToBlock.description=转换为块
action.CIDR.Lang.ObjC.ConvertToFunction.text=转换为函数...
action.CIDR.Lang.ObjC.ConvertToFunction.description=转换为函数
action.CIDR.Lang.ObjC.ConvertToMethod.text=转换为方法...
action.CIDR.Lang.ObjC.ConvertToMethod.description=转换为方法
action.CIDR.Lang.ObjC.ExtractCategory.text=分类...
action.CIDR.Lang.ObjC.ExtractCategory.description=将成员提取到新类别
action.CIDR.Lang.ObjC.ExtractProtocol.text=协议...
action.CIDR.Lang.ObjC.ExtractProtocol.description=将成员提取到新协议
action.CIDR.Lang.ObjC.ExtractSubclass.text=子类...
action.CIDR.Lang.ObjC.ExtractSubclass.description=将成员提取到新子类
action.CIDR.Lang.ObjC.ExtractBlock.text=块参数...
action.CIDR.Lang.ObjC.ExtractBlock.description=提取块参数
action.CIDR.Lang.IntroduceTypedef.text=Typedef...
action.CIDR.Lang.IntroduceTypedef.description=引入 Typedef
action.CIDR.Lang.IntroduceDefine.text=定义...
action.CIDR.Lang.IntroduceDefine.description=引入定义
action.CIDR.Lang.IntroduceParameter.text=参数...
action.CIDR.Lang.IntroduceParameter.description=引入参数
action.CIDR.Lang.ObjC.IntroduceProperty.text=特性...
action.CIDR.Lang.ObjC.IntroduceProperty.description=引入属性
action.CIDR.Lang.ObjC.IntroduceIvar.text=实例变量...
action.CIDR.Lang.ObjC.IntroduceIvar.description=引入实例变量
action.CIDR.Lang.IntroduceConstant.text=常量...
action.CIDR.Lang.IntroduceConstant.description=引入常量
action.CIDR.Lang.IntroduceVariable.text=变量...
action.CIDR.Lang.IntroduceVariable.description=引入变量
action.CIDR.Lang.SwitchHeaderSourceDebug.text=调试标题/源
action.CIDR.Lang.SwitchHeaderSource.text=头文件/源码
action.CIDR.Lang.Wrap.By.Pragma.Region=\#pragma region...endregion
loading.module.maps=正在加载模块映射…
saving.module.maps=正在保存模块映射…
