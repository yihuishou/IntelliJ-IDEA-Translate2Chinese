evaluation.error.empty.code.fragment=预期的代码片段
evaluation.error.cannot.evaluate.tostring=无法评估 {0}.toString()
evaluation.error.unsupported.expression.type=不支持的表达式类型
evaluation.error.object.is.being.initialized=对象正在初始化
internal.error.locations.of.line=内部错误从''{0}''加载调试信息.  此类不能使用断点.
evaluation.error.inconsistent.debug.info=调试信息不一致
evaluation.error.boolean.value.expected.in.condition=条件中预估值为'boolean'
evaluation.error.boolean.condition.expected=条件中预估值为'boolean'
evaluation.error.process.exited=无法评估\: 进程退出
evaluation.error.stack.frame.unavailable=堆栈框架不可用
evaluation.error.nested.evaluation=评估不支持另一种方法的评估
evaluation.error.sources.out.of.sync=源码与执行的代码不对应
evaluation.error.cannot.find.stackframe.source=找不到当前堆栈帧的源类
evaluation.error.cannot.find.source=找不到 {0} 的源类
evaluation.error.object.collected=已搜集对象
evaluation.error.thread.collected=已收集线程
evaluation.error.array.collected=已收集数组
evaluation.error.thread.resumed=线程已被恢复
evaluation.error.debug.info.unavailable=调试信息不可用
evaluation.error.invalid.expression=无效的表达式 \: {0}
evaluation.error.unknown.expression.type=表达式类型未知\: {0}
evaluation.error.unknown.expression.operand=表达式操作数未知\: {0}
evaluation.error.type.mismatch=类型不匹配
evaluation.error.class.not.loaded=类''{0}''未加载
evaluation.error.thread.not.at.breakpoint=无法评估e\: 线程不会在断点处暂停
evaluation.error.method.exception=方法抛出''{0}''异常.
evaluation.error.surrounded.expression.null=环绕的表达式为null
title.customize.data.views=自定义数据视图
title.evaluating=评估...
error.modification.watchpoints.not.supported=目标VM不支持修改观察点
error.native.method.exception=所有帧和包括帧都不是本机的
error.executing.finally=执行finally块时出错\: {0}
error.early.return=早期返回时出错\: {0}
error.throw.exception=抛出异常时出错\: {0}
warning.finally.block.detected=非空的finally块检测到\:
button.drop.anyway=不执行
button.execute.finally=执行 Finally 块
drop.frame.error.no.information=有关框架的信息不可用
action.remove.watch.text=移除观察点
progress.evaluating=评估{0}
action.resume.thread.text.resume=恢复
action.resume.thread.text.unfreeze=解冻
action.interrupt.thread.text=中断
title.set.value=设置值
warning.recalculate=将重新计算该值
warning.source.code.not.match=源码与字节码不匹配
progress.set.value=设定值...
action.add.field.watchpoint.text=添加字段观察点
status.process.started=进程已启动
status.process.terminated=进程已终止
status.disconnected=与目标VM断开连接, 地址为\: ''{0}'', 传输\: ''{1}''
status.stopped.at.cursor=在游标停止
status.line.breakpoint.reached=到达{0}({1}\:{2,number,\#})的断点
status.line.breakpoint.reached.full.trace=到达{0}的断点
export.threads.stackframe.format=在{0}({1}\:{2,number,\#})
status.generic.breakpoint.reached=已到达断点
status.thread.blocked.by=线程{0}被线程{1}组织
status.thread.blocked.by.resume=<a href\="\#">恢复{0}</a>
status.breakpoint.reached.in.thread=线程{0}中到达的断点
status.breakpoint.reached.in.thread.switch=<a href\="\#">切换线程</a>
status.method.entry.breakpoint.reached=方法''{0}''进入{1}({2}\:{3,number,\#})
status.method.exit.breakpoint.reached=已达到方法断点. 方法''{0}''即将退出{1}({2}\:{3,number,\#})
status.exception.breakpoint.reached=到达异常断点
status.exception.breakpoint.reached.details=线程''{1}''中的异常''{0}''
status.field.watchpoint.reached=到达字段观察点
status.field.watchpoint.reached.access=''{''{0}@{5}''}''.{1}将在访问{2}({3}\:{4,number,\#})
status.static.field.watchpoint.reached.access={0}.{1} 将在访问{2}({3}\:{4,number,\#})
status.field.watchpoint.reached.modification=''{''{0}@{7}''}''.{1}将被修改为{4}({5}\:{6,number,\#}). 当前值 \= ''{2}''. 新值 \= ''{3}''
status.static.field.watchpoint.reached.modification={0}.{1}将被修改为{4}({5}\:{6,number,\#}). 当前值 \= ''{2}''. 新值 \= ''{3}''
status.connected=连接到目标VM, 地址\: ''{0}'', 传输\: ''{1}''
status.connect.failed=无法建立与目标VM的连接, 地址\: ''{0}'', 传输\: ''{1}''
error.debugger.already.listening=调试器已经在侦听
transport.name.shared.memory=共享内存
transport.name.socket=套接字
error.debug.connector.not.found=无法使用传输''{0}''连接\: 未找到所需的连接. 检查您的JDK安装.
error.no.debug.listen.port=未指定的监听端口
error.no.debug.attach.port=要附加到未指定的端口
error.no.shmem.address=未指定共享内存地址
error.no.pid=未指定 Pid
debugger.jdi.bootstrap.error={0}. 请检查您的JDK安装.
warning.jdk140.unstable=调试程序的VM版本为"1.4.0".\nJ2SDK 1.4.0 记录的错误可能会导致不稳定的调试器行为.\n我们建议使用J2SDK 1.4.0_01 或更高的版本.
title.jdk140.unstable=VM版本警告
message.remote.jre.version.mismatch=目标JRE版本 ({0})\n与项目JDK版本不匹配({1}), \n将使用JDK中的源\: {2}
message.breakpoint.skipped=跳过的断点在{0}, 因为它发生在调试器评估中
error.invalid.argument={0,choice, 1\#无效参数|2\#参数无效} 
error.vm.disconnected=VM断开连接. 目标虚拟机关闭连接
error.unknown.host=无法连接到远程进程, 主机是未知的
error.cannot.open.debugger.port=无法打开调试器端口
error.exception.while.connecting=连接到远程进程的错误.\n异常事件\: {0}\n异常消息\: {1}
status.waiting.attach=调试器正在等待应用程序启动; 调试地址\: ''{0}''; 传输\: ''{1}''
status.listening=监听连接, 地址\: ''{0}'', 传输\: ''{1}''
status.connecting=连接到目标 VM, 地址\: ''{0}'', 传输\: ''{1}''
status.app.running=应用程序正在运行
status.debug.stopped=调试已停止
status.waiting.evaluation.result=等待直到最后一个调试器命令完成
status.step.out=步出
status.step.into=步入
status.step.over=步过
status.run.to.cursor=运行到光标
status.process.resumed=恢复进程
status.paused.in.another.thread=在另一个线程中暂停
string.connection=''{0}''，传输\: ''{1}''
error.pop.bottom.stackframe=无法弹出底部框架
error.pop.stackframe=弹出框架时发生错误\: {0}
error.class.not.loaded=未加载类\: {0}
string.file.line.position={0}中的类\:{1}
string.null.context=上下文为null
evaluation.error.array.reference.expected=预期的数组引用
evaluation.error.invalid.index.expression=索引表达式无效
evaluation.error.not.rvalue=分配的右边部分不是一个值
evaluation.error.not.lvalue=分配的左边部分不是一个值
evaluation.error.incompatible.types=''{0}''操作不兼容的类型
evaluation.error.lebeled.loops.not.found=没有标记为''{0}''为循环语句
evaluation.error.reference.type.expected=预期引用类型
evaluation.error.variable.not.declared=变量''{0}''未声明
evaluation.error.variable.already.declared=变量''{0}''已被声明
evaluation.error.operation.not.supported=操作''{0}''不支持
evaluation.error.statement.not.supported=声明 ''{0}''不支持
evaluation.error.incompatible.variable.initializer.type=''{0}''的初始化程序具有不兼容的类型
evaluation.error.local.variable.missing.from.class.closure=在闭包类中找不到局部变量''{0}''
evaluation.error.local.variable.missing=找不到局部变量''{0}''
evaluation.error.cannot.resolve.field.class=无法解析包含字段''{0}''
evaluation.error.cannot.sources.for.field.class=找不到包含字段''{0}''的类的源
evaluation.error.identifier.expected=预期的标识符不是''{0}''
evaluation.error.qualifier.type.unknown=''{0}''的类型不明
evaluation.error.cannot.evaluate.qualifier=无法评估限定符''{0}''
evaluation.error.method.not.found=方法''{0}''未找到
evaluation.error.cannot.resolve.class=无法解析类''{0}''
evaluation.error.invalid.array.dimension.expression=数组维度无效的表达式\: {0}
evaluation.error.multi.dimensional.arrays.creation.not.supported=创建不支持的多维数组
evaluation.error.anonymous.class.evaluation.not.supported=不支持匿名类评估
evaluation.error.lambda.evaluation.not.supported=不支持Lambdas评估
evaluation.error.method.reference.evaluation.not.supported=不支持方法引用评估
evaluation.error.no.static.field=没有这样的静态字段\: ''{0}''
evaluation.error.no.instance.field=没有这样的实例字段\: ''{0}''
evaluation.error.class.or.array.expected=在评估字段''{0}''时预期的类或数组类型
evaluation.error.evaluating.field=评估字段错误 \: ''{0}''
evaluation.error.evaluating.method=评估方法错误 \: ''{0}''
evaluation.error.object.reference.expected=预期对象引用
evaluation.error.no.stackframe=无法评估\: 堆栈帧不可用
evaluation.error.no.static.method=不存在的静态方法\: ''{0}''
evaluation.error.no.instance.method=不存在的实例方法\: ''{0}''
evaluation.error.array.type.expected=数组类型预期
evaluation.error.array.dimention.numeric.value.expected=数字值预计为多维数组
evaluation.error.cannot.evaluate.array.initializer=无法评估数组初始化程序
evaluation.error.incompatible.array.initializer.type=初始化器类型与数组的组件类型不兼容
evaluation.error.invalid.array.size=数组大小无效
evaluation.error.cannot.initialize.array=无法初始化数组
evaluation.error.cannot.evaluate.class.type=无法评估类类型
evaluation.error.cannot.resolve.constructor=无法解析构造函数 ''{0}''
evaluation.error.this.not.avalilable='this'是不可用的
evaluation.error.cannot.cast.null=不能将null转换为''{0}''
evaluation.error.cannot.cast.numeric=不能将数字转换为''{0}''
evaluation.error.cannot.cast.boolean=不能将布尔转换为''{0}''
evaluation.error.cannot.cast.char=不能将字符转换为''{0}''
evaluation.error.cannot.cast.object=不能转换''{0}''为''{1}''
evaluation.error.numeric.expected=预期数值
evaluation.error.integer.expected=预期的整数值
evaluation.error.boolean.expected=预期的布尔值
status.invalid.breakpoint.out.of.class=断点不属于任何类
error.invalid.breakpoint.source.changed=源文件已更改或找到源文件与断点的文件不对应
error.invalid.breakpoint.source.not.found=在项目类路径中找到的类{0}没有关联的源文件
status.paused=已暂停
status.thread.monitor=MONITOR
status.thread.not.started=NOT_STARTED
status.thread.running=运行中
status.thread.sleeping=SLEEPING
status.thread.unknown=未知
status.thread.wait=WAIT
status.thread.zombie=ZOMBIE
status.thread.undefined=UNDEFINED
string.debugger.runner.description=调试选定的配置
debugger.runner.start.action.text=调试 (&D)
progress.hotswap.scanning.path=扫描\: {0}
progress.hotswap.scanning.classes=扫描类以重新加载...
progress.hotswap.reloading=重新加载类...
warning.hotswap.ignored.breakpoints=断点将被忽略,因为该方法的版本已过时
error.operation.canceled=操作被取消
error.operation.not.supported.by.vm=虚拟机不支持的操作
error.class.def.not.found=找不到类定义 \: {0}
error.verification.error=验证错误 \: {0}
error.unsupported.class.version=不支持的类版本 \: {0}
error.class.format.error=类格式错误 \: {0}
error.class.circularity.error=类循环错误\: {0}
error.exception.while.reloading=重新加载类时出现异常 \: {0} \: {1}
status.hotswap.loaded.classes.up.to.date=已加载类是最新的. 不需要重新加载
error.io.error=I/O 错误
status.classes.reloaded={0,number}个类重新加载
status.classes.not.all.versions.reloaded=对于{0},{1}个类并非所有版本都重新加载
error.cannot.create.void.value=无法创建void值
warning.range.too.big=指定范围太大. {0} 需要太多的资源才能执行请求的操作. 你确定你要继续吗?
title.range.too.big=范围太大了
error.array.renderer.configurable.start.index.less.than.zero=开始索引小于 0
error.array.renderer.configurable.end.index.less.than.start=结束索引小于开始索引
label.array.renderer.configurable.start.index=数组开始索引 (&R)\:
label.array.renderer.configurable.end.index=结束索引 (&D)\:
label.array.renderer.configurable.max.count1=显示最大值 (&M)
label.array.renderer.configurable.max.count2=数组元素
label.base.renderer.configurable.autoscroll=自动定位到新的局部变量 (&L)
label.base.renderer.configurable.dfa.assist=基于数据流分析预测条件值和异常
label.base.renderer.configurable.show.synthetic.fields=合成字段 (&Y)
label.base.renderer.configurable.show.val.fields.as.locals=$val 字段作为局部变量(&V)
label.base.renderer.configurable.sort.alphabetically=按字母顺序排序 (&L)
label.base.renderer.configurable.hide.null.array.elements=在数组和集合中隐藏空元素 (&N)
label.base.renderer.configurable.show.static.fields=静态字段 (&S)
label.base.renderer.configurable.show.static.final.fields=静态不可变字段
label.base.renderer.configurable.show.declared.type=已声明类型 (&T)
label.base.renderer.configurable.show.fq.names=完全限定名称 (&Q)
label.base.renderer.configurable.show.object.id=对象ID (&I)
label.base.renderer.configurable.show.hex.value=显示原函数的十六进制值
label.base.renderer.configurable.show.strings.type=显示字符串的类型
label.base.renderer.configurable.populate.throwable.stack=自动填充可抛出对象的堆栈跟踪
label.base.renderer.configurable.alternate.view=启用集合类的替代视图 (&E)
label.base.renderer.configurable.enable.toString=启用 't&oString()' 对象视图 (&O)\:
label.base.renderer.configurable.all.overriding=对于覆盖'toString()'方法的所有类
label.base.renderer.configurable.classes.from.list=对于列表中的类\:
label.compound.renderer.configurable.show.type=显示类型和对象id
label.compound.renderer.configurable.ondemand=按需
label.compound.renderer.configurable.use.default.renderer=使用默认渲染器
label.compound.renderer.configurable.use.expression=使用以下表达式\:
label.compound.renderer.configurable.use.expression.list=使用表达式列表\:
label.compound.renderer.configurable.apply.to=将渲染器应用于类型对象 (完全限定名称)\:
label.compound.renderer.configurable.when.rendering=渲染节点时
label.compound.renderer.configurable.when.expanding=展开节点时
label.compound.renderer.configurable.test.can.expand=测试一个节点是否可以扩展 (可选)\:
title.compound.renderer.configurable.choose.renderer.reference.type=渲染器引用类型
text.base.renderer.configurable.no.class.patterns=没有配置类模式
label.compound.renderer.configurable.append.default.children=追加默认子节点
button.add=添加
button.remove=移除(R)
button.move.up=上移 (&U)
button.move.down=下移 (&D)
label.compound.renderer.configurable.table.header.name=名称
label.compound.renderer.configurable.table.header.expression=表达式
label.compound.renderer.configurable.table.header.ondemand=按需
label.debugger.hotswap.configurable.hotswap.background=在后台重新加载类 (&B)
label.debugger.hotswap.configurable.compile.before.hotswap=在重新加载类之前构建项目
label.debugger.hotswap.configurable.enable.vm.hang.warning=开启 'JVM将挂起' 警告
label.debugger.hotswap.configurable.reload.classes=编译后重新加载类\:
label.debugger.hotswap.configurable.always=总是(&A)
label.debugger.hotswap.configurable.never=从不 (&N)
label.debugger.hotswap.configurable.ask=询问 (&K)
label.debugger.launching.configurable.force.classic.vm=强制对 JDK 1.3.x 和更早版本使用经典虚拟机(&I)
label.debugger.launching.configurable.disable.jit=关闭 JIT
label.debugger.launching.configurable.debugger.transport=传输\:
label.debugger.launching.configurable.socket=&Socket 
label.debugger.launching.configurable.shmem=Shared memory(&M)
label.debugger.general.configurable.show.alternative.source=显示替代源切换器
label.debugger.general.configurable.kill.immediately=立即停止调试进程
label.debugger.general.configurable.always.debug=开始使用调试代理运行配置
label.debugger.general.configurable.enable.memory.agent=附加内存代理
label.debugger.general.configurable.enable.memory.agent.tooltip.text=Java 调试器将提供有关堆中对象的其他信息
label.debugger.general.configurable.always.smart.step.into=始终进行智能单步执行(&L)
label.debugger.general.configurable.skip.synthetic.methods=跳过合成方法 (&P)
label.debugger.general.configurable.skip.constructors=跳过构造函数 (&C)
label.debugger.general.configurable.skip.classLoaders=跳过加载器 (&O)
label.debugger.general.configurable.skip.simple.getters=跳过简单的getter (&G)
label.debugger.general.configurable.step.filters.list.header=不要进入类 (&I)
label.debugger.general.configurable.evaluate.finally.on.pop=评估抛出帧和早期返回的finally块\:
label.debugger.general.configurable.evaluate.finally.always=总是(&A)
label.debugger.general.configurable.evaluate.finally.never=从不 (&E)
label.debugger.general.configurable.evaluate.finally.ask=询问 (&K)
label.debugger.general.configurable.resume.only.current.thread=只恢复当前线程
label.threads.view.configurable.show.source.file.name=显示源文件名
label.threads.view.configurable.show.class.name=显示类名
label.threads.view.configurable.show.package=显示包名
label.threads.view.configurable.show.line.number=显示行号 (&L)
label.threads.view.configurable.current.thread.on.top=将当前线程移动到顶部
label.threads.view.configurable.show.stack.frames.for.synthetic.methods=显示堆栈帧的合成方法 (&F)
label.threads.view.configurable.show.thread.groups=显示线程组 (&G)
label.capture.configurable.capture.variables=捕获局部变量 (可能会大大减慢执行速度)
label.capture.configurable.debugger.agent=检测代理 (需要调试器重启)
label.capture.configurable.annotations.configure=配置注解…
threads.view.configurable.display.name=自定义线程视图
user.renderers.configurable.display.name=Java类型渲染器
async.stacktraces.configurable.display.name=异步堆栈跟踪
label.user.renderers.configurable.renderer.name=渲染器名称\:
text.user.renderers.configurable.no.renderers=没有渲染器
button.copy=复制
user.renderers.configurable.button.description.add=添加新的渲染器
user.renderers.configurable.button.description.remove=移除选择的渲染器
user.renderers.configurable.button.description.copy=拷贝选择的渲染器
user.renderers.configurable.button.description.move.up=向上移动渲染器
user.renderers.configurable.button.description.move.down=向下移动渲染器
label.complete.input.dialog.expression=输入表达式
debugger.session.tab.threads.title=线程
debugger.session.tab.log.content.name=日志\: {0}
debugger.session.tab.watches.title.with.size=监视 ({0})
button.close.no.mnemonic=关闭
button.evaluate=评估 (&V)
threads.export.dialog.title=导出线程
button.save=保存
label.threads.export.dialog.file=导出到文件\:
error.threads.export.dialog.file.is.directory=指定的文件是一个目录.\n请指定正确的文件名.
error.threads.export.dialog.file.already.exists=文件\n''{0}''\n已经存在. 您想覆盖它吗?
threads.export.attribute.label.daemon=守护进程
threads.export.attribute.label.group=在组 ''{0}''
threads.export.attribute.label.status=状态\: ''{0}''
threads.export.attribute.label.priority=prio\={0}
threads.export.attribute.label.tid=tid\=0x{0}
threads.export.attribute.label.nid=nid\={0}
threads.export.attribute.label.blocks.thread=块 {0}
threads.export.attribute.label.waiting.for.thread=等待 {0} 释放锁定 {1}
threads.export.attribute.label.locked=锁定 {0}
threads.export.attribute.label.object-id=<0x{0}> (a {1})
threads.export.attribute.error.incompatible.state=线程不兼容\: 线程未挂起
export.dialog.copy.action.description=将文本复制到剪贴板 (&C)
evaluate.expression.dialog.title=表达式评估
label.evaluate.dialog.language=语言\:
label.evaluate.dialog.expression=表达式 (&E)\:
label.evaluate.dialog.result=结果 (&R)\:
action.evaluate.expression.dialog.switch.mode.description=代码片段模式 (&M)
label.generic.debugger.parameters.patcher.configurable.shmem=Shared &memory ()
label.generic.debugger.parameters.patcher.configurable.socket=&Socket 
button.debugger.settings=调试设置...
label.generic.debugger.parameters.patcher.configurable.transport=传输\:
label.generic.debugger.parameters.patcher.configurable.shmem.address=共享内存地址\:
get.jpda.dialog.title=缺少JPDA库
label.get.jpda.dialog.prompt=要获取JPDA库请访问
label.get.jpda.dialog.error.description=无法启动调试器\: JDK home中缺少调试库
progress.hot.swap.title=热交换
status.hot.swap.completed.with.errors=Hot Swap 失败.
status.hot.swap.completed.restart=<a href\="restart">重新启动调试会话</a>
status.hot.swap.completed.stop=<a href\="stop">停止调试会话</a>
status.hot.swap.completed.with.warnings=Hot Swap完成并发出警告
label.generic.debugger.parameters.patcher.configurable.port=端口\:
status.hotswap.uptodate=已加载类是最新的. 没有什么可以重新加载.
add.instance.filter.dialog.title=添加实例过滤器
add.instance.filter.dialog.prompt=输入实例ID\:
add.instance.filter.dialog.error.numeric.value.expected=实例ID应为'long'类型的数值
filters.not.configured=没有过滤器配置
position.highlighter.stripe.tooltip=执行行
hotswap.dialog.title.with.session=重新加载已更改的类 {0}
hotswap.dialog.title=重新加载已更改的类
hotswap.dialog.run.prompt=一些类已经改变. 现在重新加载更改的类?
hotswap.dialog.hang.warning=JVM当前已被暂停.\n使用活动的第三方JVM代理重新加载类可能会导致JVM挂起.
hotswap.dialog.hang.question=你想重新加载改变的类吗?
evaluate.statement.dialog.title=代码片段评估
label.evaluation.dialog.statements=评估报告 (&E)\:
action.evaluate.statement.dialog.switch.mode.description=表达式模式 (&M)
label.add.field.breakpoint.dialog.fq.name=一个类的完全限定名称\:
label.add.field.breakpoint.dialog.field.name=字段名\:
add.field.breakpoint.dialog.title=添加字段监视
add.field.breakpoint.dialog.classchooser.title=选择字段的类
add.field.breakpoint.dialog.field.chooser.title={0,choice, 0\#类没有字段|1\#选择字段}
label.add.wildcard.breakpoint.dialog.method.name=&方法名称\:
label.add.wildcard.breakpoint.dialog.class.pattern=类模式(&C)\:
breakpoint.any.exception.display.name=任何异常
breakpoint.log.message="到达 {0}"
action.enable.text=开启
action.disable.text=关闭
breakpoint.manager.action.view.breakpoints.text=查看断点
action.remove.text=移除
value.none=<无>
breakpoint.table.header.column.enabled=开启
breakpoint.table.header.column.name=名称
default.package.name=<默认>
class.filters.dialog.title=类过滤器
class.filters.dialog.inclusion.filters.group=类过滤器
class.filters.dialog.exclusion.filters.group=类排除过滤器
instance.filters.dialog.title=实例过滤器
instance.filters.dialog.instance.filters.group=实例过滤器
breakpoint.exception.breakpoint.display.name=''{0}''
exception.breakpoints.tab.title=Java异常断点
field.watchpoints.tab.title=Java字段监视点
line.breakpoints.tab.title=Java行断点
method.breakpoints.tab.title=Java方法断点
method.breakpoints.slowness.warning=方法断点可能会大大减慢调试速度
title.error.evaluating.breakpoint.condition=断点条件错误
title.error.evaluating.breakpoint.action=断点操作错误
error.evaluating.breakpoint.condition.or.action=处理虚拟机事件的问题\:\n断点\: ''{0}''\n错误\: {1}\n是否要在断点处停止?
error.unable.to.evaluate.expression=无法评估表达式
error.unable.to.evaluate.capture.expression=无法评估捕获键表达式\: {0}
error.unable.to.evaluate.insert.expression=无法评估插入键表达式\: {0}
breakpoint.properties.panel.option.pass.count=合格次数 (&P)\:
breakpoint.properties.panel.option.class.filters=类过滤器 (&L)\:
breakpoint.properties.panel.option.instance.filters=实例过滤器 (&I)\:
breakpoint.properties.panel.option.condition=条件 (&N)\:
breakpoint.properties.panel.option.suspend.all=全部
breakpoint.properties.panel.option.suspend.none=无
breakpoint.properties.panel.option.suspend.thread=线程
breakpoint.properties.panel.option.log.expression=记录评估表达式 (&E)
breakpoint.properties.panel.option.depends.on=依赖于取决于\:
breakpoint.properties.panel.option.log.message=将日志输出到控制台 (&M)
breakpoint.warning=警告 \: {0}
breakpoint.property.name.suspend.policy=暂停
breakpoint.property.name.log.message=日志消息
breakpoint.property.name.log.expression=日志表达式
breakpoint.property.name.condition=条件
breakpoint.property.name.pass.count=合格次数
breakpoint.property.name.class.filters=类过滤器
breakpoint.property.name.instance.filters=实例过滤器\:
breakpoint.tooltip.text=断点在行{0}
error.absent.exception.breakpoint.class.name=没有异常断点的类名
exception.breakpoint.console.message.location.info={0}\:{1,number,\#}
exception.breakpoint.console.message.location.info.absent=没有调试信息
exception.breakpoint.console.message.with.thread.info={2}({3}) 的线程 ''{1}'' 中发生异常 ''{0}'' 
exception.breakpoint.console.message={1}({2}) 中发生异常 ''{0}'' 
add.exception.breakpoint.classchooser.title=输入异常类
label.exception.breakpoint.properties.panel.caught.exception=捕获异常 (&N)
label.exception.breakpoint.properties.panel.uncaught.exception=未捕获的异常 (&O)
label.exception.breakpoint.properties.panel.group.notifications=通知
error.invalid.breakpoint.missing.field.in.class=在类 ''{1}'' 中找不到字段 ''{0}''
status.breakpoint.invalid=无效
error.field.breakpoint.class.name.not.specified=无法添加监视点\: 未指定类名称
error.field.breakpoint.field.name.not.specified=无法添加监视点\: 未指定字段名称
error.field.breakpoint.field.not.found=无法为''{0}.{1}'' 创建字段监视点.\n字段 ''{2}'' 未找到
error.field.breakpoint.class.sources.not.found=无法为 ''{0}.{1}'' 创建字段监视点.\n没有来源类''{2}''
label.filed.breakpoint.properties.panel.field.access=字段访问 (&S)
label.filed.breakpoint.properties.panel.field.modification=修改 (&M)
label.group.watch.events=监视
error.failed.evaluating.breakpoint.condition=无法评估断点条件\n''{0}''\n原因\: {1}
error.invalid.breakpoint.no.executable.code=在类{1}中的行{0}处找不到可执行代码
error.invalid.breakpoint.no.line.info=行号信息在类{0}不可用
error.invalid.breakpoint.bad.line.number=行号无效
line.breakpoint.display.name=行 {0}
line.breakpoint.display.name.with.class.or.method=行 {0,number,\#} 在 {1}
error.invalid.breakpoint.method.not.found=在类{0}未找到方法
label.method.breakpoints.processing.classes=处理仿真方法断点的类
label.method.breakpoints.setting.breakpoints=设置仿真方法断点
label.method.breakpoint.properties.panel.method.entry=方法输入 (&Y)
label.method.breakpoint.properties.panel.method.exit=方法退出 (&X)
label.method.breakpoint.properties.panel.emulated=仿真 (&U)
button.switch.view=切换视图 (&W)
button.list.view=列表视图
button.tree.view=树视图
button.flatten.packages=拼合包 (&F)
button.group.by.classes=按类分组 (&A)
button.group.by.methods=按方法分组 (&T)
error.cannot.build.node.children.object.collected=不能评估后代, 对象被收集. {0}
error.invalid.field.name=字段名无效 ''{0}''
label.unknown.value=<未知>
message.node.debug.info.not.available=调试信息不可用
message.node.local.variables.debug.info.not.available=变量调试信息不可用
message.node.local.variables.not.captured=局部变量未被捕获用于合成,桥接等方法
message.node.local.variables.capture.disabled=局部变量未被捕获,您可以更改它
message.node.elements.null.hidden=不显示空元素
message.node.all.array.elements.null=所有元素在范围 ({0}, {1})都是空
message.node.all.elements.null=所有元素都为空
message.node.filtered=已过滤用\:
message.node.empty.array=空
message.node.class.has.no.fields=类没有字段
message.node.class.no.fields.to.display=没有字段显示
message.node.object.collected=对象在方法调用期间已被垃圾回收
message.node.thread.running=线程正在运行
message.node.thread.has.no.frames=线程没有帧
message.node.evaluation.not.possible=目标虚拟机不被断点请求暂停. 在这种模式下评估方法是不可能的
message.node.show.image=… 显示图片
message.node.show.icon=… 显示图标
message.node.navigate=… 导航
message.node.toString=… toString()
message.node.evaluate=…评估
label.thread.node.thread.collected=线程被垃圾收集
label.thread.node="{0}"@{1}\: {2}
label.thread.node.in.group="{0}"@{1} 在组 "{3}"\: {2}
label.thread.group.node.group.collected=线程组 "{0}" 已被垃圾收集
label.thread.group.node=线程组 "{0}"@{1}
evaluation.error.objref.expected=预期对象引用而不是{0}
evaluation.error.invalid.type.name=类型名称无效\: ''{0}''
label.undefined=未定义
label.node.descendands.expression=节点后代表达式 (&D)\:
node.has.descendands.expression.optional='节点有后代'表达式 (可选) (&H)\:
label.class.label.expression.configurable.node.label=节点标签表达式
label.named.children.configurable.node.descendants=节点后代 (&S)\:
label.named.children.configurable.table.header.column.name=名称
label.named.children.configurable.table.header.column.expression=表达式
error.running.to.cursor.no.executable.code={0}没有可执行代码\:{1}
evaluation.error.local.variable.declarations.not.supported=局部变量声明不受支持.
evaluation.error.unsupported.declaration=声明无效 \: {0} 仅支持局部变量声明.
error.jdk.not.specified=JDK未指定
error.unsupported.jdk.version=JDK {0}不支持调试
error.invalid.jdk.home=指定的JDK主目录无效.{0}
error.debug.libraries.missing=JDK home中缺少调试库.\n为了调试器启动，应该安装库.\n请访问 http\://java.sun.com/products/jpda
error.field.not.found.in.class={1}中没有这样的字段{0}
error.breakpoint.file.not.found=文件 ''{0}'' 未找到; b此文件的断点将被忽略
error.cannot.load.breakpoint.file=无法加载文件 ''{0}''; 此文件的断点将被忽略
evaluation.error.invalid.this.expression=不能替换''{1}''的''{0}''为''this''
error.invalid.type.name=无效的类型名称''{0}''
error.cannot.create.expression.from.code.fragment=无法从代码片段创建表达式.
error.invalid.local.variable.name=无效的局部变量名''{0}''
error.inconsistent.debug.info=不一致的调试信息
error.invalid.stackframe=内部异常 - 无效的堆栈框架
label.breakpoint.properties.panel.group.conditions=过滤器
label.breakpoint.properties.panel.group.actions=动作
label.breakpoint.properties.panel.group.suspend.policy=挂起策略
active.tooltip.title=评估{0}
active.tooltip.suggestion=单击此处查看对象数
error.text.invalid.port=未指定端口
error.cannot.invoke.method.in.collected.thread=无法调用方法\: 已收集调用线程
title.smart.step.popup=进入的方法
action.show.watches.description=显示或隐藏 '监视' 窗口
action.show.watches.text.hide=隐藏监视
action.show.watches.text.show=显示监视
action.watch.method.return.value.description=启用观察上次执行的方法返回值
action.watches.method.return.value.enable=显示方法返回值
action.watches.method.return.value.disable=停止监视方法返回值
action.watches.method.return.value.unavailable.reason=目标VM不支持的功能
action.auto.variables.mode=自动变量模式
action.auto.variables.mode.description=仅显示执行点附近使用的变量
action.maximizeContent.text=
breakpoint.properties.panel.option.depends.disable.again=再次禁用
breakpoint.properties.panel.option.depends.leave.enabled=保持启用
breakpoint.properties.panel.option.dependency.type.lable=断点被命中后\:
watchs.add.text=添加到监视器
breakpoint.properties.panel.option.suspend.default=设为默认值 (&F)
frame.panel.frames.not.available=帧不可用于未挂起的线程
frame.panel.thread.finished=线程已结束执行
frame.panel.async.stacktrace=异步堆栈跟踪
error.corrupt.debug.info=调试信息可能已损坏\: {0}
action.kill.process.text=杀死进程
action.kill.process.description=强制终止调试应用程序
evaluation.error.unknown.method.return.type=无法解析方法返回类型\: {0}
rule.name.group.by.class=按类分组
rule.name.group.by.package=按包分组
error.context.has.changed=上下文已经改变，操作是不可能的
editor.notification.alternative.source=类{0}的替代来源
label.threads.view.configurable.show.prams.types=显示方法参数类型
breakpoint.properties.panel.option.catch.class.filters=捕捉类过滤器\:
breakpoint.properties.panel.option.caller.filter=调用者过滤器(&R)\:
caller.filters.dialog.title=调用者过滤器
settings.breakpoints.based=基于断点：
settings.capture.column.capture.class.name=捕获类名
settings.capture.column.capture.method.name=捕获方法名称
settings.capture.column.capture.key.expression=捕获键表达式
settings.capture.column.insert.class.name=插入类名
settings.capture.column.insert.method.name=插入方法名称
settings.capture.column.insert.key.expression=插入键表达式
settings.async.schedule=异步调度
settings.async.execute=异步执行
settings.async.annotations.configuration=异步注解配置
action.AnActionButton.text.duplicate=副本
action.AnActionButton.description.duplicate=副本
action.AnActionButton.text.enable.selected=启用选定项
action.AnActionButton.description.enable.selected=启用选定项
action.AnActionButton.text.disable.selected=禁用选定项
action.AnActionButton.description.disable.selected=禁用选定项
action.AnActionButton.text.import=导入
action.AnActionButton.description.import=导入
action.AnActionButton.text.export=导出
action.AnActionButton.description.export=导出
action.TurnOffDfaAssist.text=关闭数据流辅助
action.TurnOffDfaAssist.description=为此会话关闭数据流辅助调试
warning.0=警告\! {0}
instances.window.show.history=InstancesWindow.ShowHistory
select.stack.frame=选择栈帧
tracing.class.filters=跟踪类过滤器
filters=过滤器...
export.failed=导出失败
export.selected.capture.points.to.file=将所选捕获点导出到文件...
import.capture.points=导入捕获点
please.select.a.file.to.import=请选择要导入的文件。
waiting.for.debugger.response=等待调试器响应
thread.dump=线程转储
cancel.emulation=取消仿真
thread.operation.interrupt.is.not.supported.by.vm=虚拟机不支持线程操作 'interrupt'
size.of.the.object=对象大小
add.stepping.filter=添加步进过滤器
method.name.not.specified=未指定方法名称
class.pattern.not.specified=未指定类模式
add.method.breakpoint=添加方法断点
if.the.value.is.referenced.by.a.constant.field=如果该值由抽象类的常量字段引用，\nIDEA 可以使用引用字段的名称来另外标记从此类引用的所有值。
action.failed=操作失败
label.object.markup.dialog.mark.referenced=标记从常量字段引用的值(&M)
debugger.data.views.configurable.show.title=显示
overhead.toolwindow.title=开销
memory.toolwindow.title=内存问题
checkbox.tracing=跟踪
enable.tracking.for.new.instances=启用跟踪新实例
condition=条件\:
warning.filtering.may.have.side.effects=警告\: 过滤可能有不利影响
invoke.completion.once.more=再次调用完成以查看运行时类型变量
debugger.actions.group.title=调试器操作
surround.with.runtime.type.template=((RuntimeType)expr)
command.name.surround.with.runtime.cast=环绕用运行时转换
checkbox.start.tracing=开始
checkbox.stop.tracing=停止
checkbox.tracking.filters=过滤器